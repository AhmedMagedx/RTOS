
RTOS_APP2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000048ac  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000058  00800060  000048ac  00004940  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000680  008000b8  008000b8  00004998  2**0
                  ALLOC
  3 .stab         00007584  00000000  00000000  00004998  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003cee  00000000  00000000  0000bf1c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 b5 10 	jmp	0x216a	; 0x216a <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec ea       	ldi	r30, 0xAC	; 172
      68:	f8 e4       	ldi	r31, 0x48	; 72
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 3b       	cpi	r26, 0xB8	; 184
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a8 eb       	ldi	r26, 0xB8	; 184
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 33       	cpi	r26, 0x38	; 56
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 d3 21 	call	0x43a6	; 0x43a6 <main>
      8a:	0c 94 54 24 	jmp	0x48a8	; 0x48a8 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_voidSetPinValue>:



/* IO Pins */
void DIO_voidSetPinValue(u8 u8PortIdCopy , u8 u8PinIdCopy, u8 u8PinValCopy)
{
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	27 97       	sbiw	r28, 0x07	; 7
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	89 83       	std	Y+1, r24	; 0x01
      a8:	6a 83       	std	Y+2, r22	; 0x02
      aa:	4b 83       	std	Y+3, r20	; 0x03
	/* Make sure that the Port ID and Pin ID are in the valid range */
	if ((u8PortIdCopy <= DIO_u8_PORTD) && (u8PinIdCopy <= DIO_u8_PIN7))
      ac:	89 81       	ldd	r24, Y+1	; 0x01
      ae:	84 30       	cpi	r24, 0x04	; 4
      b0:	08 f0       	brcs	.+2      	; 0xb4 <DIO_voidSetPinValue+0x22>
      b2:	ee c0       	rjmp	.+476    	; 0x290 <DIO_voidSetPinValue+0x1fe>
      b4:	8a 81       	ldd	r24, Y+2	; 0x02
      b6:	88 30       	cpi	r24, 0x08	; 8
      b8:	08 f0       	brcs	.+2      	; 0xbc <DIO_voidSetPinValue+0x2a>
      ba:	ea c0       	rjmp	.+468    	; 0x290 <DIO_voidSetPinValue+0x1fe>
	{
		if (u8PinValCopy == DIO_u8_HIGH)
      bc:	8b 81       	ldd	r24, Y+3	; 0x03
      be:	81 30       	cpi	r24, 0x01	; 1
      c0:	09 f0       	breq	.+2      	; 0xc4 <DIO_voidSetPinValue+0x32>
      c2:	6f c0       	rjmp	.+222    	; 0x1a2 <DIO_voidSetPinValue+0x110>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
      c4:	89 81       	ldd	r24, Y+1	; 0x01
      c6:	28 2f       	mov	r18, r24
      c8:	30 e0       	ldi	r19, 0x00	; 0
      ca:	3f 83       	std	Y+7, r19	; 0x07
      cc:	2e 83       	std	Y+6, r18	; 0x06
      ce:	8e 81       	ldd	r24, Y+6	; 0x06
      d0:	9f 81       	ldd	r25, Y+7	; 0x07
      d2:	81 30       	cpi	r24, 0x01	; 1
      d4:	91 05       	cpc	r25, r1
      d6:	49 f1       	breq	.+82     	; 0x12a <DIO_voidSetPinValue+0x98>
      d8:	2e 81       	ldd	r18, Y+6	; 0x06
      da:	3f 81       	ldd	r19, Y+7	; 0x07
      dc:	22 30       	cpi	r18, 0x02	; 2
      de:	31 05       	cpc	r19, r1
      e0:	2c f4       	brge	.+10     	; 0xec <DIO_voidSetPinValue+0x5a>
      e2:	8e 81       	ldd	r24, Y+6	; 0x06
      e4:	9f 81       	ldd	r25, Y+7	; 0x07
      e6:	00 97       	sbiw	r24, 0x00	; 0
      e8:	61 f0       	breq	.+24     	; 0x102 <DIO_voidSetPinValue+0x70>
      ea:	d2 c0       	rjmp	.+420    	; 0x290 <DIO_voidSetPinValue+0x1fe>
      ec:	2e 81       	ldd	r18, Y+6	; 0x06
      ee:	3f 81       	ldd	r19, Y+7	; 0x07
      f0:	22 30       	cpi	r18, 0x02	; 2
      f2:	31 05       	cpc	r19, r1
      f4:	71 f1       	breq	.+92     	; 0x152 <DIO_voidSetPinValue+0xc0>
      f6:	8e 81       	ldd	r24, Y+6	; 0x06
      f8:	9f 81       	ldd	r25, Y+7	; 0x07
      fa:	83 30       	cpi	r24, 0x03	; 3
      fc:	91 05       	cpc	r25, r1
      fe:	e9 f1       	breq	.+122    	; 0x17a <DIO_voidSetPinValue+0xe8>
     100:	c7 c0       	rjmp	.+398    	; 0x290 <DIO_voidSetPinValue+0x1fe>
			{
				case DIO_u8_PORTA: SET_BIT(PORTA_Register,u8PinIdCopy); break;
     102:	ab e3       	ldi	r26, 0x3B	; 59
     104:	b0 e0       	ldi	r27, 0x00	; 0
     106:	eb e3       	ldi	r30, 0x3B	; 59
     108:	f0 e0       	ldi	r31, 0x00	; 0
     10a:	80 81       	ld	r24, Z
     10c:	48 2f       	mov	r20, r24
     10e:	8a 81       	ldd	r24, Y+2	; 0x02
     110:	28 2f       	mov	r18, r24
     112:	30 e0       	ldi	r19, 0x00	; 0
     114:	81 e0       	ldi	r24, 0x01	; 1
     116:	90 e0       	ldi	r25, 0x00	; 0
     118:	02 2e       	mov	r0, r18
     11a:	02 c0       	rjmp	.+4      	; 0x120 <DIO_voidSetPinValue+0x8e>
     11c:	88 0f       	add	r24, r24
     11e:	99 1f       	adc	r25, r25
     120:	0a 94       	dec	r0
     122:	e2 f7       	brpl	.-8      	; 0x11c <DIO_voidSetPinValue+0x8a>
     124:	84 2b       	or	r24, r20
     126:	8c 93       	st	X, r24
     128:	b3 c0       	rjmp	.+358    	; 0x290 <DIO_voidSetPinValue+0x1fe>
				case DIO_u8_PORTB: SET_BIT(PORTB_Register,u8PinIdCopy); break;
     12a:	a8 e3       	ldi	r26, 0x38	; 56
     12c:	b0 e0       	ldi	r27, 0x00	; 0
     12e:	e8 e3       	ldi	r30, 0x38	; 56
     130:	f0 e0       	ldi	r31, 0x00	; 0
     132:	80 81       	ld	r24, Z
     134:	48 2f       	mov	r20, r24
     136:	8a 81       	ldd	r24, Y+2	; 0x02
     138:	28 2f       	mov	r18, r24
     13a:	30 e0       	ldi	r19, 0x00	; 0
     13c:	81 e0       	ldi	r24, 0x01	; 1
     13e:	90 e0       	ldi	r25, 0x00	; 0
     140:	02 2e       	mov	r0, r18
     142:	02 c0       	rjmp	.+4      	; 0x148 <DIO_voidSetPinValue+0xb6>
     144:	88 0f       	add	r24, r24
     146:	99 1f       	adc	r25, r25
     148:	0a 94       	dec	r0
     14a:	e2 f7       	brpl	.-8      	; 0x144 <DIO_voidSetPinValue+0xb2>
     14c:	84 2b       	or	r24, r20
     14e:	8c 93       	st	X, r24
     150:	9f c0       	rjmp	.+318    	; 0x290 <DIO_voidSetPinValue+0x1fe>
				case DIO_u8_PORTC: SET_BIT(PORTC_Register,u8PinIdCopy); break;
     152:	a5 e3       	ldi	r26, 0x35	; 53
     154:	b0 e0       	ldi	r27, 0x00	; 0
     156:	e5 e3       	ldi	r30, 0x35	; 53
     158:	f0 e0       	ldi	r31, 0x00	; 0
     15a:	80 81       	ld	r24, Z
     15c:	48 2f       	mov	r20, r24
     15e:	8a 81       	ldd	r24, Y+2	; 0x02
     160:	28 2f       	mov	r18, r24
     162:	30 e0       	ldi	r19, 0x00	; 0
     164:	81 e0       	ldi	r24, 0x01	; 1
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	02 2e       	mov	r0, r18
     16a:	02 c0       	rjmp	.+4      	; 0x170 <DIO_voidSetPinValue+0xde>
     16c:	88 0f       	add	r24, r24
     16e:	99 1f       	adc	r25, r25
     170:	0a 94       	dec	r0
     172:	e2 f7       	brpl	.-8      	; 0x16c <DIO_voidSetPinValue+0xda>
     174:	84 2b       	or	r24, r20
     176:	8c 93       	st	X, r24
     178:	8b c0       	rjmp	.+278    	; 0x290 <DIO_voidSetPinValue+0x1fe>
				case DIO_u8_PORTD: SET_BIT(PORTD_Register,u8PinIdCopy); break;
     17a:	a2 e3       	ldi	r26, 0x32	; 50
     17c:	b0 e0       	ldi	r27, 0x00	; 0
     17e:	e2 e3       	ldi	r30, 0x32	; 50
     180:	f0 e0       	ldi	r31, 0x00	; 0
     182:	80 81       	ld	r24, Z
     184:	48 2f       	mov	r20, r24
     186:	8a 81       	ldd	r24, Y+2	; 0x02
     188:	28 2f       	mov	r18, r24
     18a:	30 e0       	ldi	r19, 0x00	; 0
     18c:	81 e0       	ldi	r24, 0x01	; 1
     18e:	90 e0       	ldi	r25, 0x00	; 0
     190:	02 2e       	mov	r0, r18
     192:	02 c0       	rjmp	.+4      	; 0x198 <DIO_voidSetPinValue+0x106>
     194:	88 0f       	add	r24, r24
     196:	99 1f       	adc	r25, r25
     198:	0a 94       	dec	r0
     19a:	e2 f7       	brpl	.-8      	; 0x194 <DIO_voidSetPinValue+0x102>
     19c:	84 2b       	or	r24, r20
     19e:	8c 93       	st	X, r24
     1a0:	77 c0       	rjmp	.+238    	; 0x290 <DIO_voidSetPinValue+0x1fe>
			}
		
		}
		
		else if (u8PinValCopy == DIO_u8_LOW)
     1a2:	8b 81       	ldd	r24, Y+3	; 0x03
     1a4:	88 23       	and	r24, r24
     1a6:	09 f0       	breq	.+2      	; 0x1aa <DIO_voidSetPinValue+0x118>
     1a8:	73 c0       	rjmp	.+230    	; 0x290 <DIO_voidSetPinValue+0x1fe>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
     1aa:	89 81       	ldd	r24, Y+1	; 0x01
     1ac:	28 2f       	mov	r18, r24
     1ae:	30 e0       	ldi	r19, 0x00	; 0
     1b0:	3d 83       	std	Y+5, r19	; 0x05
     1b2:	2c 83       	std	Y+4, r18	; 0x04
     1b4:	8c 81       	ldd	r24, Y+4	; 0x04
     1b6:	9d 81       	ldd	r25, Y+5	; 0x05
     1b8:	81 30       	cpi	r24, 0x01	; 1
     1ba:	91 05       	cpc	r25, r1
     1bc:	59 f1       	breq	.+86     	; 0x214 <DIO_voidSetPinValue+0x182>
     1be:	2c 81       	ldd	r18, Y+4	; 0x04
     1c0:	3d 81       	ldd	r19, Y+5	; 0x05
     1c2:	22 30       	cpi	r18, 0x02	; 2
     1c4:	31 05       	cpc	r19, r1
     1c6:	2c f4       	brge	.+10     	; 0x1d2 <DIO_voidSetPinValue+0x140>
     1c8:	8c 81       	ldd	r24, Y+4	; 0x04
     1ca:	9d 81       	ldd	r25, Y+5	; 0x05
     1cc:	00 97       	sbiw	r24, 0x00	; 0
     1ce:	69 f0       	breq	.+26     	; 0x1ea <DIO_voidSetPinValue+0x158>
     1d0:	5f c0       	rjmp	.+190    	; 0x290 <DIO_voidSetPinValue+0x1fe>
     1d2:	2c 81       	ldd	r18, Y+4	; 0x04
     1d4:	3d 81       	ldd	r19, Y+5	; 0x05
     1d6:	22 30       	cpi	r18, 0x02	; 2
     1d8:	31 05       	cpc	r19, r1
     1da:	89 f1       	breq	.+98     	; 0x23e <DIO_voidSetPinValue+0x1ac>
     1dc:	8c 81       	ldd	r24, Y+4	; 0x04
     1de:	9d 81       	ldd	r25, Y+5	; 0x05
     1e0:	83 30       	cpi	r24, 0x03	; 3
     1e2:	91 05       	cpc	r25, r1
     1e4:	09 f4       	brne	.+2      	; 0x1e8 <DIO_voidSetPinValue+0x156>
     1e6:	40 c0       	rjmp	.+128    	; 0x268 <DIO_voidSetPinValue+0x1d6>
     1e8:	53 c0       	rjmp	.+166    	; 0x290 <DIO_voidSetPinValue+0x1fe>
			{
				case DIO_u8_PORTA: CLR_BIT(PORTA_Register,u8PinIdCopy); break;
     1ea:	ab e3       	ldi	r26, 0x3B	; 59
     1ec:	b0 e0       	ldi	r27, 0x00	; 0
     1ee:	eb e3       	ldi	r30, 0x3B	; 59
     1f0:	f0 e0       	ldi	r31, 0x00	; 0
     1f2:	80 81       	ld	r24, Z
     1f4:	48 2f       	mov	r20, r24
     1f6:	8a 81       	ldd	r24, Y+2	; 0x02
     1f8:	28 2f       	mov	r18, r24
     1fa:	30 e0       	ldi	r19, 0x00	; 0
     1fc:	81 e0       	ldi	r24, 0x01	; 1
     1fe:	90 e0       	ldi	r25, 0x00	; 0
     200:	02 2e       	mov	r0, r18
     202:	02 c0       	rjmp	.+4      	; 0x208 <DIO_voidSetPinValue+0x176>
     204:	88 0f       	add	r24, r24
     206:	99 1f       	adc	r25, r25
     208:	0a 94       	dec	r0
     20a:	e2 f7       	brpl	.-8      	; 0x204 <DIO_voidSetPinValue+0x172>
     20c:	80 95       	com	r24
     20e:	84 23       	and	r24, r20
     210:	8c 93       	st	X, r24
     212:	3e c0       	rjmp	.+124    	; 0x290 <DIO_voidSetPinValue+0x1fe>
				case DIO_u8_PORTB: CLR_BIT(PORTB_Register,u8PinIdCopy); break;
     214:	a8 e3       	ldi	r26, 0x38	; 56
     216:	b0 e0       	ldi	r27, 0x00	; 0
     218:	e8 e3       	ldi	r30, 0x38	; 56
     21a:	f0 e0       	ldi	r31, 0x00	; 0
     21c:	80 81       	ld	r24, Z
     21e:	48 2f       	mov	r20, r24
     220:	8a 81       	ldd	r24, Y+2	; 0x02
     222:	28 2f       	mov	r18, r24
     224:	30 e0       	ldi	r19, 0x00	; 0
     226:	81 e0       	ldi	r24, 0x01	; 1
     228:	90 e0       	ldi	r25, 0x00	; 0
     22a:	02 2e       	mov	r0, r18
     22c:	02 c0       	rjmp	.+4      	; 0x232 <DIO_voidSetPinValue+0x1a0>
     22e:	88 0f       	add	r24, r24
     230:	99 1f       	adc	r25, r25
     232:	0a 94       	dec	r0
     234:	e2 f7       	brpl	.-8      	; 0x22e <DIO_voidSetPinValue+0x19c>
     236:	80 95       	com	r24
     238:	84 23       	and	r24, r20
     23a:	8c 93       	st	X, r24
     23c:	29 c0       	rjmp	.+82     	; 0x290 <DIO_voidSetPinValue+0x1fe>
				case DIO_u8_PORTC: CLR_BIT(PORTC_Register,u8PinIdCopy); break;
     23e:	a5 e3       	ldi	r26, 0x35	; 53
     240:	b0 e0       	ldi	r27, 0x00	; 0
     242:	e5 e3       	ldi	r30, 0x35	; 53
     244:	f0 e0       	ldi	r31, 0x00	; 0
     246:	80 81       	ld	r24, Z
     248:	48 2f       	mov	r20, r24
     24a:	8a 81       	ldd	r24, Y+2	; 0x02
     24c:	28 2f       	mov	r18, r24
     24e:	30 e0       	ldi	r19, 0x00	; 0
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 2e       	mov	r0, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <DIO_voidSetPinValue+0x1ca>
     258:	88 0f       	add	r24, r24
     25a:	99 1f       	adc	r25, r25
     25c:	0a 94       	dec	r0
     25e:	e2 f7       	brpl	.-8      	; 0x258 <DIO_voidSetPinValue+0x1c6>
     260:	80 95       	com	r24
     262:	84 23       	and	r24, r20
     264:	8c 93       	st	X, r24
     266:	14 c0       	rjmp	.+40     	; 0x290 <DIO_voidSetPinValue+0x1fe>
				case DIO_u8_PORTD: CLR_BIT(PORTD_Register,u8PinIdCopy); break;
     268:	a2 e3       	ldi	r26, 0x32	; 50
     26a:	b0 e0       	ldi	r27, 0x00	; 0
     26c:	e2 e3       	ldi	r30, 0x32	; 50
     26e:	f0 e0       	ldi	r31, 0x00	; 0
     270:	80 81       	ld	r24, Z
     272:	48 2f       	mov	r20, r24
     274:	8a 81       	ldd	r24, Y+2	; 0x02
     276:	28 2f       	mov	r18, r24
     278:	30 e0       	ldi	r19, 0x00	; 0
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	90 e0       	ldi	r25, 0x00	; 0
     27e:	02 2e       	mov	r0, r18
     280:	02 c0       	rjmp	.+4      	; 0x286 <DIO_voidSetPinValue+0x1f4>
     282:	88 0f       	add	r24, r24
     284:	99 1f       	adc	r25, r25
     286:	0a 94       	dec	r0
     288:	e2 f7       	brpl	.-8      	; 0x282 <DIO_voidSetPinValue+0x1f0>
     28a:	80 95       	com	r24
     28c:	84 23       	and	r24, r20
     28e:	8c 93       	st	X, r24
	
	else
	{
		/* Do nothing, Error in the Pin ID or PORT ID */
	}
}
     290:	27 96       	adiw	r28, 0x07	; 7
     292:	0f b6       	in	r0, 0x3f	; 63
     294:	f8 94       	cli
     296:	de bf       	out	0x3e, r29	; 62
     298:	0f be       	out	0x3f, r0	; 63
     29a:	cd bf       	out	0x3d, r28	; 61
     29c:	cf 91       	pop	r28
     29e:	df 91       	pop	r29
     2a0:	08 95       	ret

000002a2 <DIO_u8GetPinValue>:

u8 DIO_u8GetPinValue(u8 u8PortIdCopy, u8 u8PinIdCopy)
{
     2a2:	df 93       	push	r29
     2a4:	cf 93       	push	r28
     2a6:	00 d0       	rcall	.+0      	; 0x2a8 <DIO_u8GetPinValue+0x6>
     2a8:	00 d0       	rcall	.+0      	; 0x2aa <DIO_u8GetPinValue+0x8>
     2aa:	0f 92       	push	r0
     2ac:	cd b7       	in	r28, 0x3d	; 61
     2ae:	de b7       	in	r29, 0x3e	; 62
     2b0:	8a 83       	std	Y+2, r24	; 0x02
     2b2:	6b 83       	std	Y+3, r22	; 0x03
	/* Define Local Variable to get the BIT Value */
	u8 u8ResultLocal;
	/* Make sure that the Port ID and Pin ID are in the valid range */
	if ((u8PortIdCopy <= DIO_u8_PORTD) && (u8PinIdCopy <= DIO_u8_PIN7))
     2b4:	8a 81       	ldd	r24, Y+2	; 0x02
     2b6:	84 30       	cpi	r24, 0x04	; 4
     2b8:	08 f0       	brcs	.+2      	; 0x2bc <DIO_u8GetPinValue+0x1a>
     2ba:	6c c0       	rjmp	.+216    	; 0x394 <DIO_u8GetPinValue+0xf2>
     2bc:	8b 81       	ldd	r24, Y+3	; 0x03
     2be:	88 30       	cpi	r24, 0x08	; 8
     2c0:	08 f0       	brcs	.+2      	; 0x2c4 <DIO_u8GetPinValue+0x22>
     2c2:	68 c0       	rjmp	.+208    	; 0x394 <DIO_u8GetPinValue+0xf2>
	{
		/* Check on the Required PORT Number */
		switch (u8PortIdCopy)
     2c4:	8a 81       	ldd	r24, Y+2	; 0x02
     2c6:	28 2f       	mov	r18, r24
     2c8:	30 e0       	ldi	r19, 0x00	; 0
     2ca:	3d 83       	std	Y+5, r19	; 0x05
     2cc:	2c 83       	std	Y+4, r18	; 0x04
     2ce:	4c 81       	ldd	r20, Y+4	; 0x04
     2d0:	5d 81       	ldd	r21, Y+5	; 0x05
     2d2:	41 30       	cpi	r20, 0x01	; 1
     2d4:	51 05       	cpc	r21, r1
     2d6:	41 f1       	breq	.+80     	; 0x328 <DIO_u8GetPinValue+0x86>
     2d8:	8c 81       	ldd	r24, Y+4	; 0x04
     2da:	9d 81       	ldd	r25, Y+5	; 0x05
     2dc:	82 30       	cpi	r24, 0x02	; 2
     2de:	91 05       	cpc	r25, r1
     2e0:	34 f4       	brge	.+12     	; 0x2ee <DIO_u8GetPinValue+0x4c>
     2e2:	2c 81       	ldd	r18, Y+4	; 0x04
     2e4:	3d 81       	ldd	r19, Y+5	; 0x05
     2e6:	21 15       	cp	r18, r1
     2e8:	31 05       	cpc	r19, r1
     2ea:	61 f0       	breq	.+24     	; 0x304 <DIO_u8GetPinValue+0x62>
     2ec:	55 c0       	rjmp	.+170    	; 0x398 <DIO_u8GetPinValue+0xf6>
     2ee:	4c 81       	ldd	r20, Y+4	; 0x04
     2f0:	5d 81       	ldd	r21, Y+5	; 0x05
     2f2:	42 30       	cpi	r20, 0x02	; 2
     2f4:	51 05       	cpc	r21, r1
     2f6:	51 f1       	breq	.+84     	; 0x34c <DIO_u8GetPinValue+0xaa>
     2f8:	8c 81       	ldd	r24, Y+4	; 0x04
     2fa:	9d 81       	ldd	r25, Y+5	; 0x05
     2fc:	83 30       	cpi	r24, 0x03	; 3
     2fe:	91 05       	cpc	r25, r1
     300:	b9 f1       	breq	.+110    	; 0x370 <DIO_u8GetPinValue+0xce>
     302:	4a c0       	rjmp	.+148    	; 0x398 <DIO_u8GetPinValue+0xf6>
		{
			case DIO_u8_PORTA: u8ResultLocal= GET_BIT(PINA_Register,u8PinIdCopy); break;
     304:	e9 e3       	ldi	r30, 0x39	; 57
     306:	f0 e0       	ldi	r31, 0x00	; 0
     308:	80 81       	ld	r24, Z
     30a:	28 2f       	mov	r18, r24
     30c:	30 e0       	ldi	r19, 0x00	; 0
     30e:	8b 81       	ldd	r24, Y+3	; 0x03
     310:	88 2f       	mov	r24, r24
     312:	90 e0       	ldi	r25, 0x00	; 0
     314:	a9 01       	movw	r20, r18
     316:	02 c0       	rjmp	.+4      	; 0x31c <DIO_u8GetPinValue+0x7a>
     318:	55 95       	asr	r21
     31a:	47 95       	ror	r20
     31c:	8a 95       	dec	r24
     31e:	e2 f7       	brpl	.-8      	; 0x318 <DIO_u8GetPinValue+0x76>
     320:	ca 01       	movw	r24, r20
     322:	81 70       	andi	r24, 0x01	; 1
     324:	89 83       	std	Y+1, r24	; 0x01
     326:	38 c0       	rjmp	.+112    	; 0x398 <DIO_u8GetPinValue+0xf6>
			case DIO_u8_PORTB: u8ResultLocal= GET_BIT(PINB_Register,u8PinIdCopy); break;
     328:	e6 e3       	ldi	r30, 0x36	; 54
     32a:	f0 e0       	ldi	r31, 0x00	; 0
     32c:	80 81       	ld	r24, Z
     32e:	28 2f       	mov	r18, r24
     330:	30 e0       	ldi	r19, 0x00	; 0
     332:	8b 81       	ldd	r24, Y+3	; 0x03
     334:	88 2f       	mov	r24, r24
     336:	90 e0       	ldi	r25, 0x00	; 0
     338:	a9 01       	movw	r20, r18
     33a:	02 c0       	rjmp	.+4      	; 0x340 <DIO_u8GetPinValue+0x9e>
     33c:	55 95       	asr	r21
     33e:	47 95       	ror	r20
     340:	8a 95       	dec	r24
     342:	e2 f7       	brpl	.-8      	; 0x33c <DIO_u8GetPinValue+0x9a>
     344:	ca 01       	movw	r24, r20
     346:	81 70       	andi	r24, 0x01	; 1
     348:	89 83       	std	Y+1, r24	; 0x01
     34a:	26 c0       	rjmp	.+76     	; 0x398 <DIO_u8GetPinValue+0xf6>
			case DIO_u8_PORTC: u8ResultLocal= GET_BIT(PINC_Register,u8PinIdCopy); break;
     34c:	e3 e3       	ldi	r30, 0x33	; 51
     34e:	f0 e0       	ldi	r31, 0x00	; 0
     350:	80 81       	ld	r24, Z
     352:	28 2f       	mov	r18, r24
     354:	30 e0       	ldi	r19, 0x00	; 0
     356:	8b 81       	ldd	r24, Y+3	; 0x03
     358:	88 2f       	mov	r24, r24
     35a:	90 e0       	ldi	r25, 0x00	; 0
     35c:	a9 01       	movw	r20, r18
     35e:	02 c0       	rjmp	.+4      	; 0x364 <DIO_u8GetPinValue+0xc2>
     360:	55 95       	asr	r21
     362:	47 95       	ror	r20
     364:	8a 95       	dec	r24
     366:	e2 f7       	brpl	.-8      	; 0x360 <DIO_u8GetPinValue+0xbe>
     368:	ca 01       	movw	r24, r20
     36a:	81 70       	andi	r24, 0x01	; 1
     36c:	89 83       	std	Y+1, r24	; 0x01
     36e:	14 c0       	rjmp	.+40     	; 0x398 <DIO_u8GetPinValue+0xf6>
			case DIO_u8_PORTD: u8ResultLocal= GET_BIT(PIND_Register,u8PinIdCopy); break;
     370:	e0 e3       	ldi	r30, 0x30	; 48
     372:	f0 e0       	ldi	r31, 0x00	; 0
     374:	80 81       	ld	r24, Z
     376:	28 2f       	mov	r18, r24
     378:	30 e0       	ldi	r19, 0x00	; 0
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
     37c:	88 2f       	mov	r24, r24
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	a9 01       	movw	r20, r18
     382:	02 c0       	rjmp	.+4      	; 0x388 <DIO_u8GetPinValue+0xe6>
     384:	55 95       	asr	r21
     386:	47 95       	ror	r20
     388:	8a 95       	dec	r24
     38a:	e2 f7       	brpl	.-8      	; 0x384 <DIO_u8GetPinValue+0xe2>
     38c:	ca 01       	movw	r24, r20
     38e:	81 70       	andi	r24, 0x01	; 1
     390:	89 83       	std	Y+1, r24	; 0x01
     392:	02 c0       	rjmp	.+4      	; 0x398 <DIO_u8GetPinValue+0xf6>
	}
	
	else
	{
		/* return 0xff in case of error in the Pin ID or PORT ID */
		u8ResultLocal = 0xFF;
     394:	8f ef       	ldi	r24, 0xFF	; 255
     396:	89 83       	std	Y+1, r24	; 0x01
	}
	
	return u8ResultLocal;
     398:	89 81       	ldd	r24, Y+1	; 0x01
}
     39a:	0f 90       	pop	r0
     39c:	0f 90       	pop	r0
     39e:	0f 90       	pop	r0
     3a0:	0f 90       	pop	r0
     3a2:	0f 90       	pop	r0
     3a4:	cf 91       	pop	r28
     3a6:	df 91       	pop	r29
     3a8:	08 95       	ret

000003aa <DIO_voidSetPinDirection>:

void DIO_voidSetPinDirection  (u8 u8PortIdCopy, u8 u8PinIdCopy, u8 u8PinDirCopy)
{
     3aa:	df 93       	push	r29
     3ac:	cf 93       	push	r28
     3ae:	cd b7       	in	r28, 0x3d	; 61
     3b0:	de b7       	in	r29, 0x3e	; 62
     3b2:	27 97       	sbiw	r28, 0x07	; 7
     3b4:	0f b6       	in	r0, 0x3f	; 63
     3b6:	f8 94       	cli
     3b8:	de bf       	out	0x3e, r29	; 62
     3ba:	0f be       	out	0x3f, r0	; 63
     3bc:	cd bf       	out	0x3d, r28	; 61
     3be:	89 83       	std	Y+1, r24	; 0x01
     3c0:	6a 83       	std	Y+2, r22	; 0x02
     3c2:	4b 83       	std	Y+3, r20	; 0x03
	/* Make sure that the Port ID and Pin ID are in the valid range */
	if ((u8PortIdCopy <= DIO_u8_PORTD) && (u8PinIdCopy <= DIO_u8_PIN7))
     3c4:	89 81       	ldd	r24, Y+1	; 0x01
     3c6:	84 30       	cpi	r24, 0x04	; 4
     3c8:	08 f0       	brcs	.+2      	; 0x3cc <DIO_voidSetPinDirection+0x22>
     3ca:	ee c0       	rjmp	.+476    	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
     3cc:	8a 81       	ldd	r24, Y+2	; 0x02
     3ce:	88 30       	cpi	r24, 0x08	; 8
     3d0:	08 f0       	brcs	.+2      	; 0x3d4 <DIO_voidSetPinDirection+0x2a>
     3d2:	ea c0       	rjmp	.+468    	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
	{
		if ( u8PinDirCopy == DIO_u8_OUTPUT )
     3d4:	8b 81       	ldd	r24, Y+3	; 0x03
     3d6:	81 30       	cpi	r24, 0x01	; 1
     3d8:	09 f0       	breq	.+2      	; 0x3dc <DIO_voidSetPinDirection+0x32>
     3da:	6f c0       	rjmp	.+222    	; 0x4ba <DIO_voidSetPinDirection+0x110>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
     3dc:	89 81       	ldd	r24, Y+1	; 0x01
     3de:	28 2f       	mov	r18, r24
     3e0:	30 e0       	ldi	r19, 0x00	; 0
     3e2:	3f 83       	std	Y+7, r19	; 0x07
     3e4:	2e 83       	std	Y+6, r18	; 0x06
     3e6:	8e 81       	ldd	r24, Y+6	; 0x06
     3e8:	9f 81       	ldd	r25, Y+7	; 0x07
     3ea:	81 30       	cpi	r24, 0x01	; 1
     3ec:	91 05       	cpc	r25, r1
     3ee:	49 f1       	breq	.+82     	; 0x442 <DIO_voidSetPinDirection+0x98>
     3f0:	2e 81       	ldd	r18, Y+6	; 0x06
     3f2:	3f 81       	ldd	r19, Y+7	; 0x07
     3f4:	22 30       	cpi	r18, 0x02	; 2
     3f6:	31 05       	cpc	r19, r1
     3f8:	2c f4       	brge	.+10     	; 0x404 <DIO_voidSetPinDirection+0x5a>
     3fa:	8e 81       	ldd	r24, Y+6	; 0x06
     3fc:	9f 81       	ldd	r25, Y+7	; 0x07
     3fe:	00 97       	sbiw	r24, 0x00	; 0
     400:	61 f0       	breq	.+24     	; 0x41a <DIO_voidSetPinDirection+0x70>
     402:	d2 c0       	rjmp	.+420    	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
     404:	2e 81       	ldd	r18, Y+6	; 0x06
     406:	3f 81       	ldd	r19, Y+7	; 0x07
     408:	22 30       	cpi	r18, 0x02	; 2
     40a:	31 05       	cpc	r19, r1
     40c:	71 f1       	breq	.+92     	; 0x46a <DIO_voidSetPinDirection+0xc0>
     40e:	8e 81       	ldd	r24, Y+6	; 0x06
     410:	9f 81       	ldd	r25, Y+7	; 0x07
     412:	83 30       	cpi	r24, 0x03	; 3
     414:	91 05       	cpc	r25, r1
     416:	e9 f1       	breq	.+122    	; 0x492 <DIO_voidSetPinDirection+0xe8>
     418:	c7 c0       	rjmp	.+398    	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
			{
				case DIO_u8_PORTA: SET_BIT(DDRA_Register,u8PinIdCopy); break;
     41a:	aa e3       	ldi	r26, 0x3A	; 58
     41c:	b0 e0       	ldi	r27, 0x00	; 0
     41e:	ea e3       	ldi	r30, 0x3A	; 58
     420:	f0 e0       	ldi	r31, 0x00	; 0
     422:	80 81       	ld	r24, Z
     424:	48 2f       	mov	r20, r24
     426:	8a 81       	ldd	r24, Y+2	; 0x02
     428:	28 2f       	mov	r18, r24
     42a:	30 e0       	ldi	r19, 0x00	; 0
     42c:	81 e0       	ldi	r24, 0x01	; 1
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	02 2e       	mov	r0, r18
     432:	02 c0       	rjmp	.+4      	; 0x438 <DIO_voidSetPinDirection+0x8e>
     434:	88 0f       	add	r24, r24
     436:	99 1f       	adc	r25, r25
     438:	0a 94       	dec	r0
     43a:	e2 f7       	brpl	.-8      	; 0x434 <DIO_voidSetPinDirection+0x8a>
     43c:	84 2b       	or	r24, r20
     43e:	8c 93       	st	X, r24
     440:	b3 c0       	rjmp	.+358    	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
				case DIO_u8_PORTB: SET_BIT(DDRB_Register,u8PinIdCopy); break;
     442:	a7 e3       	ldi	r26, 0x37	; 55
     444:	b0 e0       	ldi	r27, 0x00	; 0
     446:	e7 e3       	ldi	r30, 0x37	; 55
     448:	f0 e0       	ldi	r31, 0x00	; 0
     44a:	80 81       	ld	r24, Z
     44c:	48 2f       	mov	r20, r24
     44e:	8a 81       	ldd	r24, Y+2	; 0x02
     450:	28 2f       	mov	r18, r24
     452:	30 e0       	ldi	r19, 0x00	; 0
     454:	81 e0       	ldi	r24, 0x01	; 1
     456:	90 e0       	ldi	r25, 0x00	; 0
     458:	02 2e       	mov	r0, r18
     45a:	02 c0       	rjmp	.+4      	; 0x460 <DIO_voidSetPinDirection+0xb6>
     45c:	88 0f       	add	r24, r24
     45e:	99 1f       	adc	r25, r25
     460:	0a 94       	dec	r0
     462:	e2 f7       	brpl	.-8      	; 0x45c <DIO_voidSetPinDirection+0xb2>
     464:	84 2b       	or	r24, r20
     466:	8c 93       	st	X, r24
     468:	9f c0       	rjmp	.+318    	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
				case DIO_u8_PORTC: SET_BIT(DDRC_Register,u8PinIdCopy); break;
     46a:	a4 e3       	ldi	r26, 0x34	; 52
     46c:	b0 e0       	ldi	r27, 0x00	; 0
     46e:	e4 e3       	ldi	r30, 0x34	; 52
     470:	f0 e0       	ldi	r31, 0x00	; 0
     472:	80 81       	ld	r24, Z
     474:	48 2f       	mov	r20, r24
     476:	8a 81       	ldd	r24, Y+2	; 0x02
     478:	28 2f       	mov	r18, r24
     47a:	30 e0       	ldi	r19, 0x00	; 0
     47c:	81 e0       	ldi	r24, 0x01	; 1
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	02 2e       	mov	r0, r18
     482:	02 c0       	rjmp	.+4      	; 0x488 <DIO_voidSetPinDirection+0xde>
     484:	88 0f       	add	r24, r24
     486:	99 1f       	adc	r25, r25
     488:	0a 94       	dec	r0
     48a:	e2 f7       	brpl	.-8      	; 0x484 <DIO_voidSetPinDirection+0xda>
     48c:	84 2b       	or	r24, r20
     48e:	8c 93       	st	X, r24
     490:	8b c0       	rjmp	.+278    	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
				case DIO_u8_PORTD: SET_BIT(DDRD_Register,u8PinIdCopy); break;
     492:	a1 e3       	ldi	r26, 0x31	; 49
     494:	b0 e0       	ldi	r27, 0x00	; 0
     496:	e1 e3       	ldi	r30, 0x31	; 49
     498:	f0 e0       	ldi	r31, 0x00	; 0
     49a:	80 81       	ld	r24, Z
     49c:	48 2f       	mov	r20, r24
     49e:	8a 81       	ldd	r24, Y+2	; 0x02
     4a0:	28 2f       	mov	r18, r24
     4a2:	30 e0       	ldi	r19, 0x00	; 0
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	02 2e       	mov	r0, r18
     4aa:	02 c0       	rjmp	.+4      	; 0x4b0 <DIO_voidSetPinDirection+0x106>
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	0a 94       	dec	r0
     4b2:	e2 f7       	brpl	.-8      	; 0x4ac <DIO_voidSetPinDirection+0x102>
     4b4:	84 2b       	or	r24, r20
     4b6:	8c 93       	st	X, r24
     4b8:	77 c0       	rjmp	.+238    	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
			}
		}
		
		else if ( u8PinDirCopy == DIO_u8_INPUT )
     4ba:	8b 81       	ldd	r24, Y+3	; 0x03
     4bc:	88 23       	and	r24, r24
     4be:	09 f0       	breq	.+2      	; 0x4c2 <DIO_voidSetPinDirection+0x118>
     4c0:	73 c0       	rjmp	.+230    	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
     4c2:	89 81       	ldd	r24, Y+1	; 0x01
     4c4:	28 2f       	mov	r18, r24
     4c6:	30 e0       	ldi	r19, 0x00	; 0
     4c8:	3d 83       	std	Y+5, r19	; 0x05
     4ca:	2c 83       	std	Y+4, r18	; 0x04
     4cc:	8c 81       	ldd	r24, Y+4	; 0x04
     4ce:	9d 81       	ldd	r25, Y+5	; 0x05
     4d0:	81 30       	cpi	r24, 0x01	; 1
     4d2:	91 05       	cpc	r25, r1
     4d4:	59 f1       	breq	.+86     	; 0x52c <DIO_voidSetPinDirection+0x182>
     4d6:	2c 81       	ldd	r18, Y+4	; 0x04
     4d8:	3d 81       	ldd	r19, Y+5	; 0x05
     4da:	22 30       	cpi	r18, 0x02	; 2
     4dc:	31 05       	cpc	r19, r1
     4de:	2c f4       	brge	.+10     	; 0x4ea <DIO_voidSetPinDirection+0x140>
     4e0:	8c 81       	ldd	r24, Y+4	; 0x04
     4e2:	9d 81       	ldd	r25, Y+5	; 0x05
     4e4:	00 97       	sbiw	r24, 0x00	; 0
     4e6:	69 f0       	breq	.+26     	; 0x502 <DIO_voidSetPinDirection+0x158>
     4e8:	5f c0       	rjmp	.+190    	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
     4ea:	2c 81       	ldd	r18, Y+4	; 0x04
     4ec:	3d 81       	ldd	r19, Y+5	; 0x05
     4ee:	22 30       	cpi	r18, 0x02	; 2
     4f0:	31 05       	cpc	r19, r1
     4f2:	89 f1       	breq	.+98     	; 0x556 <DIO_voidSetPinDirection+0x1ac>
     4f4:	8c 81       	ldd	r24, Y+4	; 0x04
     4f6:	9d 81       	ldd	r25, Y+5	; 0x05
     4f8:	83 30       	cpi	r24, 0x03	; 3
     4fa:	91 05       	cpc	r25, r1
     4fc:	09 f4       	brne	.+2      	; 0x500 <DIO_voidSetPinDirection+0x156>
     4fe:	40 c0       	rjmp	.+128    	; 0x580 <DIO_voidSetPinDirection+0x1d6>
     500:	53 c0       	rjmp	.+166    	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
			{
				case DIO_u8_PORTA: CLR_BIT(DDRA_Register,u8PinIdCopy); break;
     502:	aa e3       	ldi	r26, 0x3A	; 58
     504:	b0 e0       	ldi	r27, 0x00	; 0
     506:	ea e3       	ldi	r30, 0x3A	; 58
     508:	f0 e0       	ldi	r31, 0x00	; 0
     50a:	80 81       	ld	r24, Z
     50c:	48 2f       	mov	r20, r24
     50e:	8a 81       	ldd	r24, Y+2	; 0x02
     510:	28 2f       	mov	r18, r24
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 2e       	mov	r0, r18
     51a:	02 c0       	rjmp	.+4      	; 0x520 <DIO_voidSetPinDirection+0x176>
     51c:	88 0f       	add	r24, r24
     51e:	99 1f       	adc	r25, r25
     520:	0a 94       	dec	r0
     522:	e2 f7       	brpl	.-8      	; 0x51c <DIO_voidSetPinDirection+0x172>
     524:	80 95       	com	r24
     526:	84 23       	and	r24, r20
     528:	8c 93       	st	X, r24
     52a:	3e c0       	rjmp	.+124    	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
				case DIO_u8_PORTB: CLR_BIT(DDRB_Register,u8PinIdCopy); break;
     52c:	a7 e3       	ldi	r26, 0x37	; 55
     52e:	b0 e0       	ldi	r27, 0x00	; 0
     530:	e7 e3       	ldi	r30, 0x37	; 55
     532:	f0 e0       	ldi	r31, 0x00	; 0
     534:	80 81       	ld	r24, Z
     536:	48 2f       	mov	r20, r24
     538:	8a 81       	ldd	r24, Y+2	; 0x02
     53a:	28 2f       	mov	r18, r24
     53c:	30 e0       	ldi	r19, 0x00	; 0
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	02 2e       	mov	r0, r18
     544:	02 c0       	rjmp	.+4      	; 0x54a <DIO_voidSetPinDirection+0x1a0>
     546:	88 0f       	add	r24, r24
     548:	99 1f       	adc	r25, r25
     54a:	0a 94       	dec	r0
     54c:	e2 f7       	brpl	.-8      	; 0x546 <DIO_voidSetPinDirection+0x19c>
     54e:	80 95       	com	r24
     550:	84 23       	and	r24, r20
     552:	8c 93       	st	X, r24
     554:	29 c0       	rjmp	.+82     	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
				case DIO_u8_PORTC: CLR_BIT(DDRC_Register,u8PinIdCopy); break;
     556:	a4 e3       	ldi	r26, 0x34	; 52
     558:	b0 e0       	ldi	r27, 0x00	; 0
     55a:	e4 e3       	ldi	r30, 0x34	; 52
     55c:	f0 e0       	ldi	r31, 0x00	; 0
     55e:	80 81       	ld	r24, Z
     560:	48 2f       	mov	r20, r24
     562:	8a 81       	ldd	r24, Y+2	; 0x02
     564:	28 2f       	mov	r18, r24
     566:	30 e0       	ldi	r19, 0x00	; 0
     568:	81 e0       	ldi	r24, 0x01	; 1
     56a:	90 e0       	ldi	r25, 0x00	; 0
     56c:	02 2e       	mov	r0, r18
     56e:	02 c0       	rjmp	.+4      	; 0x574 <DIO_voidSetPinDirection+0x1ca>
     570:	88 0f       	add	r24, r24
     572:	99 1f       	adc	r25, r25
     574:	0a 94       	dec	r0
     576:	e2 f7       	brpl	.-8      	; 0x570 <DIO_voidSetPinDirection+0x1c6>
     578:	80 95       	com	r24
     57a:	84 23       	and	r24, r20
     57c:	8c 93       	st	X, r24
     57e:	14 c0       	rjmp	.+40     	; 0x5a8 <DIO_voidSetPinDirection+0x1fe>
				case DIO_u8_PORTD: CLR_BIT(DDRD_Register,u8PinIdCopy); break;
     580:	a1 e3       	ldi	r26, 0x31	; 49
     582:	b0 e0       	ldi	r27, 0x00	; 0
     584:	e1 e3       	ldi	r30, 0x31	; 49
     586:	f0 e0       	ldi	r31, 0x00	; 0
     588:	80 81       	ld	r24, Z
     58a:	48 2f       	mov	r20, r24
     58c:	8a 81       	ldd	r24, Y+2	; 0x02
     58e:	28 2f       	mov	r18, r24
     590:	30 e0       	ldi	r19, 0x00	; 0
     592:	81 e0       	ldi	r24, 0x01	; 1
     594:	90 e0       	ldi	r25, 0x00	; 0
     596:	02 2e       	mov	r0, r18
     598:	02 c0       	rjmp	.+4      	; 0x59e <DIO_voidSetPinDirection+0x1f4>
     59a:	88 0f       	add	r24, r24
     59c:	99 1f       	adc	r25, r25
     59e:	0a 94       	dec	r0
     5a0:	e2 f7       	brpl	.-8      	; 0x59a <DIO_voidSetPinDirection+0x1f0>
     5a2:	80 95       	com	r24
     5a4:	84 23       	and	r24, r20
     5a6:	8c 93       	st	X, r24
	
	else
	{
		/* Do nothing, Error in the Pin ID or PORT ID */
	}
}
     5a8:	27 96       	adiw	r28, 0x07	; 7
     5aa:	0f b6       	in	r0, 0x3f	; 63
     5ac:	f8 94       	cli
     5ae:	de bf       	out	0x3e, r29	; 62
     5b0:	0f be       	out	0x3f, r0	; 63
     5b2:	cd bf       	out	0x3d, r28	; 61
     5b4:	cf 91       	pop	r28
     5b6:	df 91       	pop	r29
     5b8:	08 95       	ret

000005ba <DIO_voidSetPortDirection>:


/* IO Ports */
void DIO_voidSetPortDirection (u8 u8PortId, u8 u8PortDir)
{
     5ba:	df 93       	push	r29
     5bc:	cf 93       	push	r28
     5be:	00 d0       	rcall	.+0      	; 0x5c0 <DIO_voidSetPortDirection+0x6>
     5c0:	00 d0       	rcall	.+0      	; 0x5c2 <DIO_voidSetPortDirection+0x8>
     5c2:	cd b7       	in	r28, 0x3d	; 61
     5c4:	de b7       	in	r29, 0x3e	; 62
     5c6:	89 83       	std	Y+1, r24	; 0x01
     5c8:	6a 83       	std	Y+2, r22	; 0x02
	/* Check on the Required PORT Number */
	switch (u8PortId)
     5ca:	89 81       	ldd	r24, Y+1	; 0x01
     5cc:	28 2f       	mov	r18, r24
     5ce:	30 e0       	ldi	r19, 0x00	; 0
     5d0:	3c 83       	std	Y+4, r19	; 0x04
     5d2:	2b 83       	std	Y+3, r18	; 0x03
     5d4:	8b 81       	ldd	r24, Y+3	; 0x03
     5d6:	9c 81       	ldd	r25, Y+4	; 0x04
     5d8:	81 30       	cpi	r24, 0x01	; 1
     5da:	91 05       	cpc	r25, r1
     5dc:	d1 f0       	breq	.+52     	; 0x612 <DIO_voidSetPortDirection+0x58>
     5de:	2b 81       	ldd	r18, Y+3	; 0x03
     5e0:	3c 81       	ldd	r19, Y+4	; 0x04
     5e2:	22 30       	cpi	r18, 0x02	; 2
     5e4:	31 05       	cpc	r19, r1
     5e6:	2c f4       	brge	.+10     	; 0x5f2 <DIO_voidSetPortDirection+0x38>
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	9c 81       	ldd	r25, Y+4	; 0x04
     5ec:	00 97       	sbiw	r24, 0x00	; 0
     5ee:	61 f0       	breq	.+24     	; 0x608 <DIO_voidSetPortDirection+0x4e>
     5f0:	1e c0       	rjmp	.+60     	; 0x62e <DIO_voidSetPortDirection+0x74>
     5f2:	2b 81       	ldd	r18, Y+3	; 0x03
     5f4:	3c 81       	ldd	r19, Y+4	; 0x04
     5f6:	22 30       	cpi	r18, 0x02	; 2
     5f8:	31 05       	cpc	r19, r1
     5fa:	81 f0       	breq	.+32     	; 0x61c <DIO_voidSetPortDirection+0x62>
     5fc:	8b 81       	ldd	r24, Y+3	; 0x03
     5fe:	9c 81       	ldd	r25, Y+4	; 0x04
     600:	83 30       	cpi	r24, 0x03	; 3
     602:	91 05       	cpc	r25, r1
     604:	81 f0       	breq	.+32     	; 0x626 <DIO_voidSetPortDirection+0x6c>
     606:	13 c0       	rjmp	.+38     	; 0x62e <DIO_voidSetPortDirection+0x74>
	{
		case     DIO_u8_PORTA: DDRA_Register = u8PortDir; break;
     608:	ea e3       	ldi	r30, 0x3A	; 58
     60a:	f0 e0       	ldi	r31, 0x00	; 0
     60c:	8a 81       	ldd	r24, Y+2	; 0x02
     60e:	80 83       	st	Z, r24
     610:	0e c0       	rjmp	.+28     	; 0x62e <DIO_voidSetPortDirection+0x74>
		case     DIO_u8_PORTB: DDRB_Register = u8PortDir; break;
     612:	e7 e3       	ldi	r30, 0x37	; 55
     614:	f0 e0       	ldi	r31, 0x00	; 0
     616:	8a 81       	ldd	r24, Y+2	; 0x02
     618:	80 83       	st	Z, r24
     61a:	09 c0       	rjmp	.+18     	; 0x62e <DIO_voidSetPortDirection+0x74>
		case     DIO_u8_PORTC: DDRC_Register = u8PortDir; break;
     61c:	e4 e3       	ldi	r30, 0x34	; 52
     61e:	f0 e0       	ldi	r31, 0x00	; 0
     620:	8a 81       	ldd	r24, Y+2	; 0x02
     622:	80 83       	st	Z, r24
     624:	04 c0       	rjmp	.+8      	; 0x62e <DIO_voidSetPortDirection+0x74>
		case     DIO_u8_PORTD: DDRD_Register = u8PortDir; break;
     626:	e1 e3       	ldi	r30, 0x31	; 49
     628:	f0 e0       	ldi	r31, 0x00	; 0
     62a:	8a 81       	ldd	r24, Y+2	; 0x02
     62c:	80 83       	st	Z, r24
		default: /* Wrong Port ID */       break;
	}
}
     62e:	0f 90       	pop	r0
     630:	0f 90       	pop	r0
     632:	0f 90       	pop	r0
     634:	0f 90       	pop	r0
     636:	cf 91       	pop	r28
     638:	df 91       	pop	r29
     63a:	08 95       	ret

0000063c <DIO_voidSetPortValue>:

void DIO_voidSetPortValue     (u8 u8PortId, u8 u8PortVal)
{
     63c:	df 93       	push	r29
     63e:	cf 93       	push	r28
     640:	00 d0       	rcall	.+0      	; 0x642 <DIO_voidSetPortValue+0x6>
     642:	00 d0       	rcall	.+0      	; 0x644 <DIO_voidSetPortValue+0x8>
     644:	cd b7       	in	r28, 0x3d	; 61
     646:	de b7       	in	r29, 0x3e	; 62
     648:	89 83       	std	Y+1, r24	; 0x01
     64a:	6a 83       	std	Y+2, r22	; 0x02
	/* Check on the Required PORT Number */
	switch (u8PortId)
     64c:	89 81       	ldd	r24, Y+1	; 0x01
     64e:	28 2f       	mov	r18, r24
     650:	30 e0       	ldi	r19, 0x00	; 0
     652:	3c 83       	std	Y+4, r19	; 0x04
     654:	2b 83       	std	Y+3, r18	; 0x03
     656:	8b 81       	ldd	r24, Y+3	; 0x03
     658:	9c 81       	ldd	r25, Y+4	; 0x04
     65a:	81 30       	cpi	r24, 0x01	; 1
     65c:	91 05       	cpc	r25, r1
     65e:	d1 f0       	breq	.+52     	; 0x694 <DIO_voidSetPortValue+0x58>
     660:	2b 81       	ldd	r18, Y+3	; 0x03
     662:	3c 81       	ldd	r19, Y+4	; 0x04
     664:	22 30       	cpi	r18, 0x02	; 2
     666:	31 05       	cpc	r19, r1
     668:	2c f4       	brge	.+10     	; 0x674 <DIO_voidSetPortValue+0x38>
     66a:	8b 81       	ldd	r24, Y+3	; 0x03
     66c:	9c 81       	ldd	r25, Y+4	; 0x04
     66e:	00 97       	sbiw	r24, 0x00	; 0
     670:	61 f0       	breq	.+24     	; 0x68a <DIO_voidSetPortValue+0x4e>
     672:	1e c0       	rjmp	.+60     	; 0x6b0 <DIO_voidSetPortValue+0x74>
     674:	2b 81       	ldd	r18, Y+3	; 0x03
     676:	3c 81       	ldd	r19, Y+4	; 0x04
     678:	22 30       	cpi	r18, 0x02	; 2
     67a:	31 05       	cpc	r19, r1
     67c:	81 f0       	breq	.+32     	; 0x69e <DIO_voidSetPortValue+0x62>
     67e:	8b 81       	ldd	r24, Y+3	; 0x03
     680:	9c 81       	ldd	r25, Y+4	; 0x04
     682:	83 30       	cpi	r24, 0x03	; 3
     684:	91 05       	cpc	r25, r1
     686:	81 f0       	breq	.+32     	; 0x6a8 <DIO_voidSetPortValue+0x6c>
     688:	13 c0       	rjmp	.+38     	; 0x6b0 <DIO_voidSetPortValue+0x74>
	{
		case     DIO_u8_PORTA: PORTA_Register = u8PortVal; break;
     68a:	eb e3       	ldi	r30, 0x3B	; 59
     68c:	f0 e0       	ldi	r31, 0x00	; 0
     68e:	8a 81       	ldd	r24, Y+2	; 0x02
     690:	80 83       	st	Z, r24
     692:	0e c0       	rjmp	.+28     	; 0x6b0 <DIO_voidSetPortValue+0x74>
		case     DIO_u8_PORTB: PORTB_Register = u8PortVal; break;
     694:	e8 e3       	ldi	r30, 0x38	; 56
     696:	f0 e0       	ldi	r31, 0x00	; 0
     698:	8a 81       	ldd	r24, Y+2	; 0x02
     69a:	80 83       	st	Z, r24
     69c:	09 c0       	rjmp	.+18     	; 0x6b0 <DIO_voidSetPortValue+0x74>
		case     DIO_u8_PORTC: PORTC_Register = u8PortVal; break;
     69e:	e5 e3       	ldi	r30, 0x35	; 53
     6a0:	f0 e0       	ldi	r31, 0x00	; 0
     6a2:	8a 81       	ldd	r24, Y+2	; 0x02
     6a4:	80 83       	st	Z, r24
     6a6:	04 c0       	rjmp	.+8      	; 0x6b0 <DIO_voidSetPortValue+0x74>
		case     DIO_u8_PORTD: PORTD_Register = u8PortVal; break;
     6a8:	e2 e3       	ldi	r30, 0x32	; 50
     6aa:	f0 e0       	ldi	r31, 0x00	; 0
     6ac:	8a 81       	ldd	r24, Y+2	; 0x02
     6ae:	80 83       	st	Z, r24
		default: /* Wrong Port ID */        break;
	}
}
     6b0:	0f 90       	pop	r0
     6b2:	0f 90       	pop	r0
     6b4:	0f 90       	pop	r0
     6b6:	0f 90       	pop	r0
     6b8:	cf 91       	pop	r28
     6ba:	df 91       	pop	r29
     6bc:	08 95       	ret

000006be <delay_eNonBlocking_ms>:
 */
#include "common.h"


ERROR_t delay_eNonBlocking_ms(const char Time_ms)
{
     6be:	df 93       	push	r29
     6c0:	cf 93       	push	r28
     6c2:	00 d0       	rcall	.+0      	; 0x6c4 <delay_eNonBlocking_ms+0x6>
     6c4:	0f 92       	push	r0
     6c6:	cd b7       	in	r28, 0x3d	; 61
     6c8:	de b7       	in	r29, 0x3e	; 62
     6ca:	8a 83       	std	Y+2, r24	; 0x02
	static int locTime_uS = 0;
	static int locTime_mS = 0;
	/* 1 cycle time for 8MHz processor = 0.125 uS*/
	for(char locTemp = 0; locTemp<4; locTemp++)
     6cc:	19 82       	std	Y+1, r1	; 0x01
     6ce:	03 c0       	rjmp	.+6      	; 0x6d6 <delay_eNonBlocking_ms+0x18>
     6d0:	89 81       	ldd	r24, Y+1	; 0x01
     6d2:	8f 5f       	subi	r24, 0xFF	; 255
     6d4:	89 83       	std	Y+1, r24	; 0x01
     6d6:	89 81       	ldd	r24, Y+1	; 0x01
     6d8:	84 30       	cpi	r24, 0x04	; 4
     6da:	d0 f3       	brcs	.-12     	; 0x6d0 <delay_eNonBlocking_ms+0x12>
	{
	/* for 8MHz processor, 4 cycle time = 1 uS*/
		/*	1 uS block */
	}

	locTime_uS++;		/* increament the microSecond var by 1 uS */
     6dc:	80 91 ba 00 	lds	r24, 0x00BA
     6e0:	90 91 bb 00 	lds	r25, 0x00BB
     6e4:	01 96       	adiw	r24, 0x01	; 1
     6e6:	90 93 bb 00 	sts	0x00BB, r25
     6ea:	80 93 ba 00 	sts	0x00BA, r24

	if (locTime_uS > 999)
     6ee:	80 91 ba 00 	lds	r24, 0x00BA
     6f2:	90 91 bb 00 	lds	r25, 0x00BB
     6f6:	23 e0       	ldi	r18, 0x03	; 3
     6f8:	88 3e       	cpi	r24, 0xE8	; 232
     6fa:	92 07       	cpc	r25, r18
     6fc:	6c f0       	brlt	.+26     	; 0x718 <delay_eNonBlocking_ms+0x5a>
	{
		locTime_mS++;
     6fe:	80 91 b8 00 	lds	r24, 0x00B8
     702:	90 91 b9 00 	lds	r25, 0x00B9
     706:	01 96       	adiw	r24, 0x01	; 1
     708:	90 93 b9 00 	sts	0x00B9, r25
     70c:	80 93 b8 00 	sts	0x00B8, r24
		locTime_uS = 0;
     710:	10 92 bb 00 	sts	0x00BB, r1
     714:	10 92 ba 00 	sts	0x00BA, r1
	}

	//printf("%s %d %s %d\n", "MilliSecond is:",locTime_mS,"  MicroSecond is:",locTime_uS);
	if(locTime_mS >= Time_ms)
     718:	8a 81       	ldd	r24, Y+2	; 0x02
     71a:	28 2f       	mov	r18, r24
     71c:	30 e0       	ldi	r19, 0x00	; 0
     71e:	80 91 b8 00 	lds	r24, 0x00B8
     722:	90 91 b9 00 	lds	r25, 0x00B9
     726:	82 17       	cp	r24, r18
     728:	93 07       	cpc	r25, r19
     72a:	54 f0       	brlt	.+20     	; 0x740 <delay_eNonBlocking_ms+0x82>
	{
		/* clearing the variables for the next call */
		locTime_mS = 0;
     72c:	10 92 b9 00 	sts	0x00B9, r1
     730:	10 92 b8 00 	sts	0x00B8, r1
		locTime_uS = 0;
     734:	10 92 bb 00 	sts	0x00BB, r1
     738:	10 92 ba 00 	sts	0x00BA, r1
		return E_OK;
     73c:	1b 82       	std	Y+3, r1	; 0x03
     73e:	02 c0       	rjmp	.+4      	; 0x744 <delay_eNonBlocking_ms+0x86>
	}
	else
	{
		return PENDING;
     740:	82 e0       	ldi	r24, 0x02	; 2
     742:	8b 83       	std	Y+3, r24	; 0x03
     744:	8b 81       	ldd	r24, Y+3	; 0x03
	}
}
     746:	0f 90       	pop	r0
     748:	0f 90       	pop	r0
     74a:	0f 90       	pop	r0
     74c:	cf 91       	pop	r28
     74e:	df 91       	pop	r29
     750:	08 95       	ret

00000752 <usart_init>:
#include <avr/io.h>
#include "usart_driver.h"
#include "STD_TYPES.h"

void usart_init(unsigned short int baudrate)
{
     752:	df 93       	push	r29
     754:	cf 93       	push	r28
     756:	00 d0       	rcall	.+0      	; 0x758 <usart_init+0x6>
     758:	00 d0       	rcall	.+0      	; 0x75a <usart_init+0x8>
     75a:	cd b7       	in	r28, 0x3d	; 61
     75c:	de b7       	in	r29, 0x3e	; 62
     75e:	9c 83       	std	Y+4, r25	; 0x04
     760:	8b 83       	std	Y+3, r24	; 0x03
	//Set baud rate
	unsigned short int UBRRVAL=(FCLK_SYSTEM/(baudrate*16UL))-1;
     762:	8b 81       	ldd	r24, Y+3	; 0x03
     764:	9c 81       	ldd	r25, Y+4	; 0x04
     766:	cc 01       	movw	r24, r24
     768:	a0 e0       	ldi	r26, 0x00	; 0
     76a:	b0 e0       	ldi	r27, 0x00	; 0
     76c:	88 0f       	add	r24, r24
     76e:	99 1f       	adc	r25, r25
     770:	aa 1f       	adc	r26, r26
     772:	bb 1f       	adc	r27, r27
     774:	88 0f       	add	r24, r24
     776:	99 1f       	adc	r25, r25
     778:	aa 1f       	adc	r26, r26
     77a:	bb 1f       	adc	r27, r27
     77c:	88 0f       	add	r24, r24
     77e:	99 1f       	adc	r25, r25
     780:	aa 1f       	adc	r26, r26
     782:	bb 1f       	adc	r27, r27
     784:	88 0f       	add	r24, r24
     786:	99 1f       	adc	r25, r25
     788:	aa 1f       	adc	r26, r26
     78a:	bb 1f       	adc	r27, r27
     78c:	9c 01       	movw	r18, r24
     78e:	ad 01       	movw	r20, r26
     790:	80 e0       	ldi	r24, 0x00	; 0
     792:	92 e1       	ldi	r25, 0x12	; 18
     794:	aa e7       	ldi	r26, 0x7A	; 122
     796:	b0 e0       	ldi	r27, 0x00	; 0
     798:	bc 01       	movw	r22, r24
     79a:	cd 01       	movw	r24, r26
     79c:	0e 94 9c 23 	call	0x4738	; 0x4738 <__udivmodsi4>
     7a0:	da 01       	movw	r26, r20
     7a2:	c9 01       	movw	r24, r18
     7a4:	01 97       	sbiw	r24, 0x01	; 1
     7a6:	9a 83       	std	Y+2, r25	; 0x02
     7a8:	89 83       	std	Y+1, r24	; 0x01
	UBRRL=UBRRVAL; 			//low byte
     7aa:	e9 e2       	ldi	r30, 0x29	; 41
     7ac:	f0 e0       	ldi	r31, 0x00	; 0
     7ae:	89 81       	ldd	r24, Y+1	; 0x01
     7b0:	80 83       	st	Z, r24
	UBRRH=(UBRRVAL>>8); 	//high byte
     7b2:	e0 e4       	ldi	r30, 0x40	; 64
     7b4:	f0 e0       	ldi	r31, 0x00	; 0
     7b6:	89 81       	ldd	r24, Y+1	; 0x01
     7b8:	9a 81       	ldd	r25, Y+2	; 0x02
     7ba:	89 2f       	mov	r24, r25
     7bc:	99 27       	eor	r25, r25
     7be:	80 83       	st	Z, r24

	//Set data frame format: asynchronous mode,no parity, 1 stop bit, 8 bit size
	UCSRC=(1<<URSEL)|(0<<UMSEL)|(0<<UPM1)|(0<<UPM0)|(0<<USBS)|(0<<UCSZ2)|(1<<UCSZ1)|(1<<UCSZ0); 
     7c0:	e0 e4       	ldi	r30, 0x40	; 64
     7c2:	f0 e0       	ldi	r31, 0x00	; 0
     7c4:	86 e8       	ldi	r24, 0x86	; 134
     7c6:	80 83       	st	Z, r24

	//Enable Transmitter and Receiver
	UCSRB=(1<<RXEN)|(1<<TXEN);
     7c8:	ea e2       	ldi	r30, 0x2A	; 42
     7ca:	f0 e0       	ldi	r31, 0x00	; 0
     7cc:	88 e1       	ldi	r24, 0x18	; 24
     7ce:	80 83       	st	Z, r24
}
     7d0:	0f 90       	pop	r0
     7d2:	0f 90       	pop	r0
     7d4:	0f 90       	pop	r0
     7d6:	0f 90       	pop	r0
     7d8:	cf 91       	pop	r28
     7da:	df 91       	pop	r29
     7dc:	08 95       	ret

000007de <usart_getc>:
unsigned char usart_getc( void )
{
     7de:	df 93       	push	r29
     7e0:	cf 93       	push	r28
     7e2:	cd b7       	in	r28, 0x3d	; 61
     7e4:	de b7       	in	r29, 0x3e	; 62
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<RXC)) );
     7e6:	eb e2       	ldi	r30, 0x2B	; 43
     7e8:	f0 e0       	ldi	r31, 0x00	; 0
     7ea:	80 81       	ld	r24, Z
     7ec:	88 23       	and	r24, r24
     7ee:	dc f7       	brge	.-10     	; 0x7e6 <usart_getc+0x8>
	/* Get and return received data from buffer */
	return UDR;
     7f0:	ec e2       	ldi	r30, 0x2C	; 44
     7f2:	f0 e0       	ldi	r31, 0x00	; 0
     7f4:	80 81       	ld	r24, Z
}
     7f6:	cf 91       	pop	r28
     7f8:	df 91       	pop	r29
     7fa:	08 95       	ret

000007fc <usart_getc_NonBlocking>:

ERROR_t usart_getc_NonBlocking(u8 * pData )
{
     7fc:	df 93       	push	r29
     7fe:	cf 93       	push	r28
     800:	00 d0       	rcall	.+0      	; 0x802 <usart_getc_NonBlocking+0x6>
     802:	0f 92       	push	r0
     804:	cd b7       	in	r28, 0x3d	; 61
     806:	de b7       	in	r29, 0x3e	; 62
     808:	9a 83       	std	Y+2, r25	; 0x02
     80a:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for data to be received */
	if ( (UCSRA & (1<<RXC)) )
     80c:	eb e2       	ldi	r30, 0x2B	; 43
     80e:	f0 e0       	ldi	r31, 0x00	; 0
     810:	80 81       	ld	r24, Z
     812:	88 23       	and	r24, r24
     814:	44 f4       	brge	.+16     	; 0x826 <usart_getc_NonBlocking+0x2a>
	{
		*pData = UDR;
     816:	ec e2       	ldi	r30, 0x2C	; 44
     818:	f0 e0       	ldi	r31, 0x00	; 0
     81a:	80 81       	ld	r24, Z
     81c:	e9 81       	ldd	r30, Y+1	; 0x01
     81e:	fa 81       	ldd	r31, Y+2	; 0x02
     820:	80 83       	st	Z, r24
		return E_OK;
     822:	1b 82       	std	Y+3, r1	; 0x03
     824:	02 c0       	rjmp	.+4      	; 0x82a <usart_getc_NonBlocking+0x2e>
	}
	else
	{
		return PENDING;
     826:	82 e0       	ldi	r24, 0x02	; 2
     828:	8b 83       	std	Y+3, r24	; 0x03
     82a:	8b 81       	ldd	r24, Y+3	; 0x03
	}

}
     82c:	0f 90       	pop	r0
     82e:	0f 90       	pop	r0
     830:	0f 90       	pop	r0
     832:	cf 91       	pop	r28
     834:	df 91       	pop	r29
     836:	08 95       	ret

00000838 <usart_putc>:
void usart_putc( unsigned char data )
{
     838:	df 93       	push	r29
     83a:	cf 93       	push	r28
     83c:	0f 92       	push	r0
     83e:	cd b7       	in	r28, 0x3d	; 61
     840:	de b7       	in	r29, 0x3e	; 62
     842:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)));
     844:	eb e2       	ldi	r30, 0x2B	; 43
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	80 81       	ld	r24, Z
     84a:	88 2f       	mov	r24, r24
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	80 72       	andi	r24, 0x20	; 32
     850:	90 70       	andi	r25, 0x00	; 0
     852:	00 97       	sbiw	r24, 0x00	; 0
     854:	b9 f3       	breq	.-18     	; 0x844 <usart_putc+0xc>
	/* Put data into buffer, sends the data */
	UDR = data;
     856:	ec e2       	ldi	r30, 0x2C	; 44
     858:	f0 e0       	ldi	r31, 0x00	; 0
     85a:	89 81       	ldd	r24, Y+1	; 0x01
     85c:	80 83       	st	Z, r24
}
     85e:	0f 90       	pop	r0
     860:	cf 91       	pop	r28
     862:	df 91       	pop	r29
     864:	08 95       	ret

00000866 <usart_puts>:
void usart_puts( char* str )
{
     866:	df 93       	push	r29
     868:	cf 93       	push	r28
     86a:	00 d0       	rcall	.+0      	; 0x86c <usart_puts+0x6>
     86c:	00 d0       	rcall	.+0      	; 0x86e <usart_puts+0x8>
     86e:	cd b7       	in	r28, 0x3d	; 61
     870:	de b7       	in	r29, 0x3e	; 62
     872:	9c 83       	std	Y+4, r25	; 0x04
     874:	8b 83       	std	Y+3, r24	; 0x03
	short int i=0;
     876:	1a 82       	std	Y+2, r1	; 0x02
     878:	19 82       	std	Y+1, r1	; 0x01
     87a:	0f c0       	rjmp	.+30     	; 0x89a <usart_puts+0x34>
	while(str[i])
	{
		usart_putc(str[i]);
     87c:	29 81       	ldd	r18, Y+1	; 0x01
     87e:	3a 81       	ldd	r19, Y+2	; 0x02
     880:	8b 81       	ldd	r24, Y+3	; 0x03
     882:	9c 81       	ldd	r25, Y+4	; 0x04
     884:	fc 01       	movw	r30, r24
     886:	e2 0f       	add	r30, r18
     888:	f3 1f       	adc	r31, r19
     88a:	80 81       	ld	r24, Z
     88c:	0e 94 1c 04 	call	0x838	; 0x838 <usart_putc>
		i++;
     890:	89 81       	ldd	r24, Y+1	; 0x01
     892:	9a 81       	ldd	r25, Y+2	; 0x02
     894:	01 96       	adiw	r24, 0x01	; 1
     896:	9a 83       	std	Y+2, r25	; 0x02
     898:	89 83       	std	Y+1, r24	; 0x01
	UDR = data;
}
void usart_puts( char* str )
{
	short int i=0;
	while(str[i])
     89a:	29 81       	ldd	r18, Y+1	; 0x01
     89c:	3a 81       	ldd	r19, Y+2	; 0x02
     89e:	8b 81       	ldd	r24, Y+3	; 0x03
     8a0:	9c 81       	ldd	r25, Y+4	; 0x04
     8a2:	fc 01       	movw	r30, r24
     8a4:	e2 0f       	add	r30, r18
     8a6:	f3 1f       	adc	r31, r19
     8a8:	80 81       	ld	r24, Z
     8aa:	88 23       	and	r24, r24
     8ac:	39 f7       	brne	.-50     	; 0x87c <usart_puts+0x16>
	{
		usart_putc(str[i]);
		i++;
	}
}
     8ae:	0f 90       	pop	r0
     8b0:	0f 90       	pop	r0
     8b2:	0f 90       	pop	r0
     8b4:	0f 90       	pop	r0
     8b6:	cf 91       	pop	r28
     8b8:	df 91       	pop	r29
     8ba:	08 95       	ret

000008bc <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
     8bc:	af 92       	push	r10
     8be:	bf 92       	push	r11
     8c0:	cf 92       	push	r12
     8c2:	df 92       	push	r13
     8c4:	ef 92       	push	r14
     8c6:	ff 92       	push	r15
     8c8:	0f 93       	push	r16
     8ca:	df 93       	push	r29
     8cc:	cf 93       	push	r28
     8ce:	0f 92       	push	r0
     8d0:	cd b7       	in	r28, 0x3d	; 61
     8d2:	de b7       	in	r29, 0x3e	; 62
     8d4:	89 83       	std	Y+1, r24	; 0x01
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
     8d6:	8a e0       	ldi	r24, 0x0A	; 10
     8d8:	62 e0       	ldi	r22, 0x02	; 2
     8da:	40 e0       	ldi	r20, 0x00	; 0
     8dc:	0e 94 3e 11 	call	0x227c	; 0x227c <xQueueGenericCreate>
     8e0:	90 93 bf 00 	sts	0x00BF, r25
     8e4:	80 93 be 00 	sts	0x00BE, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
     8e8:	82 ee       	ldi	r24, 0xE2	; 226
     8ea:	94 e0       	ldi	r25, 0x04	; 4
     8ec:	20 e6       	ldi	r18, 0x60	; 96
     8ee:	30 e0       	ldi	r19, 0x00	; 0
     8f0:	ee eb       	ldi	r30, 0xBE	; 190
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	b9 01       	movw	r22, r18
     8f6:	45 e5       	ldi	r20, 0x55	; 85
     8f8:	50 e0       	ldi	r21, 0x00	; 0
     8fa:	9f 01       	movw	r18, r30
     8fc:	09 81       	ldd	r16, Y+1	; 0x01
     8fe:	ee 24       	eor	r14, r14
     900:	ff 24       	eor	r15, r15
     902:	cc 24       	eor	r12, r12
     904:	dd 24       	eor	r13, r13
     906:	aa 24       	eor	r10, r10
     908:	bb 24       	eor	r11, r11
     90a:	0e 94 64 18 	call	0x30c8	; 0x30c8 <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
     90e:	85 ea       	ldi	r24, 0xA5	; 165
     910:	94 e0       	ldi	r25, 0x04	; 4
     912:	28 e6       	ldi	r18, 0x68	; 104
     914:	30 e0       	ldi	r19, 0x00	; 0
     916:	ee eb       	ldi	r30, 0xBE	; 190
     918:	f0 e0       	ldi	r31, 0x00	; 0
     91a:	b9 01       	movw	r22, r18
     91c:	45 e5       	ldi	r20, 0x55	; 85
     91e:	50 e0       	ldi	r21, 0x00	; 0
     920:	9f 01       	movw	r18, r30
     922:	09 81       	ldd	r16, Y+1	; 0x01
     924:	ee 24       	eor	r14, r14
     926:	ff 24       	eor	r15, r15
     928:	cc 24       	eor	r12, r12
     92a:	dd 24       	eor	r13, r13
     92c:	aa 24       	eor	r10, r10
     92e:	bb 24       	eor	r11, r11
     930:	0e 94 64 18 	call	0x30c8	; 0x30c8 <xTaskGenericCreate>
}
     934:	0f 90       	pop	r0
     936:	cf 91       	pop	r28
     938:	df 91       	pop	r29
     93a:	0f 91       	pop	r16
     93c:	ff 90       	pop	r15
     93e:	ef 90       	pop	r14
     940:	df 90       	pop	r13
     942:	cf 90       	pop	r12
     944:	bf 90       	pop	r11
     946:	af 90       	pop	r10
     948:	08 95       	ret

0000094a <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
     94a:	df 93       	push	r29
     94c:	cf 93       	push	r28
     94e:	00 d0       	rcall	.+0      	; 0x950 <vPolledQueueProducer+0x6>
     950:	00 d0       	rcall	.+0      	; 0x952 <vPolledQueueProducer+0x8>
     952:	00 d0       	rcall	.+0      	; 0x954 <vPolledQueueProducer+0xa>
     954:	cd b7       	in	r28, 0x3d	; 61
     956:	de b7       	in	r29, 0x3e	; 62
     958:	9e 83       	std	Y+6, r25	; 0x06
     95a:	8d 83       	std	Y+5, r24	; 0x05
uint16_t usValue = ( uint16_t ) 0;
     95c:	1c 82       	std	Y+4, r1	; 0x04
     95e:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xError = pdFALSE, xLoop;
     960:	1a 82       	std	Y+2, r1	; 0x02

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     962:	19 82       	std	Y+1, r1	; 0x01
     964:	27 c0       	rjmp	.+78     	; 0x9b4 <vPolledQueueProducer+0x6a>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
     966:	ed 81       	ldd	r30, Y+5	; 0x05
     968:	fe 81       	ldd	r31, Y+6	; 0x06
     96a:	80 81       	ld	r24, Z
     96c:	91 81       	ldd	r25, Z+1	; 0x01
     96e:	9e 01       	movw	r18, r28
     970:	2d 5f       	subi	r18, 0xFD	; 253
     972:	3f 4f       	sbci	r19, 0xFF	; 255
     974:	b9 01       	movw	r22, r18
     976:	40 e0       	ldi	r20, 0x00	; 0
     978:	50 e0       	ldi	r21, 0x00	; 0
     97a:	20 e0       	ldi	r18, 0x00	; 0
     97c:	0e 94 09 12 	call	0x2412	; 0x2412 <xQueueGenericSend>
     980:	81 30       	cpi	r24, 0x01	; 1
     982:	19 f0       	breq	.+6      	; 0x98a <vPolledQueueProducer+0x40>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
     984:	81 e0       	ldi	r24, 0x01	; 1
     986:	8a 83       	std	Y+2, r24	; 0x02
     988:	12 c0       	rjmp	.+36     	; 0x9ae <vPolledQueueProducer+0x64>
			}
			else
			{
				if( xError == pdFALSE )
     98a:	8a 81       	ldd	r24, Y+2	; 0x02
     98c:	88 23       	and	r24, r24
     98e:	51 f4       	brne	.+20     	; 0x9a4 <vPolledQueueProducer+0x5a>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
     990:	0f b6       	in	r0, 0x3f	; 63
     992:	f8 94       	cli
     994:	0f 92       	push	r0
						xPollingProducerCount++;
     996:	80 91 bd 00 	lds	r24, 0x00BD
     99a:	8f 5f       	subi	r24, 0xFF	; 255
     99c:	80 93 bd 00 	sts	0x00BD, r24
					portEXIT_CRITICAL();
     9a0:	0f 90       	pop	r0
     9a2:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
     9a4:	8b 81       	ldd	r24, Y+3	; 0x03
     9a6:	9c 81       	ldd	r25, Y+4	; 0x04
     9a8:	01 96       	adiw	r24, 0x01	; 1
     9aa:	9c 83       	std	Y+4, r25	; 0x04
     9ac:	8b 83       	std	Y+3, r24	; 0x03
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     9ae:	89 81       	ldd	r24, Y+1	; 0x01
     9b0:	8f 5f       	subi	r24, 0xFF	; 255
     9b2:	89 83       	std	Y+1, r24	; 0x01
     9b4:	89 81       	ldd	r24, Y+1	; 0x01
     9b6:	83 30       	cpi	r24, 0x03	; 3
     9b8:	b4 f2       	brlt	.-84     	; 0x966 <vPolledQueueProducer+0x1c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
     9ba:	88 ec       	ldi	r24, 0xC8	; 200
     9bc:	90 e0       	ldi	r25, 0x00	; 0
     9be:	0e 94 1e 1a 	call	0x343c	; 0x343c <vTaskDelay>
     9c2:	cf cf       	rjmp	.-98     	; 0x962 <vPolledQueueProducer+0x18>

000009c4 <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
     9c4:	df 93       	push	r29
     9c6:	cf 93       	push	r28
     9c8:	cd b7       	in	r28, 0x3d	; 61
     9ca:	de b7       	in	r29, 0x3e	; 62
     9cc:	27 97       	sbiw	r28, 0x07	; 7
     9ce:	0f b6       	in	r0, 0x3f	; 63
     9d0:	f8 94       	cli
     9d2:	de bf       	out	0x3e, r29	; 62
     9d4:	0f be       	out	0x3f, r0	; 63
     9d6:	cd bf       	out	0x3d, r28	; 61
     9d8:	9f 83       	std	Y+7, r25	; 0x07
     9da:	8e 83       	std	Y+6, r24	; 0x06
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
     9dc:	1b 82       	std	Y+3, r1	; 0x03
     9de:	1a 82       	std	Y+2, r1	; 0x02
BaseType_t xError = pdFALSE;
     9e0:	19 82       	std	Y+1, r1	; 0x01
     9e2:	2f c0       	rjmp	.+94     	; 0xa42 <vPolledQueueConsumer+0x7e>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
     9e4:	ee 81       	ldd	r30, Y+6	; 0x06
     9e6:	ff 81       	ldd	r31, Y+7	; 0x07
     9e8:	80 81       	ld	r24, Z
     9ea:	91 81       	ldd	r25, Z+1	; 0x01
     9ec:	9e 01       	movw	r18, r28
     9ee:	2c 5f       	subi	r18, 0xFC	; 252
     9f0:	3f 4f       	sbci	r19, 0xFF	; 255
     9f2:	b9 01       	movw	r22, r18
     9f4:	40 e0       	ldi	r20, 0x00	; 0
     9f6:	50 e0       	ldi	r21, 0x00	; 0
     9f8:	20 e0       	ldi	r18, 0x00	; 0
     9fa:	0e 94 17 13 	call	0x262e	; 0x262e <xQueueGenericReceive>
     9fe:	81 30       	cpi	r24, 0x01	; 1
     a00:	01 f5       	brne	.+64     	; 0xa42 <vPolledQueueConsumer+0x7e>
			{
				if( usData != usExpectedValue )
     a02:	2c 81       	ldd	r18, Y+4	; 0x04
     a04:	3d 81       	ldd	r19, Y+5	; 0x05
     a06:	8a 81       	ldd	r24, Y+2	; 0x02
     a08:	9b 81       	ldd	r25, Y+3	; 0x03
     a0a:	28 17       	cp	r18, r24
     a0c:	39 07       	cpc	r19, r25
     a0e:	39 f0       	breq	.+14     	; 0xa1e <vPolledQueueConsumer+0x5a>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
     a10:	81 e0       	ldi	r24, 0x01	; 1
     a12:	89 83       	std	Y+1, r24	; 0x01

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
     a14:	8c 81       	ldd	r24, Y+4	; 0x04
     a16:	9d 81       	ldd	r25, Y+5	; 0x05
     a18:	9b 83       	std	Y+3, r25	; 0x03
     a1a:	8a 83       	std	Y+2, r24	; 0x02
     a1c:	0d c0       	rjmp	.+26     	; 0xa38 <vPolledQueueConsumer+0x74>
				}
				else
				{
					if( xError == pdFALSE )
     a1e:	89 81       	ldd	r24, Y+1	; 0x01
     a20:	88 23       	and	r24, r24
     a22:	51 f4       	brne	.+20     	; 0xa38 <vPolledQueueConsumer+0x74>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
     a24:	0f b6       	in	r0, 0x3f	; 63
     a26:	f8 94       	cli
     a28:	0f 92       	push	r0
							xPollingConsumerCount++;
     a2a:	80 91 bc 00 	lds	r24, 0x00BC
     a2e:	8f 5f       	subi	r24, 0xFF	; 255
     a30:	80 93 bc 00 	sts	0x00BC, r24
						portEXIT_CRITICAL();
     a34:	0f 90       	pop	r0
     a36:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
     a38:	8a 81       	ldd	r24, Y+2	; 0x02
     a3a:	9b 81       	ldd	r25, Y+3	; 0x03
     a3c:	01 96       	adiw	r24, 0x01	; 1
     a3e:	9b 83       	std	Y+3, r25	; 0x03
     a40:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
     a42:	ee 81       	ldd	r30, Y+6	; 0x06
     a44:	ff 81       	ldd	r31, Y+7	; 0x07
     a46:	80 81       	ld	r24, Z
     a48:	91 81       	ldd	r25, Z+1	; 0x01
     a4a:	0e 94 88 14 	call	0x2910	; 0x2910 <uxQueueMessagesWaiting>
     a4e:	88 23       	and	r24, r24
     a50:	49 f6       	brne	.-110    	; 0x9e4 <vPolledQueueConsumer+0x20>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
     a52:	84 eb       	ldi	r24, 0xB4	; 180
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	0e 94 1e 1a 	call	0x343c	; 0x343c <vTaskDelay>
     a5a:	f3 cf       	rjmp	.-26     	; 0xa42 <vPolledQueueConsumer+0x7e>

00000a5c <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
     a5c:	df 93       	push	r29
     a5e:	cf 93       	push	r28
     a60:	0f 92       	push	r0
     a62:	cd b7       	in	r28, 0x3d	; 61
     a64:	de b7       	in	r29, 0x3e	; 62

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
     a66:	80 91 bc 00 	lds	r24, 0x00BC
     a6a:	88 23       	and	r24, r24
     a6c:	21 f0       	breq	.+8      	; 0xa76 <xArePollingQueuesStillRunning+0x1a>
     a6e:	80 91 bd 00 	lds	r24, 0x00BD
     a72:	88 23       	and	r24, r24
     a74:	11 f4       	brne	.+4      	; 0xa7a <xArePollingQueuesStillRunning+0x1e>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
     a76:	19 82       	std	Y+1, r1	; 0x01
     a78:	02 c0       	rjmp	.+4      	; 0xa7e <xArePollingQueuesStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
     a7a:	81 e0       	ldi	r24, 0x01	; 1
     a7c:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
     a7e:	10 92 bc 00 	sts	0x00BC, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
     a82:	10 92 bd 00 	sts	0x00BD, r1

	return xReturn;
     a86:	89 81       	ldd	r24, Y+1	; 0x01
}
     a88:	0f 90       	pop	r0
     a8a:	cf 91       	pop	r28
     a8c:	df 91       	pop	r29
     a8e:	08 95       	ret

00000a90 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     a90:	df 93       	push	r29
     a92:	cf 93       	push	r28
     a94:	cd b7       	in	r28, 0x3d	; 61
     a96:	de b7       	in	r29, 0x3e	; 62
     a98:	27 97       	sbiw	r28, 0x07	; 7
     a9a:	0f b6       	in	r0, 0x3f	; 63
     a9c:	f8 94       	cli
     a9e:	de bf       	out	0x3e, r29	; 62
     aa0:	0f be       	out	0x3f, r0	; 63
     aa2:	cd bf       	out	0x3d, r28	; 61
     aa4:	9d 83       	std	Y+5, r25	; 0x05
     aa6:	8c 83       	std	Y+4, r24	; 0x04
     aa8:	6e 83       	std	Y+6, r22	; 0x06
     aaa:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     aac:	8a e1       	ldi	r24, 0x1A	; 26
     aae:	90 e0       	ldi	r25, 0x00	; 0
     ab0:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <pvPortMalloc>
     ab4:	9a 83       	std	Y+2, r25	; 0x02
     ab6:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     ab8:	89 81       	ldd	r24, Y+1	; 0x01
     aba:	9a 81       	ldd	r25, Y+2	; 0x02
     abc:	00 97       	sbiw	r24, 0x00	; 0
     abe:	09 f4       	brne	.+2      	; 0xac2 <xCoRoutineCreate+0x32>
     ac0:	6f c0       	rjmp	.+222    	; 0xba0 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     ac2:	80 91 c0 00 	lds	r24, 0x00C0
     ac6:	90 91 c1 00 	lds	r25, 0x00C1
     aca:	00 97       	sbiw	r24, 0x00	; 0
     acc:	41 f4       	brne	.+16     	; 0xade <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     ace:	89 81       	ldd	r24, Y+1	; 0x01
     ad0:	9a 81       	ldd	r25, Y+2	; 0x02
     ad2:	90 93 c1 00 	sts	0x00C1, r25
     ad6:	80 93 c0 00 	sts	0x00C0, r24
			prvInitialiseCoRoutineLists();
     ada:	0e 94 af 07 	call	0xf5e	; 0xf5e <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     ade:	8e 81       	ldd	r24, Y+6	; 0x06
     ae0:	82 30       	cpi	r24, 0x02	; 2
     ae2:	10 f0       	brcs	.+4      	; 0xae8 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     ae4:	81 e0       	ldi	r24, 0x01	; 1
     ae6:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     ae8:	e9 81       	ldd	r30, Y+1	; 0x01
     aea:	fa 81       	ldd	r31, Y+2	; 0x02
     aec:	11 8e       	std	Z+25, r1	; 0x19
     aee:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     af0:	e9 81       	ldd	r30, Y+1	; 0x01
     af2:	fa 81       	ldd	r31, Y+2	; 0x02
     af4:	8e 81       	ldd	r24, Y+6	; 0x06
     af6:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     af8:	e9 81       	ldd	r30, Y+1	; 0x01
     afa:	fa 81       	ldd	r31, Y+2	; 0x02
     afc:	8f 81       	ldd	r24, Y+7	; 0x07
     afe:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     b00:	e9 81       	ldd	r30, Y+1	; 0x01
     b02:	fa 81       	ldd	r31, Y+2	; 0x02
     b04:	8c 81       	ldd	r24, Y+4	; 0x04
     b06:	9d 81       	ldd	r25, Y+5	; 0x05
     b08:	91 83       	std	Z+1, r25	; 0x01
     b0a:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     b0c:	89 81       	ldd	r24, Y+1	; 0x01
     b0e:	9a 81       	ldd	r25, Y+2	; 0x02
     b10:	02 96       	adiw	r24, 0x02	; 2
     b12:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     b16:	89 81       	ldd	r24, Y+1	; 0x01
     b18:	9a 81       	ldd	r25, Y+2	; 0x02
     b1a:	0c 96       	adiw	r24, 0x0c	; 12
     b1c:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     b20:	e9 81       	ldd	r30, Y+1	; 0x01
     b22:	fa 81       	ldd	r31, Y+2	; 0x02
     b24:	89 81       	ldd	r24, Y+1	; 0x01
     b26:	9a 81       	ldd	r25, Y+2	; 0x02
     b28:	91 87       	std	Z+9, r25	; 0x09
     b2a:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     b2c:	e9 81       	ldd	r30, Y+1	; 0x01
     b2e:	fa 81       	ldd	r31, Y+2	; 0x02
     b30:	89 81       	ldd	r24, Y+1	; 0x01
     b32:	9a 81       	ldd	r25, Y+2	; 0x02
     b34:	93 8b       	std	Z+19, r25	; 0x13
     b36:	82 8b       	std	Z+18, r24	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     b38:	8e 81       	ldd	r24, Y+6	; 0x06
     b3a:	28 2f       	mov	r18, r24
     b3c:	30 e0       	ldi	r19, 0x00	; 0
     b3e:	82 e0       	ldi	r24, 0x02	; 2
     b40:	90 e0       	ldi	r25, 0x00	; 0
     b42:	82 1b       	sub	r24, r18
     b44:	93 0b       	sbc	r25, r19
     b46:	e9 81       	ldd	r30, Y+1	; 0x01
     b48:	fa 81       	ldd	r31, Y+2	; 0x02
     b4a:	95 87       	std	Z+13, r25	; 0x0d
     b4c:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     b4e:	e9 81       	ldd	r30, Y+1	; 0x01
     b50:	fa 81       	ldd	r31, Y+2	; 0x02
     b52:	96 89       	ldd	r25, Z+22	; 0x16
     b54:	80 91 c2 00 	lds	r24, 0x00C2
     b58:	89 17       	cp	r24, r25
     b5a:	28 f4       	brcc	.+10     	; 0xb66 <xCoRoutineCreate+0xd6>
     b5c:	e9 81       	ldd	r30, Y+1	; 0x01
     b5e:	fa 81       	ldd	r31, Y+2	; 0x02
     b60:	86 89       	ldd	r24, Z+22	; 0x16
     b62:	80 93 c2 00 	sts	0x00C2, r24
     b66:	e9 81       	ldd	r30, Y+1	; 0x01
     b68:	fa 81       	ldd	r31, Y+2	; 0x02
     b6a:	86 89       	ldd	r24, Z+22	; 0x16
     b6c:	28 2f       	mov	r18, r24
     b6e:	30 e0       	ldi	r19, 0x00	; 0
     b70:	c9 01       	movw	r24, r18
     b72:	88 0f       	add	r24, r24
     b74:	99 1f       	adc	r25, r25
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	88 0f       	add	r24, r24
     b7c:	99 1f       	adc	r25, r25
     b7e:	82 0f       	add	r24, r18
     b80:	93 1f       	adc	r25, r19
     b82:	ac 01       	movw	r20, r24
     b84:	47 53       	subi	r20, 0x37	; 55
     b86:	5f 4f       	sbci	r21, 0xFF	; 255
     b88:	89 81       	ldd	r24, Y+1	; 0x01
     b8a:	9a 81       	ldd	r25, Y+2	; 0x02
     b8c:	9c 01       	movw	r18, r24
     b8e:	2e 5f       	subi	r18, 0xFE	; 254
     b90:	3f 4f       	sbci	r19, 0xFF	; 255
     b92:	ca 01       	movw	r24, r20
     b94:	b9 01       	movw	r22, r18
     b96:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>

		xReturn = pdPASS;
     b9a:	81 e0       	ldi	r24, 0x01	; 1
     b9c:	8b 83       	std	Y+3, r24	; 0x03
     b9e:	02 c0       	rjmp	.+4      	; 0xba4 <xCoRoutineCreate+0x114>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     ba0:	8f ef       	ldi	r24, 0xFF	; 255
     ba2:	8b 83       	std	Y+3, r24	; 0x03
	}

	return xReturn;
     ba4:	8b 81       	ldd	r24, Y+3	; 0x03
}
     ba6:	27 96       	adiw	r28, 0x07	; 7
     ba8:	0f b6       	in	r0, 0x3f	; 63
     baa:	f8 94       	cli
     bac:	de bf       	out	0x3e, r29	; 62
     bae:	0f be       	out	0x3f, r0	; 63
     bb0:	cd bf       	out	0x3d, r28	; 61
     bb2:	cf 91       	pop	r28
     bb4:	df 91       	pop	r29
     bb6:	08 95       	ret

00000bb8 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     bb8:	df 93       	push	r29
     bba:	cf 93       	push	r28
     bbc:	00 d0       	rcall	.+0      	; 0xbbe <vCoRoutineAddToDelayedList+0x6>
     bbe:	00 d0       	rcall	.+0      	; 0xbc0 <vCoRoutineAddToDelayedList+0x8>
     bc0:	00 d0       	rcall	.+0      	; 0xbc2 <vCoRoutineAddToDelayedList+0xa>
     bc2:	cd b7       	in	r28, 0x3d	; 61
     bc4:	de b7       	in	r29, 0x3e	; 62
     bc6:	9c 83       	std	Y+4, r25	; 0x04
     bc8:	8b 83       	std	Y+3, r24	; 0x03
     bca:	7e 83       	std	Y+6, r23	; 0x06
     bcc:	6d 83       	std	Y+5, r22	; 0x05
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     bce:	20 91 c3 00 	lds	r18, 0x00C3
     bd2:	30 91 c4 00 	lds	r19, 0x00C4
     bd6:	8b 81       	ldd	r24, Y+3	; 0x03
     bd8:	9c 81       	ldd	r25, Y+4	; 0x04
     bda:	82 0f       	add	r24, r18
     bdc:	93 1f       	adc	r25, r19
     bde:	9a 83       	std	Y+2, r25	; 0x02
     be0:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     be2:	80 91 c0 00 	lds	r24, 0x00C0
     be6:	90 91 c1 00 	lds	r25, 0x00C1
     bea:	02 96       	adiw	r24, 0x02	; 2
     bec:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     bf0:	e0 91 c0 00 	lds	r30, 0x00C0
     bf4:	f0 91 c1 00 	lds	r31, 0x00C1
     bf8:	89 81       	ldd	r24, Y+1	; 0x01
     bfa:	9a 81       	ldd	r25, Y+2	; 0x02
     bfc:	93 83       	std	Z+3, r25	; 0x03
     bfe:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     c00:	20 91 c3 00 	lds	r18, 0x00C3
     c04:	30 91 c4 00 	lds	r19, 0x00C4
     c08:	89 81       	ldd	r24, Y+1	; 0x01
     c0a:	9a 81       	ldd	r25, Y+2	; 0x02
     c0c:	82 17       	cp	r24, r18
     c0e:	93 07       	cpc	r25, r19
     c10:	70 f4       	brcc	.+28     	; 0xc2e <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     c12:	80 91 ef 00 	lds	r24, 0x00EF
     c16:	90 91 f0 00 	lds	r25, 0x00F0
     c1a:	20 91 c0 00 	lds	r18, 0x00C0
     c1e:	30 91 c1 00 	lds	r19, 0x00C1
     c22:	2e 5f       	subi	r18, 0xFE	; 254
     c24:	3f 4f       	sbci	r19, 0xFF	; 255
     c26:	b9 01       	movw	r22, r18
     c28:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <vListInsert>
     c2c:	0d c0       	rjmp	.+26     	; 0xc48 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     c2e:	80 91 ed 00 	lds	r24, 0x00ED
     c32:	90 91 ee 00 	lds	r25, 0x00EE
     c36:	20 91 c0 00 	lds	r18, 0x00C0
     c3a:	30 91 c1 00 	lds	r19, 0x00C1
     c3e:	2e 5f       	subi	r18, 0xFE	; 254
     c40:	3f 4f       	sbci	r19, 0xFF	; 255
     c42:	b9 01       	movw	r22, r18
     c44:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <vListInsert>
	}

	if( pxEventList )
     c48:	8d 81       	ldd	r24, Y+5	; 0x05
     c4a:	9e 81       	ldd	r25, Y+6	; 0x06
     c4c:	00 97       	sbiw	r24, 0x00	; 0
     c4e:	61 f0       	breq	.+24     	; 0xc68 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     c50:	80 91 c0 00 	lds	r24, 0x00C0
     c54:	90 91 c1 00 	lds	r25, 0x00C1
     c58:	9c 01       	movw	r18, r24
     c5a:	24 5f       	subi	r18, 0xF4	; 244
     c5c:	3f 4f       	sbci	r19, 0xFF	; 255
     c5e:	8d 81       	ldd	r24, Y+5	; 0x05
     c60:	9e 81       	ldd	r25, Y+6	; 0x06
     c62:	b9 01       	movw	r22, r18
     c64:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <vListInsert>
	}
}
     c68:	26 96       	adiw	r28, 0x06	; 6
     c6a:	0f b6       	in	r0, 0x3f	; 63
     c6c:	f8 94       	cli
     c6e:	de bf       	out	0x3e, r29	; 62
     c70:	0f be       	out	0x3f, r0	; 63
     c72:	cd bf       	out	0x3d, r28	; 61
     c74:	cf 91       	pop	r28
     c76:	df 91       	pop	r29
     c78:	08 95       	ret

00000c7a <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     c7a:	df 93       	push	r29
     c7c:	cf 93       	push	r28
     c7e:	00 d0       	rcall	.+0      	; 0xc80 <prvCheckPendingReadyList+0x6>
     c80:	cd b7       	in	r28, 0x3d	; 61
     c82:	de b7       	in	r29, 0x3e	; 62
     c84:	3a c0       	rjmp	.+116    	; 0xcfa <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     c86:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     c88:	e0 91 f6 00 	lds	r30, 0x00F6
     c8c:	f0 91 f7 00 	lds	r31, 0x00F7
     c90:	86 81       	ldd	r24, Z+6	; 0x06
     c92:	97 81       	ldd	r25, Z+7	; 0x07
     c94:	9a 83       	std	Y+2, r25	; 0x02
     c96:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     c98:	89 81       	ldd	r24, Y+1	; 0x01
     c9a:	9a 81       	ldd	r25, Y+2	; 0x02
     c9c:	0c 96       	adiw	r24, 0x0c	; 12
     c9e:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     ca2:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     ca4:	89 81       	ldd	r24, Y+1	; 0x01
     ca6:	9a 81       	ldd	r25, Y+2	; 0x02
     ca8:	02 96       	adiw	r24, 0x02	; 2
     caa:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     cae:	e9 81       	ldd	r30, Y+1	; 0x01
     cb0:	fa 81       	ldd	r31, Y+2	; 0x02
     cb2:	96 89       	ldd	r25, Z+22	; 0x16
     cb4:	80 91 c2 00 	lds	r24, 0x00C2
     cb8:	89 17       	cp	r24, r25
     cba:	28 f4       	brcc	.+10     	; 0xcc6 <prvCheckPendingReadyList+0x4c>
     cbc:	e9 81       	ldd	r30, Y+1	; 0x01
     cbe:	fa 81       	ldd	r31, Y+2	; 0x02
     cc0:	86 89       	ldd	r24, Z+22	; 0x16
     cc2:	80 93 c2 00 	sts	0x00C2, r24
     cc6:	e9 81       	ldd	r30, Y+1	; 0x01
     cc8:	fa 81       	ldd	r31, Y+2	; 0x02
     cca:	86 89       	ldd	r24, Z+22	; 0x16
     ccc:	28 2f       	mov	r18, r24
     cce:	30 e0       	ldi	r19, 0x00	; 0
     cd0:	c9 01       	movw	r24, r18
     cd2:	88 0f       	add	r24, r24
     cd4:	99 1f       	adc	r25, r25
     cd6:	88 0f       	add	r24, r24
     cd8:	99 1f       	adc	r25, r25
     cda:	88 0f       	add	r24, r24
     cdc:	99 1f       	adc	r25, r25
     cde:	82 0f       	add	r24, r18
     ce0:	93 1f       	adc	r25, r19
     ce2:	ac 01       	movw	r20, r24
     ce4:	47 53       	subi	r20, 0x37	; 55
     ce6:	5f 4f       	sbci	r21, 0xFF	; 255
     ce8:	89 81       	ldd	r24, Y+1	; 0x01
     cea:	9a 81       	ldd	r25, Y+2	; 0x02
     cec:	9c 01       	movw	r18, r24
     cee:	2e 5f       	subi	r18, 0xFE	; 254
     cf0:	3f 4f       	sbci	r19, 0xFF	; 255
     cf2:	ca 01       	movw	r24, r20
     cf4:	b9 01       	movw	r22, r18
     cf6:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     cfa:	80 91 f1 00 	lds	r24, 0x00F1
     cfe:	88 23       	and	r24, r24
     d00:	09 f0       	breq	.+2      	; 0xd04 <prvCheckPendingReadyList+0x8a>
     d02:	c1 cf       	rjmp	.-126    	; 0xc86 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
     d04:	0f 90       	pop	r0
     d06:	0f 90       	pop	r0
     d08:	cf 91       	pop	r28
     d0a:	df 91       	pop	r29
     d0c:	08 95       	ret

00000d0e <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     d0e:	df 93       	push	r29
     d10:	cf 93       	push	r28
     d12:	00 d0       	rcall	.+0      	; 0xd14 <prvCheckDelayedList+0x6>
     d14:	00 d0       	rcall	.+0      	; 0xd16 <prvCheckDelayedList+0x8>
     d16:	cd b7       	in	r28, 0x3d	; 61
     d18:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     d1a:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <xTaskGetTickCount>
     d1e:	20 91 c5 00 	lds	r18, 0x00C5
     d22:	30 91 c6 00 	lds	r19, 0x00C6
     d26:	82 1b       	sub	r24, r18
     d28:	93 0b       	sbc	r25, r19
     d2a:	90 93 c8 00 	sts	0x00C8, r25
     d2e:	80 93 c7 00 	sts	0x00C7, r24
     d32:	85 c0       	rjmp	.+266    	; 0xe3e <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     d34:	80 91 c3 00 	lds	r24, 0x00C3
     d38:	90 91 c4 00 	lds	r25, 0x00C4
     d3c:	01 96       	adiw	r24, 0x01	; 1
     d3e:	90 93 c4 00 	sts	0x00C4, r25
     d42:	80 93 c3 00 	sts	0x00C3, r24
		xPassedTicks--;
     d46:	80 91 c7 00 	lds	r24, 0x00C7
     d4a:	90 91 c8 00 	lds	r25, 0x00C8
     d4e:	01 97       	sbiw	r24, 0x01	; 1
     d50:	90 93 c8 00 	sts	0x00C8, r25
     d54:	80 93 c7 00 	sts	0x00C7, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     d58:	80 91 c3 00 	lds	r24, 0x00C3
     d5c:	90 91 c4 00 	lds	r25, 0x00C4
     d60:	00 97       	sbiw	r24, 0x00	; 0
     d62:	09 f0       	breq	.+2      	; 0xd66 <prvCheckDelayedList+0x58>
     d64:	64 c0       	rjmp	.+200    	; 0xe2e <prvCheckDelayedList+0x120>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     d66:	80 91 ed 00 	lds	r24, 0x00ED
     d6a:	90 91 ee 00 	lds	r25, 0x00EE
     d6e:	9a 83       	std	Y+2, r25	; 0x02
     d70:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     d72:	80 91 ef 00 	lds	r24, 0x00EF
     d76:	90 91 f0 00 	lds	r25, 0x00F0
     d7a:	90 93 ee 00 	sts	0x00EE, r25
     d7e:	80 93 ed 00 	sts	0x00ED, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     d82:	89 81       	ldd	r24, Y+1	; 0x01
     d84:	9a 81       	ldd	r25, Y+2	; 0x02
     d86:	90 93 f0 00 	sts	0x00F0, r25
     d8a:	80 93 ef 00 	sts	0x00EF, r24
     d8e:	4f c0       	rjmp	.+158    	; 0xe2e <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     d90:	e0 91 ed 00 	lds	r30, 0x00ED
     d94:	f0 91 ee 00 	lds	r31, 0x00EE
     d98:	05 80       	ldd	r0, Z+5	; 0x05
     d9a:	f6 81       	ldd	r31, Z+6	; 0x06
     d9c:	e0 2d       	mov	r30, r0
     d9e:	86 81       	ldd	r24, Z+6	; 0x06
     da0:	97 81       	ldd	r25, Z+7	; 0x07
     da2:	9c 83       	std	Y+4, r25	; 0x04
     da4:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     da6:	eb 81       	ldd	r30, Y+3	; 0x03
     da8:	fc 81       	ldd	r31, Y+4	; 0x04
     daa:	22 81       	ldd	r18, Z+2	; 0x02
     dac:	33 81       	ldd	r19, Z+3	; 0x03
     dae:	80 91 c3 00 	lds	r24, 0x00C3
     db2:	90 91 c4 00 	lds	r25, 0x00C4
     db6:	82 17       	cp	r24, r18
     db8:	93 07       	cpc	r25, r19
     dba:	08 f4       	brcc	.+2      	; 0xdbe <prvCheckDelayedList+0xb0>
     dbc:	40 c0       	rjmp	.+128    	; 0xe3e <prvCheckDelayedList+0x130>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     dbe:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     dc0:	8b 81       	ldd	r24, Y+3	; 0x03
     dc2:	9c 81       	ldd	r25, Y+4	; 0x04
     dc4:	02 96       	adiw	r24, 0x02	; 2
     dc6:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     dca:	eb 81       	ldd	r30, Y+3	; 0x03
     dcc:	fc 81       	ldd	r31, Y+4	; 0x04
     dce:	84 89       	ldd	r24, Z+20	; 0x14
     dd0:	95 89       	ldd	r25, Z+21	; 0x15
     dd2:	00 97       	sbiw	r24, 0x00	; 0
     dd4:	29 f0       	breq	.+10     	; 0xde0 <prvCheckDelayedList+0xd2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     dd6:	8b 81       	ldd	r24, Y+3	; 0x03
     dd8:	9c 81       	ldd	r25, Y+4	; 0x04
     dda:	0c 96       	adiw	r24, 0x0c	; 12
     ddc:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     de0:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     de2:	eb 81       	ldd	r30, Y+3	; 0x03
     de4:	fc 81       	ldd	r31, Y+4	; 0x04
     de6:	96 89       	ldd	r25, Z+22	; 0x16
     de8:	80 91 c2 00 	lds	r24, 0x00C2
     dec:	89 17       	cp	r24, r25
     dee:	28 f4       	brcc	.+10     	; 0xdfa <prvCheckDelayedList+0xec>
     df0:	eb 81       	ldd	r30, Y+3	; 0x03
     df2:	fc 81       	ldd	r31, Y+4	; 0x04
     df4:	86 89       	ldd	r24, Z+22	; 0x16
     df6:	80 93 c2 00 	sts	0x00C2, r24
     dfa:	eb 81       	ldd	r30, Y+3	; 0x03
     dfc:	fc 81       	ldd	r31, Y+4	; 0x04
     dfe:	86 89       	ldd	r24, Z+22	; 0x16
     e00:	28 2f       	mov	r18, r24
     e02:	30 e0       	ldi	r19, 0x00	; 0
     e04:	c9 01       	movw	r24, r18
     e06:	88 0f       	add	r24, r24
     e08:	99 1f       	adc	r25, r25
     e0a:	88 0f       	add	r24, r24
     e0c:	99 1f       	adc	r25, r25
     e0e:	88 0f       	add	r24, r24
     e10:	99 1f       	adc	r25, r25
     e12:	82 0f       	add	r24, r18
     e14:	93 1f       	adc	r25, r19
     e16:	ac 01       	movw	r20, r24
     e18:	47 53       	subi	r20, 0x37	; 55
     e1a:	5f 4f       	sbci	r21, 0xFF	; 255
     e1c:	8b 81       	ldd	r24, Y+3	; 0x03
     e1e:	9c 81       	ldd	r25, Y+4	; 0x04
     e20:	9c 01       	movw	r18, r24
     e22:	2e 5f       	subi	r18, 0xFE	; 254
     e24:	3f 4f       	sbci	r19, 0xFF	; 255
     e26:	ca 01       	movw	r24, r20
     e28:	b9 01       	movw	r22, r18
     e2a:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     e2e:	e0 91 ed 00 	lds	r30, 0x00ED
     e32:	f0 91 ee 00 	lds	r31, 0x00EE
     e36:	80 81       	ld	r24, Z
     e38:	88 23       	and	r24, r24
     e3a:	09 f0       	breq	.+2      	; 0xe3e <prvCheckDelayedList+0x130>
     e3c:	a9 cf       	rjmp	.-174    	; 0xd90 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     e3e:	80 91 c7 00 	lds	r24, 0x00C7
     e42:	90 91 c8 00 	lds	r25, 0x00C8
     e46:	00 97       	sbiw	r24, 0x00	; 0
     e48:	09 f0       	breq	.+2      	; 0xe4c <prvCheckDelayedList+0x13e>
     e4a:	74 cf       	rjmp	.-280    	; 0xd34 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     e4c:	80 91 c3 00 	lds	r24, 0x00C3
     e50:	90 91 c4 00 	lds	r25, 0x00C4
     e54:	90 93 c6 00 	sts	0x00C6, r25
     e58:	80 93 c5 00 	sts	0x00C5, r24
}
     e5c:	0f 90       	pop	r0
     e5e:	0f 90       	pop	r0
     e60:	0f 90       	pop	r0
     e62:	0f 90       	pop	r0
     e64:	cf 91       	pop	r28
     e66:	df 91       	pop	r29
     e68:	08 95       	ret

00000e6a <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     e6a:	df 93       	push	r29
     e6c:	cf 93       	push	r28
     e6e:	00 d0       	rcall	.+0      	; 0xe70 <vCoRoutineSchedule+0x6>
     e70:	cd b7       	in	r28, 0x3d	; 61
     e72:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     e74:	0e 94 3d 06 	call	0xc7a	; 0xc7a <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     e78:	0e 94 87 06 	call	0xd0e	; 0xd0e <prvCheckDelayedList>
     e7c:	0a c0       	rjmp	.+20     	; 0xe92 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     e7e:	80 91 c2 00 	lds	r24, 0x00C2
     e82:	88 23       	and	r24, r24
     e84:	09 f4       	brne	.+2      	; 0xe88 <vCoRoutineSchedule+0x1e>
     e86:	66 c0       	rjmp	.+204    	; 0xf54 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     e88:	80 91 c2 00 	lds	r24, 0x00C2
     e8c:	81 50       	subi	r24, 0x01	; 1
     e8e:	80 93 c2 00 	sts	0x00C2, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     e92:	80 91 c2 00 	lds	r24, 0x00C2
     e96:	28 2f       	mov	r18, r24
     e98:	30 e0       	ldi	r19, 0x00	; 0
     e9a:	c9 01       	movw	r24, r18
     e9c:	88 0f       	add	r24, r24
     e9e:	99 1f       	adc	r25, r25
     ea0:	88 0f       	add	r24, r24
     ea2:	99 1f       	adc	r25, r25
     ea4:	88 0f       	add	r24, r24
     ea6:	99 1f       	adc	r25, r25
     ea8:	82 0f       	add	r24, r18
     eaa:	93 1f       	adc	r25, r19
     eac:	fc 01       	movw	r30, r24
     eae:	e7 53       	subi	r30, 0x37	; 55
     eb0:	ff 4f       	sbci	r31, 0xFF	; 255
     eb2:	80 81       	ld	r24, Z
     eb4:	88 23       	and	r24, r24
     eb6:	19 f3       	breq	.-58     	; 0xe7e <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     eb8:	80 91 c2 00 	lds	r24, 0x00C2
     ebc:	28 2f       	mov	r18, r24
     ebe:	30 e0       	ldi	r19, 0x00	; 0
     ec0:	c9 01       	movw	r24, r18
     ec2:	88 0f       	add	r24, r24
     ec4:	99 1f       	adc	r25, r25
     ec6:	88 0f       	add	r24, r24
     ec8:	99 1f       	adc	r25, r25
     eca:	88 0f       	add	r24, r24
     ecc:	99 1f       	adc	r25, r25
     ece:	82 0f       	add	r24, r18
     ed0:	93 1f       	adc	r25, r19
     ed2:	87 53       	subi	r24, 0x37	; 55
     ed4:	9f 4f       	sbci	r25, 0xFF	; 255
     ed6:	9a 83       	std	Y+2, r25	; 0x02
     ed8:	89 83       	std	Y+1, r24	; 0x01
     eda:	e9 81       	ldd	r30, Y+1	; 0x01
     edc:	fa 81       	ldd	r31, Y+2	; 0x02
     ede:	01 80       	ldd	r0, Z+1	; 0x01
     ee0:	f2 81       	ldd	r31, Z+2	; 0x02
     ee2:	e0 2d       	mov	r30, r0
     ee4:	82 81       	ldd	r24, Z+2	; 0x02
     ee6:	93 81       	ldd	r25, Z+3	; 0x03
     ee8:	e9 81       	ldd	r30, Y+1	; 0x01
     eea:	fa 81       	ldd	r31, Y+2	; 0x02
     eec:	92 83       	std	Z+2, r25	; 0x02
     eee:	81 83       	std	Z+1, r24	; 0x01
     ef0:	e9 81       	ldd	r30, Y+1	; 0x01
     ef2:	fa 81       	ldd	r31, Y+2	; 0x02
     ef4:	21 81       	ldd	r18, Z+1	; 0x01
     ef6:	32 81       	ldd	r19, Z+2	; 0x02
     ef8:	89 81       	ldd	r24, Y+1	; 0x01
     efa:	9a 81       	ldd	r25, Y+2	; 0x02
     efc:	03 96       	adiw	r24, 0x03	; 3
     efe:	28 17       	cp	r18, r24
     f00:	39 07       	cpc	r19, r25
     f02:	59 f4       	brne	.+22     	; 0xf1a <vCoRoutineSchedule+0xb0>
     f04:	e9 81       	ldd	r30, Y+1	; 0x01
     f06:	fa 81       	ldd	r31, Y+2	; 0x02
     f08:	01 80       	ldd	r0, Z+1	; 0x01
     f0a:	f2 81       	ldd	r31, Z+2	; 0x02
     f0c:	e0 2d       	mov	r30, r0
     f0e:	82 81       	ldd	r24, Z+2	; 0x02
     f10:	93 81       	ldd	r25, Z+3	; 0x03
     f12:	e9 81       	ldd	r30, Y+1	; 0x01
     f14:	fa 81       	ldd	r31, Y+2	; 0x02
     f16:	92 83       	std	Z+2, r25	; 0x02
     f18:	81 83       	std	Z+1, r24	; 0x01
     f1a:	e9 81       	ldd	r30, Y+1	; 0x01
     f1c:	fa 81       	ldd	r31, Y+2	; 0x02
     f1e:	01 80       	ldd	r0, Z+1	; 0x01
     f20:	f2 81       	ldd	r31, Z+2	; 0x02
     f22:	e0 2d       	mov	r30, r0
     f24:	86 81       	ldd	r24, Z+6	; 0x06
     f26:	97 81       	ldd	r25, Z+7	; 0x07
     f28:	90 93 c1 00 	sts	0x00C1, r25
     f2c:	80 93 c0 00 	sts	0x00C0, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     f30:	e0 91 c0 00 	lds	r30, 0x00C0
     f34:	f0 91 c1 00 	lds	r31, 0x00C1
     f38:	40 81       	ld	r20, Z
     f3a:	51 81       	ldd	r21, Z+1	; 0x01
     f3c:	80 91 c0 00 	lds	r24, 0x00C0
     f40:	90 91 c1 00 	lds	r25, 0x00C1
     f44:	e0 91 c0 00 	lds	r30, 0x00C0
     f48:	f0 91 c1 00 	lds	r31, 0x00C1
     f4c:	27 89       	ldd	r18, Z+23	; 0x17
     f4e:	62 2f       	mov	r22, r18
     f50:	fa 01       	movw	r30, r20
     f52:	09 95       	icall

	return;
}
     f54:	0f 90       	pop	r0
     f56:	0f 90       	pop	r0
     f58:	cf 91       	pop	r28
     f5a:	df 91       	pop	r29
     f5c:	08 95       	ret

00000f5e <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     f5e:	df 93       	push	r29
     f60:	cf 93       	push	r28
     f62:	0f 92       	push	r0
     f64:	cd b7       	in	r28, 0x3d	; 61
     f66:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     f68:	19 82       	std	Y+1, r1	; 0x01
     f6a:	13 c0       	rjmp	.+38     	; 0xf92 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     f6c:	89 81       	ldd	r24, Y+1	; 0x01
     f6e:	28 2f       	mov	r18, r24
     f70:	30 e0       	ldi	r19, 0x00	; 0
     f72:	c9 01       	movw	r24, r18
     f74:	88 0f       	add	r24, r24
     f76:	99 1f       	adc	r25, r25
     f78:	88 0f       	add	r24, r24
     f7a:	99 1f       	adc	r25, r25
     f7c:	88 0f       	add	r24, r24
     f7e:	99 1f       	adc	r25, r25
     f80:	82 0f       	add	r24, r18
     f82:	93 1f       	adc	r25, r19
     f84:	87 53       	subi	r24, 0x37	; 55
     f86:	9f 4f       	sbci	r25, 0xFF	; 255
     f88:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     f8c:	89 81       	ldd	r24, Y+1	; 0x01
     f8e:	8f 5f       	subi	r24, 0xFF	; 255
     f90:	89 83       	std	Y+1, r24	; 0x01
     f92:	89 81       	ldd	r24, Y+1	; 0x01
     f94:	82 30       	cpi	r24, 0x02	; 2
     f96:	50 f3       	brcs	.-44     	; 0xf6c <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     f98:	8b ed       	ldi	r24, 0xDB	; 219
     f9a:	90 e0       	ldi	r25, 0x00	; 0
     f9c:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     fa0:	84 ee       	ldi	r24, 0xE4	; 228
     fa2:	90 e0       	ldi	r25, 0x00	; 0
     fa4:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     fa8:	81 ef       	ldi	r24, 0xF1	; 241
     faa:	90 e0       	ldi	r25, 0x00	; 0
     fac:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     fb0:	8b ed       	ldi	r24, 0xDB	; 219
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	90 93 ee 00 	sts	0x00EE, r25
     fb8:	80 93 ed 00 	sts	0x00ED, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     fbc:	84 ee       	ldi	r24, 0xE4	; 228
     fbe:	90 e0       	ldi	r25, 0x00	; 0
     fc0:	90 93 f0 00 	sts	0x00F0, r25
     fc4:	80 93 ef 00 	sts	0x00EF, r24
}
     fc8:	0f 90       	pop	r0
     fca:	cf 91       	pop	r28
     fcc:	df 91       	pop	r29
     fce:	08 95       	ret

00000fd0 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     fd0:	df 93       	push	r29
     fd2:	cf 93       	push	r28
     fd4:	00 d0       	rcall	.+0      	; 0xfd6 <xCoRoutineRemoveFromEventList+0x6>
     fd6:	00 d0       	rcall	.+0      	; 0xfd8 <xCoRoutineRemoveFromEventList+0x8>
     fd8:	0f 92       	push	r0
     fda:	cd b7       	in	r28, 0x3d	; 61
     fdc:	de b7       	in	r29, 0x3e	; 62
     fde:	9d 83       	std	Y+5, r25	; 0x05
     fe0:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     fe2:	ec 81       	ldd	r30, Y+4	; 0x04
     fe4:	fd 81       	ldd	r31, Y+5	; 0x05
     fe6:	05 80       	ldd	r0, Z+5	; 0x05
     fe8:	f6 81       	ldd	r31, Z+6	; 0x06
     fea:	e0 2d       	mov	r30, r0
     fec:	86 81       	ldd	r24, Z+6	; 0x06
     fee:	97 81       	ldd	r25, Z+7	; 0x07
     ff0:	9b 83       	std	Y+3, r25	; 0x03
     ff2:	8a 83       	std	Y+2, r24	; 0x02
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     ff4:	8a 81       	ldd	r24, Y+2	; 0x02
     ff6:	9b 81       	ldd	r25, Y+3	; 0x03
     ff8:	0c 96       	adiw	r24, 0x0c	; 12
     ffa:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     ffe:	8a 81       	ldd	r24, Y+2	; 0x02
    1000:	9b 81       	ldd	r25, Y+3	; 0x03
    1002:	9c 01       	movw	r18, r24
    1004:	24 5f       	subi	r18, 0xF4	; 244
    1006:	3f 4f       	sbci	r19, 0xFF	; 255
    1008:	81 ef       	ldi	r24, 0xF1	; 241
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	b9 01       	movw	r22, r18
    100e:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1012:	ea 81       	ldd	r30, Y+2	; 0x02
    1014:	fb 81       	ldd	r31, Y+3	; 0x03
    1016:	96 89       	ldd	r25, Z+22	; 0x16
    1018:	e0 91 c0 00 	lds	r30, 0x00C0
    101c:	f0 91 c1 00 	lds	r31, 0x00C1
    1020:	86 89       	ldd	r24, Z+22	; 0x16
    1022:	98 17       	cp	r25, r24
    1024:	18 f0       	brcs	.+6      	; 0x102c <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    1026:	81 e0       	ldi	r24, 0x01	; 1
    1028:	89 83       	std	Y+1, r24	; 0x01
    102a:	01 c0       	rjmp	.+2      	; 0x102e <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    102c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    102e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1030:	0f 90       	pop	r0
    1032:	0f 90       	pop	r0
    1034:	0f 90       	pop	r0
    1036:	0f 90       	pop	r0
    1038:	0f 90       	pop	r0
    103a:	cf 91       	pop	r28
    103c:	df 91       	pop	r29
    103e:	08 95       	ret

00001040 <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    1040:	df 93       	push	r29
    1042:	cf 93       	push	r28
    1044:	00 d0       	rcall	.+0      	; 0x1046 <xEventGroupCreate+0x6>
    1046:	cd b7       	in	r28, 0x3d	; 61
    1048:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
    104a:	8b e0       	ldi	r24, 0x0B	; 11
    104c:	90 e0       	ldi	r25, 0x00	; 0
    104e:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <pvPortMalloc>
    1052:	9a 83       	std	Y+2, r25	; 0x02
    1054:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
    1056:	89 81       	ldd	r24, Y+1	; 0x01
    1058:	9a 81       	ldd	r25, Y+2	; 0x02
    105a:	00 97       	sbiw	r24, 0x00	; 0
    105c:	49 f0       	breq	.+18     	; 0x1070 <xEventGroupCreate+0x30>
	{
		pxEventBits->uxEventBits = 0;
    105e:	e9 81       	ldd	r30, Y+1	; 0x01
    1060:	fa 81       	ldd	r31, Y+2	; 0x02
    1062:	11 82       	std	Z+1, r1	; 0x01
    1064:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1066:	89 81       	ldd	r24, Y+1	; 0x01
    1068:	9a 81       	ldd	r25, Y+2	; 0x02
    106a:	02 96       	adiw	r24, 0x02	; 2
    106c:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
    1070:	89 81       	ldd	r24, Y+1	; 0x01
    1072:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1074:	0f 90       	pop	r0
    1076:	0f 90       	pop	r0
    1078:	cf 91       	pop	r28
    107a:	df 91       	pop	r29
    107c:	08 95       	ret

0000107e <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    107e:	df 93       	push	r29
    1080:	cf 93       	push	r28
    1082:	cd b7       	in	r28, 0x3d	; 61
    1084:	de b7       	in	r29, 0x3e	; 62
    1086:	60 97       	sbiw	r28, 0x10	; 16
    1088:	0f b6       	in	r0, 0x3f	; 63
    108a:	f8 94       	cli
    108c:	de bf       	out	0x3e, r29	; 62
    108e:	0f be       	out	0x3f, r0	; 63
    1090:	cd bf       	out	0x3d, r28	; 61
    1092:	9a 87       	std	Y+10, r25	; 0x0a
    1094:	89 87       	std	Y+9, r24	; 0x09
    1096:	7c 87       	std	Y+12, r23	; 0x0c
    1098:	6b 87       	std	Y+11, r22	; 0x0b
    109a:	5e 87       	std	Y+14, r21	; 0x0e
    109c:	4d 87       	std	Y+13, r20	; 0x0d
    109e:	38 8b       	std	Y+16, r19	; 0x10
    10a0:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    10a2:	89 85       	ldd	r24, Y+9	; 0x09
    10a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    10a6:	9c 83       	std	Y+4, r25	; 0x04
    10a8:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    10aa:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    10ac:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    10b0:	eb 81       	ldd	r30, Y+3	; 0x03
    10b2:	fc 81       	ldd	r31, Y+4	; 0x04
    10b4:	80 81       	ld	r24, Z
    10b6:	91 81       	ldd	r25, Z+1	; 0x01
    10b8:	98 87       	std	Y+8, r25	; 0x08
    10ba:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    10bc:	89 85       	ldd	r24, Y+9	; 0x09
    10be:	9a 85       	ldd	r25, Y+10	; 0x0a
    10c0:	2b 85       	ldd	r18, Y+11	; 0x0b
    10c2:	3c 85       	ldd	r19, Y+12	; 0x0c
    10c4:	b9 01       	movw	r22, r18
    10c6:	0e 94 11 0a 	call	0x1422	; 0x1422 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    10ca:	2f 81       	ldd	r18, Y+7	; 0x07
    10cc:	38 85       	ldd	r19, Y+8	; 0x08
    10ce:	8b 85       	ldd	r24, Y+11	; 0x0b
    10d0:	9c 85       	ldd	r25, Y+12	; 0x0c
    10d2:	28 2b       	or	r18, r24
    10d4:	39 2b       	or	r19, r25
    10d6:	8d 85       	ldd	r24, Y+13	; 0x0d
    10d8:	9e 85       	ldd	r25, Y+14	; 0x0e
    10da:	28 23       	and	r18, r24
    10dc:	39 23       	and	r19, r25
    10de:	8d 85       	ldd	r24, Y+13	; 0x0d
    10e0:	9e 85       	ldd	r25, Y+14	; 0x0e
    10e2:	28 17       	cp	r18, r24
    10e4:	39 07       	cpc	r19, r25
    10e6:	c9 f4       	brne	.+50     	; 0x111a <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    10e8:	2f 81       	ldd	r18, Y+7	; 0x07
    10ea:	38 85       	ldd	r19, Y+8	; 0x08
    10ec:	8b 85       	ldd	r24, Y+11	; 0x0b
    10ee:	9c 85       	ldd	r25, Y+12	; 0x0c
    10f0:	82 2b       	or	r24, r18
    10f2:	93 2b       	or	r25, r19
    10f4:	9e 83       	std	Y+6, r25	; 0x06
    10f6:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    10f8:	eb 81       	ldd	r30, Y+3	; 0x03
    10fa:	fc 81       	ldd	r31, Y+4	; 0x04
    10fc:	20 81       	ld	r18, Z
    10fe:	31 81       	ldd	r19, Z+1	; 0x01
    1100:	8d 85       	ldd	r24, Y+13	; 0x0d
    1102:	9e 85       	ldd	r25, Y+14	; 0x0e
    1104:	80 95       	com	r24
    1106:	90 95       	com	r25
    1108:	82 23       	and	r24, r18
    110a:	93 23       	and	r25, r19
    110c:	eb 81       	ldd	r30, Y+3	; 0x03
    110e:	fc 81       	ldd	r31, Y+4	; 0x04
    1110:	91 83       	std	Z+1, r25	; 0x01
    1112:	80 83       	st	Z, r24

			xTicksToWait = 0;
    1114:	18 8a       	std	Y+16, r1	; 0x10
    1116:	1f 86       	std	Y+15, r1	; 0x0f
    1118:	1c c0       	rjmp	.+56     	; 0x1152 <xEventGroupSync+0xd4>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    111a:	8f 85       	ldd	r24, Y+15	; 0x0f
    111c:	98 89       	ldd	r25, Y+16	; 0x10
    111e:	00 97       	sbiw	r24, 0x00	; 0
    1120:	91 f0       	breq	.+36     	; 0x1146 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1122:	8b 81       	ldd	r24, Y+3	; 0x03
    1124:	9c 81       	ldd	r25, Y+4	; 0x04
    1126:	bc 01       	movw	r22, r24
    1128:	6e 5f       	subi	r22, 0xFE	; 254
    112a:	7f 4f       	sbci	r23, 0xFF	; 255
    112c:	8d 85       	ldd	r24, Y+13	; 0x0d
    112e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1130:	9c 01       	movw	r18, r24
    1132:	35 60       	ori	r19, 0x05	; 5
    1134:	4f 85       	ldd	r20, Y+15	; 0x0f
    1136:	58 89       	ldd	r21, Y+16	; 0x10
    1138:	cb 01       	movw	r24, r22
    113a:	b9 01       	movw	r22, r18
    113c:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1140:	1e 82       	std	Y+6, r1	; 0x06
    1142:	1d 82       	std	Y+5, r1	; 0x05
    1144:	06 c0       	rjmp	.+12     	; 0x1152 <xEventGroupSync+0xd4>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1146:	eb 81       	ldd	r30, Y+3	; 0x03
    1148:	fc 81       	ldd	r31, Y+4	; 0x04
    114a:	80 81       	ld	r24, Z
    114c:	91 81       	ldd	r25, Z+1	; 0x01
    114e:	9e 83       	std	Y+6, r25	; 0x06
    1150:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1152:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>
    1156:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    1158:	8f 85       	ldd	r24, Y+15	; 0x0f
    115a:	98 89       	ldd	r25, Y+16	; 0x10
    115c:	00 97       	sbiw	r24, 0x00	; 0
    115e:	09 f4       	brne	.+2      	; 0x1162 <xEventGroupSync+0xe4>
    1160:	3a c0       	rjmp	.+116    	; 0x11d6 <xEventGroupSync+0x158>
	{
		if( xAlreadyYielded == pdFALSE )
    1162:	8a 81       	ldd	r24, Y+2	; 0x02
    1164:	88 23       	and	r24, r24
    1166:	11 f4       	brne	.+4      	; 0x116c <xEventGroupSync+0xee>
		{
			portYIELD_WITHIN_API();
    1168:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    116c:	0e 94 94 21 	call	0x4328	; 0x4328 <uxTaskResetEventItemValue>
    1170:	9e 83       	std	Y+6, r25	; 0x06
    1172:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1174:	8d 81       	ldd	r24, Y+5	; 0x05
    1176:	9e 81       	ldd	r25, Y+6	; 0x06
    1178:	80 70       	andi	r24, 0x00	; 0
    117a:	92 70       	andi	r25, 0x02	; 2
    117c:	00 97       	sbiw	r24, 0x00	; 0
    117e:	31 f5       	brne	.+76     	; 0x11cc <xEventGroupSync+0x14e>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1180:	0f b6       	in	r0, 0x3f	; 63
    1182:	f8 94       	cli
    1184:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1186:	eb 81       	ldd	r30, Y+3	; 0x03
    1188:	fc 81       	ldd	r31, Y+4	; 0x04
    118a:	80 81       	ld	r24, Z
    118c:	91 81       	ldd	r25, Z+1	; 0x01
    118e:	9e 83       	std	Y+6, r25	; 0x06
    1190:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1192:	2d 81       	ldd	r18, Y+5	; 0x05
    1194:	3e 81       	ldd	r19, Y+6	; 0x06
    1196:	8d 85       	ldd	r24, Y+13	; 0x0d
    1198:	9e 85       	ldd	r25, Y+14	; 0x0e
    119a:	28 23       	and	r18, r24
    119c:	39 23       	and	r19, r25
    119e:	8d 85       	ldd	r24, Y+13	; 0x0d
    11a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    11a2:	28 17       	cp	r18, r24
    11a4:	39 07       	cpc	r19, r25
    11a6:	71 f4       	brne	.+28     	; 0x11c4 <xEventGroupSync+0x146>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    11a8:	eb 81       	ldd	r30, Y+3	; 0x03
    11aa:	fc 81       	ldd	r31, Y+4	; 0x04
    11ac:	20 81       	ld	r18, Z
    11ae:	31 81       	ldd	r19, Z+1	; 0x01
    11b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    11b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    11b4:	80 95       	com	r24
    11b6:	90 95       	com	r25
    11b8:	82 23       	and	r24, r18
    11ba:	93 23       	and	r25, r19
    11bc:	eb 81       	ldd	r30, Y+3	; 0x03
    11be:	fc 81       	ldd	r31, Y+4	; 0x04
    11c0:	91 83       	std	Z+1, r25	; 0x01
    11c2:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    11c4:	0f 90       	pop	r0
    11c6:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    11c8:	81 e0       	ldi	r24, 0x01	; 1
    11ca:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    11cc:	8d 81       	ldd	r24, Y+5	; 0x05
    11ce:	9e 81       	ldd	r25, Y+6	; 0x06
    11d0:	90 70       	andi	r25, 0x00	; 0
    11d2:	9e 83       	std	Y+6, r25	; 0x06
    11d4:	8d 83       	std	Y+5, r24	; 0x05
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    11d6:	8d 81       	ldd	r24, Y+5	; 0x05
    11d8:	9e 81       	ldd	r25, Y+6	; 0x06
}
    11da:	60 96       	adiw	r28, 0x10	; 16
    11dc:	0f b6       	in	r0, 0x3f	; 63
    11de:	f8 94       	cli
    11e0:	de bf       	out	0x3e, r29	; 62
    11e2:	0f be       	out	0x3f, r0	; 63
    11e4:	cd bf       	out	0x3d, r28	; 61
    11e6:	cf 91       	pop	r28
    11e8:	df 91       	pop	r29
    11ea:	08 95       	ret

000011ec <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    11ec:	0f 93       	push	r16
    11ee:	1f 93       	push	r17
    11f0:	df 93       	push	r29
    11f2:	cf 93       	push	r28
    11f4:	cd b7       	in	r28, 0x3d	; 61
    11f6:	de b7       	in	r29, 0x3e	; 62
    11f8:	63 97       	sbiw	r28, 0x13	; 19
    11fa:	0f b6       	in	r0, 0x3f	; 63
    11fc:	f8 94       	cli
    11fe:	de bf       	out	0x3e, r29	; 62
    1200:	0f be       	out	0x3f, r0	; 63
    1202:	cd bf       	out	0x3d, r28	; 61
    1204:	9d 87       	std	Y+13, r25	; 0x0d
    1206:	8c 87       	std	Y+12, r24	; 0x0c
    1208:	7f 87       	std	Y+15, r23	; 0x0f
    120a:	6e 87       	std	Y+14, r22	; 0x0e
    120c:	48 8b       	std	Y+16, r20	; 0x10
    120e:	29 8b       	std	Y+17, r18	; 0x11
    1210:	1b 8b       	std	Y+19, r17	; 0x13
    1212:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1214:	8c 85       	ldd	r24, Y+12	; 0x0c
    1216:	9d 85       	ldd	r25, Y+13	; 0x0d
    1218:	9b 87       	std	Y+11, r25	; 0x0b
    121a:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    121c:	1f 82       	std	Y+7, r1	; 0x07
    121e:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1220:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1222:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1226:	ea 85       	ldd	r30, Y+10	; 0x0a
    1228:	fb 85       	ldd	r31, Y+11	; 0x0b
    122a:	80 81       	ld	r24, Z
    122c:	91 81       	ldd	r25, Z+1	; 0x01
    122e:	9a 83       	std	Y+2, r25	; 0x02
    1230:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    1232:	89 81       	ldd	r24, Y+1	; 0x01
    1234:	9a 81       	ldd	r25, Y+2	; 0x02
    1236:	2e 85       	ldd	r18, Y+14	; 0x0e
    1238:	3f 85       	ldd	r19, Y+15	; 0x0f
    123a:	b9 01       	movw	r22, r18
    123c:	49 89       	ldd	r20, Y+17	; 0x11
    123e:	0e 94 2e 0b 	call	0x165c	; 0x165c <prvTestWaitCondition>
    1242:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    1244:	8d 81       	ldd	r24, Y+5	; 0x05
    1246:	88 23       	and	r24, r24
    1248:	c1 f0       	breq	.+48     	; 0x127a <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    124a:	89 81       	ldd	r24, Y+1	; 0x01
    124c:	9a 81       	ldd	r25, Y+2	; 0x02
    124e:	99 87       	std	Y+9, r25	; 0x09
    1250:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    1252:	1b 8a       	std	Y+19, r1	; 0x13
    1254:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    1256:	88 89       	ldd	r24, Y+16	; 0x10
    1258:	88 23       	and	r24, r24
    125a:	d9 f1       	breq	.+118    	; 0x12d2 <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    125c:	ea 85       	ldd	r30, Y+10	; 0x0a
    125e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1260:	20 81       	ld	r18, Z
    1262:	31 81       	ldd	r19, Z+1	; 0x01
    1264:	8e 85       	ldd	r24, Y+14	; 0x0e
    1266:	9f 85       	ldd	r25, Y+15	; 0x0f
    1268:	80 95       	com	r24
    126a:	90 95       	com	r25
    126c:	82 23       	and	r24, r18
    126e:	93 23       	and	r25, r19
    1270:	ea 85       	ldd	r30, Y+10	; 0x0a
    1272:	fb 85       	ldd	r31, Y+11	; 0x0b
    1274:	91 83       	std	Z+1, r25	; 0x01
    1276:	80 83       	st	Z, r24
    1278:	2c c0       	rjmp	.+88     	; 0x12d2 <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    127a:	8a 89       	ldd	r24, Y+18	; 0x12
    127c:	9b 89       	ldd	r25, Y+19	; 0x13
    127e:	00 97       	sbiw	r24, 0x00	; 0
    1280:	29 f4       	brne	.+10     	; 0x128c <xEventGroupWaitBits+0xa0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    1282:	89 81       	ldd	r24, Y+1	; 0x01
    1284:	9a 81       	ldd	r25, Y+2	; 0x02
    1286:	99 87       	std	Y+9, r25	; 0x09
    1288:	88 87       	std	Y+8, r24	; 0x08
    128a:	23 c0       	rjmp	.+70     	; 0x12d2 <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    128c:	88 89       	ldd	r24, Y+16	; 0x10
    128e:	88 23       	and	r24, r24
    1290:	29 f0       	breq	.+10     	; 0x129c <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1292:	8e 81       	ldd	r24, Y+6	; 0x06
    1294:	9f 81       	ldd	r25, Y+7	; 0x07
    1296:	91 60       	ori	r25, 0x01	; 1
    1298:	9f 83       	std	Y+7, r25	; 0x07
    129a:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    129c:	89 89       	ldd	r24, Y+17	; 0x11
    129e:	88 23       	and	r24, r24
    12a0:	29 f0       	breq	.+10     	; 0x12ac <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    12a2:	8e 81       	ldd	r24, Y+6	; 0x06
    12a4:	9f 81       	ldd	r25, Y+7	; 0x07
    12a6:	94 60       	ori	r25, 0x04	; 4
    12a8:	9f 83       	std	Y+7, r25	; 0x07
    12aa:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    12ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    12ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    12b0:	bc 01       	movw	r22, r24
    12b2:	6e 5f       	subi	r22, 0xFE	; 254
    12b4:	7f 4f       	sbci	r23, 0xFF	; 255
    12b6:	2e 85       	ldd	r18, Y+14	; 0x0e
    12b8:	3f 85       	ldd	r19, Y+15	; 0x0f
    12ba:	8e 81       	ldd	r24, Y+6	; 0x06
    12bc:	9f 81       	ldd	r25, Y+7	; 0x07
    12be:	28 2b       	or	r18, r24
    12c0:	39 2b       	or	r19, r25
    12c2:	4a 89       	ldd	r20, Y+18	; 0x12
    12c4:	5b 89       	ldd	r21, Y+19	; 0x13
    12c6:	cb 01       	movw	r24, r22
    12c8:	b9 01       	movw	r22, r18
    12ca:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    12ce:	19 86       	std	Y+9, r1	; 0x09
    12d0:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    12d2:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>
    12d6:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    12d8:	8a 89       	ldd	r24, Y+18	; 0x12
    12da:	9b 89       	ldd	r25, Y+19	; 0x13
    12dc:	00 97       	sbiw	r24, 0x00	; 0
    12de:	09 f4       	brne	.+2      	; 0x12e2 <xEventGroupWaitBits+0xf6>
    12e0:	3b c0       	rjmp	.+118    	; 0x1358 <xEventGroupWaitBits+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
    12e2:	8c 81       	ldd	r24, Y+4	; 0x04
    12e4:	88 23       	and	r24, r24
    12e6:	11 f4       	brne	.+4      	; 0x12ec <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
    12e8:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    12ec:	0e 94 94 21 	call	0x4328	; 0x4328 <uxTaskResetEventItemValue>
    12f0:	99 87       	std	Y+9, r25	; 0x09
    12f2:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    12f4:	88 85       	ldd	r24, Y+8	; 0x08
    12f6:	99 85       	ldd	r25, Y+9	; 0x09
    12f8:	80 70       	andi	r24, 0x00	; 0
    12fa:	92 70       	andi	r25, 0x02	; 2
    12fc:	00 97       	sbiw	r24, 0x00	; 0
    12fe:	39 f5       	brne	.+78     	; 0x134e <xEventGroupWaitBits+0x162>
		{
			taskENTER_CRITICAL();
    1300:	0f b6       	in	r0, 0x3f	; 63
    1302:	f8 94       	cli
    1304:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1306:	ea 85       	ldd	r30, Y+10	; 0x0a
    1308:	fb 85       	ldd	r31, Y+11	; 0x0b
    130a:	80 81       	ld	r24, Z
    130c:	91 81       	ldd	r25, Z+1	; 0x01
    130e:	99 87       	std	Y+9, r25	; 0x09
    1310:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1312:	88 85       	ldd	r24, Y+8	; 0x08
    1314:	99 85       	ldd	r25, Y+9	; 0x09
    1316:	2e 85       	ldd	r18, Y+14	; 0x0e
    1318:	3f 85       	ldd	r19, Y+15	; 0x0f
    131a:	b9 01       	movw	r22, r18
    131c:	49 89       	ldd	r20, Y+17	; 0x11
    131e:	0e 94 2e 0b 	call	0x165c	; 0x165c <prvTestWaitCondition>
    1322:	88 23       	and	r24, r24
    1324:	89 f0       	breq	.+34     	; 0x1348 <xEventGroupWaitBits+0x15c>
				{
					if( xClearOnExit != pdFALSE )
    1326:	88 89       	ldd	r24, Y+16	; 0x10
    1328:	88 23       	and	r24, r24
    132a:	71 f0       	breq	.+28     	; 0x1348 <xEventGroupWaitBits+0x15c>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    132c:	ea 85       	ldd	r30, Y+10	; 0x0a
    132e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1330:	20 81       	ld	r18, Z
    1332:	31 81       	ldd	r19, Z+1	; 0x01
    1334:	8e 85       	ldd	r24, Y+14	; 0x0e
    1336:	9f 85       	ldd	r25, Y+15	; 0x0f
    1338:	80 95       	com	r24
    133a:	90 95       	com	r25
    133c:	82 23       	and	r24, r18
    133e:	93 23       	and	r25, r19
    1340:	ea 85       	ldd	r30, Y+10	; 0x0a
    1342:	fb 85       	ldd	r31, Y+11	; 0x0b
    1344:	91 83       	std	Z+1, r25	; 0x01
    1346:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1348:	0f 90       	pop	r0
    134a:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    134c:	1b 82       	std	Y+3, r1	; 0x03
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    134e:	88 85       	ldd	r24, Y+8	; 0x08
    1350:	99 85       	ldd	r25, Y+9	; 0x09
    1352:	90 70       	andi	r25, 0x00	; 0
    1354:	99 87       	std	Y+9, r25	; 0x09
    1356:	88 87       	std	Y+8, r24	; 0x08
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    1358:	88 85       	ldd	r24, Y+8	; 0x08
    135a:	99 85       	ldd	r25, Y+9	; 0x09
}
    135c:	63 96       	adiw	r28, 0x13	; 19
    135e:	0f b6       	in	r0, 0x3f	; 63
    1360:	f8 94       	cli
    1362:	de bf       	out	0x3e, r29	; 62
    1364:	0f be       	out	0x3f, r0	; 63
    1366:	cd bf       	out	0x3d, r28	; 61
    1368:	cf 91       	pop	r28
    136a:	df 91       	pop	r29
    136c:	1f 91       	pop	r17
    136e:	0f 91       	pop	r16
    1370:	08 95       	ret

00001372 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    1372:	df 93       	push	r29
    1374:	cf 93       	push	r28
    1376:	cd b7       	in	r28, 0x3d	; 61
    1378:	de b7       	in	r29, 0x3e	; 62
    137a:	28 97       	sbiw	r28, 0x08	; 8
    137c:	0f b6       	in	r0, 0x3f	; 63
    137e:	f8 94       	cli
    1380:	de bf       	out	0x3e, r29	; 62
    1382:	0f be       	out	0x3f, r0	; 63
    1384:	cd bf       	out	0x3d, r28	; 61
    1386:	9e 83       	std	Y+6, r25	; 0x06
    1388:	8d 83       	std	Y+5, r24	; 0x05
    138a:	78 87       	std	Y+8, r23	; 0x08
    138c:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    138e:	8d 81       	ldd	r24, Y+5	; 0x05
    1390:	9e 81       	ldd	r25, Y+6	; 0x06
    1392:	9c 83       	std	Y+4, r25	; 0x04
    1394:	8b 83       	std	Y+3, r24	; 0x03

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    1396:	0f b6       	in	r0, 0x3f	; 63
    1398:	f8 94       	cli
    139a:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    139c:	eb 81       	ldd	r30, Y+3	; 0x03
    139e:	fc 81       	ldd	r31, Y+4	; 0x04
    13a0:	80 81       	ld	r24, Z
    13a2:	91 81       	ldd	r25, Z+1	; 0x01
    13a4:	9a 83       	std	Y+2, r25	; 0x02
    13a6:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    13a8:	eb 81       	ldd	r30, Y+3	; 0x03
    13aa:	fc 81       	ldd	r31, Y+4	; 0x04
    13ac:	20 81       	ld	r18, Z
    13ae:	31 81       	ldd	r19, Z+1	; 0x01
    13b0:	8f 81       	ldd	r24, Y+7	; 0x07
    13b2:	98 85       	ldd	r25, Y+8	; 0x08
    13b4:	80 95       	com	r24
    13b6:	90 95       	com	r25
    13b8:	82 23       	and	r24, r18
    13ba:	93 23       	and	r25, r19
    13bc:	eb 81       	ldd	r30, Y+3	; 0x03
    13be:	fc 81       	ldd	r31, Y+4	; 0x04
    13c0:	91 83       	std	Z+1, r25	; 0x01
    13c2:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    13c4:	0f 90       	pop	r0
    13c6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    13c8:	89 81       	ldd	r24, Y+1	; 0x01
    13ca:	9a 81       	ldd	r25, Y+2	; 0x02
}
    13cc:	28 96       	adiw	r28, 0x08	; 8
    13ce:	0f b6       	in	r0, 0x3f	; 63
    13d0:	f8 94       	cli
    13d2:	de bf       	out	0x3e, r29	; 62
    13d4:	0f be       	out	0x3f, r0	; 63
    13d6:	cd bf       	out	0x3d, r28	; 61
    13d8:	cf 91       	pop	r28
    13da:	df 91       	pop	r29
    13dc:	08 95       	ret

000013de <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    13de:	df 93       	push	r29
    13e0:	cf 93       	push	r28
    13e2:	cd b7       	in	r28, 0x3d	; 61
    13e4:	de b7       	in	r29, 0x3e	; 62
    13e6:	27 97       	sbiw	r28, 0x07	; 7
    13e8:	0f b6       	in	r0, 0x3f	; 63
    13ea:	f8 94       	cli
    13ec:	de bf       	out	0x3e, r29	; 62
    13ee:	0f be       	out	0x3f, r0	; 63
    13f0:	cd bf       	out	0x3d, r28	; 61
    13f2:	9f 83       	std	Y+7, r25	; 0x07
    13f4:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    13f6:	8e 81       	ldd	r24, Y+6	; 0x06
    13f8:	9f 81       	ldd	r25, Y+7	; 0x07
    13fa:	9c 83       	std	Y+4, r25	; 0x04
    13fc:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    13fe:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    1400:	eb 81       	ldd	r30, Y+3	; 0x03
    1402:	fc 81       	ldd	r31, Y+4	; 0x04
    1404:	80 81       	ld	r24, Z
    1406:	91 81       	ldd	r25, Z+1	; 0x01
    1408:	9a 83       	std	Y+2, r25	; 0x02
    140a:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    140c:	89 81       	ldd	r24, Y+1	; 0x01
    140e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1410:	27 96       	adiw	r28, 0x07	; 7
    1412:	0f b6       	in	r0, 0x3f	; 63
    1414:	f8 94       	cli
    1416:	de bf       	out	0x3e, r29	; 62
    1418:	0f be       	out	0x3f, r0	; 63
    141a:	cd bf       	out	0x3d, r28	; 61
    141c:	cf 91       	pop	r28
    141e:	df 91       	pop	r29
    1420:	08 95       	ret

00001422 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    1422:	df 93       	push	r29
    1424:	cf 93       	push	r28
    1426:	cd b7       	in	r28, 0x3d	; 61
    1428:	de b7       	in	r29, 0x3e	; 62
    142a:	65 97       	sbiw	r28, 0x15	; 21
    142c:	0f b6       	in	r0, 0x3f	; 63
    142e:	f8 94       	cli
    1430:	de bf       	out	0x3e, r29	; 62
    1432:	0f be       	out	0x3f, r0	; 63
    1434:	cd bf       	out	0x3d, r28	; 61
    1436:	9b 8b       	std	Y+19, r25	; 0x13
    1438:	8a 8b       	std	Y+18, r24	; 0x12
    143a:	7d 8b       	std	Y+21, r23	; 0x15
    143c:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    143e:	19 86       	std	Y+9, r1	; 0x09
    1440:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1442:	8a 89       	ldd	r24, Y+18	; 0x12
    1444:	9b 89       	ldd	r25, Y+19	; 0x13
    1446:	9b 83       	std	Y+3, r25	; 0x03
    1448:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    144a:	19 82       	std	Y+1, r1	; 0x01

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    144c:	8a 81       	ldd	r24, Y+2	; 0x02
    144e:	9b 81       	ldd	r25, Y+3	; 0x03
    1450:	02 96       	adiw	r24, 0x02	; 2
    1452:	9b 87       	std	Y+11, r25	; 0x0b
    1454:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1456:	8a 85       	ldd	r24, Y+10	; 0x0a
    1458:	9b 85       	ldd	r25, Y+11	; 0x0b
    145a:	03 96       	adiw	r24, 0x03	; 3
    145c:	9d 87       	std	Y+13, r25	; 0x0d
    145e:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    1460:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    1464:	ea 85       	ldd	r30, Y+10	; 0x0a
    1466:	fb 85       	ldd	r31, Y+11	; 0x0b
    1468:	85 81       	ldd	r24, Z+5	; 0x05
    146a:	96 81       	ldd	r25, Z+6	; 0x06
    146c:	99 8b       	std	Y+17, r25	; 0x11
    146e:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    1470:	ea 81       	ldd	r30, Y+2	; 0x02
    1472:	fb 81       	ldd	r31, Y+3	; 0x03
    1474:	20 81       	ld	r18, Z
    1476:	31 81       	ldd	r19, Z+1	; 0x01
    1478:	8c 89       	ldd	r24, Y+20	; 0x14
    147a:	9d 89       	ldd	r25, Y+21	; 0x15
    147c:	82 2b       	or	r24, r18
    147e:	93 2b       	or	r25, r19
    1480:	ea 81       	ldd	r30, Y+2	; 0x02
    1482:	fb 81       	ldd	r31, Y+3	; 0x03
    1484:	91 83       	std	Z+1, r25	; 0x01
    1486:	80 83       	st	Z, r24
    1488:	59 c0       	rjmp	.+178    	; 0x153c <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    148a:	e8 89       	ldd	r30, Y+16	; 0x10
    148c:	f9 89       	ldd	r31, Y+17	; 0x11
    148e:	82 81       	ldd	r24, Z+2	; 0x02
    1490:	93 81       	ldd	r25, Z+3	; 0x03
    1492:	9f 87       	std	Y+15, r25	; 0x0f
    1494:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1496:	e8 89       	ldd	r30, Y+16	; 0x10
    1498:	f9 89       	ldd	r31, Y+17	; 0x11
    149a:	80 81       	ld	r24, Z
    149c:	91 81       	ldd	r25, Z+1	; 0x01
    149e:	9f 83       	std	Y+7, r25	; 0x07
    14a0:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    14a2:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    14a4:	8e 81       	ldd	r24, Y+6	; 0x06
    14a6:	9f 81       	ldd	r25, Y+7	; 0x07
    14a8:	80 70       	andi	r24, 0x00	; 0
    14aa:	9d 83       	std	Y+5, r25	; 0x05
    14ac:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    14ae:	8e 81       	ldd	r24, Y+6	; 0x06
    14b0:	9f 81       	ldd	r25, Y+7	; 0x07
    14b2:	90 70       	andi	r25, 0x00	; 0
    14b4:	9f 83       	std	Y+7, r25	; 0x07
    14b6:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    14b8:	8c 81       	ldd	r24, Y+4	; 0x04
    14ba:	9d 81       	ldd	r25, Y+5	; 0x05
    14bc:	80 70       	andi	r24, 0x00	; 0
    14be:	94 70       	andi	r25, 0x04	; 4
    14c0:	00 97       	sbiw	r24, 0x00	; 0
    14c2:	69 f4       	brne	.+26     	; 0x14de <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    14c4:	ea 81       	ldd	r30, Y+2	; 0x02
    14c6:	fb 81       	ldd	r31, Y+3	; 0x03
    14c8:	20 81       	ld	r18, Z
    14ca:	31 81       	ldd	r19, Z+1	; 0x01
    14cc:	8e 81       	ldd	r24, Y+6	; 0x06
    14ce:	9f 81       	ldd	r25, Y+7	; 0x07
    14d0:	82 23       	and	r24, r18
    14d2:	93 23       	and	r25, r19
    14d4:	00 97       	sbiw	r24, 0x00	; 0
    14d6:	91 f0       	breq	.+36     	; 0x14fc <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    14d8:	81 e0       	ldi	r24, 0x01	; 1
    14da:	89 83       	std	Y+1, r24	; 0x01
    14dc:	0f c0       	rjmp	.+30     	; 0x14fc <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    14de:	ea 81       	ldd	r30, Y+2	; 0x02
    14e0:	fb 81       	ldd	r31, Y+3	; 0x03
    14e2:	20 81       	ld	r18, Z
    14e4:	31 81       	ldd	r19, Z+1	; 0x01
    14e6:	8e 81       	ldd	r24, Y+6	; 0x06
    14e8:	9f 81       	ldd	r25, Y+7	; 0x07
    14ea:	28 23       	and	r18, r24
    14ec:	39 23       	and	r19, r25
    14ee:	8e 81       	ldd	r24, Y+6	; 0x06
    14f0:	9f 81       	ldd	r25, Y+7	; 0x07
    14f2:	28 17       	cp	r18, r24
    14f4:	39 07       	cpc	r19, r25
    14f6:	11 f4       	brne	.+4      	; 0x14fc <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    14f8:	81 e0       	ldi	r24, 0x01	; 1
    14fa:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    14fc:	89 81       	ldd	r24, Y+1	; 0x01
    14fe:	88 23       	and	r24, r24
    1500:	c9 f0       	breq	.+50     	; 0x1534 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1502:	8c 81       	ldd	r24, Y+4	; 0x04
    1504:	9d 81       	ldd	r25, Y+5	; 0x05
    1506:	80 70       	andi	r24, 0x00	; 0
    1508:	91 70       	andi	r25, 0x01	; 1
    150a:	00 97       	sbiw	r24, 0x00	; 0
    150c:	41 f0       	breq	.+16     	; 0x151e <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    150e:	88 85       	ldd	r24, Y+8	; 0x08
    1510:	99 85       	ldd	r25, Y+9	; 0x09
    1512:	2e 81       	ldd	r18, Y+6	; 0x06
    1514:	3f 81       	ldd	r19, Y+7	; 0x07
    1516:	82 2b       	or	r24, r18
    1518:	93 2b       	or	r25, r19
    151a:	99 87       	std	Y+9, r25	; 0x09
    151c:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    151e:	ea 81       	ldd	r30, Y+2	; 0x02
    1520:	fb 81       	ldd	r31, Y+3	; 0x03
    1522:	80 81       	ld	r24, Z
    1524:	91 81       	ldd	r25, Z+1	; 0x01
    1526:	9c 01       	movw	r18, r24
    1528:	32 60       	ori	r19, 0x02	; 2
    152a:	88 89       	ldd	r24, Y+16	; 0x10
    152c:	99 89       	ldd	r25, Y+17	; 0x11
    152e:	b9 01       	movw	r22, r18
    1530:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    1534:	8e 85       	ldd	r24, Y+14	; 0x0e
    1536:	9f 85       	ldd	r25, Y+15	; 0x0f
    1538:	99 8b       	std	Y+17, r25	; 0x11
    153a:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    153c:	28 89       	ldd	r18, Y+16	; 0x10
    153e:	39 89       	ldd	r19, Y+17	; 0x11
    1540:	8c 85       	ldd	r24, Y+12	; 0x0c
    1542:	9d 85       	ldd	r25, Y+13	; 0x0d
    1544:	28 17       	cp	r18, r24
    1546:	39 07       	cpc	r19, r25
    1548:	09 f0       	breq	.+2      	; 0x154c <xEventGroupSetBits+0x12a>
    154a:	9f cf       	rjmp	.-194    	; 0x148a <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    154c:	ea 81       	ldd	r30, Y+2	; 0x02
    154e:	fb 81       	ldd	r31, Y+3	; 0x03
    1550:	20 81       	ld	r18, Z
    1552:	31 81       	ldd	r19, Z+1	; 0x01
    1554:	88 85       	ldd	r24, Y+8	; 0x08
    1556:	99 85       	ldd	r25, Y+9	; 0x09
    1558:	80 95       	com	r24
    155a:	90 95       	com	r25
    155c:	82 23       	and	r24, r18
    155e:	93 23       	and	r25, r19
    1560:	ea 81       	ldd	r30, Y+2	; 0x02
    1562:	fb 81       	ldd	r31, Y+3	; 0x03
    1564:	91 83       	std	Z+1, r25	; 0x01
    1566:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    1568:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    156c:	ea 81       	ldd	r30, Y+2	; 0x02
    156e:	fb 81       	ldd	r31, Y+3	; 0x03
    1570:	80 81       	ld	r24, Z
    1572:	91 81       	ldd	r25, Z+1	; 0x01
}
    1574:	65 96       	adiw	r28, 0x15	; 21
    1576:	0f b6       	in	r0, 0x3f	; 63
    1578:	f8 94       	cli
    157a:	de bf       	out	0x3e, r29	; 62
    157c:	0f be       	out	0x3f, r0	; 63
    157e:	cd bf       	out	0x3d, r28	; 61
    1580:	cf 91       	pop	r28
    1582:	df 91       	pop	r29
    1584:	08 95       	ret

00001586 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1586:	df 93       	push	r29
    1588:	cf 93       	push	r28
    158a:	00 d0       	rcall	.+0      	; 0x158c <vEventGroupDelete+0x6>
    158c:	00 d0       	rcall	.+0      	; 0x158e <vEventGroupDelete+0x8>
    158e:	00 d0       	rcall	.+0      	; 0x1590 <vEventGroupDelete+0xa>
    1590:	cd b7       	in	r28, 0x3d	; 61
    1592:	de b7       	in	r29, 0x3e	; 62
    1594:	9e 83       	std	Y+6, r25	; 0x06
    1596:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1598:	8d 81       	ldd	r24, Y+5	; 0x05
    159a:	9e 81       	ldd	r25, Y+6	; 0x06
    159c:	9c 83       	std	Y+4, r25	; 0x04
    159e:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    15a0:	8b 81       	ldd	r24, Y+3	; 0x03
    15a2:	9c 81       	ldd	r25, Y+4	; 0x04
    15a4:	02 96       	adiw	r24, 0x02	; 2
    15a6:	9a 83       	std	Y+2, r25	; 0x02
    15a8:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    15aa:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vTaskSuspendAll>
    15ae:	08 c0       	rjmp	.+16     	; 0x15c0 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    15b0:	e9 81       	ldd	r30, Y+1	; 0x01
    15b2:	fa 81       	ldd	r31, Y+2	; 0x02
    15b4:	85 81       	ldd	r24, Z+5	; 0x05
    15b6:	96 81       	ldd	r25, Z+6	; 0x06
    15b8:	60 e0       	ldi	r22, 0x00	; 0
    15ba:	72 e0       	ldi	r23, 0x02	; 2
    15bc:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    15c0:	e9 81       	ldd	r30, Y+1	; 0x01
    15c2:	fa 81       	ldd	r31, Y+2	; 0x02
    15c4:	80 81       	ld	r24, Z
    15c6:	88 23       	and	r24, r24
    15c8:	99 f7       	brne	.-26     	; 0x15b0 <vEventGroupDelete+0x2a>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    15ca:	8b 81       	ldd	r24, Y+3	; 0x03
    15cc:	9c 81       	ldd	r25, Y+4	; 0x04
    15ce:	0e 94 b6 0b 	call	0x176c	; 0x176c <vPortFree>
	}
	( void ) xTaskResumeAll();
    15d2:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>
}
    15d6:	26 96       	adiw	r28, 0x06	; 6
    15d8:	0f b6       	in	r0, 0x3f	; 63
    15da:	f8 94       	cli
    15dc:	de bf       	out	0x3e, r29	; 62
    15de:	0f be       	out	0x3f, r0	; 63
    15e0:	cd bf       	out	0x3d, r28	; 61
    15e2:	cf 91       	pop	r28
    15e4:	df 91       	pop	r29
    15e6:	08 95       	ret

000015e8 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    15e8:	df 93       	push	r29
    15ea:	cf 93       	push	r28
    15ec:	00 d0       	rcall	.+0      	; 0x15ee <vEventGroupSetBitsCallback+0x6>
    15ee:	00 d0       	rcall	.+0      	; 0x15f0 <vEventGroupSetBitsCallback+0x8>
    15f0:	00 d0       	rcall	.+0      	; 0x15f2 <vEventGroupSetBitsCallback+0xa>
    15f2:	cd b7       	in	r28, 0x3d	; 61
    15f4:	de b7       	in	r29, 0x3e	; 62
    15f6:	9a 83       	std	Y+2, r25	; 0x02
    15f8:	89 83       	std	Y+1, r24	; 0x01
    15fa:	4b 83       	std	Y+3, r20	; 0x03
    15fc:	5c 83       	std	Y+4, r21	; 0x04
    15fe:	6d 83       	std	Y+5, r22	; 0x05
    1600:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    1602:	2b 81       	ldd	r18, Y+3	; 0x03
    1604:	3c 81       	ldd	r19, Y+4	; 0x04
    1606:	89 81       	ldd	r24, Y+1	; 0x01
    1608:	9a 81       	ldd	r25, Y+2	; 0x02
    160a:	b9 01       	movw	r22, r18
    160c:	0e 94 11 0a 	call	0x1422	; 0x1422 <xEventGroupSetBits>
}
    1610:	26 96       	adiw	r28, 0x06	; 6
    1612:	0f b6       	in	r0, 0x3f	; 63
    1614:	f8 94       	cli
    1616:	de bf       	out	0x3e, r29	; 62
    1618:	0f be       	out	0x3f, r0	; 63
    161a:	cd bf       	out	0x3d, r28	; 61
    161c:	cf 91       	pop	r28
    161e:	df 91       	pop	r29
    1620:	08 95       	ret

00001622 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    1622:	df 93       	push	r29
    1624:	cf 93       	push	r28
    1626:	00 d0       	rcall	.+0      	; 0x1628 <vEventGroupClearBitsCallback+0x6>
    1628:	00 d0       	rcall	.+0      	; 0x162a <vEventGroupClearBitsCallback+0x8>
    162a:	00 d0       	rcall	.+0      	; 0x162c <vEventGroupClearBitsCallback+0xa>
    162c:	cd b7       	in	r28, 0x3d	; 61
    162e:	de b7       	in	r29, 0x3e	; 62
    1630:	9a 83       	std	Y+2, r25	; 0x02
    1632:	89 83       	std	Y+1, r24	; 0x01
    1634:	4b 83       	std	Y+3, r20	; 0x03
    1636:	5c 83       	std	Y+4, r21	; 0x04
    1638:	6d 83       	std	Y+5, r22	; 0x05
    163a:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    163c:	2b 81       	ldd	r18, Y+3	; 0x03
    163e:	3c 81       	ldd	r19, Y+4	; 0x04
    1640:	89 81       	ldd	r24, Y+1	; 0x01
    1642:	9a 81       	ldd	r25, Y+2	; 0x02
    1644:	b9 01       	movw	r22, r18
    1646:	0e 94 b9 09 	call	0x1372	; 0x1372 <xEventGroupClearBits>
}
    164a:	26 96       	adiw	r28, 0x06	; 6
    164c:	0f b6       	in	r0, 0x3f	; 63
    164e:	f8 94       	cli
    1650:	de bf       	out	0x3e, r29	; 62
    1652:	0f be       	out	0x3f, r0	; 63
    1654:	cd bf       	out	0x3d, r28	; 61
    1656:	cf 91       	pop	r28
    1658:	df 91       	pop	r29
    165a:	08 95       	ret

0000165c <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    165c:	df 93       	push	r29
    165e:	cf 93       	push	r28
    1660:	00 d0       	rcall	.+0      	; 0x1662 <prvTestWaitCondition+0x6>
    1662:	00 d0       	rcall	.+0      	; 0x1664 <prvTestWaitCondition+0x8>
    1664:	00 d0       	rcall	.+0      	; 0x1666 <prvTestWaitCondition+0xa>
    1666:	cd b7       	in	r28, 0x3d	; 61
    1668:	de b7       	in	r29, 0x3e	; 62
    166a:	9b 83       	std	Y+3, r25	; 0x03
    166c:	8a 83       	std	Y+2, r24	; 0x02
    166e:	7d 83       	std	Y+5, r23	; 0x05
    1670:	6c 83       	std	Y+4, r22	; 0x04
    1672:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    1674:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    1676:	8e 81       	ldd	r24, Y+6	; 0x06
    1678:	88 23       	and	r24, r24
    167a:	59 f4       	brne	.+22     	; 0x1692 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    167c:	8a 81       	ldd	r24, Y+2	; 0x02
    167e:	9b 81       	ldd	r25, Y+3	; 0x03
    1680:	2c 81       	ldd	r18, Y+4	; 0x04
    1682:	3d 81       	ldd	r19, Y+5	; 0x05
    1684:	82 23       	and	r24, r18
    1686:	93 23       	and	r25, r19
    1688:	00 97       	sbiw	r24, 0x00	; 0
    168a:	81 f0       	breq	.+32     	; 0x16ac <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    168c:	81 e0       	ldi	r24, 0x01	; 1
    168e:	89 83       	std	Y+1, r24	; 0x01
    1690:	0d c0       	rjmp	.+26     	; 0x16ac <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1692:	2a 81       	ldd	r18, Y+2	; 0x02
    1694:	3b 81       	ldd	r19, Y+3	; 0x03
    1696:	8c 81       	ldd	r24, Y+4	; 0x04
    1698:	9d 81       	ldd	r25, Y+5	; 0x05
    169a:	28 23       	and	r18, r24
    169c:	39 23       	and	r19, r25
    169e:	8c 81       	ldd	r24, Y+4	; 0x04
    16a0:	9d 81       	ldd	r25, Y+5	; 0x05
    16a2:	28 17       	cp	r18, r24
    16a4:	39 07       	cpc	r19, r25
    16a6:	11 f4       	brne	.+4      	; 0x16ac <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    16a8:	81 e0       	ldi	r24, 0x01	; 1
    16aa:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    16ac:	89 81       	ldd	r24, Y+1	; 0x01
}
    16ae:	26 96       	adiw	r28, 0x06	; 6
    16b0:	0f b6       	in	r0, 0x3f	; 63
    16b2:	f8 94       	cli
    16b4:	de bf       	out	0x3e, r29	; 62
    16b6:	0f be       	out	0x3f, r0	; 63
    16b8:	cd bf       	out	0x3d, r28	; 61
    16ba:	cf 91       	pop	r28
    16bc:	df 91       	pop	r29
    16be:	08 95       	ret

000016c0 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    16c0:	df 93       	push	r29
    16c2:	cf 93       	push	r28
    16c4:	00 d0       	rcall	.+0      	; 0x16c6 <pvPortMalloc+0x6>
    16c6:	00 d0       	rcall	.+0      	; 0x16c8 <pvPortMalloc+0x8>
    16c8:	cd b7       	in	r28, 0x3d	; 61
    16ca:	de b7       	in	r29, 0x3e	; 62
    16cc:	9c 83       	std	Y+4, r25	; 0x04
    16ce:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    16d0:	1a 82       	std	Y+2, r1	; 0x02
    16d2:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    16d4:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    16d8:	80 91 fc 00 	lds	r24, 0x00FC
    16dc:	90 91 fd 00 	lds	r25, 0x00FD
    16e0:	00 97       	sbiw	r24, 0x00	; 0
    16e2:	31 f4       	brne	.+12     	; 0x16f0 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    16e4:	8f ef       	ldi	r24, 0xFF	; 255
    16e6:	90 e0       	ldi	r25, 0x00	; 0
    16e8:	90 93 fd 00 	sts	0x00FD, r25
    16ec:	80 93 fc 00 	sts	0x00FC, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    16f0:	80 91 fa 00 	lds	r24, 0x00FA
    16f4:	90 91 fb 00 	lds	r25, 0x00FB
    16f8:	2b 81       	ldd	r18, Y+3	; 0x03
    16fa:	3c 81       	ldd	r19, Y+4	; 0x04
    16fc:	82 0f       	add	r24, r18
    16fe:	93 1f       	adc	r25, r19
    1700:	25 e0       	ldi	r18, 0x05	; 5
    1702:	8b 3d       	cpi	r24, 0xDB	; 219
    1704:	92 07       	cpc	r25, r18
    1706:	38 f5       	brcc	.+78     	; 0x1756 <pvPortMalloc+0x96>
    1708:	20 91 fa 00 	lds	r18, 0x00FA
    170c:	30 91 fb 00 	lds	r19, 0x00FB
    1710:	8b 81       	ldd	r24, Y+3	; 0x03
    1712:	9c 81       	ldd	r25, Y+4	; 0x04
    1714:	28 0f       	add	r18, r24
    1716:	39 1f       	adc	r19, r25
    1718:	80 91 fa 00 	lds	r24, 0x00FA
    171c:	90 91 fb 00 	lds	r25, 0x00FB
    1720:	82 17       	cp	r24, r18
    1722:	93 07       	cpc	r25, r19
    1724:	c0 f4       	brcc	.+48     	; 0x1756 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1726:	20 91 fc 00 	lds	r18, 0x00FC
    172a:	30 91 fd 00 	lds	r19, 0x00FD
    172e:	80 91 fa 00 	lds	r24, 0x00FA
    1732:	90 91 fb 00 	lds	r25, 0x00FB
    1736:	82 0f       	add	r24, r18
    1738:	93 1f       	adc	r25, r19
    173a:	9a 83       	std	Y+2, r25	; 0x02
    173c:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    173e:	20 91 fa 00 	lds	r18, 0x00FA
    1742:	30 91 fb 00 	lds	r19, 0x00FB
    1746:	8b 81       	ldd	r24, Y+3	; 0x03
    1748:	9c 81       	ldd	r25, Y+4	; 0x04
    174a:	82 0f       	add	r24, r18
    174c:	93 1f       	adc	r25, r19
    174e:	90 93 fb 00 	sts	0x00FB, r25
    1752:	80 93 fa 00 	sts	0x00FA, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1756:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    175a:	89 81       	ldd	r24, Y+1	; 0x01
    175c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    175e:	0f 90       	pop	r0
    1760:	0f 90       	pop	r0
    1762:	0f 90       	pop	r0
    1764:	0f 90       	pop	r0
    1766:	cf 91       	pop	r28
    1768:	df 91       	pop	r29
    176a:	08 95       	ret

0000176c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    176c:	df 93       	push	r29
    176e:	cf 93       	push	r28
    1770:	00 d0       	rcall	.+0      	; 0x1772 <vPortFree+0x6>
    1772:	cd b7       	in	r28, 0x3d	; 61
    1774:	de b7       	in	r29, 0x3e	; 62
    1776:	9a 83       	std	Y+2, r25	; 0x02
    1778:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    177a:	0f 90       	pop	r0
    177c:	0f 90       	pop	r0
    177e:	cf 91       	pop	r28
    1780:	df 91       	pop	r29
    1782:	08 95       	ret

00001784 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1784:	df 93       	push	r29
    1786:	cf 93       	push	r28
    1788:	cd b7       	in	r28, 0x3d	; 61
    178a:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    178c:	10 92 fb 00 	sts	0x00FB, r1
    1790:	10 92 fa 00 	sts	0x00FA, r1
}
    1794:	cf 91       	pop	r28
    1796:	df 91       	pop	r29
    1798:	08 95       	ret

0000179a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    179a:	df 93       	push	r29
    179c:	cf 93       	push	r28
    179e:	cd b7       	in	r28, 0x3d	; 61
    17a0:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    17a2:	20 91 fa 00 	lds	r18, 0x00FA
    17a6:	30 91 fb 00 	lds	r19, 0x00FB
    17aa:	8b ed       	ldi	r24, 0xDB	; 219
    17ac:	95 e0       	ldi	r25, 0x05	; 5
    17ae:	82 1b       	sub	r24, r18
    17b0:	93 0b       	sbc	r25, r19
}
    17b2:	cf 91       	pop	r28
    17b4:	df 91       	pop	r29
    17b6:	08 95       	ret

000017b8 <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    17b8:	af 92       	push	r10
    17ba:	bf 92       	push	r11
    17bc:	cf 92       	push	r12
    17be:	df 92       	push	r13
    17c0:	ef 92       	push	r14
    17c2:	ff 92       	push	r15
    17c4:	0f 93       	push	r16
    17c6:	df 93       	push	r29
    17c8:	cf 93       	push	r28
    17ca:	00 d0       	rcall	.+0      	; 0x17cc <vStartIntegerMathTasks+0x14>
    17cc:	0f 92       	push	r0
    17ce:	cd b7       	in	r28, 0x3d	; 61
    17d0:	de b7       	in	r29, 0x3e	; 62
    17d2:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    17d4:	1a 82       	std	Y+2, r1	; 0x02
    17d6:	19 82       	std	Y+1, r1	; 0x01
    17d8:	1b c0       	rjmp	.+54     	; 0x1810 <vStartIntegerMathTasks+0x58>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    17da:	89 81       	ldd	r24, Y+1	; 0x01
    17dc:	9a 81       	ldd	r25, Y+2	; 0x02
    17de:	fc 01       	movw	r30, r24
    17e0:	e6 52       	subi	r30, 0x26	; 38
    17e2:	f9 4f       	sbci	r31, 0xF9	; 249
    17e4:	8a e1       	ldi	r24, 0x1A	; 26
    17e6:	9c e0       	ldi	r25, 0x0C	; 12
    17e8:	20 e7       	ldi	r18, 0x70	; 112
    17ea:	30 e0       	ldi	r19, 0x00	; 0
    17ec:	b9 01       	movw	r22, r18
    17ee:	45 e5       	ldi	r20, 0x55	; 85
    17f0:	50 e0       	ldi	r21, 0x00	; 0
    17f2:	9f 01       	movw	r18, r30
    17f4:	0b 81       	ldd	r16, Y+3	; 0x03
    17f6:	ee 24       	eor	r14, r14
    17f8:	ff 24       	eor	r15, r15
    17fa:	cc 24       	eor	r12, r12
    17fc:	dd 24       	eor	r13, r13
    17fe:	aa 24       	eor	r10, r10
    1800:	bb 24       	eor	r11, r11
    1802:	0e 94 64 18 	call	0x30c8	; 0x30c8 <xTaskGenericCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1806:	89 81       	ldd	r24, Y+1	; 0x01
    1808:	9a 81       	ldd	r25, Y+2	; 0x02
    180a:	01 96       	adiw	r24, 0x01	; 1
    180c:	9a 83       	std	Y+2, r25	; 0x02
    180e:	89 83       	std	Y+1, r24	; 0x01
    1810:	89 81       	ldd	r24, Y+1	; 0x01
    1812:	9a 81       	ldd	r25, Y+2	; 0x02
    1814:	18 16       	cp	r1, r24
    1816:	19 06       	cpc	r1, r25
    1818:	04 f7       	brge	.-64     	; 0x17da <vStartIntegerMathTasks+0x22>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
    181a:	0f 90       	pop	r0
    181c:	0f 90       	pop	r0
    181e:	0f 90       	pop	r0
    1820:	cf 91       	pop	r28
    1822:	df 91       	pop	r29
    1824:	0f 91       	pop	r16
    1826:	ff 90       	pop	r15
    1828:	ef 90       	pop	r14
    182a:	df 90       	pop	r13
    182c:	cf 90       	pop	r12
    182e:	bf 90       	pop	r11
    1830:	af 90       	pop	r10
    1832:	08 95       	ret

00001834 <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    1834:	df 93       	push	r29
    1836:	cf 93       	push	r28
    1838:	cd b7       	in	r28, 0x3d	; 61
    183a:	de b7       	in	r29, 0x3e	; 62
    183c:	2a 97       	sbiw	r28, 0x0a	; 10
    183e:	0f b6       	in	r0, 0x3f	; 63
    1840:	f8 94       	cli
    1842:	de bf       	out	0x3e, r29	; 62
    1844:	0f be       	out	0x3f, r0	; 63
    1846:	cd bf       	out	0x3d, r28	; 61
    1848:	9a 87       	std	Y+10, r25	; 0x0a
    184a:	89 87       	std	Y+9, r24	; 0x09
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    184c:	1c 82       	std	Y+4, r1	; 0x04
    184e:	1b 82       	std	Y+3, r1	; 0x03
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    1850:	89 85       	ldd	r24, Y+9	; 0x09
    1852:	9a 85       	ldd	r25, Y+10	; 0x0a
    1854:	9a 83       	std	Y+2, r25	; 0x02
    1856:	89 83       	std	Y+1, r24	; 0x01
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    1858:	8b e7       	ldi	r24, 0x7B	; 123
    185a:	90 e0       	ldi	r25, 0x00	; 0
    185c:	a0 e0       	ldi	r26, 0x00	; 0
    185e:	b0 e0       	ldi	r27, 0x00	; 0
    1860:	8d 83       	std	Y+5, r24	; 0x05
    1862:	9e 83       	std	Y+6, r25	; 0x06
    1864:	af 83       	std	Y+7, r26	; 0x07
    1866:	b8 87       	std	Y+8, r27	; 0x08
		lValue += intgCONST2;
    1868:	8d 81       	ldd	r24, Y+5	; 0x05
    186a:	9e 81       	ldd	r25, Y+6	; 0x06
    186c:	af 81       	ldd	r26, Y+7	; 0x07
    186e:	b8 85       	ldd	r27, Y+8	; 0x08
    1870:	89 5b       	subi	r24, 0xB9	; 185
    1872:	9b 46       	sbci	r25, 0x6B	; 107
    1874:	ac 4f       	sbci	r26, 0xFC	; 252
    1876:	bf 4f       	sbci	r27, 0xFF	; 255
    1878:	8d 83       	std	Y+5, r24	; 0x05
    187a:	9e 83       	std	Y+6, r25	; 0x06
    187c:	af 83       	std	Y+7, r26	; 0x07
    187e:	b8 87       	std	Y+8, r27	; 0x08
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    1880:	8d 81       	ldd	r24, Y+5	; 0x05
    1882:	9e 81       	ldd	r25, Y+6	; 0x06
    1884:	af 81       	ldd	r26, Y+7	; 0x07
    1886:	b8 85       	ldd	r27, Y+8	; 0x08
    1888:	2d ef       	ldi	r18, 0xFD	; 253
    188a:	3f ef       	ldi	r19, 0xFF	; 255
    188c:	4f ef       	ldi	r20, 0xFF	; 255
    188e:	5f ef       	ldi	r21, 0xFF	; 255
    1890:	bc 01       	movw	r22, r24
    1892:	cd 01       	movw	r24, r26
    1894:	0e 94 7d 23 	call	0x46fa	; 0x46fa <__mulsi3>
    1898:	dc 01       	movw	r26, r24
    189a:	cb 01       	movw	r24, r22
    189c:	8d 83       	std	Y+5, r24	; 0x05
    189e:	9e 83       	std	Y+6, r25	; 0x06
    18a0:	af 83       	std	Y+7, r26	; 0x07
    18a2:	b8 87       	std	Y+8, r27	; 0x08
		lValue /= intgCONST4;
    18a4:	8d 81       	ldd	r24, Y+5	; 0x05
    18a6:	9e 81       	ldd	r25, Y+6	; 0x06
    18a8:	af 81       	ldd	r26, Y+7	; 0x07
    18aa:	b8 85       	ldd	r27, Y+8	; 0x08
    18ac:	27 e0       	ldi	r18, 0x07	; 7
    18ae:	30 e0       	ldi	r19, 0x00	; 0
    18b0:	40 e0       	ldi	r20, 0x00	; 0
    18b2:	50 e0       	ldi	r21, 0x00	; 0
    18b4:	bc 01       	movw	r22, r24
    18b6:	cd 01       	movw	r24, r26
    18b8:	0e 94 be 23 	call	0x477c	; 0x477c <__divmodsi4>
    18bc:	da 01       	movw	r26, r20
    18be:	c9 01       	movw	r24, r18
    18c0:	8d 83       	std	Y+5, r24	; 0x05
    18c2:	9e 83       	std	Y+6, r25	; 0x06
    18c4:	af 83       	std	Y+7, r26	; 0x07
    18c6:	b8 87       	std	Y+8, r27	; 0x08

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    18c8:	8d 81       	ldd	r24, Y+5	; 0x05
    18ca:	9e 81       	ldd	r25, Y+6	; 0x06
    18cc:	af 81       	ldd	r26, Y+7	; 0x07
    18ce:	b8 85       	ldd	r27, Y+8	; 0x08
    18d0:	8b 31       	cpi	r24, 0x1B	; 27
    18d2:	27 e7       	ldi	r18, 0x77	; 119
    18d4:	92 07       	cpc	r25, r18
    18d6:	2e ef       	ldi	r18, 0xFE	; 254
    18d8:	a2 07       	cpc	r26, r18
    18da:	2f ef       	ldi	r18, 0xFF	; 255
    18dc:	b2 07       	cpc	r27, r18
    18de:	21 f0       	breq	.+8      	; 0x18e8 <vCompeteingIntMathTask+0xb4>
		{
			sError = pdTRUE;
    18e0:	81 e0       	ldi	r24, 0x01	; 1
    18e2:	90 e0       	ldi	r25, 0x00	; 0
    18e4:	9c 83       	std	Y+4, r25	; 0x04
    18e6:	8b 83       	std	Y+3, r24	; 0x03
		}

		if( sError == pdFALSE )
    18e8:	8b 81       	ldd	r24, Y+3	; 0x03
    18ea:	9c 81       	ldd	r25, Y+4	; 0x04
    18ec:	00 97       	sbiw	r24, 0x00	; 0
    18ee:	09 f0       	breq	.+2      	; 0x18f2 <vCompeteingIntMathTask+0xbe>
    18f0:	b3 cf       	rjmp	.-154    	; 0x1858 <vCompeteingIntMathTask+0x24>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    18f2:	0f b6       	in	r0, 0x3f	; 63
    18f4:	f8 94       	cli
    18f6:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    18f8:	e9 81       	ldd	r30, Y+1	; 0x01
    18fa:	fa 81       	ldd	r31, Y+2	; 0x02
    18fc:	81 e0       	ldi	r24, 0x01	; 1
    18fe:	80 83       	st	Z, r24
			portEXIT_CRITICAL();
    1900:	0f 90       	pop	r0
    1902:	0f be       	out	0x3f, r0	; 63
    1904:	a9 cf       	rjmp	.-174    	; 0x1858 <vCompeteingIntMathTask+0x24>

00001906 <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
    1906:	df 93       	push	r29
    1908:	cf 93       	push	r28
    190a:	00 d0       	rcall	.+0      	; 0x190c <xAreIntegerMathsTaskStillRunning+0x6>
    190c:	0f 92       	push	r0
    190e:	cd b7       	in	r28, 0x3d	; 61
    1910:	de b7       	in	r29, 0x3e	; 62
BaseType_t xReturn = pdTRUE;
    1912:	81 e0       	ldi	r24, 0x01	; 1
    1914:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1916:	1a 82       	std	Y+2, r1	; 0x02
    1918:	19 82       	std	Y+1, r1	; 0x01
    191a:	14 c0       	rjmp	.+40     	; 0x1944 <xAreIntegerMathsTaskStillRunning+0x3e>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    191c:	89 81       	ldd	r24, Y+1	; 0x01
    191e:	9a 81       	ldd	r25, Y+2	; 0x02
    1920:	fc 01       	movw	r30, r24
    1922:	e6 52       	subi	r30, 0x26	; 38
    1924:	f9 4f       	sbci	r31, 0xF9	; 249
    1926:	80 81       	ld	r24, Z
    1928:	88 23       	and	r24, r24
    192a:	09 f4       	brne	.+2      	; 0x192e <xAreIntegerMathsTaskStillRunning+0x28>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    192c:	1b 82       	std	Y+3, r1	; 0x03
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    192e:	89 81       	ldd	r24, Y+1	; 0x01
    1930:	9a 81       	ldd	r25, Y+2	; 0x02
    1932:	fc 01       	movw	r30, r24
    1934:	e6 52       	subi	r30, 0x26	; 38
    1936:	f9 4f       	sbci	r31, 0xF9	; 249
    1938:	10 82       	st	Z, r1
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    193a:	89 81       	ldd	r24, Y+1	; 0x01
    193c:	9a 81       	ldd	r25, Y+2	; 0x02
    193e:	01 96       	adiw	r24, 0x01	; 1
    1940:	9a 83       	std	Y+2, r25	; 0x02
    1942:	89 83       	std	Y+1, r24	; 0x01
    1944:	89 81       	ldd	r24, Y+1	; 0x01
    1946:	9a 81       	ldd	r25, Y+2	; 0x02
    1948:	18 16       	cp	r1, r24
    194a:	19 06       	cpc	r1, r25
    194c:	3c f7       	brge	.-50     	; 0x191c <xAreIntegerMathsTaskStillRunning+0x16>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    194e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1950:	0f 90       	pop	r0
    1952:	0f 90       	pop	r0
    1954:	0f 90       	pop	r0
    1956:	cf 91       	pop	r28
    1958:	df 91       	pop	r29
    195a:	08 95       	ret

0000195c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    195c:	df 93       	push	r29
    195e:	cf 93       	push	r28
    1960:	00 d0       	rcall	.+0      	; 0x1962 <vListInitialise+0x6>
    1962:	cd b7       	in	r28, 0x3d	; 61
    1964:	de b7       	in	r29, 0x3e	; 62
    1966:	9a 83       	std	Y+2, r25	; 0x02
    1968:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    196a:	89 81       	ldd	r24, Y+1	; 0x01
    196c:	9a 81       	ldd	r25, Y+2	; 0x02
    196e:	03 96       	adiw	r24, 0x03	; 3
    1970:	e9 81       	ldd	r30, Y+1	; 0x01
    1972:	fa 81       	ldd	r31, Y+2	; 0x02
    1974:	92 83       	std	Z+2, r25	; 0x02
    1976:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1978:	e9 81       	ldd	r30, Y+1	; 0x01
    197a:	fa 81       	ldd	r31, Y+2	; 0x02
    197c:	8f ef       	ldi	r24, 0xFF	; 255
    197e:	9f ef       	ldi	r25, 0xFF	; 255
    1980:	94 83       	std	Z+4, r25	; 0x04
    1982:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1984:	89 81       	ldd	r24, Y+1	; 0x01
    1986:	9a 81       	ldd	r25, Y+2	; 0x02
    1988:	03 96       	adiw	r24, 0x03	; 3
    198a:	e9 81       	ldd	r30, Y+1	; 0x01
    198c:	fa 81       	ldd	r31, Y+2	; 0x02
    198e:	96 83       	std	Z+6, r25	; 0x06
    1990:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1992:	89 81       	ldd	r24, Y+1	; 0x01
    1994:	9a 81       	ldd	r25, Y+2	; 0x02
    1996:	03 96       	adiw	r24, 0x03	; 3
    1998:	e9 81       	ldd	r30, Y+1	; 0x01
    199a:	fa 81       	ldd	r31, Y+2	; 0x02
    199c:	90 87       	std	Z+8, r25	; 0x08
    199e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    19a0:	e9 81       	ldd	r30, Y+1	; 0x01
    19a2:	fa 81       	ldd	r31, Y+2	; 0x02
    19a4:	10 82       	st	Z, r1
}
    19a6:	0f 90       	pop	r0
    19a8:	0f 90       	pop	r0
    19aa:	cf 91       	pop	r28
    19ac:	df 91       	pop	r29
    19ae:	08 95       	ret

000019b0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    19b0:	df 93       	push	r29
    19b2:	cf 93       	push	r28
    19b4:	00 d0       	rcall	.+0      	; 0x19b6 <vListInitialiseItem+0x6>
    19b6:	cd b7       	in	r28, 0x3d	; 61
    19b8:	de b7       	in	r29, 0x3e	; 62
    19ba:	9a 83       	std	Y+2, r25	; 0x02
    19bc:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    19be:	e9 81       	ldd	r30, Y+1	; 0x01
    19c0:	fa 81       	ldd	r31, Y+2	; 0x02
    19c2:	11 86       	std	Z+9, r1	; 0x09
    19c4:	10 86       	std	Z+8, r1	; 0x08
}
    19c6:	0f 90       	pop	r0
    19c8:	0f 90       	pop	r0
    19ca:	cf 91       	pop	r28
    19cc:	df 91       	pop	r29
    19ce:	08 95       	ret

000019d0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    19d0:	df 93       	push	r29
    19d2:	cf 93       	push	r28
    19d4:	00 d0       	rcall	.+0      	; 0x19d6 <vListInsertEnd+0x6>
    19d6:	00 d0       	rcall	.+0      	; 0x19d8 <vListInsertEnd+0x8>
    19d8:	00 d0       	rcall	.+0      	; 0x19da <vListInsertEnd+0xa>
    19da:	cd b7       	in	r28, 0x3d	; 61
    19dc:	de b7       	in	r29, 0x3e	; 62
    19de:	9c 83       	std	Y+4, r25	; 0x04
    19e0:	8b 83       	std	Y+3, r24	; 0x03
    19e2:	7e 83       	std	Y+6, r23	; 0x06
    19e4:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    19e6:	eb 81       	ldd	r30, Y+3	; 0x03
    19e8:	fc 81       	ldd	r31, Y+4	; 0x04
    19ea:	81 81       	ldd	r24, Z+1	; 0x01
    19ec:	92 81       	ldd	r25, Z+2	; 0x02
    19ee:	9a 83       	std	Y+2, r25	; 0x02
    19f0:	89 83       	std	Y+1, r24	; 0x01

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    19f2:	ed 81       	ldd	r30, Y+5	; 0x05
    19f4:	fe 81       	ldd	r31, Y+6	; 0x06
    19f6:	89 81       	ldd	r24, Y+1	; 0x01
    19f8:	9a 81       	ldd	r25, Y+2	; 0x02
    19fa:	93 83       	std	Z+3, r25	; 0x03
    19fc:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    19fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1a00:	fa 81       	ldd	r31, Y+2	; 0x02
    1a02:	84 81       	ldd	r24, Z+4	; 0x04
    1a04:	95 81       	ldd	r25, Z+5	; 0x05
    1a06:	ed 81       	ldd	r30, Y+5	; 0x05
    1a08:	fe 81       	ldd	r31, Y+6	; 0x06
    1a0a:	95 83       	std	Z+5, r25	; 0x05
    1a0c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1a0e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a10:	fa 81       	ldd	r31, Y+2	; 0x02
    1a12:	04 80       	ldd	r0, Z+4	; 0x04
    1a14:	f5 81       	ldd	r31, Z+5	; 0x05
    1a16:	e0 2d       	mov	r30, r0
    1a18:	8d 81       	ldd	r24, Y+5	; 0x05
    1a1a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a1c:	93 83       	std	Z+3, r25	; 0x03
    1a1e:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1a20:	e9 81       	ldd	r30, Y+1	; 0x01
    1a22:	fa 81       	ldd	r31, Y+2	; 0x02
    1a24:	8d 81       	ldd	r24, Y+5	; 0x05
    1a26:	9e 81       	ldd	r25, Y+6	; 0x06
    1a28:	95 83       	std	Z+5, r25	; 0x05
    1a2a:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1a2c:	ed 81       	ldd	r30, Y+5	; 0x05
    1a2e:	fe 81       	ldd	r31, Y+6	; 0x06
    1a30:	8b 81       	ldd	r24, Y+3	; 0x03
    1a32:	9c 81       	ldd	r25, Y+4	; 0x04
    1a34:	91 87       	std	Z+9, r25	; 0x09
    1a36:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1a38:	eb 81       	ldd	r30, Y+3	; 0x03
    1a3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a3c:	80 81       	ld	r24, Z
    1a3e:	8f 5f       	subi	r24, 0xFF	; 255
    1a40:	eb 81       	ldd	r30, Y+3	; 0x03
    1a42:	fc 81       	ldd	r31, Y+4	; 0x04
    1a44:	80 83       	st	Z, r24
}
    1a46:	26 96       	adiw	r28, 0x06	; 6
    1a48:	0f b6       	in	r0, 0x3f	; 63
    1a4a:	f8 94       	cli
    1a4c:	de bf       	out	0x3e, r29	; 62
    1a4e:	0f be       	out	0x3f, r0	; 63
    1a50:	cd bf       	out	0x3d, r28	; 61
    1a52:	cf 91       	pop	r28
    1a54:	df 91       	pop	r29
    1a56:	08 95       	ret

00001a58 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1a58:	df 93       	push	r29
    1a5a:	cf 93       	push	r28
    1a5c:	cd b7       	in	r28, 0x3d	; 61
    1a5e:	de b7       	in	r29, 0x3e	; 62
    1a60:	28 97       	sbiw	r28, 0x08	; 8
    1a62:	0f b6       	in	r0, 0x3f	; 63
    1a64:	f8 94       	cli
    1a66:	de bf       	out	0x3e, r29	; 62
    1a68:	0f be       	out	0x3f, r0	; 63
    1a6a:	cd bf       	out	0x3d, r28	; 61
    1a6c:	9e 83       	std	Y+6, r25	; 0x06
    1a6e:	8d 83       	std	Y+5, r24	; 0x05
    1a70:	78 87       	std	Y+8, r23	; 0x08
    1a72:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1a74:	ef 81       	ldd	r30, Y+7	; 0x07
    1a76:	f8 85       	ldd	r31, Y+8	; 0x08
    1a78:	80 81       	ld	r24, Z
    1a7a:	91 81       	ldd	r25, Z+1	; 0x01
    1a7c:	9a 83       	std	Y+2, r25	; 0x02
    1a7e:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1a80:	89 81       	ldd	r24, Y+1	; 0x01
    1a82:	9a 81       	ldd	r25, Y+2	; 0x02
    1a84:	2f ef       	ldi	r18, 0xFF	; 255
    1a86:	8f 3f       	cpi	r24, 0xFF	; 255
    1a88:	92 07       	cpc	r25, r18
    1a8a:	39 f4       	brne	.+14     	; 0x1a9a <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1a8c:	ed 81       	ldd	r30, Y+5	; 0x05
    1a8e:	fe 81       	ldd	r31, Y+6	; 0x06
    1a90:	87 81       	ldd	r24, Z+7	; 0x07
    1a92:	90 85       	ldd	r25, Z+8	; 0x08
    1a94:	9c 83       	std	Y+4, r25	; 0x04
    1a96:	8b 83       	std	Y+3, r24	; 0x03
    1a98:	18 c0       	rjmp	.+48     	; 0x1aca <vListInsert+0x72>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1a9a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a9c:	9e 81       	ldd	r25, Y+6	; 0x06
    1a9e:	03 96       	adiw	r24, 0x03	; 3
    1aa0:	9c 83       	std	Y+4, r25	; 0x04
    1aa2:	8b 83       	std	Y+3, r24	; 0x03
    1aa4:	06 c0       	rjmp	.+12     	; 0x1ab2 <vListInsert+0x5a>
    1aa6:	eb 81       	ldd	r30, Y+3	; 0x03
    1aa8:	fc 81       	ldd	r31, Y+4	; 0x04
    1aaa:	82 81       	ldd	r24, Z+2	; 0x02
    1aac:	93 81       	ldd	r25, Z+3	; 0x03
    1aae:	9c 83       	std	Y+4, r25	; 0x04
    1ab0:	8b 83       	std	Y+3, r24	; 0x03
    1ab2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ab4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ab6:	02 80       	ldd	r0, Z+2	; 0x02
    1ab8:	f3 81       	ldd	r31, Z+3	; 0x03
    1aba:	e0 2d       	mov	r30, r0
    1abc:	20 81       	ld	r18, Z
    1abe:	31 81       	ldd	r19, Z+1	; 0x01
    1ac0:	89 81       	ldd	r24, Y+1	; 0x01
    1ac2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ac4:	82 17       	cp	r24, r18
    1ac6:	93 07       	cpc	r25, r19
    1ac8:	70 f7       	brcc	.-36     	; 0x1aa6 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1aca:	eb 81       	ldd	r30, Y+3	; 0x03
    1acc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ace:	82 81       	ldd	r24, Z+2	; 0x02
    1ad0:	93 81       	ldd	r25, Z+3	; 0x03
    1ad2:	ef 81       	ldd	r30, Y+7	; 0x07
    1ad4:	f8 85       	ldd	r31, Y+8	; 0x08
    1ad6:	93 83       	std	Z+3, r25	; 0x03
    1ad8:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1ada:	ef 81       	ldd	r30, Y+7	; 0x07
    1adc:	f8 85       	ldd	r31, Y+8	; 0x08
    1ade:	02 80       	ldd	r0, Z+2	; 0x02
    1ae0:	f3 81       	ldd	r31, Z+3	; 0x03
    1ae2:	e0 2d       	mov	r30, r0
    1ae4:	8f 81       	ldd	r24, Y+7	; 0x07
    1ae6:	98 85       	ldd	r25, Y+8	; 0x08
    1ae8:	95 83       	std	Z+5, r25	; 0x05
    1aea:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1aec:	ef 81       	ldd	r30, Y+7	; 0x07
    1aee:	f8 85       	ldd	r31, Y+8	; 0x08
    1af0:	8b 81       	ldd	r24, Y+3	; 0x03
    1af2:	9c 81       	ldd	r25, Y+4	; 0x04
    1af4:	95 83       	std	Z+5, r25	; 0x05
    1af6:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1af8:	eb 81       	ldd	r30, Y+3	; 0x03
    1afa:	fc 81       	ldd	r31, Y+4	; 0x04
    1afc:	8f 81       	ldd	r24, Y+7	; 0x07
    1afe:	98 85       	ldd	r25, Y+8	; 0x08
    1b00:	93 83       	std	Z+3, r25	; 0x03
    1b02:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1b04:	ef 81       	ldd	r30, Y+7	; 0x07
    1b06:	f8 85       	ldd	r31, Y+8	; 0x08
    1b08:	8d 81       	ldd	r24, Y+5	; 0x05
    1b0a:	9e 81       	ldd	r25, Y+6	; 0x06
    1b0c:	91 87       	std	Z+9, r25	; 0x09
    1b0e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1b10:	ed 81       	ldd	r30, Y+5	; 0x05
    1b12:	fe 81       	ldd	r31, Y+6	; 0x06
    1b14:	80 81       	ld	r24, Z
    1b16:	8f 5f       	subi	r24, 0xFF	; 255
    1b18:	ed 81       	ldd	r30, Y+5	; 0x05
    1b1a:	fe 81       	ldd	r31, Y+6	; 0x06
    1b1c:	80 83       	st	Z, r24
}
    1b1e:	28 96       	adiw	r28, 0x08	; 8
    1b20:	0f b6       	in	r0, 0x3f	; 63
    1b22:	f8 94       	cli
    1b24:	de bf       	out	0x3e, r29	; 62
    1b26:	0f be       	out	0x3f, r0	; 63
    1b28:	cd bf       	out	0x3d, r28	; 61
    1b2a:	cf 91       	pop	r28
    1b2c:	df 91       	pop	r29
    1b2e:	08 95       	ret

00001b30 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1b30:	df 93       	push	r29
    1b32:	cf 93       	push	r28
    1b34:	00 d0       	rcall	.+0      	; 0x1b36 <uxListRemove+0x6>
    1b36:	00 d0       	rcall	.+0      	; 0x1b38 <uxListRemove+0x8>
    1b38:	cd b7       	in	r28, 0x3d	; 61
    1b3a:	de b7       	in	r29, 0x3e	; 62
    1b3c:	9c 83       	std	Y+4, r25	; 0x04
    1b3e:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1b40:	eb 81       	ldd	r30, Y+3	; 0x03
    1b42:	fc 81       	ldd	r31, Y+4	; 0x04
    1b44:	80 85       	ldd	r24, Z+8	; 0x08
    1b46:	91 85       	ldd	r25, Z+9	; 0x09
    1b48:	9a 83       	std	Y+2, r25	; 0x02
    1b4a:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1b4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b50:	a2 81       	ldd	r26, Z+2	; 0x02
    1b52:	b3 81       	ldd	r27, Z+3	; 0x03
    1b54:	eb 81       	ldd	r30, Y+3	; 0x03
    1b56:	fc 81       	ldd	r31, Y+4	; 0x04
    1b58:	84 81       	ldd	r24, Z+4	; 0x04
    1b5a:	95 81       	ldd	r25, Z+5	; 0x05
    1b5c:	15 96       	adiw	r26, 0x05	; 5
    1b5e:	9c 93       	st	X, r25
    1b60:	8e 93       	st	-X, r24
    1b62:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1b64:	eb 81       	ldd	r30, Y+3	; 0x03
    1b66:	fc 81       	ldd	r31, Y+4	; 0x04
    1b68:	a4 81       	ldd	r26, Z+4	; 0x04
    1b6a:	b5 81       	ldd	r27, Z+5	; 0x05
    1b6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b70:	82 81       	ldd	r24, Z+2	; 0x02
    1b72:	93 81       	ldd	r25, Z+3	; 0x03
    1b74:	13 96       	adiw	r26, 0x03	; 3
    1b76:	9c 93       	st	X, r25
    1b78:	8e 93       	st	-X, r24
    1b7a:	12 97       	sbiw	r26, 0x02	; 2

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1b7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b80:	21 81       	ldd	r18, Z+1	; 0x01
    1b82:	32 81       	ldd	r19, Z+2	; 0x02
    1b84:	8b 81       	ldd	r24, Y+3	; 0x03
    1b86:	9c 81       	ldd	r25, Y+4	; 0x04
    1b88:	28 17       	cp	r18, r24
    1b8a:	39 07       	cpc	r19, r25
    1b8c:	41 f4       	brne	.+16     	; 0x1b9e <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1b8e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b90:	fc 81       	ldd	r31, Y+4	; 0x04
    1b92:	84 81       	ldd	r24, Z+4	; 0x04
    1b94:	95 81       	ldd	r25, Z+5	; 0x05
    1b96:	e9 81       	ldd	r30, Y+1	; 0x01
    1b98:	fa 81       	ldd	r31, Y+2	; 0x02
    1b9a:	92 83       	std	Z+2, r25	; 0x02
    1b9c:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1b9e:	eb 81       	ldd	r30, Y+3	; 0x03
    1ba0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ba2:	11 86       	std	Z+9, r1	; 0x09
    1ba4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1ba6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ba8:	fa 81       	ldd	r31, Y+2	; 0x02
    1baa:	80 81       	ld	r24, Z
    1bac:	81 50       	subi	r24, 0x01	; 1
    1bae:	e9 81       	ldd	r30, Y+1	; 0x01
    1bb0:	fa 81       	ldd	r31, Y+2	; 0x02
    1bb2:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    1bb4:	e9 81       	ldd	r30, Y+1	; 0x01
    1bb6:	fa 81       	ldd	r31, Y+2	; 0x02
    1bb8:	80 81       	ld	r24, Z
}
    1bba:	0f 90       	pop	r0
    1bbc:	0f 90       	pop	r0
    1bbe:	0f 90       	pop	r0
    1bc0:	0f 90       	pop	r0
    1bc2:	cf 91       	pop	r28
    1bc4:	df 91       	pop	r29
    1bc6:	08 95       	ret

00001bc8 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1bc8:	df 93       	push	r29
    1bca:	cf 93       	push	r28
    1bcc:	cd b7       	in	r28, 0x3d	; 61
    1bce:	de b7       	in	r29, 0x3e	; 62
    1bd0:	28 97       	sbiw	r28, 0x08	; 8
    1bd2:	0f b6       	in	r0, 0x3f	; 63
    1bd4:	f8 94       	cli
    1bd6:	de bf       	out	0x3e, r29	; 62
    1bd8:	0f be       	out	0x3f, r0	; 63
    1bda:	cd bf       	out	0x3d, r28	; 61
    1bdc:	9c 83       	std	Y+4, r25	; 0x04
    1bde:	8b 83       	std	Y+3, r24	; 0x03
    1be0:	7e 83       	std	Y+6, r23	; 0x06
    1be2:	6d 83       	std	Y+5, r22	; 0x05
    1be4:	58 87       	std	Y+8, r21	; 0x08
    1be6:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1be8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bea:	fc 81       	ldd	r31, Y+4	; 0x04
    1bec:	81 e1       	ldi	r24, 0x11	; 17
    1bee:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bf0:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf2:	9c 81       	ldd	r25, Y+4	; 0x04
    1bf4:	01 97       	sbiw	r24, 0x01	; 1
    1bf6:	9c 83       	std	Y+4, r25	; 0x04
    1bf8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1bfa:	eb 81       	ldd	r30, Y+3	; 0x03
    1bfc:	fc 81       	ldd	r31, Y+4	; 0x04
    1bfe:	82 e2       	ldi	r24, 0x22	; 34
    1c00:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c02:	8b 81       	ldd	r24, Y+3	; 0x03
    1c04:	9c 81       	ldd	r25, Y+4	; 0x04
    1c06:	01 97       	sbiw	r24, 0x01	; 1
    1c08:	9c 83       	std	Y+4, r25	; 0x04
    1c0a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1c0c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c0e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c10:	83 e3       	ldi	r24, 0x33	; 51
    1c12:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c14:	8b 81       	ldd	r24, Y+3	; 0x03
    1c16:	9c 81       	ldd	r25, Y+4	; 0x04
    1c18:	01 97       	sbiw	r24, 0x01	; 1
    1c1a:	9c 83       	std	Y+4, r25	; 0x04
    1c1c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1c1e:	8d 81       	ldd	r24, Y+5	; 0x05
    1c20:	9e 81       	ldd	r25, Y+6	; 0x06
    1c22:	9a 83       	std	Y+2, r25	; 0x02
    1c24:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1c26:	89 81       	ldd	r24, Y+1	; 0x01
    1c28:	eb 81       	ldd	r30, Y+3	; 0x03
    1c2a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c2c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c30:	9c 81       	ldd	r25, Y+4	; 0x04
    1c32:	01 97       	sbiw	r24, 0x01	; 1
    1c34:	9c 83       	std	Y+4, r25	; 0x04
    1c36:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1c38:	89 81       	ldd	r24, Y+1	; 0x01
    1c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c3c:	89 2f       	mov	r24, r25
    1c3e:	99 27       	eor	r25, r25
    1c40:	9a 83       	std	Y+2, r25	; 0x02
    1c42:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1c44:	89 81       	ldd	r24, Y+1	; 0x01
    1c46:	eb 81       	ldd	r30, Y+3	; 0x03
    1c48:	fc 81       	ldd	r31, Y+4	; 0x04
    1c4a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c50:	01 97       	sbiw	r24, 0x01	; 1
    1c52:	9c 83       	std	Y+4, r25	; 0x04
    1c54:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1c56:	eb 81       	ldd	r30, Y+3	; 0x03
    1c58:	fc 81       	ldd	r31, Y+4	; 0x04
    1c5a:	10 82       	st	Z, r1
	pxTopOfStack--;
    1c5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c60:	01 97       	sbiw	r24, 0x01	; 1
    1c62:	9c 83       	std	Y+4, r25	; 0x04
    1c64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1c66:	eb 81       	ldd	r30, Y+3	; 0x03
    1c68:	fc 81       	ldd	r31, Y+4	; 0x04
    1c6a:	80 e8       	ldi	r24, 0x80	; 128
    1c6c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c70:	9c 81       	ldd	r25, Y+4	; 0x04
    1c72:	01 97       	sbiw	r24, 0x01	; 1
    1c74:	9c 83       	std	Y+4, r25	; 0x04
    1c76:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1c78:	eb 81       	ldd	r30, Y+3	; 0x03
    1c7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c7c:	10 82       	st	Z, r1
	pxTopOfStack--;
    1c7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c80:	9c 81       	ldd	r25, Y+4	; 0x04
    1c82:	01 97       	sbiw	r24, 0x01	; 1
    1c84:	9c 83       	std	Y+4, r25	; 0x04
    1c86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1c88:	eb 81       	ldd	r30, Y+3	; 0x03
    1c8a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c8c:	82 e0       	ldi	r24, 0x02	; 2
    1c8e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c90:	8b 81       	ldd	r24, Y+3	; 0x03
    1c92:	9c 81       	ldd	r25, Y+4	; 0x04
    1c94:	01 97       	sbiw	r24, 0x01	; 1
    1c96:	9c 83       	std	Y+4, r25	; 0x04
    1c98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1c9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c9e:	83 e0       	ldi	r24, 0x03	; 3
    1ca0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ca2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ca4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ca6:	01 97       	sbiw	r24, 0x01	; 1
    1ca8:	9c 83       	std	Y+4, r25	; 0x04
    1caa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1cac:	eb 81       	ldd	r30, Y+3	; 0x03
    1cae:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb0:	84 e0       	ldi	r24, 0x04	; 4
    1cb2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cb4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb6:	9c 81       	ldd	r25, Y+4	; 0x04
    1cb8:	01 97       	sbiw	r24, 0x01	; 1
    1cba:	9c 83       	std	Y+4, r25	; 0x04
    1cbc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1cbe:	eb 81       	ldd	r30, Y+3	; 0x03
    1cc0:	fc 81       	ldd	r31, Y+4	; 0x04
    1cc2:	85 e0       	ldi	r24, 0x05	; 5
    1cc4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cca:	01 97       	sbiw	r24, 0x01	; 1
    1ccc:	9c 83       	std	Y+4, r25	; 0x04
    1cce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1cd0:	eb 81       	ldd	r30, Y+3	; 0x03
    1cd2:	fc 81       	ldd	r31, Y+4	; 0x04
    1cd4:	86 e0       	ldi	r24, 0x06	; 6
    1cd6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cd8:	8b 81       	ldd	r24, Y+3	; 0x03
    1cda:	9c 81       	ldd	r25, Y+4	; 0x04
    1cdc:	01 97       	sbiw	r24, 0x01	; 1
    1cde:	9c 83       	std	Y+4, r25	; 0x04
    1ce0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1ce2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ce6:	87 e0       	ldi	r24, 0x07	; 7
    1ce8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cea:	8b 81       	ldd	r24, Y+3	; 0x03
    1cec:	9c 81       	ldd	r25, Y+4	; 0x04
    1cee:	01 97       	sbiw	r24, 0x01	; 1
    1cf0:	9c 83       	std	Y+4, r25	; 0x04
    1cf2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1cf4:	eb 81       	ldd	r30, Y+3	; 0x03
    1cf6:	fc 81       	ldd	r31, Y+4	; 0x04
    1cf8:	88 e0       	ldi	r24, 0x08	; 8
    1cfa:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cfc:	8b 81       	ldd	r24, Y+3	; 0x03
    1cfe:	9c 81       	ldd	r25, Y+4	; 0x04
    1d00:	01 97       	sbiw	r24, 0x01	; 1
    1d02:	9c 83       	std	Y+4, r25	; 0x04
    1d04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1d06:	eb 81       	ldd	r30, Y+3	; 0x03
    1d08:	fc 81       	ldd	r31, Y+4	; 0x04
    1d0a:	89 e0       	ldi	r24, 0x09	; 9
    1d0c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d10:	9c 81       	ldd	r25, Y+4	; 0x04
    1d12:	01 97       	sbiw	r24, 0x01	; 1
    1d14:	9c 83       	std	Y+4, r25	; 0x04
    1d16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1d18:	eb 81       	ldd	r30, Y+3	; 0x03
    1d1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d1c:	80 e1       	ldi	r24, 0x10	; 16
    1d1e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d20:	8b 81       	ldd	r24, Y+3	; 0x03
    1d22:	9c 81       	ldd	r25, Y+4	; 0x04
    1d24:	01 97       	sbiw	r24, 0x01	; 1
    1d26:	9c 83       	std	Y+4, r25	; 0x04
    1d28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1d2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d2e:	81 e1       	ldi	r24, 0x11	; 17
    1d30:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d32:	8b 81       	ldd	r24, Y+3	; 0x03
    1d34:	9c 81       	ldd	r25, Y+4	; 0x04
    1d36:	01 97       	sbiw	r24, 0x01	; 1
    1d38:	9c 83       	std	Y+4, r25	; 0x04
    1d3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1d3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d40:	82 e1       	ldi	r24, 0x12	; 18
    1d42:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d44:	8b 81       	ldd	r24, Y+3	; 0x03
    1d46:	9c 81       	ldd	r25, Y+4	; 0x04
    1d48:	01 97       	sbiw	r24, 0x01	; 1
    1d4a:	9c 83       	std	Y+4, r25	; 0x04
    1d4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1d4e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d50:	fc 81       	ldd	r31, Y+4	; 0x04
    1d52:	83 e1       	ldi	r24, 0x13	; 19
    1d54:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d56:	8b 81       	ldd	r24, Y+3	; 0x03
    1d58:	9c 81       	ldd	r25, Y+4	; 0x04
    1d5a:	01 97       	sbiw	r24, 0x01	; 1
    1d5c:	9c 83       	std	Y+4, r25	; 0x04
    1d5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1d60:	eb 81       	ldd	r30, Y+3	; 0x03
    1d62:	fc 81       	ldd	r31, Y+4	; 0x04
    1d64:	84 e1       	ldi	r24, 0x14	; 20
    1d66:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d68:	8b 81       	ldd	r24, Y+3	; 0x03
    1d6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d6c:	01 97       	sbiw	r24, 0x01	; 1
    1d6e:	9c 83       	std	Y+4, r25	; 0x04
    1d70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1d72:	eb 81       	ldd	r30, Y+3	; 0x03
    1d74:	fc 81       	ldd	r31, Y+4	; 0x04
    1d76:	85 e1       	ldi	r24, 0x15	; 21
    1d78:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d7e:	01 97       	sbiw	r24, 0x01	; 1
    1d80:	9c 83       	std	Y+4, r25	; 0x04
    1d82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1d84:	eb 81       	ldd	r30, Y+3	; 0x03
    1d86:	fc 81       	ldd	r31, Y+4	; 0x04
    1d88:	86 e1       	ldi	r24, 0x16	; 22
    1d8a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d8c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d8e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d90:	01 97       	sbiw	r24, 0x01	; 1
    1d92:	9c 83       	std	Y+4, r25	; 0x04
    1d94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1d96:	eb 81       	ldd	r30, Y+3	; 0x03
    1d98:	fc 81       	ldd	r31, Y+4	; 0x04
    1d9a:	87 e1       	ldi	r24, 0x17	; 23
    1d9c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1da0:	9c 81       	ldd	r25, Y+4	; 0x04
    1da2:	01 97       	sbiw	r24, 0x01	; 1
    1da4:	9c 83       	std	Y+4, r25	; 0x04
    1da6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1da8:	eb 81       	ldd	r30, Y+3	; 0x03
    1daa:	fc 81       	ldd	r31, Y+4	; 0x04
    1dac:	88 e1       	ldi	r24, 0x18	; 24
    1dae:	80 83       	st	Z, r24
	pxTopOfStack--;
    1db0:	8b 81       	ldd	r24, Y+3	; 0x03
    1db2:	9c 81       	ldd	r25, Y+4	; 0x04
    1db4:	01 97       	sbiw	r24, 0x01	; 1
    1db6:	9c 83       	std	Y+4, r25	; 0x04
    1db8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1dba:	eb 81       	ldd	r30, Y+3	; 0x03
    1dbc:	fc 81       	ldd	r31, Y+4	; 0x04
    1dbe:	89 e1       	ldi	r24, 0x19	; 25
    1dc0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1dc2:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc4:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc6:	01 97       	sbiw	r24, 0x01	; 1
    1dc8:	9c 83       	std	Y+4, r25	; 0x04
    1dca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1dcc:	eb 81       	ldd	r30, Y+3	; 0x03
    1dce:	fc 81       	ldd	r31, Y+4	; 0x04
    1dd0:	80 e2       	ldi	r24, 0x20	; 32
    1dd2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1dd4:	8b 81       	ldd	r24, Y+3	; 0x03
    1dd6:	9c 81       	ldd	r25, Y+4	; 0x04
    1dd8:	01 97       	sbiw	r24, 0x01	; 1
    1dda:	9c 83       	std	Y+4, r25	; 0x04
    1ddc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1dde:	eb 81       	ldd	r30, Y+3	; 0x03
    1de0:	fc 81       	ldd	r31, Y+4	; 0x04
    1de2:	81 e2       	ldi	r24, 0x21	; 33
    1de4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1de6:	8b 81       	ldd	r24, Y+3	; 0x03
    1de8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dea:	01 97       	sbiw	r24, 0x01	; 1
    1dec:	9c 83       	std	Y+4, r25	; 0x04
    1dee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1df0:	eb 81       	ldd	r30, Y+3	; 0x03
    1df2:	fc 81       	ldd	r31, Y+4	; 0x04
    1df4:	82 e2       	ldi	r24, 0x22	; 34
    1df6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1df8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dfa:	9c 81       	ldd	r25, Y+4	; 0x04
    1dfc:	01 97       	sbiw	r24, 0x01	; 1
    1dfe:	9c 83       	std	Y+4, r25	; 0x04
    1e00:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1e02:	eb 81       	ldd	r30, Y+3	; 0x03
    1e04:	fc 81       	ldd	r31, Y+4	; 0x04
    1e06:	83 e2       	ldi	r24, 0x23	; 35
    1e08:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e0c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e0e:	01 97       	sbiw	r24, 0x01	; 1
    1e10:	9c 83       	std	Y+4, r25	; 0x04
    1e12:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1e14:	8f 81       	ldd	r24, Y+7	; 0x07
    1e16:	98 85       	ldd	r25, Y+8	; 0x08
    1e18:	9a 83       	std	Y+2, r25	; 0x02
    1e1a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1e1c:	89 81       	ldd	r24, Y+1	; 0x01
    1e1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e20:	fc 81       	ldd	r31, Y+4	; 0x04
    1e22:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e24:	8b 81       	ldd	r24, Y+3	; 0x03
    1e26:	9c 81       	ldd	r25, Y+4	; 0x04
    1e28:	01 97       	sbiw	r24, 0x01	; 1
    1e2a:	9c 83       	std	Y+4, r25	; 0x04
    1e2c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1e2e:	89 81       	ldd	r24, Y+1	; 0x01
    1e30:	9a 81       	ldd	r25, Y+2	; 0x02
    1e32:	89 2f       	mov	r24, r25
    1e34:	99 27       	eor	r25, r25
    1e36:	9a 83       	std	Y+2, r25	; 0x02
    1e38:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1e3a:	89 81       	ldd	r24, Y+1	; 0x01
    1e3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e40:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e42:	8b 81       	ldd	r24, Y+3	; 0x03
    1e44:	9c 81       	ldd	r25, Y+4	; 0x04
    1e46:	01 97       	sbiw	r24, 0x01	; 1
    1e48:	9c 83       	std	Y+4, r25	; 0x04
    1e4a:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1e4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e50:	86 e2       	ldi	r24, 0x26	; 38
    1e52:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e54:	8b 81       	ldd	r24, Y+3	; 0x03
    1e56:	9c 81       	ldd	r25, Y+4	; 0x04
    1e58:	01 97       	sbiw	r24, 0x01	; 1
    1e5a:	9c 83       	std	Y+4, r25	; 0x04
    1e5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1e5e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e60:	fc 81       	ldd	r31, Y+4	; 0x04
    1e62:	87 e2       	ldi	r24, 0x27	; 39
    1e64:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e66:	8b 81       	ldd	r24, Y+3	; 0x03
    1e68:	9c 81       	ldd	r25, Y+4	; 0x04
    1e6a:	01 97       	sbiw	r24, 0x01	; 1
    1e6c:	9c 83       	std	Y+4, r25	; 0x04
    1e6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1e70:	eb 81       	ldd	r30, Y+3	; 0x03
    1e72:	fc 81       	ldd	r31, Y+4	; 0x04
    1e74:	88 e2       	ldi	r24, 0x28	; 40
    1e76:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e78:	8b 81       	ldd	r24, Y+3	; 0x03
    1e7a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e7c:	01 97       	sbiw	r24, 0x01	; 1
    1e7e:	9c 83       	std	Y+4, r25	; 0x04
    1e80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1e82:	eb 81       	ldd	r30, Y+3	; 0x03
    1e84:	fc 81       	ldd	r31, Y+4	; 0x04
    1e86:	89 e2       	ldi	r24, 0x29	; 41
    1e88:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e8c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e8e:	01 97       	sbiw	r24, 0x01	; 1
    1e90:	9c 83       	std	Y+4, r25	; 0x04
    1e92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1e94:	eb 81       	ldd	r30, Y+3	; 0x03
    1e96:	fc 81       	ldd	r31, Y+4	; 0x04
    1e98:	80 e3       	ldi	r24, 0x30	; 48
    1e9a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e9e:	9c 81       	ldd	r25, Y+4	; 0x04
    1ea0:	01 97       	sbiw	r24, 0x01	; 1
    1ea2:	9c 83       	std	Y+4, r25	; 0x04
    1ea4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1ea6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ea8:	fc 81       	ldd	r31, Y+4	; 0x04
    1eaa:	81 e3       	ldi	r24, 0x31	; 49
    1eac:	80 83       	st	Z, r24
	pxTopOfStack--;
    1eae:	8b 81       	ldd	r24, Y+3	; 0x03
    1eb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb2:	01 97       	sbiw	r24, 0x01	; 1
    1eb4:	9c 83       	std	Y+4, r25	; 0x04
    1eb6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1eb8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eba:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1ebc:	28 96       	adiw	r28, 0x08	; 8
    1ebe:	0f b6       	in	r0, 0x3f	; 63
    1ec0:	f8 94       	cli
    1ec2:	de bf       	out	0x3e, r29	; 62
    1ec4:	0f be       	out	0x3f, r0	; 63
    1ec6:	cd bf       	out	0x3d, r28	; 61
    1ec8:	cf 91       	pop	r28
    1eca:	df 91       	pop	r29
    1ecc:	08 95       	ret

00001ece <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1ece:	df 93       	push	r29
    1ed0:	cf 93       	push	r28
    1ed2:	cd b7       	in	r28, 0x3d	; 61
    1ed4:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1ed6:	0e 94 59 10 	call	0x20b2	; 0x20b2 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1eda:	a0 91 db 06 	lds	r26, 0x06DB
    1ede:	b0 91 dc 06 	lds	r27, 0x06DC
    1ee2:	cd 91       	ld	r28, X+
    1ee4:	cd bf       	out	0x3d, r28	; 61
    1ee6:	dd 91       	ld	r29, X+
    1ee8:	de bf       	out	0x3e, r29	; 62
    1eea:	ff 91       	pop	r31
    1eec:	ef 91       	pop	r30
    1eee:	df 91       	pop	r29
    1ef0:	cf 91       	pop	r28
    1ef2:	bf 91       	pop	r27
    1ef4:	af 91       	pop	r26
    1ef6:	9f 91       	pop	r25
    1ef8:	8f 91       	pop	r24
    1efa:	7f 91       	pop	r23
    1efc:	6f 91       	pop	r22
    1efe:	5f 91       	pop	r21
    1f00:	4f 91       	pop	r20
    1f02:	3f 91       	pop	r19
    1f04:	2f 91       	pop	r18
    1f06:	1f 91       	pop	r17
    1f08:	0f 91       	pop	r16
    1f0a:	ff 90       	pop	r15
    1f0c:	ef 90       	pop	r14
    1f0e:	df 90       	pop	r13
    1f10:	cf 90       	pop	r12
    1f12:	bf 90       	pop	r11
    1f14:	af 90       	pop	r10
    1f16:	9f 90       	pop	r9
    1f18:	8f 90       	pop	r8
    1f1a:	7f 90       	pop	r7
    1f1c:	6f 90       	pop	r6
    1f1e:	5f 90       	pop	r5
    1f20:	4f 90       	pop	r4
    1f22:	3f 90       	pop	r3
    1f24:	2f 90       	pop	r2
    1f26:	1f 90       	pop	r1
    1f28:	0f 90       	pop	r0
    1f2a:	0f be       	out	0x3f, r0	; 63
    1f2c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1f2e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1f30:	81 e0       	ldi	r24, 0x01	; 1
}
    1f32:	cf 91       	pop	r28
    1f34:	df 91       	pop	r29
    1f36:	08 95       	ret

00001f38 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1f38:	df 93       	push	r29
    1f3a:	cf 93       	push	r28
    1f3c:	cd b7       	in	r28, 0x3d	; 61
    1f3e:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1f40:	cf 91       	pop	r28
    1f42:	df 91       	pop	r29
    1f44:	08 95       	ret

00001f46 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1f46:	0f 92       	push	r0
    1f48:	0f b6       	in	r0, 0x3f	; 63
    1f4a:	f8 94       	cli
    1f4c:	0f 92       	push	r0
    1f4e:	1f 92       	push	r1
    1f50:	11 24       	eor	r1, r1
    1f52:	2f 92       	push	r2
    1f54:	3f 92       	push	r3
    1f56:	4f 92       	push	r4
    1f58:	5f 92       	push	r5
    1f5a:	6f 92       	push	r6
    1f5c:	7f 92       	push	r7
    1f5e:	8f 92       	push	r8
    1f60:	9f 92       	push	r9
    1f62:	af 92       	push	r10
    1f64:	bf 92       	push	r11
    1f66:	cf 92       	push	r12
    1f68:	df 92       	push	r13
    1f6a:	ef 92       	push	r14
    1f6c:	ff 92       	push	r15
    1f6e:	0f 93       	push	r16
    1f70:	1f 93       	push	r17
    1f72:	2f 93       	push	r18
    1f74:	3f 93       	push	r19
    1f76:	4f 93       	push	r20
    1f78:	5f 93       	push	r21
    1f7a:	6f 93       	push	r22
    1f7c:	7f 93       	push	r23
    1f7e:	8f 93       	push	r24
    1f80:	9f 93       	push	r25
    1f82:	af 93       	push	r26
    1f84:	bf 93       	push	r27
    1f86:	cf 93       	push	r28
    1f88:	df 93       	push	r29
    1f8a:	ef 93       	push	r30
    1f8c:	ff 93       	push	r31
    1f8e:	a0 91 db 06 	lds	r26, 0x06DB
    1f92:	b0 91 dc 06 	lds	r27, 0x06DC
    1f96:	0d b6       	in	r0, 0x3d	; 61
    1f98:	0d 92       	st	X+, r0
    1f9a:	0e b6       	in	r0, 0x3e	; 62
    1f9c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1f9e:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1fa2:	a0 91 db 06 	lds	r26, 0x06DB
    1fa6:	b0 91 dc 06 	lds	r27, 0x06DC
    1faa:	cd 91       	ld	r28, X+
    1fac:	cd bf       	out	0x3d, r28	; 61
    1fae:	dd 91       	ld	r29, X+
    1fb0:	de bf       	out	0x3e, r29	; 62
    1fb2:	ff 91       	pop	r31
    1fb4:	ef 91       	pop	r30
    1fb6:	df 91       	pop	r29
    1fb8:	cf 91       	pop	r28
    1fba:	bf 91       	pop	r27
    1fbc:	af 91       	pop	r26
    1fbe:	9f 91       	pop	r25
    1fc0:	8f 91       	pop	r24
    1fc2:	7f 91       	pop	r23
    1fc4:	6f 91       	pop	r22
    1fc6:	5f 91       	pop	r21
    1fc8:	4f 91       	pop	r20
    1fca:	3f 91       	pop	r19
    1fcc:	2f 91       	pop	r18
    1fce:	1f 91       	pop	r17
    1fd0:	0f 91       	pop	r16
    1fd2:	ff 90       	pop	r15
    1fd4:	ef 90       	pop	r14
    1fd6:	df 90       	pop	r13
    1fd8:	cf 90       	pop	r12
    1fda:	bf 90       	pop	r11
    1fdc:	af 90       	pop	r10
    1fde:	9f 90       	pop	r9
    1fe0:	8f 90       	pop	r8
    1fe2:	7f 90       	pop	r7
    1fe4:	6f 90       	pop	r6
    1fe6:	5f 90       	pop	r5
    1fe8:	4f 90       	pop	r4
    1fea:	3f 90       	pop	r3
    1fec:	2f 90       	pop	r2
    1fee:	1f 90       	pop	r1
    1ff0:	0f 90       	pop	r0
    1ff2:	0f be       	out	0x3f, r0	; 63
    1ff4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1ff6:	08 95       	ret

00001ff8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1ff8:	0f 92       	push	r0
    1ffa:	0f b6       	in	r0, 0x3f	; 63
    1ffc:	f8 94       	cli
    1ffe:	0f 92       	push	r0
    2000:	1f 92       	push	r1
    2002:	11 24       	eor	r1, r1
    2004:	2f 92       	push	r2
    2006:	3f 92       	push	r3
    2008:	4f 92       	push	r4
    200a:	5f 92       	push	r5
    200c:	6f 92       	push	r6
    200e:	7f 92       	push	r7
    2010:	8f 92       	push	r8
    2012:	9f 92       	push	r9
    2014:	af 92       	push	r10
    2016:	bf 92       	push	r11
    2018:	cf 92       	push	r12
    201a:	df 92       	push	r13
    201c:	ef 92       	push	r14
    201e:	ff 92       	push	r15
    2020:	0f 93       	push	r16
    2022:	1f 93       	push	r17
    2024:	2f 93       	push	r18
    2026:	3f 93       	push	r19
    2028:	4f 93       	push	r20
    202a:	5f 93       	push	r21
    202c:	6f 93       	push	r22
    202e:	7f 93       	push	r23
    2030:	8f 93       	push	r24
    2032:	9f 93       	push	r25
    2034:	af 93       	push	r26
    2036:	bf 93       	push	r27
    2038:	cf 93       	push	r28
    203a:	df 93       	push	r29
    203c:	ef 93       	push	r30
    203e:	ff 93       	push	r31
    2040:	a0 91 db 06 	lds	r26, 0x06DB
    2044:	b0 91 dc 06 	lds	r27, 0x06DC
    2048:	0d b6       	in	r0, 0x3d	; 61
    204a:	0d 92       	st	X+, r0
    204c:	0e b6       	in	r0, 0x3e	; 62
    204e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2050:	0e 94 93 1b 	call	0x3726	; 0x3726 <xTaskIncrementTick>
    2054:	88 23       	and	r24, r24
    2056:	11 f0       	breq	.+4      	; 0x205c <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2058:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    205c:	a0 91 db 06 	lds	r26, 0x06DB
    2060:	b0 91 dc 06 	lds	r27, 0x06DC
    2064:	cd 91       	ld	r28, X+
    2066:	cd bf       	out	0x3d, r28	; 61
    2068:	dd 91       	ld	r29, X+
    206a:	de bf       	out	0x3e, r29	; 62
    206c:	ff 91       	pop	r31
    206e:	ef 91       	pop	r30
    2070:	df 91       	pop	r29
    2072:	cf 91       	pop	r28
    2074:	bf 91       	pop	r27
    2076:	af 91       	pop	r26
    2078:	9f 91       	pop	r25
    207a:	8f 91       	pop	r24
    207c:	7f 91       	pop	r23
    207e:	6f 91       	pop	r22
    2080:	5f 91       	pop	r21
    2082:	4f 91       	pop	r20
    2084:	3f 91       	pop	r19
    2086:	2f 91       	pop	r18
    2088:	1f 91       	pop	r17
    208a:	0f 91       	pop	r16
    208c:	ff 90       	pop	r15
    208e:	ef 90       	pop	r14
    2090:	df 90       	pop	r13
    2092:	cf 90       	pop	r12
    2094:	bf 90       	pop	r11
    2096:	af 90       	pop	r10
    2098:	9f 90       	pop	r9
    209a:	8f 90       	pop	r8
    209c:	7f 90       	pop	r7
    209e:	6f 90       	pop	r6
    20a0:	5f 90       	pop	r5
    20a2:	4f 90       	pop	r4
    20a4:	3f 90       	pop	r3
    20a6:	2f 90       	pop	r2
    20a8:	1f 90       	pop	r1
    20aa:	0f 90       	pop	r0
    20ac:	0f be       	out	0x3f, r0	; 63
    20ae:	0f 90       	pop	r0

	asm volatile ( "ret" );
    20b0:	08 95       	ret

000020b2 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    20b2:	df 93       	push	r29
    20b4:	cf 93       	push	r28
    20b6:	00 d0       	rcall	.+0      	; 0x20b8 <prvSetupTimerInterrupt+0x6>
    20b8:	00 d0       	rcall	.+0      	; 0x20ba <prvSetupTimerInterrupt+0x8>
    20ba:	00 d0       	rcall	.+0      	; 0x20bc <prvSetupTimerInterrupt+0xa>
    20bc:	cd b7       	in	r28, 0x3d	; 61
    20be:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    20c0:	80 e4       	ldi	r24, 0x40	; 64
    20c2:	9f e1       	ldi	r25, 0x1F	; 31
    20c4:	a0 e0       	ldi	r26, 0x00	; 0
    20c6:	b0 e0       	ldi	r27, 0x00	; 0
    20c8:	8b 83       	std	Y+3, r24	; 0x03
    20ca:	9c 83       	std	Y+4, r25	; 0x04
    20cc:	ad 83       	std	Y+5, r26	; 0x05
    20ce:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    20d0:	8b 81       	ldd	r24, Y+3	; 0x03
    20d2:	9c 81       	ldd	r25, Y+4	; 0x04
    20d4:	ad 81       	ldd	r26, Y+5	; 0x05
    20d6:	be 81       	ldd	r27, Y+6	; 0x06
    20d8:	68 94       	set
    20da:	15 f8       	bld	r1, 5
    20dc:	b6 95       	lsr	r27
    20de:	a7 95       	ror	r26
    20e0:	97 95       	ror	r25
    20e2:	87 95       	ror	r24
    20e4:	16 94       	lsr	r1
    20e6:	d1 f7       	brne	.-12     	; 0x20dc <prvSetupTimerInterrupt+0x2a>
    20e8:	8b 83       	std	Y+3, r24	; 0x03
    20ea:	9c 83       	std	Y+4, r25	; 0x04
    20ec:	ad 83       	std	Y+5, r26	; 0x05
    20ee:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    20f0:	8b 81       	ldd	r24, Y+3	; 0x03
    20f2:	9c 81       	ldd	r25, Y+4	; 0x04
    20f4:	ad 81       	ldd	r26, Y+5	; 0x05
    20f6:	be 81       	ldd	r27, Y+6	; 0x06
    20f8:	01 97       	sbiw	r24, 0x01	; 1
    20fa:	a1 09       	sbc	r26, r1
    20fc:	b1 09       	sbc	r27, r1
    20fe:	8b 83       	std	Y+3, r24	; 0x03
    2100:	9c 83       	std	Y+4, r25	; 0x04
    2102:	ad 83       	std	Y+5, r26	; 0x05
    2104:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2106:	8b 81       	ldd	r24, Y+3	; 0x03
    2108:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    210a:	8b 81       	ldd	r24, Y+3	; 0x03
    210c:	9c 81       	ldd	r25, Y+4	; 0x04
    210e:	ad 81       	ldd	r26, Y+5	; 0x05
    2110:	be 81       	ldd	r27, Y+6	; 0x06
    2112:	89 2f       	mov	r24, r25
    2114:	9a 2f       	mov	r25, r26
    2116:	ab 2f       	mov	r26, r27
    2118:	bb 27       	eor	r27, r27
    211a:	8b 83       	std	Y+3, r24	; 0x03
    211c:	9c 83       	std	Y+4, r25	; 0x04
    211e:	ad 83       	std	Y+5, r26	; 0x05
    2120:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2122:	8b 81       	ldd	r24, Y+3	; 0x03
    2124:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2126:	eb e4       	ldi	r30, 0x4B	; 75
    2128:	f0 e0       	ldi	r31, 0x00	; 0
    212a:	8a 81       	ldd	r24, Y+2	; 0x02
    212c:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    212e:	ea e4       	ldi	r30, 0x4A	; 74
    2130:	f0 e0       	ldi	r31, 0x00	; 0
    2132:	89 81       	ldd	r24, Y+1	; 0x01
    2134:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2136:	8b e0       	ldi	r24, 0x0B	; 11
    2138:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    213a:	ee e4       	ldi	r30, 0x4E	; 78
    213c:	f0 e0       	ldi	r31, 0x00	; 0
    213e:	89 81       	ldd	r24, Y+1	; 0x01
    2140:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2142:	e9 e5       	ldi	r30, 0x59	; 89
    2144:	f0 e0       	ldi	r31, 0x00	; 0
    2146:	80 81       	ld	r24, Z
    2148:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    214a:	89 81       	ldd	r24, Y+1	; 0x01
    214c:	80 61       	ori	r24, 0x10	; 16
    214e:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2150:	e9 e5       	ldi	r30, 0x59	; 89
    2152:	f0 e0       	ldi	r31, 0x00	; 0
    2154:	89 81       	ldd	r24, Y+1	; 0x01
    2156:	80 83       	st	Z, r24
}
    2158:	26 96       	adiw	r28, 0x06	; 6
    215a:	0f b6       	in	r0, 0x3f	; 63
    215c:	f8 94       	cli
    215e:	de bf       	out	0x3e, r29	; 62
    2160:	0f be       	out	0x3f, r0	; 63
    2162:	cd bf       	out	0x3d, r28	; 61
    2164:	cf 91       	pop	r28
    2166:	df 91       	pop	r29
    2168:	08 95       	ret

0000216a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    216a:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    216e:	18 95       	reti

00002170 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2170:	df 93       	push	r29
    2172:	cf 93       	push	r28
    2174:	00 d0       	rcall	.+0      	; 0x2176 <xQueueGenericReset+0x6>
    2176:	00 d0       	rcall	.+0      	; 0x2178 <xQueueGenericReset+0x8>
    2178:	0f 92       	push	r0
    217a:	cd b7       	in	r28, 0x3d	; 61
    217c:	de b7       	in	r29, 0x3e	; 62
    217e:	9c 83       	std	Y+4, r25	; 0x04
    2180:	8b 83       	std	Y+3, r24	; 0x03
    2182:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2184:	8b 81       	ldd	r24, Y+3	; 0x03
    2186:	9c 81       	ldd	r25, Y+4	; 0x04
    2188:	9a 83       	std	Y+2, r25	; 0x02
    218a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    218c:	0f b6       	in	r0, 0x3f	; 63
    218e:	f8 94       	cli
    2190:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    2192:	e9 81       	ldd	r30, Y+1	; 0x01
    2194:	fa 81       	ldd	r31, Y+2	; 0x02
    2196:	40 81       	ld	r20, Z
    2198:	51 81       	ldd	r21, Z+1	; 0x01
    219a:	e9 81       	ldd	r30, Y+1	; 0x01
    219c:	fa 81       	ldd	r31, Y+2	; 0x02
    219e:	83 8d       	ldd	r24, Z+27	; 0x1b
    21a0:	28 2f       	mov	r18, r24
    21a2:	30 e0       	ldi	r19, 0x00	; 0
    21a4:	e9 81       	ldd	r30, Y+1	; 0x01
    21a6:	fa 81       	ldd	r31, Y+2	; 0x02
    21a8:	84 8d       	ldd	r24, Z+28	; 0x1c
    21aa:	88 2f       	mov	r24, r24
    21ac:	90 e0       	ldi	r25, 0x00	; 0
    21ae:	bc 01       	movw	r22, r24
    21b0:	26 9f       	mul	r18, r22
    21b2:	c0 01       	movw	r24, r0
    21b4:	27 9f       	mul	r18, r23
    21b6:	90 0d       	add	r25, r0
    21b8:	36 9f       	mul	r19, r22
    21ba:	90 0d       	add	r25, r0
    21bc:	11 24       	eor	r1, r1
    21be:	84 0f       	add	r24, r20
    21c0:	95 1f       	adc	r25, r21
    21c2:	e9 81       	ldd	r30, Y+1	; 0x01
    21c4:	fa 81       	ldd	r31, Y+2	; 0x02
    21c6:	93 83       	std	Z+3, r25	; 0x03
    21c8:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    21ca:	e9 81       	ldd	r30, Y+1	; 0x01
    21cc:	fa 81       	ldd	r31, Y+2	; 0x02
    21ce:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    21d0:	e9 81       	ldd	r30, Y+1	; 0x01
    21d2:	fa 81       	ldd	r31, Y+2	; 0x02
    21d4:	80 81       	ld	r24, Z
    21d6:	91 81       	ldd	r25, Z+1	; 0x01
    21d8:	e9 81       	ldd	r30, Y+1	; 0x01
    21da:	fa 81       	ldd	r31, Y+2	; 0x02
    21dc:	95 83       	std	Z+5, r25	; 0x05
    21de:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    21e0:	e9 81       	ldd	r30, Y+1	; 0x01
    21e2:	fa 81       	ldd	r31, Y+2	; 0x02
    21e4:	40 81       	ld	r20, Z
    21e6:	51 81       	ldd	r21, Z+1	; 0x01
    21e8:	e9 81       	ldd	r30, Y+1	; 0x01
    21ea:	fa 81       	ldd	r31, Y+2	; 0x02
    21ec:	83 8d       	ldd	r24, Z+27	; 0x1b
    21ee:	88 2f       	mov	r24, r24
    21f0:	90 e0       	ldi	r25, 0x00	; 0
    21f2:	9c 01       	movw	r18, r24
    21f4:	21 50       	subi	r18, 0x01	; 1
    21f6:	30 40       	sbci	r19, 0x00	; 0
    21f8:	e9 81       	ldd	r30, Y+1	; 0x01
    21fa:	fa 81       	ldd	r31, Y+2	; 0x02
    21fc:	84 8d       	ldd	r24, Z+28	; 0x1c
    21fe:	88 2f       	mov	r24, r24
    2200:	90 e0       	ldi	r25, 0x00	; 0
    2202:	bc 01       	movw	r22, r24
    2204:	26 9f       	mul	r18, r22
    2206:	c0 01       	movw	r24, r0
    2208:	27 9f       	mul	r18, r23
    220a:	90 0d       	add	r25, r0
    220c:	36 9f       	mul	r19, r22
    220e:	90 0d       	add	r25, r0
    2210:	11 24       	eor	r1, r1
    2212:	84 0f       	add	r24, r20
    2214:	95 1f       	adc	r25, r21
    2216:	e9 81       	ldd	r30, Y+1	; 0x01
    2218:	fa 81       	ldd	r31, Y+2	; 0x02
    221a:	97 83       	std	Z+7, r25	; 0x07
    221c:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    221e:	e9 81       	ldd	r30, Y+1	; 0x01
    2220:	fa 81       	ldd	r31, Y+2	; 0x02
    2222:	8f ef       	ldi	r24, 0xFF	; 255
    2224:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    2226:	e9 81       	ldd	r30, Y+1	; 0x01
    2228:	fa 81       	ldd	r31, Y+2	; 0x02
    222a:	8f ef       	ldi	r24, 0xFF	; 255
    222c:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    222e:	8d 81       	ldd	r24, Y+5	; 0x05
    2230:	88 23       	and	r24, r24
    2232:	79 f4       	brne	.+30     	; 0x2252 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2234:	e9 81       	ldd	r30, Y+1	; 0x01
    2236:	fa 81       	ldd	r31, Y+2	; 0x02
    2238:	80 85       	ldd	r24, Z+8	; 0x08
    223a:	88 23       	and	r24, r24
    223c:	a1 f0       	breq	.+40     	; 0x2266 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    223e:	89 81       	ldd	r24, Y+1	; 0x01
    2240:	9a 81       	ldd	r25, Y+2	; 0x02
    2242:	08 96       	adiw	r24, 0x08	; 8
    2244:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <xTaskRemoveFromEventList>
    2248:	81 30       	cpi	r24, 0x01	; 1
    224a:	69 f4       	brne	.+26     	; 0x2266 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    224c:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
    2250:	0a c0       	rjmp	.+20     	; 0x2266 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2252:	89 81       	ldd	r24, Y+1	; 0x01
    2254:	9a 81       	ldd	r25, Y+2	; 0x02
    2256:	08 96       	adiw	r24, 0x08	; 8
    2258:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    225c:	89 81       	ldd	r24, Y+1	; 0x01
    225e:	9a 81       	ldd	r25, Y+2	; 0x02
    2260:	41 96       	adiw	r24, 0x11	; 17
    2262:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2266:	0f 90       	pop	r0
    2268:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    226a:	81 e0       	ldi	r24, 0x01	; 1
}
    226c:	0f 90       	pop	r0
    226e:	0f 90       	pop	r0
    2270:	0f 90       	pop	r0
    2272:	0f 90       	pop	r0
    2274:	0f 90       	pop	r0
    2276:	cf 91       	pop	r28
    2278:	df 91       	pop	r29
    227a:	08 95       	ret

0000227c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    227c:	df 93       	push	r29
    227e:	cf 93       	push	r28
    2280:	cd b7       	in	r28, 0x3d	; 61
    2282:	de b7       	in	r29, 0x3e	; 62
    2284:	29 97       	sbiw	r28, 0x09	; 9
    2286:	0f b6       	in	r0, 0x3f	; 63
    2288:	f8 94       	cli
    228a:	de bf       	out	0x3e, r29	; 62
    228c:	0f be       	out	0x3f, r0	; 63
    228e:	cd bf       	out	0x3d, r28	; 61
    2290:	8f 83       	std	Y+7, r24	; 0x07
    2292:	68 87       	std	Y+8, r22	; 0x08
    2294:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    2296:	1a 82       	std	Y+2, r1	; 0x02
    2298:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    229a:	8f 81       	ldd	r24, Y+7	; 0x07
    229c:	88 23       	and	r24, r24
    229e:	09 f4       	brne	.+2      	; 0x22a2 <xQueueGenericCreate+0x26>
    22a0:	3f c0       	rjmp	.+126    	; 0x2320 <xQueueGenericCreate+0xa4>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    22a2:	8f e1       	ldi	r24, 0x1F	; 31
    22a4:	90 e0       	ldi	r25, 0x00	; 0
    22a6:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <pvPortMalloc>
    22aa:	9e 83       	std	Y+6, r25	; 0x06
    22ac:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    22ae:	8d 81       	ldd	r24, Y+5	; 0x05
    22b0:	9e 81       	ldd	r25, Y+6	; 0x06
    22b2:	00 97       	sbiw	r24, 0x00	; 0
    22b4:	a9 f1       	breq	.+106    	; 0x2320 <xQueueGenericCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    22b6:	8f 81       	ldd	r24, Y+7	; 0x07
    22b8:	28 2f       	mov	r18, r24
    22ba:	30 e0       	ldi	r19, 0x00	; 0
    22bc:	88 85       	ldd	r24, Y+8	; 0x08
    22be:	88 2f       	mov	r24, r24
    22c0:	90 e0       	ldi	r25, 0x00	; 0
    22c2:	ac 01       	movw	r20, r24
    22c4:	24 9f       	mul	r18, r20
    22c6:	c0 01       	movw	r24, r0
    22c8:	25 9f       	mul	r18, r21
    22ca:	90 0d       	add	r25, r0
    22cc:	34 9f       	mul	r19, r20
    22ce:	90 0d       	add	r25, r0
    22d0:	11 24       	eor	r1, r1
    22d2:	01 96       	adiw	r24, 0x01	; 1
    22d4:	9c 83       	std	Y+4, r25	; 0x04
    22d6:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    22d8:	8b 81       	ldd	r24, Y+3	; 0x03
    22da:	9c 81       	ldd	r25, Y+4	; 0x04
    22dc:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <pvPortMalloc>
    22e0:	ed 81       	ldd	r30, Y+5	; 0x05
    22e2:	fe 81       	ldd	r31, Y+6	; 0x06
    22e4:	91 83       	std	Z+1, r25	; 0x01
    22e6:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    22e8:	ed 81       	ldd	r30, Y+5	; 0x05
    22ea:	fe 81       	ldd	r31, Y+6	; 0x06
    22ec:	80 81       	ld	r24, Z
    22ee:	91 81       	ldd	r25, Z+1	; 0x01
    22f0:	00 97       	sbiw	r24, 0x00	; 0
    22f2:	91 f0       	breq	.+36     	; 0x2318 <xQueueGenericCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    22f4:	ed 81       	ldd	r30, Y+5	; 0x05
    22f6:	fe 81       	ldd	r31, Y+6	; 0x06
    22f8:	8f 81       	ldd	r24, Y+7	; 0x07
    22fa:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    22fc:	ed 81       	ldd	r30, Y+5	; 0x05
    22fe:	fe 81       	ldd	r31, Y+6	; 0x06
    2300:	88 85       	ldd	r24, Y+8	; 0x08
    2302:	84 8f       	std	Z+28, r24	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2304:	8d 81       	ldd	r24, Y+5	; 0x05
    2306:	9e 81       	ldd	r25, Y+6	; 0x06
    2308:	61 e0       	ldi	r22, 0x01	; 1
    230a:	0e 94 b8 10 	call	0x2170	; 0x2170 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    230e:	8d 81       	ldd	r24, Y+5	; 0x05
    2310:	9e 81       	ldd	r25, Y+6	; 0x06
    2312:	9a 83       	std	Y+2, r25	; 0x02
    2314:	89 83       	std	Y+1, r24	; 0x01
    2316:	04 c0       	rjmp	.+8      	; 0x2320 <xQueueGenericCreate+0xa4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    2318:	8d 81       	ldd	r24, Y+5	; 0x05
    231a:	9e 81       	ldd	r25, Y+6	; 0x06
    231c:	0e 94 b6 0b 	call	0x176c	; 0x176c <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    2320:	89 81       	ldd	r24, Y+1	; 0x01
    2322:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2324:	29 96       	adiw	r28, 0x09	; 9
    2326:	0f b6       	in	r0, 0x3f	; 63
    2328:	f8 94       	cli
    232a:	de bf       	out	0x3e, r29	; 62
    232c:	0f be       	out	0x3f, r0	; 63
    232e:	cd bf       	out	0x3d, r28	; 61
    2330:	cf 91       	pop	r28
    2332:	df 91       	pop	r29
    2334:	08 95       	ret

00002336 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    2336:	df 93       	push	r29
    2338:	cf 93       	push	r28
    233a:	00 d0       	rcall	.+0      	; 0x233c <xQueueCreateMutex+0x6>
    233c:	0f 92       	push	r0
    233e:	cd b7       	in	r28, 0x3d	; 61
    2340:	de b7       	in	r29, 0x3e	; 62
    2342:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    2344:	8f e1       	ldi	r24, 0x1F	; 31
    2346:	90 e0       	ldi	r25, 0x00	; 0
    2348:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <pvPortMalloc>
    234c:	9a 83       	std	Y+2, r25	; 0x02
    234e:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    2350:	89 81       	ldd	r24, Y+1	; 0x01
    2352:	9a 81       	ldd	r25, Y+2	; 0x02
    2354:	00 97       	sbiw	r24, 0x00	; 0
    2356:	a9 f1       	breq	.+106    	; 0x23c2 <xQueueCreateMutex+0x8c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    2358:	e9 81       	ldd	r30, Y+1	; 0x01
    235a:	fa 81       	ldd	r31, Y+2	; 0x02
    235c:	13 82       	std	Z+3, r1	; 0x03
    235e:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    2360:	e9 81       	ldd	r30, Y+1	; 0x01
    2362:	fa 81       	ldd	r31, Y+2	; 0x02
    2364:	11 82       	std	Z+1, r1	; 0x01
    2366:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    2368:	e9 81       	ldd	r30, Y+1	; 0x01
    236a:	fa 81       	ldd	r31, Y+2	; 0x02
    236c:	15 82       	std	Z+5, r1	; 0x05
    236e:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    2370:	e9 81       	ldd	r30, Y+1	; 0x01
    2372:	fa 81       	ldd	r31, Y+2	; 0x02
    2374:	17 82       	std	Z+7, r1	; 0x07
    2376:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2378:	e9 81       	ldd	r30, Y+1	; 0x01
    237a:	fa 81       	ldd	r31, Y+2	; 0x02
    237c:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    237e:	e9 81       	ldd	r30, Y+1	; 0x01
    2380:	fa 81       	ldd	r31, Y+2	; 0x02
    2382:	81 e0       	ldi	r24, 0x01	; 1
    2384:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    2386:	e9 81       	ldd	r30, Y+1	; 0x01
    2388:	fa 81       	ldd	r31, Y+2	; 0x02
    238a:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    238c:	e9 81       	ldd	r30, Y+1	; 0x01
    238e:	fa 81       	ldd	r31, Y+2	; 0x02
    2390:	8f ef       	ldi	r24, 0xFF	; 255
    2392:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    2394:	e9 81       	ldd	r30, Y+1	; 0x01
    2396:	fa 81       	ldd	r31, Y+2	; 0x02
    2398:	8f ef       	ldi	r24, 0xFF	; 255
    239a:	86 8f       	std	Z+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    239c:	89 81       	ldd	r24, Y+1	; 0x01
    239e:	9a 81       	ldd	r25, Y+2	; 0x02
    23a0:	08 96       	adiw	r24, 0x08	; 8
    23a2:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    23a6:	89 81       	ldd	r24, Y+1	; 0x01
    23a8:	9a 81       	ldd	r25, Y+2	; 0x02
    23aa:	41 96       	adiw	r24, 0x11	; 17
    23ac:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    23b0:	89 81       	ldd	r24, Y+1	; 0x01
    23b2:	9a 81       	ldd	r25, Y+2	; 0x02
    23b4:	60 e0       	ldi	r22, 0x00	; 0
    23b6:	70 e0       	ldi	r23, 0x00	; 0
    23b8:	40 e0       	ldi	r20, 0x00	; 0
    23ba:	50 e0       	ldi	r21, 0x00	; 0
    23bc:	20 e0       	ldi	r18, 0x00	; 0
    23be:	0e 94 09 12 	call	0x2412	; 0x2412 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    23c2:	89 81       	ldd	r24, Y+1	; 0x01
    23c4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    23c6:	0f 90       	pop	r0
    23c8:	0f 90       	pop	r0
    23ca:	0f 90       	pop	r0
    23cc:	cf 91       	pop	r28
    23ce:	df 91       	pop	r29
    23d0:	08 95       	ret

000023d2 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    23d2:	df 93       	push	r29
    23d4:	cf 93       	push	r28
    23d6:	00 d0       	rcall	.+0      	; 0x23d8 <xQueueCreateCountingSemaphore+0x6>
    23d8:	00 d0       	rcall	.+0      	; 0x23da <xQueueCreateCountingSemaphore+0x8>
    23da:	cd b7       	in	r28, 0x3d	; 61
    23dc:	de b7       	in	r29, 0x3e	; 62
    23de:	8b 83       	std	Y+3, r24	; 0x03
    23e0:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    23e2:	8b 81       	ldd	r24, Y+3	; 0x03
    23e4:	60 e0       	ldi	r22, 0x00	; 0
    23e6:	42 e0       	ldi	r20, 0x02	; 2
    23e8:	0e 94 3e 11 	call	0x227c	; 0x227c <xQueueGenericCreate>
    23ec:	9a 83       	std	Y+2, r25	; 0x02
    23ee:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    23f0:	89 81       	ldd	r24, Y+1	; 0x01
    23f2:	9a 81       	ldd	r25, Y+2	; 0x02
    23f4:	00 97       	sbiw	r24, 0x00	; 0
    23f6:	21 f0       	breq	.+8      	; 0x2400 <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    23f8:	e9 81       	ldd	r30, Y+1	; 0x01
    23fa:	fa 81       	ldd	r31, Y+2	; 0x02
    23fc:	8c 81       	ldd	r24, Y+4	; 0x04
    23fe:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
    2400:	89 81       	ldd	r24, Y+1	; 0x01
    2402:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    2404:	0f 90       	pop	r0
    2406:	0f 90       	pop	r0
    2408:	0f 90       	pop	r0
    240a:	0f 90       	pop	r0
    240c:	cf 91       	pop	r28
    240e:	df 91       	pop	r29
    2410:	08 95       	ret

00002412 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2412:	df 93       	push	r29
    2414:	cf 93       	push	r28
    2416:	cd b7       	in	r28, 0x3d	; 61
    2418:	de b7       	in	r29, 0x3e	; 62
    241a:	2f 97       	sbiw	r28, 0x0f	; 15
    241c:	0f b6       	in	r0, 0x3f	; 63
    241e:	f8 94       	cli
    2420:	de bf       	out	0x3e, r29	; 62
    2422:	0f be       	out	0x3f, r0	; 63
    2424:	cd bf       	out	0x3d, r28	; 61
    2426:	99 87       	std	Y+9, r25	; 0x09
    2428:	88 87       	std	Y+8, r24	; 0x08
    242a:	7b 87       	std	Y+11, r23	; 0x0b
    242c:	6a 87       	std	Y+10, r22	; 0x0a
    242e:	5d 87       	std	Y+13, r21	; 0x0d
    2430:	4c 87       	std	Y+12, r20	; 0x0c
    2432:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2434:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2436:	88 85       	ldd	r24, Y+8	; 0x08
    2438:	99 85       	ldd	r25, Y+9	; 0x09
    243a:	9a 83       	std	Y+2, r25	; 0x02
    243c:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    243e:	0f b6       	in	r0, 0x3f	; 63
    2440:	f8 94       	cli
    2442:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2444:	e9 81       	ldd	r30, Y+1	; 0x01
    2446:	fa 81       	ldd	r31, Y+2	; 0x02
    2448:	92 8d       	ldd	r25, Z+26	; 0x1a
    244a:	e9 81       	ldd	r30, Y+1	; 0x01
    244c:	fa 81       	ldd	r31, Y+2	; 0x02
    244e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2450:	98 17       	cp	r25, r24
    2452:	18 f0       	brcs	.+6      	; 0x245a <xQueueGenericSend+0x48>
    2454:	8e 85       	ldd	r24, Y+14	; 0x0e
    2456:	82 30       	cpi	r24, 0x02	; 2
    2458:	11 f5       	brne	.+68     	; 0x249e <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    245a:	89 81       	ldd	r24, Y+1	; 0x01
    245c:	9a 81       	ldd	r25, Y+2	; 0x02
    245e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2460:	3b 85       	ldd	r19, Y+11	; 0x0b
    2462:	b9 01       	movw	r22, r18
    2464:	4e 85       	ldd	r20, Y+14	; 0x0e
    2466:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <prvCopyDataToQueue>
    246a:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    246c:	e9 81       	ldd	r30, Y+1	; 0x01
    246e:	fa 81       	ldd	r31, Y+2	; 0x02
    2470:	81 89       	ldd	r24, Z+17	; 0x11
    2472:	88 23       	and	r24, r24
    2474:	51 f0       	breq	.+20     	; 0x248a <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2476:	89 81       	ldd	r24, Y+1	; 0x01
    2478:	9a 81       	ldd	r25, Y+2	; 0x02
    247a:	41 96       	adiw	r24, 0x11	; 17
    247c:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <xTaskRemoveFromEventList>
    2480:	81 30       	cpi	r24, 0x01	; 1
    2482:	41 f4       	brne	.+16     	; 0x2494 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2484:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
    2488:	05 c0       	rjmp	.+10     	; 0x2494 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    248a:	8b 81       	ldd	r24, Y+3	; 0x03
    248c:	88 23       	and	r24, r24
    248e:	11 f0       	breq	.+4      	; 0x2494 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2490:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2494:	0f 90       	pop	r0
    2496:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2498:	81 e0       	ldi	r24, 0x01	; 1
    249a:	8f 87       	std	Y+15, r24	; 0x0f
    249c:	5c c0       	rjmp	.+184    	; 0x2556 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    249e:	8c 85       	ldd	r24, Y+12	; 0x0c
    24a0:	9d 85       	ldd	r25, Y+13	; 0x0d
    24a2:	00 97       	sbiw	r24, 0x00	; 0
    24a4:	21 f4       	brne	.+8      	; 0x24ae <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    24a6:	0f 90       	pop	r0
    24a8:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    24aa:	1f 86       	std	Y+15, r1	; 0x0f
    24ac:	54 c0       	rjmp	.+168    	; 0x2556 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    24ae:	8c 81       	ldd	r24, Y+4	; 0x04
    24b0:	88 23       	and	r24, r24
    24b2:	31 f4       	brne	.+12     	; 0x24c0 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    24b4:	ce 01       	movw	r24, r28
    24b6:	05 96       	adiw	r24, 0x05	; 5
    24b8:	0e 94 2b 1e 	call	0x3c56	; 0x3c56 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    24bc:	81 e0       	ldi	r24, 0x01	; 1
    24be:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    24c0:	0f 90       	pop	r0
    24c2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    24c4:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    24c8:	0f b6       	in	r0, 0x3f	; 63
    24ca:	f8 94       	cli
    24cc:	0f 92       	push	r0
    24ce:	e9 81       	ldd	r30, Y+1	; 0x01
    24d0:	fa 81       	ldd	r31, Y+2	; 0x02
    24d2:	85 8d       	ldd	r24, Z+29	; 0x1d
    24d4:	8f 3f       	cpi	r24, 0xFF	; 255
    24d6:	19 f4       	brne	.+6      	; 0x24de <xQueueGenericSend+0xcc>
    24d8:	e9 81       	ldd	r30, Y+1	; 0x01
    24da:	fa 81       	ldd	r31, Y+2	; 0x02
    24dc:	15 8e       	std	Z+29, r1	; 0x1d
    24de:	e9 81       	ldd	r30, Y+1	; 0x01
    24e0:	fa 81       	ldd	r31, Y+2	; 0x02
    24e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    24e4:	8f 3f       	cpi	r24, 0xFF	; 255
    24e6:	19 f4       	brne	.+6      	; 0x24ee <xQueueGenericSend+0xdc>
    24e8:	e9 81       	ldd	r30, Y+1	; 0x01
    24ea:	fa 81       	ldd	r31, Y+2	; 0x02
    24ec:	16 8e       	std	Z+30, r1	; 0x1e
    24ee:	0f 90       	pop	r0
    24f0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    24f2:	ce 01       	movw	r24, r28
    24f4:	05 96       	adiw	r24, 0x05	; 5
    24f6:	9e 01       	movw	r18, r28
    24f8:	24 5f       	subi	r18, 0xF4	; 244
    24fa:	3f 4f       	sbci	r19, 0xFF	; 255
    24fc:	b9 01       	movw	r22, r18
    24fe:	0e 94 44 1e 	call	0x3c88	; 0x3c88 <xTaskCheckForTimeOut>
    2502:	88 23       	and	r24, r24
    2504:	09 f5       	brne	.+66     	; 0x2548 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2506:	89 81       	ldd	r24, Y+1	; 0x01
    2508:	9a 81       	ldd	r25, Y+2	; 0x02
    250a:	0e 94 84 16 	call	0x2d08	; 0x2d08 <prvIsQueueFull>
    250e:	88 23       	and	r24, r24
    2510:	a1 f0       	breq	.+40     	; 0x253a <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2512:	89 81       	ldd	r24, Y+1	; 0x01
    2514:	9a 81       	ldd	r25, Y+2	; 0x02
    2516:	08 96       	adiw	r24, 0x08	; 8
    2518:	2c 85       	ldd	r18, Y+12	; 0x0c
    251a:	3d 85       	ldd	r19, Y+13	; 0x0d
    251c:	b9 01       	movw	r22, r18
    251e:	0e 94 e3 1c 	call	0x39c6	; 0x39c6 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2522:	89 81       	ldd	r24, Y+1	; 0x01
    2524:	9a 81       	ldd	r25, Y+2	; 0x02
    2526:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    252a:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>
    252e:	88 23       	and	r24, r24
    2530:	09 f0       	breq	.+2      	; 0x2534 <xQueueGenericSend+0x122>
    2532:	85 cf       	rjmp	.-246    	; 0x243e <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2534:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
    2538:	82 cf       	rjmp	.-252    	; 0x243e <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    253a:	89 81       	ldd	r24, Y+1	; 0x01
    253c:	9a 81       	ldd	r25, Y+2	; 0x02
    253e:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2542:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>
    2546:	7b cf       	rjmp	.-266    	; 0x243e <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2548:	89 81       	ldd	r24, Y+1	; 0x01
    254a:	9a 81       	ldd	r25, Y+2	; 0x02
    254c:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2550:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2554:	1f 86       	std	Y+15, r1	; 0x0f
    2556:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    2558:	2f 96       	adiw	r28, 0x0f	; 15
    255a:	0f b6       	in	r0, 0x3f	; 63
    255c:	f8 94       	cli
    255e:	de bf       	out	0x3e, r29	; 62
    2560:	0f be       	out	0x3f, r0	; 63
    2562:	cd bf       	out	0x3d, r28	; 61
    2564:	cf 91       	pop	r28
    2566:	df 91       	pop	r29
    2568:	08 95       	ret

0000256a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    256a:	df 93       	push	r29
    256c:	cf 93       	push	r28
    256e:	cd b7       	in	r28, 0x3d	; 61
    2570:	de b7       	in	r29, 0x3e	; 62
    2572:	2b 97       	sbiw	r28, 0x0b	; 11
    2574:	0f b6       	in	r0, 0x3f	; 63
    2576:	f8 94       	cli
    2578:	de bf       	out	0x3e, r29	; 62
    257a:	0f be       	out	0x3f, r0	; 63
    257c:	cd bf       	out	0x3d, r28	; 61
    257e:	9e 83       	std	Y+6, r25	; 0x06
    2580:	8d 83       	std	Y+5, r24	; 0x05
    2582:	78 87       	std	Y+8, r23	; 0x08
    2584:	6f 83       	std	Y+7, r22	; 0x07
    2586:	5a 87       	std	Y+10, r21	; 0x0a
    2588:	49 87       	std	Y+9, r20	; 0x09
    258a:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    258c:	8d 81       	ldd	r24, Y+5	; 0x05
    258e:	9e 81       	ldd	r25, Y+6	; 0x06
    2590:	9a 83       	std	Y+2, r25	; 0x02
    2592:	89 83       	std	Y+1, r24	; 0x01
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2594:	1b 82       	std	Y+3, r1	; 0x03
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2596:	e9 81       	ldd	r30, Y+1	; 0x01
    2598:	fa 81       	ldd	r31, Y+2	; 0x02
    259a:	92 8d       	ldd	r25, Z+26	; 0x1a
    259c:	e9 81       	ldd	r30, Y+1	; 0x01
    259e:	fa 81       	ldd	r31, Y+2	; 0x02
    25a0:	83 8d       	ldd	r24, Z+27	; 0x1b
    25a2:	98 17       	cp	r25, r24
    25a4:	18 f0       	brcs	.+6      	; 0x25ac <xQueueGenericSendFromISR+0x42>
    25a6:	8b 85       	ldd	r24, Y+11	; 0x0b
    25a8:	82 30       	cpi	r24, 0x02	; 2
    25aa:	b1 f5       	brne	.+108    	; 0x2618 <xQueueGenericSendFromISR+0xae>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    25ac:	89 81       	ldd	r24, Y+1	; 0x01
    25ae:	9a 81       	ldd	r25, Y+2	; 0x02
    25b0:	2f 81       	ldd	r18, Y+7	; 0x07
    25b2:	38 85       	ldd	r19, Y+8	; 0x08
    25b4:	b9 01       	movw	r22, r18
    25b6:	4b 85       	ldd	r20, Y+11	; 0x0b
    25b8:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <prvCopyDataToQueue>
    25bc:	88 23       	and	r24, r24
    25be:	41 f0       	breq	.+16     	; 0x25d0 <xQueueGenericSendFromISR+0x66>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    25c0:	89 85       	ldd	r24, Y+9	; 0x09
    25c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    25c4:	00 97       	sbiw	r24, 0x00	; 0
    25c6:	21 f0       	breq	.+8      	; 0x25d0 <xQueueGenericSendFromISR+0x66>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    25c8:	e9 85       	ldd	r30, Y+9	; 0x09
    25ca:	fa 85       	ldd	r31, Y+10	; 0x0a
    25cc:	81 e0       	ldi	r24, 0x01	; 1
    25ce:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    25d0:	e9 81       	ldd	r30, Y+1	; 0x01
    25d2:	fa 81       	ldd	r31, Y+2	; 0x02
    25d4:	86 8d       	ldd	r24, Z+30	; 0x1e
    25d6:	8f 3f       	cpi	r24, 0xFF	; 255
    25d8:	a9 f4       	brne	.+42     	; 0x2604 <xQueueGenericSendFromISR+0x9a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25da:	e9 81       	ldd	r30, Y+1	; 0x01
    25dc:	fa 81       	ldd	r31, Y+2	; 0x02
    25de:	81 89       	ldd	r24, Z+17	; 0x11
    25e0:	88 23       	and	r24, r24
    25e2:	b9 f0       	breq	.+46     	; 0x2612 <xQueueGenericSendFromISR+0xa8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    25e4:	89 81       	ldd	r24, Y+1	; 0x01
    25e6:	9a 81       	ldd	r25, Y+2	; 0x02
    25e8:	41 96       	adiw	r24, 0x11	; 17
    25ea:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <xTaskRemoveFromEventList>
    25ee:	88 23       	and	r24, r24
    25f0:	81 f0       	breq	.+32     	; 0x2612 <xQueueGenericSendFromISR+0xa8>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    25f2:	89 85       	ldd	r24, Y+9	; 0x09
    25f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    25f6:	00 97       	sbiw	r24, 0x00	; 0
    25f8:	61 f0       	breq	.+24     	; 0x2612 <xQueueGenericSendFromISR+0xa8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    25fa:	e9 85       	ldd	r30, Y+9	; 0x09
    25fc:	fa 85       	ldd	r31, Y+10	; 0x0a
    25fe:	81 e0       	ldi	r24, 0x01	; 1
    2600:	80 83       	st	Z, r24
    2602:	07 c0       	rjmp	.+14     	; 0x2612 <xQueueGenericSendFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2604:	e9 81       	ldd	r30, Y+1	; 0x01
    2606:	fa 81       	ldd	r31, Y+2	; 0x02
    2608:	86 8d       	ldd	r24, Z+30	; 0x1e
    260a:	8f 5f       	subi	r24, 0xFF	; 255
    260c:	e9 81       	ldd	r30, Y+1	; 0x01
    260e:	fa 81       	ldd	r31, Y+2	; 0x02
    2610:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2612:	81 e0       	ldi	r24, 0x01	; 1
    2614:	8c 83       	std	Y+4, r24	; 0x04
    2616:	01 c0       	rjmp	.+2      	; 0x261a <xQueueGenericSendFromISR+0xb0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2618:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    261a:	8c 81       	ldd	r24, Y+4	; 0x04
}
    261c:	2b 96       	adiw	r28, 0x0b	; 11
    261e:	0f b6       	in	r0, 0x3f	; 63
    2620:	f8 94       	cli
    2622:	de bf       	out	0x3e, r29	; 62
    2624:	0f be       	out	0x3f, r0	; 63
    2626:	cd bf       	out	0x3d, r28	; 61
    2628:	cf 91       	pop	r28
    262a:	df 91       	pop	r29
    262c:	08 95       	ret

0000262e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    262e:	df 93       	push	r29
    2630:	cf 93       	push	r28
    2632:	cd b7       	in	r28, 0x3d	; 61
    2634:	de b7       	in	r29, 0x3e	; 62
    2636:	60 97       	sbiw	r28, 0x10	; 16
    2638:	0f b6       	in	r0, 0x3f	; 63
    263a:	f8 94       	cli
    263c:	de bf       	out	0x3e, r29	; 62
    263e:	0f be       	out	0x3f, r0	; 63
    2640:	cd bf       	out	0x3d, r28	; 61
    2642:	9a 87       	std	Y+10, r25	; 0x0a
    2644:	89 87       	std	Y+9, r24	; 0x09
    2646:	7c 87       	std	Y+12, r23	; 0x0c
    2648:	6b 87       	std	Y+11, r22	; 0x0b
    264a:	5e 87       	std	Y+14, r21	; 0x0e
    264c:	4d 87       	std	Y+13, r20	; 0x0d
    264e:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    2650:	1d 82       	std	Y+5, r1	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2652:	89 85       	ldd	r24, Y+9	; 0x09
    2654:	9a 85       	ldd	r25, Y+10	; 0x0a
    2656:	9a 83       	std	Y+2, r25	; 0x02
    2658:	89 83       	std	Y+1, r24	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    265a:	0f b6       	in	r0, 0x3f	; 63
    265c:	f8 94       	cli
    265e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2660:	e9 81       	ldd	r30, Y+1	; 0x01
    2662:	fa 81       	ldd	r31, Y+2	; 0x02
    2664:	82 8d       	ldd	r24, Z+26	; 0x1a
    2666:	88 23       	and	r24, r24
    2668:	09 f4       	brne	.+2      	; 0x266c <xQueueGenericReceive+0x3e>
    266a:	4b c0       	rjmp	.+150    	; 0x2702 <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    266c:	e9 81       	ldd	r30, Y+1	; 0x01
    266e:	fa 81       	ldd	r31, Y+2	; 0x02
    2670:	86 81       	ldd	r24, Z+6	; 0x06
    2672:	97 81       	ldd	r25, Z+7	; 0x07
    2674:	9c 83       	std	Y+4, r25	; 0x04
    2676:	8b 83       	std	Y+3, r24	; 0x03

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2678:	89 81       	ldd	r24, Y+1	; 0x01
    267a:	9a 81       	ldd	r25, Y+2	; 0x02
    267c:	2b 85       	ldd	r18, Y+11	; 0x0b
    267e:	3c 85       	ldd	r19, Y+12	; 0x0c
    2680:	b9 01       	movw	r22, r18
    2682:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2686:	8f 85       	ldd	r24, Y+15	; 0x0f
    2688:	88 23       	and	r24, r24
    268a:	11 f5       	brne	.+68     	; 0x26d0 <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    268c:	e9 81       	ldd	r30, Y+1	; 0x01
    268e:	fa 81       	ldd	r31, Y+2	; 0x02
    2690:	82 8d       	ldd	r24, Z+26	; 0x1a
    2692:	81 50       	subi	r24, 0x01	; 1
    2694:	e9 81       	ldd	r30, Y+1	; 0x01
    2696:	fa 81       	ldd	r31, Y+2	; 0x02
    2698:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    269a:	e9 81       	ldd	r30, Y+1	; 0x01
    269c:	fa 81       	ldd	r31, Y+2	; 0x02
    269e:	80 81       	ld	r24, Z
    26a0:	91 81       	ldd	r25, Z+1	; 0x01
    26a2:	00 97       	sbiw	r24, 0x00	; 0
    26a4:	31 f4       	brne	.+12     	; 0x26b2 <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    26a6:	0e 94 bb 21 	call	0x4376	; 0x4376 <pvTaskIncrementMutexHeldCount>
    26aa:	e9 81       	ldd	r30, Y+1	; 0x01
    26ac:	fa 81       	ldd	r31, Y+2	; 0x02
    26ae:	93 83       	std	Z+3, r25	; 0x03
    26b0:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    26b2:	e9 81       	ldd	r30, Y+1	; 0x01
    26b4:	fa 81       	ldd	r31, Y+2	; 0x02
    26b6:	80 85       	ldd	r24, Z+8	; 0x08
    26b8:	88 23       	and	r24, r24
    26ba:	f1 f0       	breq	.+60     	; 0x26f8 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    26bc:	89 81       	ldd	r24, Y+1	; 0x01
    26be:	9a 81       	ldd	r25, Y+2	; 0x02
    26c0:	08 96       	adiw	r24, 0x08	; 8
    26c2:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <xTaskRemoveFromEventList>
    26c6:	81 30       	cpi	r24, 0x01	; 1
    26c8:	b9 f4       	brne	.+46     	; 0x26f8 <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    26ca:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
    26ce:	14 c0       	rjmp	.+40     	; 0x26f8 <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    26d0:	e9 81       	ldd	r30, Y+1	; 0x01
    26d2:	fa 81       	ldd	r31, Y+2	; 0x02
    26d4:	8b 81       	ldd	r24, Y+3	; 0x03
    26d6:	9c 81       	ldd	r25, Y+4	; 0x04
    26d8:	97 83       	std	Z+7, r25	; 0x07
    26da:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    26dc:	e9 81       	ldd	r30, Y+1	; 0x01
    26de:	fa 81       	ldd	r31, Y+2	; 0x02
    26e0:	81 89       	ldd	r24, Z+17	; 0x11
    26e2:	88 23       	and	r24, r24
    26e4:	49 f0       	breq	.+18     	; 0x26f8 <xQueueGenericReceive+0xca>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    26e6:	89 81       	ldd	r24, Y+1	; 0x01
    26e8:	9a 81       	ldd	r25, Y+2	; 0x02
    26ea:	41 96       	adiw	r24, 0x11	; 17
    26ec:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <xTaskRemoveFromEventList>
    26f0:	88 23       	and	r24, r24
    26f2:	11 f0       	breq	.+4      	; 0x26f8 <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    26f4:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    26f8:	0f 90       	pop	r0
    26fa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    26fc:	81 e0       	ldi	r24, 0x01	; 1
    26fe:	88 8b       	std	Y+16, r24	; 0x10
    2700:	6d c0       	rjmp	.+218    	; 0x27dc <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2702:	8d 85       	ldd	r24, Y+13	; 0x0d
    2704:	9e 85       	ldd	r25, Y+14	; 0x0e
    2706:	00 97       	sbiw	r24, 0x00	; 0
    2708:	21 f4       	brne	.+8      	; 0x2712 <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    270a:	0f 90       	pop	r0
    270c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    270e:	18 8a       	std	Y+16, r1	; 0x10
    2710:	65 c0       	rjmp	.+202    	; 0x27dc <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
    2712:	8d 81       	ldd	r24, Y+5	; 0x05
    2714:	88 23       	and	r24, r24
    2716:	31 f4       	brne	.+12     	; 0x2724 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2718:	ce 01       	movw	r24, r28
    271a:	06 96       	adiw	r24, 0x06	; 6
    271c:	0e 94 2b 1e 	call	0x3c56	; 0x3c56 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2720:	81 e0       	ldi	r24, 0x01	; 1
    2722:	8d 83       	std	Y+5, r24	; 0x05
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2724:	0f 90       	pop	r0
    2726:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2728:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    272c:	0f b6       	in	r0, 0x3f	; 63
    272e:	f8 94       	cli
    2730:	0f 92       	push	r0
    2732:	e9 81       	ldd	r30, Y+1	; 0x01
    2734:	fa 81       	ldd	r31, Y+2	; 0x02
    2736:	85 8d       	ldd	r24, Z+29	; 0x1d
    2738:	8f 3f       	cpi	r24, 0xFF	; 255
    273a:	19 f4       	brne	.+6      	; 0x2742 <xQueueGenericReceive+0x114>
    273c:	e9 81       	ldd	r30, Y+1	; 0x01
    273e:	fa 81       	ldd	r31, Y+2	; 0x02
    2740:	15 8e       	std	Z+29, r1	; 0x1d
    2742:	e9 81       	ldd	r30, Y+1	; 0x01
    2744:	fa 81       	ldd	r31, Y+2	; 0x02
    2746:	86 8d       	ldd	r24, Z+30	; 0x1e
    2748:	8f 3f       	cpi	r24, 0xFF	; 255
    274a:	19 f4       	brne	.+6      	; 0x2752 <xQueueGenericReceive+0x124>
    274c:	e9 81       	ldd	r30, Y+1	; 0x01
    274e:	fa 81       	ldd	r31, Y+2	; 0x02
    2750:	16 8e       	std	Z+30, r1	; 0x1e
    2752:	0f 90       	pop	r0
    2754:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2756:	ce 01       	movw	r24, r28
    2758:	06 96       	adiw	r24, 0x06	; 6
    275a:	9e 01       	movw	r18, r28
    275c:	23 5f       	subi	r18, 0xF3	; 243
    275e:	3f 4f       	sbci	r19, 0xFF	; 255
    2760:	b9 01       	movw	r22, r18
    2762:	0e 94 44 1e 	call	0x3c88	; 0x3c88 <xTaskCheckForTimeOut>
    2766:	88 23       	and	r24, r24
    2768:	91 f5       	brne	.+100    	; 0x27ce <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    276a:	89 81       	ldd	r24, Y+1	; 0x01
    276c:	9a 81       	ldd	r25, Y+2	; 0x02
    276e:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <prvIsQueueEmpty>
    2772:	88 23       	and	r24, r24
    2774:	29 f1       	breq	.+74     	; 0x27c0 <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2776:	e9 81       	ldd	r30, Y+1	; 0x01
    2778:	fa 81       	ldd	r31, Y+2	; 0x02
    277a:	80 81       	ld	r24, Z
    277c:	91 81       	ldd	r25, Z+1	; 0x01
    277e:	00 97       	sbiw	r24, 0x00	; 0
    2780:	59 f4       	brne	.+22     	; 0x2798 <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    2782:	0f b6       	in	r0, 0x3f	; 63
    2784:	f8 94       	cli
    2786:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2788:	e9 81       	ldd	r30, Y+1	; 0x01
    278a:	fa 81       	ldd	r31, Y+2	; 0x02
    278c:	82 81       	ldd	r24, Z+2	; 0x02
    278e:	93 81       	ldd	r25, Z+3	; 0x03
    2790:	0e 94 97 20 	call	0x412e	; 0x412e <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    2794:	0f 90       	pop	r0
    2796:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2798:	89 81       	ldd	r24, Y+1	; 0x01
    279a:	9a 81       	ldd	r25, Y+2	; 0x02
    279c:	41 96       	adiw	r24, 0x11	; 17
    279e:	2d 85       	ldd	r18, Y+13	; 0x0d
    27a0:	3e 85       	ldd	r19, Y+14	; 0x0e
    27a2:	b9 01       	movw	r22, r18
    27a4:	0e 94 e3 1c 	call	0x39c6	; 0x39c6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    27a8:	89 81       	ldd	r24, Y+1	; 0x01
    27aa:	9a 81       	ldd	r25, Y+2	; 0x02
    27ac:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    27b0:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>
    27b4:	88 23       	and	r24, r24
    27b6:	09 f0       	breq	.+2      	; 0x27ba <xQueueGenericReceive+0x18c>
    27b8:	50 cf       	rjmp	.-352    	; 0x265a <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    27ba:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
    27be:	4d cf       	rjmp	.-358    	; 0x265a <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    27c0:	89 81       	ldd	r24, Y+1	; 0x01
    27c2:	9a 81       	ldd	r25, Y+2	; 0x02
    27c4:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    27c8:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>
    27cc:	46 cf       	rjmp	.-372    	; 0x265a <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    27ce:	89 81       	ldd	r24, Y+1	; 0x01
    27d0:	9a 81       	ldd	r25, Y+2	; 0x02
    27d2:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    27d6:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    27da:	18 8a       	std	Y+16, r1	; 0x10
    27dc:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    27de:	60 96       	adiw	r28, 0x10	; 16
    27e0:	0f b6       	in	r0, 0x3f	; 63
    27e2:	f8 94       	cli
    27e4:	de bf       	out	0x3e, r29	; 62
    27e6:	0f be       	out	0x3f, r0	; 63
    27e8:	cd bf       	out	0x3d, r28	; 61
    27ea:	cf 91       	pop	r28
    27ec:	df 91       	pop	r29
    27ee:	08 95       	ret

000027f0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    27f0:	df 93       	push	r29
    27f2:	cf 93       	push	r28
    27f4:	cd b7       	in	r28, 0x3d	; 61
    27f6:	de b7       	in	r29, 0x3e	; 62
    27f8:	2a 97       	sbiw	r28, 0x0a	; 10
    27fa:	0f b6       	in	r0, 0x3f	; 63
    27fc:	f8 94       	cli
    27fe:	de bf       	out	0x3e, r29	; 62
    2800:	0f be       	out	0x3f, r0	; 63
    2802:	cd bf       	out	0x3d, r28	; 61
    2804:	9e 83       	std	Y+6, r25	; 0x06
    2806:	8d 83       	std	Y+5, r24	; 0x05
    2808:	78 87       	std	Y+8, r23	; 0x08
    280a:	6f 83       	std	Y+7, r22	; 0x07
    280c:	5a 87       	std	Y+10, r21	; 0x0a
    280e:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2810:	8d 81       	ldd	r24, Y+5	; 0x05
    2812:	9e 81       	ldd	r25, Y+6	; 0x06
    2814:	9a 83       	std	Y+2, r25	; 0x02
    2816:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2818:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    281a:	e9 81       	ldd	r30, Y+1	; 0x01
    281c:	fa 81       	ldd	r31, Y+2	; 0x02
    281e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2820:	88 23       	and	r24, r24
    2822:	91 f1       	breq	.+100    	; 0x2888 <xQueueReceiveFromISR+0x98>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2824:	89 81       	ldd	r24, Y+1	; 0x01
    2826:	9a 81       	ldd	r25, Y+2	; 0x02
    2828:	2f 81       	ldd	r18, Y+7	; 0x07
    282a:	38 85       	ldd	r19, Y+8	; 0x08
    282c:	b9 01       	movw	r22, r18
    282e:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2832:	e9 81       	ldd	r30, Y+1	; 0x01
    2834:	fa 81       	ldd	r31, Y+2	; 0x02
    2836:	82 8d       	ldd	r24, Z+26	; 0x1a
    2838:	81 50       	subi	r24, 0x01	; 1
    283a:	e9 81       	ldd	r30, Y+1	; 0x01
    283c:	fa 81       	ldd	r31, Y+2	; 0x02
    283e:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2840:	e9 81       	ldd	r30, Y+1	; 0x01
    2842:	fa 81       	ldd	r31, Y+2	; 0x02
    2844:	85 8d       	ldd	r24, Z+29	; 0x1d
    2846:	8f 3f       	cpi	r24, 0xFF	; 255
    2848:	a9 f4       	brne	.+42     	; 0x2874 <xQueueReceiveFromISR+0x84>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    284a:	e9 81       	ldd	r30, Y+1	; 0x01
    284c:	fa 81       	ldd	r31, Y+2	; 0x02
    284e:	80 85       	ldd	r24, Z+8	; 0x08
    2850:	88 23       	and	r24, r24
    2852:	b9 f0       	breq	.+46     	; 0x2882 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2854:	89 81       	ldd	r24, Y+1	; 0x01
    2856:	9a 81       	ldd	r25, Y+2	; 0x02
    2858:	08 96       	adiw	r24, 0x08	; 8
    285a:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <xTaskRemoveFromEventList>
    285e:	88 23       	and	r24, r24
    2860:	81 f0       	breq	.+32     	; 0x2882 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2862:	89 85       	ldd	r24, Y+9	; 0x09
    2864:	9a 85       	ldd	r25, Y+10	; 0x0a
    2866:	00 97       	sbiw	r24, 0x00	; 0
    2868:	61 f0       	breq	.+24     	; 0x2882 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    286a:	e9 85       	ldd	r30, Y+9	; 0x09
    286c:	fa 85       	ldd	r31, Y+10	; 0x0a
    286e:	81 e0       	ldi	r24, 0x01	; 1
    2870:	80 83       	st	Z, r24
    2872:	07 c0       	rjmp	.+14     	; 0x2882 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2874:	e9 81       	ldd	r30, Y+1	; 0x01
    2876:	fa 81       	ldd	r31, Y+2	; 0x02
    2878:	85 8d       	ldd	r24, Z+29	; 0x1d
    287a:	8f 5f       	subi	r24, 0xFF	; 255
    287c:	e9 81       	ldd	r30, Y+1	; 0x01
    287e:	fa 81       	ldd	r31, Y+2	; 0x02
    2880:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2882:	81 e0       	ldi	r24, 0x01	; 1
    2884:	8c 83       	std	Y+4, r24	; 0x04
    2886:	01 c0       	rjmp	.+2      	; 0x288a <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2888:	1c 82       	std	Y+4, r1	; 0x04
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    288a:	8c 81       	ldd	r24, Y+4	; 0x04
}
    288c:	2a 96       	adiw	r28, 0x0a	; 10
    288e:	0f b6       	in	r0, 0x3f	; 63
    2890:	f8 94       	cli
    2892:	de bf       	out	0x3e, r29	; 62
    2894:	0f be       	out	0x3f, r0	; 63
    2896:	cd bf       	out	0x3d, r28	; 61
    2898:	cf 91       	pop	r28
    289a:	df 91       	pop	r29
    289c:	08 95       	ret

0000289e <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    289e:	df 93       	push	r29
    28a0:	cf 93       	push	r28
    28a2:	cd b7       	in	r28, 0x3d	; 61
    28a4:	de b7       	in	r29, 0x3e	; 62
    28a6:	2a 97       	sbiw	r28, 0x0a	; 10
    28a8:	0f b6       	in	r0, 0x3f	; 63
    28aa:	f8 94       	cli
    28ac:	de bf       	out	0x3e, r29	; 62
    28ae:	0f be       	out	0x3f, r0	; 63
    28b0:	cd bf       	out	0x3d, r28	; 61
    28b2:	98 87       	std	Y+8, r25	; 0x08
    28b4:	8f 83       	std	Y+7, r24	; 0x07
    28b6:	7a 87       	std	Y+10, r23	; 0x0a
    28b8:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    28ba:	8f 81       	ldd	r24, Y+7	; 0x07
    28bc:	98 85       	ldd	r25, Y+8	; 0x08
    28be:	9a 83       	std	Y+2, r25	; 0x02
    28c0:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    28c2:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    28c4:	e9 81       	ldd	r30, Y+1	; 0x01
    28c6:	fa 81       	ldd	r31, Y+2	; 0x02
    28c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    28ca:	88 23       	and	r24, r24
    28cc:	b1 f0       	breq	.+44     	; 0x28fa <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    28ce:	e9 81       	ldd	r30, Y+1	; 0x01
    28d0:	fa 81       	ldd	r31, Y+2	; 0x02
    28d2:	86 81       	ldd	r24, Z+6	; 0x06
    28d4:	97 81       	ldd	r25, Z+7	; 0x07
    28d6:	9c 83       	std	Y+4, r25	; 0x04
    28d8:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    28da:	89 81       	ldd	r24, Y+1	; 0x01
    28dc:	9a 81       	ldd	r25, Y+2	; 0x02
    28de:	29 85       	ldd	r18, Y+9	; 0x09
    28e0:	3a 85       	ldd	r19, Y+10	; 0x0a
    28e2:	b9 01       	movw	r22, r18
    28e4:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    28e8:	e9 81       	ldd	r30, Y+1	; 0x01
    28ea:	fa 81       	ldd	r31, Y+2	; 0x02
    28ec:	8b 81       	ldd	r24, Y+3	; 0x03
    28ee:	9c 81       	ldd	r25, Y+4	; 0x04
    28f0:	97 83       	std	Z+7, r25	; 0x07
    28f2:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    28f4:	81 e0       	ldi	r24, 0x01	; 1
    28f6:	8e 83       	std	Y+6, r24	; 0x06
    28f8:	01 c0       	rjmp	.+2      	; 0x28fc <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    28fa:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    28fc:	8e 81       	ldd	r24, Y+6	; 0x06
}
    28fe:	2a 96       	adiw	r28, 0x0a	; 10
    2900:	0f b6       	in	r0, 0x3f	; 63
    2902:	f8 94       	cli
    2904:	de bf       	out	0x3e, r29	; 62
    2906:	0f be       	out	0x3f, r0	; 63
    2908:	cd bf       	out	0x3d, r28	; 61
    290a:	cf 91       	pop	r28
    290c:	df 91       	pop	r29
    290e:	08 95       	ret

00002910 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2910:	df 93       	push	r29
    2912:	cf 93       	push	r28
    2914:	00 d0       	rcall	.+0      	; 0x2916 <uxQueueMessagesWaiting+0x6>
    2916:	0f 92       	push	r0
    2918:	cd b7       	in	r28, 0x3d	; 61
    291a:	de b7       	in	r29, 0x3e	; 62
    291c:	9b 83       	std	Y+3, r25	; 0x03
    291e:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2920:	0f b6       	in	r0, 0x3f	; 63
    2922:	f8 94       	cli
    2924:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2926:	ea 81       	ldd	r30, Y+2	; 0x02
    2928:	fb 81       	ldd	r31, Y+3	; 0x03
    292a:	82 8d       	ldd	r24, Z+26	; 0x1a
    292c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    292e:	0f 90       	pop	r0
    2930:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2932:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2934:	0f 90       	pop	r0
    2936:	0f 90       	pop	r0
    2938:	0f 90       	pop	r0
    293a:	cf 91       	pop	r28
    293c:	df 91       	pop	r29
    293e:	08 95       	ret

00002940 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2940:	df 93       	push	r29
    2942:	cf 93       	push	r28
    2944:	00 d0       	rcall	.+0      	; 0x2946 <uxQueueSpacesAvailable+0x6>
    2946:	00 d0       	rcall	.+0      	; 0x2948 <uxQueueSpacesAvailable+0x8>
    2948:	0f 92       	push	r0
    294a:	cd b7       	in	r28, 0x3d	; 61
    294c:	de b7       	in	r29, 0x3e	; 62
    294e:	9d 83       	std	Y+5, r25	; 0x05
    2950:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    2952:	8c 81       	ldd	r24, Y+4	; 0x04
    2954:	9d 81       	ldd	r25, Y+5	; 0x05
    2956:	9a 83       	std	Y+2, r25	; 0x02
    2958:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    295a:	0f b6       	in	r0, 0x3f	; 63
    295c:	f8 94       	cli
    295e:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2960:	e9 81       	ldd	r30, Y+1	; 0x01
    2962:	fa 81       	ldd	r31, Y+2	; 0x02
    2964:	93 8d       	ldd	r25, Z+27	; 0x1b
    2966:	e9 81       	ldd	r30, Y+1	; 0x01
    2968:	fa 81       	ldd	r31, Y+2	; 0x02
    296a:	82 8d       	ldd	r24, Z+26	; 0x1a
    296c:	29 2f       	mov	r18, r25
    296e:	28 1b       	sub	r18, r24
    2970:	82 2f       	mov	r24, r18
    2972:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2974:	0f 90       	pop	r0
    2976:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2978:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    297a:	0f 90       	pop	r0
    297c:	0f 90       	pop	r0
    297e:	0f 90       	pop	r0
    2980:	0f 90       	pop	r0
    2982:	0f 90       	pop	r0
    2984:	cf 91       	pop	r28
    2986:	df 91       	pop	r29
    2988:	08 95       	ret

0000298a <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    298a:	df 93       	push	r29
    298c:	cf 93       	push	r28
    298e:	00 d0       	rcall	.+0      	; 0x2990 <uxQueueMessagesWaitingFromISR+0x6>
    2990:	0f 92       	push	r0
    2992:	cd b7       	in	r28, 0x3d	; 61
    2994:	de b7       	in	r29, 0x3e	; 62
    2996:	9b 83       	std	Y+3, r25	; 0x03
    2998:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    299a:	ea 81       	ldd	r30, Y+2	; 0x02
    299c:	fb 81       	ldd	r31, Y+3	; 0x03
    299e:	82 8d       	ldd	r24, Z+26	; 0x1a
    29a0:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    29a2:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    29a4:	0f 90       	pop	r0
    29a6:	0f 90       	pop	r0
    29a8:	0f 90       	pop	r0
    29aa:	cf 91       	pop	r28
    29ac:	df 91       	pop	r29
    29ae:	08 95       	ret

000029b0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    29b0:	df 93       	push	r29
    29b2:	cf 93       	push	r28
    29b4:	00 d0       	rcall	.+0      	; 0x29b6 <vQueueDelete+0x6>
    29b6:	00 d0       	rcall	.+0      	; 0x29b8 <vQueueDelete+0x8>
    29b8:	cd b7       	in	r28, 0x3d	; 61
    29ba:	de b7       	in	r29, 0x3e	; 62
    29bc:	9c 83       	std	Y+4, r25	; 0x04
    29be:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    29c0:	8b 81       	ldd	r24, Y+3	; 0x03
    29c2:	9c 81       	ldd	r25, Y+4	; 0x04
    29c4:	9a 83       	std	Y+2, r25	; 0x02
    29c6:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    29c8:	e9 81       	ldd	r30, Y+1	; 0x01
    29ca:	fa 81       	ldd	r31, Y+2	; 0x02
    29cc:	80 81       	ld	r24, Z
    29ce:	91 81       	ldd	r25, Z+1	; 0x01
    29d0:	00 97       	sbiw	r24, 0x00	; 0
    29d2:	31 f0       	breq	.+12     	; 0x29e0 <vQueueDelete+0x30>
	{
		vPortFree( pxQueue->pcHead );
    29d4:	e9 81       	ldd	r30, Y+1	; 0x01
    29d6:	fa 81       	ldd	r31, Y+2	; 0x02
    29d8:	80 81       	ld	r24, Z
    29da:	91 81       	ldd	r25, Z+1	; 0x01
    29dc:	0e 94 b6 0b 	call	0x176c	; 0x176c <vPortFree>
	}
	vPortFree( pxQueue );
    29e0:	89 81       	ldd	r24, Y+1	; 0x01
    29e2:	9a 81       	ldd	r25, Y+2	; 0x02
    29e4:	0e 94 b6 0b 	call	0x176c	; 0x176c <vPortFree>
}
    29e8:	0f 90       	pop	r0
    29ea:	0f 90       	pop	r0
    29ec:	0f 90       	pop	r0
    29ee:	0f 90       	pop	r0
    29f0:	cf 91       	pop	r28
    29f2:	df 91       	pop	r29
    29f4:	08 95       	ret

000029f6 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    29f6:	df 93       	push	r29
    29f8:	cf 93       	push	r28
    29fa:	00 d0       	rcall	.+0      	; 0x29fc <prvCopyDataToQueue+0x6>
    29fc:	00 d0       	rcall	.+0      	; 0x29fe <prvCopyDataToQueue+0x8>
    29fe:	00 d0       	rcall	.+0      	; 0x2a00 <prvCopyDataToQueue+0xa>
    2a00:	cd b7       	in	r28, 0x3d	; 61
    2a02:	de b7       	in	r29, 0x3e	; 62
    2a04:	9b 83       	std	Y+3, r25	; 0x03
    2a06:	8a 83       	std	Y+2, r24	; 0x02
    2a08:	7d 83       	std	Y+5, r23	; 0x05
    2a0a:	6c 83       	std	Y+4, r22	; 0x04
    2a0c:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    2a0e:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2a10:	ea 81       	ldd	r30, Y+2	; 0x02
    2a12:	fb 81       	ldd	r31, Y+3	; 0x03
    2a14:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a16:	88 23       	and	r24, r24
    2a18:	99 f4       	brne	.+38     	; 0x2a40 <prvCopyDataToQueue+0x4a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2a1a:	ea 81       	ldd	r30, Y+2	; 0x02
    2a1c:	fb 81       	ldd	r31, Y+3	; 0x03
    2a1e:	80 81       	ld	r24, Z
    2a20:	91 81       	ldd	r25, Z+1	; 0x01
    2a22:	00 97       	sbiw	r24, 0x00	; 0
    2a24:	09 f0       	breq	.+2      	; 0x2a28 <prvCopyDataToQueue+0x32>
    2a26:	8f c0       	rjmp	.+286    	; 0x2b46 <prvCopyDataToQueue+0x150>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    2a28:	ea 81       	ldd	r30, Y+2	; 0x02
    2a2a:	fb 81       	ldd	r31, Y+3	; 0x03
    2a2c:	82 81       	ldd	r24, Z+2	; 0x02
    2a2e:	93 81       	ldd	r25, Z+3	; 0x03
    2a30:	0e 94 22 21 	call	0x4244	; 0x4244 <xTaskPriorityDisinherit>
    2a34:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->pxMutexHolder = NULL;
    2a36:	ea 81       	ldd	r30, Y+2	; 0x02
    2a38:	fb 81       	ldd	r31, Y+3	; 0x03
    2a3a:	13 82       	std	Z+3, r1	; 0x03
    2a3c:	12 82       	std	Z+2, r1	; 0x02
    2a3e:	83 c0       	rjmp	.+262    	; 0x2b46 <prvCopyDataToQueue+0x150>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2a40:	8e 81       	ldd	r24, Y+6	; 0x06
    2a42:	88 23       	and	r24, r24
    2a44:	99 f5       	brne	.+102    	; 0x2aac <prvCopyDataToQueue+0xb6>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    2a46:	ea 81       	ldd	r30, Y+2	; 0x02
    2a48:	fb 81       	ldd	r31, Y+3	; 0x03
    2a4a:	64 81       	ldd	r22, Z+4	; 0x04
    2a4c:	75 81       	ldd	r23, Z+5	; 0x05
    2a4e:	ea 81       	ldd	r30, Y+2	; 0x02
    2a50:	fb 81       	ldd	r31, Y+3	; 0x03
    2a52:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a54:	48 2f       	mov	r20, r24
    2a56:	50 e0       	ldi	r21, 0x00	; 0
    2a58:	2c 81       	ldd	r18, Y+4	; 0x04
    2a5a:	3d 81       	ldd	r19, Y+5	; 0x05
    2a5c:	cb 01       	movw	r24, r22
    2a5e:	b9 01       	movw	r22, r18
    2a60:	0e 94 f7 23 	call	0x47ee	; 0x47ee <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2a64:	ea 81       	ldd	r30, Y+2	; 0x02
    2a66:	fb 81       	ldd	r31, Y+3	; 0x03
    2a68:	24 81       	ldd	r18, Z+4	; 0x04
    2a6a:	35 81       	ldd	r19, Z+5	; 0x05
    2a6c:	ea 81       	ldd	r30, Y+2	; 0x02
    2a6e:	fb 81       	ldd	r31, Y+3	; 0x03
    2a70:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a72:	88 2f       	mov	r24, r24
    2a74:	90 e0       	ldi	r25, 0x00	; 0
    2a76:	82 0f       	add	r24, r18
    2a78:	93 1f       	adc	r25, r19
    2a7a:	ea 81       	ldd	r30, Y+2	; 0x02
    2a7c:	fb 81       	ldd	r31, Y+3	; 0x03
    2a7e:	95 83       	std	Z+5, r25	; 0x05
    2a80:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2a82:	ea 81       	ldd	r30, Y+2	; 0x02
    2a84:	fb 81       	ldd	r31, Y+3	; 0x03
    2a86:	24 81       	ldd	r18, Z+4	; 0x04
    2a88:	35 81       	ldd	r19, Z+5	; 0x05
    2a8a:	ea 81       	ldd	r30, Y+2	; 0x02
    2a8c:	fb 81       	ldd	r31, Y+3	; 0x03
    2a8e:	82 81       	ldd	r24, Z+2	; 0x02
    2a90:	93 81       	ldd	r25, Z+3	; 0x03
    2a92:	28 17       	cp	r18, r24
    2a94:	39 07       	cpc	r19, r25
    2a96:	08 f4       	brcc	.+2      	; 0x2a9a <prvCopyDataToQueue+0xa4>
    2a98:	56 c0       	rjmp	.+172    	; 0x2b46 <prvCopyDataToQueue+0x150>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2a9a:	ea 81       	ldd	r30, Y+2	; 0x02
    2a9c:	fb 81       	ldd	r31, Y+3	; 0x03
    2a9e:	80 81       	ld	r24, Z
    2aa0:	91 81       	ldd	r25, Z+1	; 0x01
    2aa2:	ea 81       	ldd	r30, Y+2	; 0x02
    2aa4:	fb 81       	ldd	r31, Y+3	; 0x03
    2aa6:	95 83       	std	Z+5, r25	; 0x05
    2aa8:	84 83       	std	Z+4, r24	; 0x04
    2aaa:	4d c0       	rjmp	.+154    	; 0x2b46 <prvCopyDataToQueue+0x150>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2aac:	ea 81       	ldd	r30, Y+2	; 0x02
    2aae:	fb 81       	ldd	r31, Y+3	; 0x03
    2ab0:	66 81       	ldd	r22, Z+6	; 0x06
    2ab2:	77 81       	ldd	r23, Z+7	; 0x07
    2ab4:	ea 81       	ldd	r30, Y+2	; 0x02
    2ab6:	fb 81       	ldd	r31, Y+3	; 0x03
    2ab8:	84 8d       	ldd	r24, Z+28	; 0x1c
    2aba:	48 2f       	mov	r20, r24
    2abc:	50 e0       	ldi	r21, 0x00	; 0
    2abe:	2c 81       	ldd	r18, Y+4	; 0x04
    2ac0:	3d 81       	ldd	r19, Y+5	; 0x05
    2ac2:	cb 01       	movw	r24, r22
    2ac4:	b9 01       	movw	r22, r18
    2ac6:	0e 94 f7 23 	call	0x47ee	; 0x47ee <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    2aca:	ea 81       	ldd	r30, Y+2	; 0x02
    2acc:	fb 81       	ldd	r31, Y+3	; 0x03
    2ace:	26 81       	ldd	r18, Z+6	; 0x06
    2ad0:	37 81       	ldd	r19, Z+7	; 0x07
    2ad2:	ea 81       	ldd	r30, Y+2	; 0x02
    2ad4:	fb 81       	ldd	r31, Y+3	; 0x03
    2ad6:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ad8:	88 2f       	mov	r24, r24
    2ada:	90 e0       	ldi	r25, 0x00	; 0
    2adc:	90 95       	com	r25
    2ade:	81 95       	neg	r24
    2ae0:	9f 4f       	sbci	r25, 0xFF	; 255
    2ae2:	82 0f       	add	r24, r18
    2ae4:	93 1f       	adc	r25, r19
    2ae6:	ea 81       	ldd	r30, Y+2	; 0x02
    2ae8:	fb 81       	ldd	r31, Y+3	; 0x03
    2aea:	97 83       	std	Z+7, r25	; 0x07
    2aec:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2aee:	ea 81       	ldd	r30, Y+2	; 0x02
    2af0:	fb 81       	ldd	r31, Y+3	; 0x03
    2af2:	26 81       	ldd	r18, Z+6	; 0x06
    2af4:	37 81       	ldd	r19, Z+7	; 0x07
    2af6:	ea 81       	ldd	r30, Y+2	; 0x02
    2af8:	fb 81       	ldd	r31, Y+3	; 0x03
    2afa:	80 81       	ld	r24, Z
    2afc:	91 81       	ldd	r25, Z+1	; 0x01
    2afe:	28 17       	cp	r18, r24
    2b00:	39 07       	cpc	r19, r25
    2b02:	90 f4       	brcc	.+36     	; 0x2b28 <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2b04:	ea 81       	ldd	r30, Y+2	; 0x02
    2b06:	fb 81       	ldd	r31, Y+3	; 0x03
    2b08:	22 81       	ldd	r18, Z+2	; 0x02
    2b0a:	33 81       	ldd	r19, Z+3	; 0x03
    2b0c:	ea 81       	ldd	r30, Y+2	; 0x02
    2b0e:	fb 81       	ldd	r31, Y+3	; 0x03
    2b10:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b12:	88 2f       	mov	r24, r24
    2b14:	90 e0       	ldi	r25, 0x00	; 0
    2b16:	90 95       	com	r25
    2b18:	81 95       	neg	r24
    2b1a:	9f 4f       	sbci	r25, 0xFF	; 255
    2b1c:	82 0f       	add	r24, r18
    2b1e:	93 1f       	adc	r25, r19
    2b20:	ea 81       	ldd	r30, Y+2	; 0x02
    2b22:	fb 81       	ldd	r31, Y+3	; 0x03
    2b24:	97 83       	std	Z+7, r25	; 0x07
    2b26:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2b28:	8e 81       	ldd	r24, Y+6	; 0x06
    2b2a:	82 30       	cpi	r24, 0x02	; 2
    2b2c:	61 f4       	brne	.+24     	; 0x2b46 <prvCopyDataToQueue+0x150>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2b2e:	ea 81       	ldd	r30, Y+2	; 0x02
    2b30:	fb 81       	ldd	r31, Y+3	; 0x03
    2b32:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b34:	88 23       	and	r24, r24
    2b36:	39 f0       	breq	.+14     	; 0x2b46 <prvCopyDataToQueue+0x150>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    2b38:	ea 81       	ldd	r30, Y+2	; 0x02
    2b3a:	fb 81       	ldd	r31, Y+3	; 0x03
    2b3c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b3e:	81 50       	subi	r24, 0x01	; 1
    2b40:	ea 81       	ldd	r30, Y+2	; 0x02
    2b42:	fb 81       	ldd	r31, Y+3	; 0x03
    2b44:	82 8f       	std	Z+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2b46:	ea 81       	ldd	r30, Y+2	; 0x02
    2b48:	fb 81       	ldd	r31, Y+3	; 0x03
    2b4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b4c:	8f 5f       	subi	r24, 0xFF	; 255
    2b4e:	ea 81       	ldd	r30, Y+2	; 0x02
    2b50:	fb 81       	ldd	r31, Y+3	; 0x03
    2b52:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2b54:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b56:	26 96       	adiw	r28, 0x06	; 6
    2b58:	0f b6       	in	r0, 0x3f	; 63
    2b5a:	f8 94       	cli
    2b5c:	de bf       	out	0x3e, r29	; 62
    2b5e:	0f be       	out	0x3f, r0	; 63
    2b60:	cd bf       	out	0x3d, r28	; 61
    2b62:	cf 91       	pop	r28
    2b64:	df 91       	pop	r29
    2b66:	08 95       	ret

00002b68 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2b68:	df 93       	push	r29
    2b6a:	cf 93       	push	r28
    2b6c:	00 d0       	rcall	.+0      	; 0x2b6e <prvCopyDataFromQueue+0x6>
    2b6e:	00 d0       	rcall	.+0      	; 0x2b70 <prvCopyDataFromQueue+0x8>
    2b70:	cd b7       	in	r28, 0x3d	; 61
    2b72:	de b7       	in	r29, 0x3e	; 62
    2b74:	9a 83       	std	Y+2, r25	; 0x02
    2b76:	89 83       	std	Y+1, r24	; 0x01
    2b78:	7c 83       	std	Y+4, r23	; 0x04
    2b7a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2b7c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b7e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b80:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b82:	88 23       	and	r24, r24
    2b84:	89 f1       	breq	.+98     	; 0x2be8 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2b86:	e9 81       	ldd	r30, Y+1	; 0x01
    2b88:	fa 81       	ldd	r31, Y+2	; 0x02
    2b8a:	26 81       	ldd	r18, Z+6	; 0x06
    2b8c:	37 81       	ldd	r19, Z+7	; 0x07
    2b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b90:	fa 81       	ldd	r31, Y+2	; 0x02
    2b92:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b94:	88 2f       	mov	r24, r24
    2b96:	90 e0       	ldi	r25, 0x00	; 0
    2b98:	82 0f       	add	r24, r18
    2b9a:	93 1f       	adc	r25, r19
    2b9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba0:	97 83       	std	Z+7, r25	; 0x07
    2ba2:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2ba4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ba6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba8:	26 81       	ldd	r18, Z+6	; 0x06
    2baa:	37 81       	ldd	r19, Z+7	; 0x07
    2bac:	e9 81       	ldd	r30, Y+1	; 0x01
    2bae:	fa 81       	ldd	r31, Y+2	; 0x02
    2bb0:	82 81       	ldd	r24, Z+2	; 0x02
    2bb2:	93 81       	ldd	r25, Z+3	; 0x03
    2bb4:	28 17       	cp	r18, r24
    2bb6:	39 07       	cpc	r19, r25
    2bb8:	40 f0       	brcs	.+16     	; 0x2bca <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2bba:	e9 81       	ldd	r30, Y+1	; 0x01
    2bbc:	fa 81       	ldd	r31, Y+2	; 0x02
    2bbe:	80 81       	ld	r24, Z
    2bc0:	91 81       	ldd	r25, Z+1	; 0x01
    2bc2:	e9 81       	ldd	r30, Y+1	; 0x01
    2bc4:	fa 81       	ldd	r31, Y+2	; 0x02
    2bc6:	97 83       	std	Z+7, r25	; 0x07
    2bc8:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    2bca:	e9 81       	ldd	r30, Y+1	; 0x01
    2bcc:	fa 81       	ldd	r31, Y+2	; 0x02
    2bce:	46 81       	ldd	r20, Z+6	; 0x06
    2bd0:	57 81       	ldd	r21, Z+7	; 0x07
    2bd2:	e9 81       	ldd	r30, Y+1	; 0x01
    2bd4:	fa 81       	ldd	r31, Y+2	; 0x02
    2bd6:	84 8d       	ldd	r24, Z+28	; 0x1c
    2bd8:	28 2f       	mov	r18, r24
    2bda:	30 e0       	ldi	r19, 0x00	; 0
    2bdc:	8b 81       	ldd	r24, Y+3	; 0x03
    2bde:	9c 81       	ldd	r25, Y+4	; 0x04
    2be0:	ba 01       	movw	r22, r20
    2be2:	a9 01       	movw	r20, r18
    2be4:	0e 94 f7 23 	call	0x47ee	; 0x47ee <memcpy>
	}
}
    2be8:	0f 90       	pop	r0
    2bea:	0f 90       	pop	r0
    2bec:	0f 90       	pop	r0
    2bee:	0f 90       	pop	r0
    2bf0:	cf 91       	pop	r28
    2bf2:	df 91       	pop	r29
    2bf4:	08 95       	ret

00002bf6 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2bf6:	df 93       	push	r29
    2bf8:	cf 93       	push	r28
    2bfa:	00 d0       	rcall	.+0      	; 0x2bfc <prvUnlockQueue+0x6>
    2bfc:	cd b7       	in	r28, 0x3d	; 61
    2bfe:	de b7       	in	r29, 0x3e	; 62
    2c00:	9a 83       	std	Y+2, r25	; 0x02
    2c02:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2c04:	0f b6       	in	r0, 0x3f	; 63
    2c06:	f8 94       	cli
    2c08:	0f 92       	push	r0
    2c0a:	15 c0       	rjmp	.+42     	; 0x2c36 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2c0c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c0e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c10:	81 89       	ldd	r24, Z+17	; 0x11
    2c12:	88 23       	and	r24, r24
    2c14:	a9 f0       	breq	.+42     	; 0x2c40 <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2c16:	89 81       	ldd	r24, Y+1	; 0x01
    2c18:	9a 81       	ldd	r25, Y+2	; 0x02
    2c1a:	41 96       	adiw	r24, 0x11	; 17
    2c1c:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <xTaskRemoveFromEventList>
    2c20:	88 23       	and	r24, r24
    2c22:	11 f0       	breq	.+4      	; 0x2c28 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2c24:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2c28:	e9 81       	ldd	r30, Y+1	; 0x01
    2c2a:	fa 81       	ldd	r31, Y+2	; 0x02
    2c2c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c2e:	81 50       	subi	r24, 0x01	; 1
    2c30:	e9 81       	ldd	r30, Y+1	; 0x01
    2c32:	fa 81       	ldd	r31, Y+2	; 0x02
    2c34:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2c36:	e9 81       	ldd	r30, Y+1	; 0x01
    2c38:	fa 81       	ldd	r31, Y+2	; 0x02
    2c3a:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c3c:	18 16       	cp	r1, r24
    2c3e:	34 f3       	brlt	.-52     	; 0x2c0c <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2c40:	e9 81       	ldd	r30, Y+1	; 0x01
    2c42:	fa 81       	ldd	r31, Y+2	; 0x02
    2c44:	8f ef       	ldi	r24, 0xFF	; 255
    2c46:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2c48:	0f 90       	pop	r0
    2c4a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2c4c:	0f b6       	in	r0, 0x3f	; 63
    2c4e:	f8 94       	cli
    2c50:	0f 92       	push	r0
    2c52:	15 c0       	rjmp	.+42     	; 0x2c7e <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2c54:	e9 81       	ldd	r30, Y+1	; 0x01
    2c56:	fa 81       	ldd	r31, Y+2	; 0x02
    2c58:	80 85       	ldd	r24, Z+8	; 0x08
    2c5a:	88 23       	and	r24, r24
    2c5c:	a9 f0       	breq	.+42     	; 0x2c88 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2c5e:	89 81       	ldd	r24, Y+1	; 0x01
    2c60:	9a 81       	ldd	r25, Y+2	; 0x02
    2c62:	08 96       	adiw	r24, 0x08	; 8
    2c64:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <xTaskRemoveFromEventList>
    2c68:	88 23       	and	r24, r24
    2c6a:	11 f0       	breq	.+4      	; 0x2c70 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2c6c:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2c70:	e9 81       	ldd	r30, Y+1	; 0x01
    2c72:	fa 81       	ldd	r31, Y+2	; 0x02
    2c74:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c76:	81 50       	subi	r24, 0x01	; 1
    2c78:	e9 81       	ldd	r30, Y+1	; 0x01
    2c7a:	fa 81       	ldd	r31, Y+2	; 0x02
    2c7c:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2c7e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c80:	fa 81       	ldd	r31, Y+2	; 0x02
    2c82:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c84:	18 16       	cp	r1, r24
    2c86:	34 f3       	brlt	.-52     	; 0x2c54 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2c88:	e9 81       	ldd	r30, Y+1	; 0x01
    2c8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2c8c:	8f ef       	ldi	r24, 0xFF	; 255
    2c8e:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2c90:	0f 90       	pop	r0
    2c92:	0f be       	out	0x3f, r0	; 63
}
    2c94:	0f 90       	pop	r0
    2c96:	0f 90       	pop	r0
    2c98:	cf 91       	pop	r28
    2c9a:	df 91       	pop	r29
    2c9c:	08 95       	ret

00002c9e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2c9e:	df 93       	push	r29
    2ca0:	cf 93       	push	r28
    2ca2:	00 d0       	rcall	.+0      	; 0x2ca4 <prvIsQueueEmpty+0x6>
    2ca4:	0f 92       	push	r0
    2ca6:	cd b7       	in	r28, 0x3d	; 61
    2ca8:	de b7       	in	r29, 0x3e	; 62
    2caa:	9b 83       	std	Y+3, r25	; 0x03
    2cac:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2cae:	0f b6       	in	r0, 0x3f	; 63
    2cb0:	f8 94       	cli
    2cb2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2cb4:	ea 81       	ldd	r30, Y+2	; 0x02
    2cb6:	fb 81       	ldd	r31, Y+3	; 0x03
    2cb8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cba:	88 23       	and	r24, r24
    2cbc:	19 f4       	brne	.+6      	; 0x2cc4 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2cbe:	81 e0       	ldi	r24, 0x01	; 1
    2cc0:	89 83       	std	Y+1, r24	; 0x01
    2cc2:	01 c0       	rjmp	.+2      	; 0x2cc6 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2cc4:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2cc6:	0f 90       	pop	r0
    2cc8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2cca:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ccc:	0f 90       	pop	r0
    2cce:	0f 90       	pop	r0
    2cd0:	0f 90       	pop	r0
    2cd2:	cf 91       	pop	r28
    2cd4:	df 91       	pop	r29
    2cd6:	08 95       	ret

00002cd8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2cd8:	df 93       	push	r29
    2cda:	cf 93       	push	r28
    2cdc:	00 d0       	rcall	.+0      	; 0x2cde <xQueueIsQueueEmptyFromISR+0x6>
    2cde:	0f 92       	push	r0
    2ce0:	cd b7       	in	r28, 0x3d	; 61
    2ce2:	de b7       	in	r29, 0x3e	; 62
    2ce4:	9b 83       	std	Y+3, r25	; 0x03
    2ce6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2ce8:	ea 81       	ldd	r30, Y+2	; 0x02
    2cea:	fb 81       	ldd	r31, Y+3	; 0x03
    2cec:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cee:	88 23       	and	r24, r24
    2cf0:	19 f4       	brne	.+6      	; 0x2cf8 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    2cf2:	81 e0       	ldi	r24, 0x01	; 1
    2cf4:	89 83       	std	Y+1, r24	; 0x01
    2cf6:	01 c0       	rjmp	.+2      	; 0x2cfa <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    2cf8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2cfa:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2cfc:	0f 90       	pop	r0
    2cfe:	0f 90       	pop	r0
    2d00:	0f 90       	pop	r0
    2d02:	cf 91       	pop	r28
    2d04:	df 91       	pop	r29
    2d06:	08 95       	ret

00002d08 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2d08:	df 93       	push	r29
    2d0a:	cf 93       	push	r28
    2d0c:	00 d0       	rcall	.+0      	; 0x2d0e <prvIsQueueFull+0x6>
    2d0e:	0f 92       	push	r0
    2d10:	cd b7       	in	r28, 0x3d	; 61
    2d12:	de b7       	in	r29, 0x3e	; 62
    2d14:	9b 83       	std	Y+3, r25	; 0x03
    2d16:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2d18:	0f b6       	in	r0, 0x3f	; 63
    2d1a:	f8 94       	cli
    2d1c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2d1e:	ea 81       	ldd	r30, Y+2	; 0x02
    2d20:	fb 81       	ldd	r31, Y+3	; 0x03
    2d22:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d24:	ea 81       	ldd	r30, Y+2	; 0x02
    2d26:	fb 81       	ldd	r31, Y+3	; 0x03
    2d28:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d2a:	98 17       	cp	r25, r24
    2d2c:	19 f4       	brne	.+6      	; 0x2d34 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2d2e:	81 e0       	ldi	r24, 0x01	; 1
    2d30:	89 83       	std	Y+1, r24	; 0x01
    2d32:	01 c0       	rjmp	.+2      	; 0x2d36 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2d34:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2d36:	0f 90       	pop	r0
    2d38:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2d3a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2d3c:	0f 90       	pop	r0
    2d3e:	0f 90       	pop	r0
    2d40:	0f 90       	pop	r0
    2d42:	cf 91       	pop	r28
    2d44:	df 91       	pop	r29
    2d46:	08 95       	ret

00002d48 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2d48:	df 93       	push	r29
    2d4a:	cf 93       	push	r28
    2d4c:	00 d0       	rcall	.+0      	; 0x2d4e <xQueueIsQueueFullFromISR+0x6>
    2d4e:	0f 92       	push	r0
    2d50:	cd b7       	in	r28, 0x3d	; 61
    2d52:	de b7       	in	r29, 0x3e	; 62
    2d54:	9b 83       	std	Y+3, r25	; 0x03
    2d56:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    2d58:	ea 81       	ldd	r30, Y+2	; 0x02
    2d5a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d5c:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d5e:	ea 81       	ldd	r30, Y+2	; 0x02
    2d60:	fb 81       	ldd	r31, Y+3	; 0x03
    2d62:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d64:	98 17       	cp	r25, r24
    2d66:	19 f4       	brne	.+6      	; 0x2d6e <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    2d68:	81 e0       	ldi	r24, 0x01	; 1
    2d6a:	89 83       	std	Y+1, r24	; 0x01
    2d6c:	01 c0       	rjmp	.+2      	; 0x2d70 <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    2d6e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2d70:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2d72:	0f 90       	pop	r0
    2d74:	0f 90       	pop	r0
    2d76:	0f 90       	pop	r0
    2d78:	cf 91       	pop	r28
    2d7a:	df 91       	pop	r29
    2d7c:	08 95       	ret

00002d7e <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    2d7e:	df 93       	push	r29
    2d80:	cf 93       	push	r28
    2d82:	cd b7       	in	r28, 0x3d	; 61
    2d84:	de b7       	in	r29, 0x3e	; 62
    2d86:	2a 97       	sbiw	r28, 0x0a	; 10
    2d88:	0f b6       	in	r0, 0x3f	; 63
    2d8a:	f8 94       	cli
    2d8c:	de bf       	out	0x3e, r29	; 62
    2d8e:	0f be       	out	0x3f, r0	; 63
    2d90:	cd bf       	out	0x3d, r28	; 61
    2d92:	9d 83       	std	Y+5, r25	; 0x05
    2d94:	8c 83       	std	Y+4, r24	; 0x04
    2d96:	7f 83       	std	Y+7, r23	; 0x07
    2d98:	6e 83       	std	Y+6, r22	; 0x06
    2d9a:	59 87       	std	Y+9, r21	; 0x09
    2d9c:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2d9e:	8c 81       	ldd	r24, Y+4	; 0x04
    2da0:	9d 81       	ldd	r25, Y+5	; 0x05
    2da2:	9a 83       	std	Y+2, r25	; 0x02
    2da4:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    2da6:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2da8:	89 81       	ldd	r24, Y+1	; 0x01
    2daa:	9a 81       	ldd	r25, Y+2	; 0x02
    2dac:	0e 94 84 16 	call	0x2d08	; 0x2d08 <prvIsQueueFull>
    2db0:	88 23       	and	r24, r24
    2db2:	a9 f0       	breq	.+42     	; 0x2dde <xQueueCRSend+0x60>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    2db4:	88 85       	ldd	r24, Y+8	; 0x08
    2db6:	99 85       	ldd	r25, Y+9	; 0x09
    2db8:	00 97       	sbiw	r24, 0x00	; 0
    2dba:	71 f0       	breq	.+28     	; 0x2dd8 <xQueueCRSend+0x5a>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    2dbc:	89 81       	ldd	r24, Y+1	; 0x01
    2dbe:	9a 81       	ldd	r25, Y+2	; 0x02
    2dc0:	9c 01       	movw	r18, r24
    2dc2:	28 5f       	subi	r18, 0xF8	; 248
    2dc4:	3f 4f       	sbci	r19, 0xFF	; 255
    2dc6:	88 85       	ldd	r24, Y+8	; 0x08
    2dc8:	99 85       	ldd	r25, Y+9	; 0x09
    2dca:	b9 01       	movw	r22, r18
    2dcc:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    2dd0:	78 94       	sei
					return errQUEUE_BLOCKED;
    2dd2:	8c ef       	ldi	r24, 0xFC	; 252
    2dd4:	8a 87       	std	Y+10, r24	; 0x0a
    2dd6:	2a c0       	rjmp	.+84     	; 0x2e2c <xQueueCRSend+0xae>
				}
				else
				{
					portENABLE_INTERRUPTS();
    2dd8:	78 94       	sei
					return errQUEUE_FULL;
    2dda:	1a 86       	std	Y+10, r1	; 0x0a
    2ddc:	27 c0       	rjmp	.+78     	; 0x2e2c <xQueueCRSend+0xae>
				}
			}
		}
		portENABLE_INTERRUPTS();
    2dde:	78 94       	sei

		portDISABLE_INTERRUPTS();
    2de0:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2de2:	e9 81       	ldd	r30, Y+1	; 0x01
    2de4:	fa 81       	ldd	r31, Y+2	; 0x02
    2de6:	92 8d       	ldd	r25, Z+26	; 0x1a
    2de8:	e9 81       	ldd	r30, Y+1	; 0x01
    2dea:	fa 81       	ldd	r31, Y+2	; 0x02
    2dec:	83 8d       	ldd	r24, Z+27	; 0x1b
    2dee:	98 17       	cp	r25, r24
    2df0:	c8 f4       	brcc	.+50     	; 0x2e24 <xQueueCRSend+0xa6>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2df2:	89 81       	ldd	r24, Y+1	; 0x01
    2df4:	9a 81       	ldd	r25, Y+2	; 0x02
    2df6:	2e 81       	ldd	r18, Y+6	; 0x06
    2df8:	3f 81       	ldd	r19, Y+7	; 0x07
    2dfa:	b9 01       	movw	r22, r18
    2dfc:	40 e0       	ldi	r20, 0x00	; 0
    2dfe:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <prvCopyDataToQueue>
				xReturn = pdPASS;
    2e02:	81 e0       	ldi	r24, 0x01	; 1
    2e04:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2e06:	e9 81       	ldd	r30, Y+1	; 0x01
    2e08:	fa 81       	ldd	r31, Y+2	; 0x02
    2e0a:	81 89       	ldd	r24, Z+17	; 0x11
    2e0c:	88 23       	and	r24, r24
    2e0e:	59 f0       	breq	.+22     	; 0x2e26 <xQueueCRSend+0xa8>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2e10:	89 81       	ldd	r24, Y+1	; 0x01
    2e12:	9a 81       	ldd	r25, Y+2	; 0x02
    2e14:	41 96       	adiw	r24, 0x11	; 17
    2e16:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <xCoRoutineRemoveFromEventList>
    2e1a:	88 23       	and	r24, r24
    2e1c:	21 f0       	breq	.+8      	; 0x2e26 <xQueueCRSend+0xa8>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    2e1e:	8b ef       	ldi	r24, 0xFB	; 251
    2e20:	8b 83       	std	Y+3, r24	; 0x03
    2e22:	01 c0       	rjmp	.+2      	; 0x2e26 <xQueueCRSend+0xa8>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    2e24:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    2e26:	78 94       	sei

		return xReturn;
    2e28:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2a:	8a 87       	std	Y+10, r24	; 0x0a
    2e2c:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    2e2e:	2a 96       	adiw	r28, 0x0a	; 10
    2e30:	0f b6       	in	r0, 0x3f	; 63
    2e32:	f8 94       	cli
    2e34:	de bf       	out	0x3e, r29	; 62
    2e36:	0f be       	out	0x3f, r0	; 63
    2e38:	cd bf       	out	0x3d, r28	; 61
    2e3a:	cf 91       	pop	r28
    2e3c:	df 91       	pop	r29
    2e3e:	08 95       	ret

00002e40 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    2e40:	df 93       	push	r29
    2e42:	cf 93       	push	r28
    2e44:	cd b7       	in	r28, 0x3d	; 61
    2e46:	de b7       	in	r29, 0x3e	; 62
    2e48:	2a 97       	sbiw	r28, 0x0a	; 10
    2e4a:	0f b6       	in	r0, 0x3f	; 63
    2e4c:	f8 94       	cli
    2e4e:	de bf       	out	0x3e, r29	; 62
    2e50:	0f be       	out	0x3f, r0	; 63
    2e52:	cd bf       	out	0x3d, r28	; 61
    2e54:	9d 83       	std	Y+5, r25	; 0x05
    2e56:	8c 83       	std	Y+4, r24	; 0x04
    2e58:	7f 83       	std	Y+7, r23	; 0x07
    2e5a:	6e 83       	std	Y+6, r22	; 0x06
    2e5c:	59 87       	std	Y+9, r21	; 0x09
    2e5e:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2e60:	8c 81       	ldd	r24, Y+4	; 0x04
    2e62:	9d 81       	ldd	r25, Y+5	; 0x05
    2e64:	9a 83       	std	Y+2, r25	; 0x02
    2e66:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    2e68:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2e6a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e6c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e70:	88 23       	and	r24, r24
    2e72:	a9 f4       	brne	.+42     	; 0x2e9e <xQueueCRReceive+0x5e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    2e74:	88 85       	ldd	r24, Y+8	; 0x08
    2e76:	99 85       	ldd	r25, Y+9	; 0x09
    2e78:	00 97       	sbiw	r24, 0x00	; 0
    2e7a:	71 f0       	breq	.+28     	; 0x2e98 <xQueueCRReceive+0x58>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2e7c:	89 81       	ldd	r24, Y+1	; 0x01
    2e7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e80:	9c 01       	movw	r18, r24
    2e82:	2f 5e       	subi	r18, 0xEF	; 239
    2e84:	3f 4f       	sbci	r19, 0xFF	; 255
    2e86:	88 85       	ldd	r24, Y+8	; 0x08
    2e88:	99 85       	ldd	r25, Y+9	; 0x09
    2e8a:	b9 01       	movw	r22, r18
    2e8c:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    2e90:	78 94       	sei
					return errQUEUE_BLOCKED;
    2e92:	8c ef       	ldi	r24, 0xFC	; 252
    2e94:	8a 87       	std	Y+10, r24	; 0x0a
    2e96:	58 c0       	rjmp	.+176    	; 0x2f48 <xQueueCRReceive+0x108>
				}
				else
				{
					portENABLE_INTERRUPTS();
    2e98:	78 94       	sei
					return errQUEUE_FULL;
    2e9a:	1a 86       	std	Y+10, r1	; 0x0a
    2e9c:	55 c0       	rjmp	.+170    	; 0x2f48 <xQueueCRReceive+0x108>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    2e9e:	78 94       	sei

		portDISABLE_INTERRUPTS();
    2ea0:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2ea2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ea4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ea8:	88 23       	and	r24, r24
    2eaa:	09 f4       	brne	.+2      	; 0x2eae <xQueueCRReceive+0x6e>
    2eac:	49 c0       	rjmp	.+146    	; 0x2f40 <xQueueCRReceive+0x100>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2eae:	e9 81       	ldd	r30, Y+1	; 0x01
    2eb0:	fa 81       	ldd	r31, Y+2	; 0x02
    2eb2:	26 81       	ldd	r18, Z+6	; 0x06
    2eb4:	37 81       	ldd	r19, Z+7	; 0x07
    2eb6:	e9 81       	ldd	r30, Y+1	; 0x01
    2eb8:	fa 81       	ldd	r31, Y+2	; 0x02
    2eba:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ebc:	88 2f       	mov	r24, r24
    2ebe:	90 e0       	ldi	r25, 0x00	; 0
    2ec0:	82 0f       	add	r24, r18
    2ec2:	93 1f       	adc	r25, r19
    2ec4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ec6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ec8:	97 83       	std	Z+7, r25	; 0x07
    2eca:	86 83       	std	Z+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    2ecc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ece:	fa 81       	ldd	r31, Y+2	; 0x02
    2ed0:	26 81       	ldd	r18, Z+6	; 0x06
    2ed2:	37 81       	ldd	r19, Z+7	; 0x07
    2ed4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ed6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ed8:	82 81       	ldd	r24, Z+2	; 0x02
    2eda:	93 81       	ldd	r25, Z+3	; 0x03
    2edc:	28 17       	cp	r18, r24
    2ede:	39 07       	cpc	r19, r25
    2ee0:	40 f0       	brcs	.+16     	; 0x2ef2 <xQueueCRReceive+0xb2>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2ee2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ee4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ee6:	80 81       	ld	r24, Z
    2ee8:	91 81       	ldd	r25, Z+1	; 0x01
    2eea:	e9 81       	ldd	r30, Y+1	; 0x01
    2eec:	fa 81       	ldd	r31, Y+2	; 0x02
    2eee:	97 83       	std	Z+7, r25	; 0x07
    2ef0:	86 83       	std	Z+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    2ef2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ef4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ef6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ef8:	81 50       	subi	r24, 0x01	; 1
    2efa:	e9 81       	ldd	r30, Y+1	; 0x01
    2efc:	fa 81       	ldd	r31, Y+2	; 0x02
    2efe:	82 8f       	std	Z+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2f00:	e9 81       	ldd	r30, Y+1	; 0x01
    2f02:	fa 81       	ldd	r31, Y+2	; 0x02
    2f04:	46 81       	ldd	r20, Z+6	; 0x06
    2f06:	57 81       	ldd	r21, Z+7	; 0x07
    2f08:	e9 81       	ldd	r30, Y+1	; 0x01
    2f0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f0c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f0e:	28 2f       	mov	r18, r24
    2f10:	30 e0       	ldi	r19, 0x00	; 0
    2f12:	8e 81       	ldd	r24, Y+6	; 0x06
    2f14:	9f 81       	ldd	r25, Y+7	; 0x07
    2f16:	ba 01       	movw	r22, r20
    2f18:	a9 01       	movw	r20, r18
    2f1a:	0e 94 f7 23 	call	0x47ee	; 0x47ee <memcpy>

				xReturn = pdPASS;
    2f1e:	81 e0       	ldi	r24, 0x01	; 1
    2f20:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2f22:	e9 81       	ldd	r30, Y+1	; 0x01
    2f24:	fa 81       	ldd	r31, Y+2	; 0x02
    2f26:	80 85       	ldd	r24, Z+8	; 0x08
    2f28:	88 23       	and	r24, r24
    2f2a:	59 f0       	breq	.+22     	; 0x2f42 <xQueueCRReceive+0x102>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2f2c:	89 81       	ldd	r24, Y+1	; 0x01
    2f2e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f30:	08 96       	adiw	r24, 0x08	; 8
    2f32:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <xCoRoutineRemoveFromEventList>
    2f36:	88 23       	and	r24, r24
    2f38:	21 f0       	breq	.+8      	; 0x2f42 <xQueueCRReceive+0x102>
					{
						xReturn = errQUEUE_YIELD;
    2f3a:	8b ef       	ldi	r24, 0xFB	; 251
    2f3c:	8b 83       	std	Y+3, r24	; 0x03
    2f3e:	01 c0       	rjmp	.+2      	; 0x2f42 <xQueueCRReceive+0x102>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    2f40:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    2f42:	78 94       	sei

		return xReturn;
    2f44:	8b 81       	ldd	r24, Y+3	; 0x03
    2f46:	8a 87       	std	Y+10, r24	; 0x0a
    2f48:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    2f4a:	2a 96       	adiw	r28, 0x0a	; 10
    2f4c:	0f b6       	in	r0, 0x3f	; 63
    2f4e:	f8 94       	cli
    2f50:	de bf       	out	0x3e, r29	; 62
    2f52:	0f be       	out	0x3f, r0	; 63
    2f54:	cd bf       	out	0x3d, r28	; 61
    2f56:	cf 91       	pop	r28
    2f58:	df 91       	pop	r29
    2f5a:	08 95       	ret

00002f5c <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    2f5c:	df 93       	push	r29
    2f5e:	cf 93       	push	r28
    2f60:	cd b7       	in	r28, 0x3d	; 61
    2f62:	de b7       	in	r29, 0x3e	; 62
    2f64:	28 97       	sbiw	r28, 0x08	; 8
    2f66:	0f b6       	in	r0, 0x3f	; 63
    2f68:	f8 94       	cli
    2f6a:	de bf       	out	0x3e, r29	; 62
    2f6c:	0f be       	out	0x3f, r0	; 63
    2f6e:	cd bf       	out	0x3d, r28	; 61
    2f70:	9c 83       	std	Y+4, r25	; 0x04
    2f72:	8b 83       	std	Y+3, r24	; 0x03
    2f74:	7e 83       	std	Y+6, r23	; 0x06
    2f76:	6d 83       	std	Y+5, r22	; 0x05
    2f78:	4f 83       	std	Y+7, r20	; 0x07
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f7e:	9a 83       	std	Y+2, r25	; 0x02
    2f80:	89 83       	std	Y+1, r24	; 0x01

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2f82:	e9 81       	ldd	r30, Y+1	; 0x01
    2f84:	fa 81       	ldd	r31, Y+2	; 0x02
    2f86:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f88:	e9 81       	ldd	r30, Y+1	; 0x01
    2f8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f8c:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f8e:	98 17       	cp	r25, r24
    2f90:	d0 f4       	brcc	.+52     	; 0x2fc6 <xQueueCRSendFromISR+0x6a>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2f92:	89 81       	ldd	r24, Y+1	; 0x01
    2f94:	9a 81       	ldd	r25, Y+2	; 0x02
    2f96:	2d 81       	ldd	r18, Y+5	; 0x05
    2f98:	3e 81       	ldd	r19, Y+6	; 0x06
    2f9a:	b9 01       	movw	r22, r18
    2f9c:	40 e0       	ldi	r20, 0x00	; 0
    2f9e:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    2fa2:	8f 81       	ldd	r24, Y+7	; 0x07
    2fa4:	88 23       	and	r24, r24
    2fa6:	79 f4       	brne	.+30     	; 0x2fc6 <xQueueCRSendFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2fa8:	e9 81       	ldd	r30, Y+1	; 0x01
    2faa:	fa 81       	ldd	r31, Y+2	; 0x02
    2fac:	81 89       	ldd	r24, Z+17	; 0x11
    2fae:	88 23       	and	r24, r24
    2fb0:	51 f0       	breq	.+20     	; 0x2fc6 <xQueueCRSendFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2fb2:	89 81       	ldd	r24, Y+1	; 0x01
    2fb4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fb6:	41 96       	adiw	r24, 0x11	; 17
    2fb8:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <xCoRoutineRemoveFromEventList>
    2fbc:	88 23       	and	r24, r24
    2fbe:	19 f0       	breq	.+6      	; 0x2fc6 <xQueueCRSendFromISR+0x6a>
					{
						return pdTRUE;
    2fc0:	81 e0       	ldi	r24, 0x01	; 1
    2fc2:	88 87       	std	Y+8, r24	; 0x08
    2fc4:	02 c0       	rjmp	.+4      	; 0x2fca <xQueueCRSendFromISR+0x6e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    2fc6:	8f 81       	ldd	r24, Y+7	; 0x07
    2fc8:	88 87       	std	Y+8, r24	; 0x08
    2fca:	88 85       	ldd	r24, Y+8	; 0x08
	}
    2fcc:	28 96       	adiw	r28, 0x08	; 8
    2fce:	0f b6       	in	r0, 0x3f	; 63
    2fd0:	f8 94       	cli
    2fd2:	de bf       	out	0x3e, r29	; 62
    2fd4:	0f be       	out	0x3f, r0	; 63
    2fd6:	cd bf       	out	0x3d, r28	; 61
    2fd8:	cf 91       	pop	r28
    2fda:	df 91       	pop	r29
    2fdc:	08 95       	ret

00002fde <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    2fde:	df 93       	push	r29
    2fe0:	cf 93       	push	r28
    2fe2:	cd b7       	in	r28, 0x3d	; 61
    2fe4:	de b7       	in	r29, 0x3e	; 62
    2fe6:	29 97       	sbiw	r28, 0x09	; 9
    2fe8:	0f b6       	in	r0, 0x3f	; 63
    2fea:	f8 94       	cli
    2fec:	de bf       	out	0x3e, r29	; 62
    2fee:	0f be       	out	0x3f, r0	; 63
    2ff0:	cd bf       	out	0x3d, r28	; 61
    2ff2:	9d 83       	std	Y+5, r25	; 0x05
    2ff4:	8c 83       	std	Y+4, r24	; 0x04
    2ff6:	7f 83       	std	Y+7, r23	; 0x07
    2ff8:	6e 83       	std	Y+6, r22	; 0x06
    2ffa:	59 87       	std	Y+9, r21	; 0x09
    2ffc:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2ffe:	8c 81       	ldd	r24, Y+4	; 0x04
    3000:	9d 81       	ldd	r25, Y+5	; 0x05
    3002:	9a 83       	std	Y+2, r25	; 0x02
    3004:	89 83       	std	Y+1, r24	; 0x01

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3006:	e9 81       	ldd	r30, Y+1	; 0x01
    3008:	fa 81       	ldd	r31, Y+2	; 0x02
    300a:	82 8d       	ldd	r24, Z+26	; 0x1a
    300c:	88 23       	and	r24, r24
    300e:	09 f4       	brne	.+2      	; 0x3012 <xQueueCRReceiveFromISR+0x34>
    3010:	50 c0       	rjmp	.+160    	; 0x30b2 <xQueueCRReceiveFromISR+0xd4>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    3012:	e9 81       	ldd	r30, Y+1	; 0x01
    3014:	fa 81       	ldd	r31, Y+2	; 0x02
    3016:	26 81       	ldd	r18, Z+6	; 0x06
    3018:	37 81       	ldd	r19, Z+7	; 0x07
    301a:	e9 81       	ldd	r30, Y+1	; 0x01
    301c:	fa 81       	ldd	r31, Y+2	; 0x02
    301e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3020:	88 2f       	mov	r24, r24
    3022:	90 e0       	ldi	r25, 0x00	; 0
    3024:	82 0f       	add	r24, r18
    3026:	93 1f       	adc	r25, r19
    3028:	e9 81       	ldd	r30, Y+1	; 0x01
    302a:	fa 81       	ldd	r31, Y+2	; 0x02
    302c:	97 83       	std	Z+7, r25	; 0x07
    302e:	86 83       	std	Z+6, r24	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    3030:	e9 81       	ldd	r30, Y+1	; 0x01
    3032:	fa 81       	ldd	r31, Y+2	; 0x02
    3034:	26 81       	ldd	r18, Z+6	; 0x06
    3036:	37 81       	ldd	r19, Z+7	; 0x07
    3038:	e9 81       	ldd	r30, Y+1	; 0x01
    303a:	fa 81       	ldd	r31, Y+2	; 0x02
    303c:	82 81       	ldd	r24, Z+2	; 0x02
    303e:	93 81       	ldd	r25, Z+3	; 0x03
    3040:	28 17       	cp	r18, r24
    3042:	39 07       	cpc	r19, r25
    3044:	40 f0       	brcs	.+16     	; 0x3056 <xQueueCRReceiveFromISR+0x78>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    3046:	e9 81       	ldd	r30, Y+1	; 0x01
    3048:	fa 81       	ldd	r31, Y+2	; 0x02
    304a:	80 81       	ld	r24, Z
    304c:	91 81       	ldd	r25, Z+1	; 0x01
    304e:	e9 81       	ldd	r30, Y+1	; 0x01
    3050:	fa 81       	ldd	r31, Y+2	; 0x02
    3052:	97 83       	std	Z+7, r25	; 0x07
    3054:	86 83       	std	Z+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    3056:	e9 81       	ldd	r30, Y+1	; 0x01
    3058:	fa 81       	ldd	r31, Y+2	; 0x02
    305a:	82 8d       	ldd	r24, Z+26	; 0x1a
    305c:	81 50       	subi	r24, 0x01	; 1
    305e:	e9 81       	ldd	r30, Y+1	; 0x01
    3060:	fa 81       	ldd	r31, Y+2	; 0x02
    3062:	82 8f       	std	Z+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3064:	e9 81       	ldd	r30, Y+1	; 0x01
    3066:	fa 81       	ldd	r31, Y+2	; 0x02
    3068:	46 81       	ldd	r20, Z+6	; 0x06
    306a:	57 81       	ldd	r21, Z+7	; 0x07
    306c:	e9 81       	ldd	r30, Y+1	; 0x01
    306e:	fa 81       	ldd	r31, Y+2	; 0x02
    3070:	84 8d       	ldd	r24, Z+28	; 0x1c
    3072:	28 2f       	mov	r18, r24
    3074:	30 e0       	ldi	r19, 0x00	; 0
    3076:	8e 81       	ldd	r24, Y+6	; 0x06
    3078:	9f 81       	ldd	r25, Y+7	; 0x07
    307a:	ba 01       	movw	r22, r20
    307c:	a9 01       	movw	r20, r18
    307e:	0e 94 f7 23 	call	0x47ee	; 0x47ee <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    3082:	e8 85       	ldd	r30, Y+8	; 0x08
    3084:	f9 85       	ldd	r31, Y+9	; 0x09
    3086:	80 81       	ld	r24, Z
    3088:	88 23       	and	r24, r24
    308a:	81 f4       	brne	.+32     	; 0x30ac <xQueueCRReceiveFromISR+0xce>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    308c:	e9 81       	ldd	r30, Y+1	; 0x01
    308e:	fa 81       	ldd	r31, Y+2	; 0x02
    3090:	80 85       	ldd	r24, Z+8	; 0x08
    3092:	88 23       	and	r24, r24
    3094:	59 f0       	breq	.+22     	; 0x30ac <xQueueCRReceiveFromISR+0xce>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3096:	89 81       	ldd	r24, Y+1	; 0x01
    3098:	9a 81       	ldd	r25, Y+2	; 0x02
    309a:	08 96       	adiw	r24, 0x08	; 8
    309c:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <xCoRoutineRemoveFromEventList>
    30a0:	88 23       	and	r24, r24
    30a2:	21 f0       	breq	.+8      	; 0x30ac <xQueueCRReceiveFromISR+0xce>
					{
						*pxCoRoutineWoken = pdTRUE;
    30a4:	e8 85       	ldd	r30, Y+8	; 0x08
    30a6:	f9 85       	ldd	r31, Y+9	; 0x09
    30a8:	81 e0       	ldi	r24, 0x01	; 1
    30aa:	80 83       	st	Z, r24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    30ac:	81 e0       	ldi	r24, 0x01	; 1
    30ae:	8b 83       	std	Y+3, r24	; 0x03
    30b0:	01 c0       	rjmp	.+2      	; 0x30b4 <xQueueCRReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
    30b2:	1b 82       	std	Y+3, r1	; 0x03
		}

		return xReturn;
    30b4:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    30b6:	29 96       	adiw	r28, 0x09	; 9
    30b8:	0f b6       	in	r0, 0x3f	; 63
    30ba:	f8 94       	cli
    30bc:	de bf       	out	0x3e, r29	; 62
    30be:	0f be       	out	0x3f, r0	; 63
    30c0:	cd bf       	out	0x3d, r28	; 61
    30c2:	cf 91       	pop	r28
    30c4:	df 91       	pop	r29
    30c6:	08 95       	ret

000030c8 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    30c8:	af 92       	push	r10
    30ca:	bf 92       	push	r11
    30cc:	cf 92       	push	r12
    30ce:	df 92       	push	r13
    30d0:	ef 92       	push	r14
    30d2:	ff 92       	push	r15
    30d4:	0f 93       	push	r16
    30d6:	1f 93       	push	r17
    30d8:	df 93       	push	r29
    30da:	cf 93       	push	r28
    30dc:	cd b7       	in	r28, 0x3d	; 61
    30de:	de b7       	in	r29, 0x3e	; 62
    30e0:	64 97       	sbiw	r28, 0x14	; 20
    30e2:	0f b6       	in	r0, 0x3f	; 63
    30e4:	f8 94       	cli
    30e6:	de bf       	out	0x3e, r29	; 62
    30e8:	0f be       	out	0x3f, r0	; 63
    30ea:	cd bf       	out	0x3d, r28	; 61
    30ec:	9f 83       	std	Y+7, r25	; 0x07
    30ee:	8e 83       	std	Y+6, r24	; 0x06
    30f0:	79 87       	std	Y+9, r23	; 0x09
    30f2:	68 87       	std	Y+8, r22	; 0x08
    30f4:	5b 87       	std	Y+11, r21	; 0x0b
    30f6:	4a 87       	std	Y+10, r20	; 0x0a
    30f8:	3d 87       	std	Y+13, r19	; 0x0d
    30fa:	2c 87       	std	Y+12, r18	; 0x0c
    30fc:	0e 87       	std	Y+14, r16	; 0x0e
    30fe:	f8 8a       	std	Y+16, r15	; 0x10
    3100:	ef 86       	std	Y+15, r14	; 0x0f
    3102:	da 8a       	std	Y+18, r13	; 0x12
    3104:	c9 8a       	std	Y+17, r12	; 0x11
    3106:	bc 8a       	std	Y+20, r11	; 0x14
    3108:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    310a:	8a 85       	ldd	r24, Y+10	; 0x0a
    310c:	9b 85       	ldd	r25, Y+11	; 0x0b
    310e:	29 89       	ldd	r18, Y+17	; 0x11
    3110:	3a 89       	ldd	r19, Y+18	; 0x12
    3112:	b9 01       	movw	r22, r18
    3114:	0e 94 00 20 	call	0x4000	; 0x4000 <prvAllocateTCBAndStack>
    3118:	9c 83       	std	Y+4, r25	; 0x04
    311a:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    311c:	8b 81       	ldd	r24, Y+3	; 0x03
    311e:	9c 81       	ldd	r25, Y+4	; 0x04
    3120:	00 97       	sbiw	r24, 0x00	; 0
    3122:	09 f4       	brne	.+2      	; 0x3126 <xTaskGenericCreate+0x5e>
    3124:	8d c0       	rjmp	.+282    	; 0x3240 <xTaskGenericCreate+0x178>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    3126:	eb 81       	ldd	r30, Y+3	; 0x03
    3128:	fc 81       	ldd	r31, Y+4	; 0x04
    312a:	27 89       	ldd	r18, Z+23	; 0x17
    312c:	30 8d       	ldd	r19, Z+24	; 0x18
    312e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3130:	9b 85       	ldd	r25, Y+11	; 0x0b
    3132:	01 97       	sbiw	r24, 0x01	; 1
    3134:	82 0f       	add	r24, r18
    3136:	93 1f       	adc	r25, r19
    3138:	9a 83       	std	Y+2, r25	; 0x02
    313a:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    313c:	8b 81       	ldd	r24, Y+3	; 0x03
    313e:	9c 81       	ldd	r25, Y+4	; 0x04
    3140:	28 85       	ldd	r18, Y+8	; 0x08
    3142:	39 85       	ldd	r19, Y+9	; 0x09
    3144:	eb 89       	ldd	r30, Y+19	; 0x13
    3146:	fc 89       	ldd	r31, Y+20	; 0x14
    3148:	aa 85       	ldd	r26, Y+10	; 0x0a
    314a:	bb 85       	ldd	r27, Y+11	; 0x0b
    314c:	b9 01       	movw	r22, r18
    314e:	4e 85       	ldd	r20, Y+14	; 0x0e
    3150:	9f 01       	movw	r18, r30
    3152:	8d 01       	movw	r16, r26
    3154:	0e 94 c1 1e 	call	0x3d82	; 0x3d82 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3158:	89 81       	ldd	r24, Y+1	; 0x01
    315a:	9a 81       	ldd	r25, Y+2	; 0x02
    315c:	2e 81       	ldd	r18, Y+6	; 0x06
    315e:	3f 81       	ldd	r19, Y+7	; 0x07
    3160:	4c 85       	ldd	r20, Y+12	; 0x0c
    3162:	5d 85       	ldd	r21, Y+13	; 0x0d
    3164:	b9 01       	movw	r22, r18
    3166:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <pxPortInitialiseStack>
    316a:	eb 81       	ldd	r30, Y+3	; 0x03
    316c:	fc 81       	ldd	r31, Y+4	; 0x04
    316e:	91 83       	std	Z+1, r25	; 0x01
    3170:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    3172:	8f 85       	ldd	r24, Y+15	; 0x0f
    3174:	98 89       	ldd	r25, Y+16	; 0x10
    3176:	00 97       	sbiw	r24, 0x00	; 0
    3178:	31 f0       	breq	.+12     	; 0x3186 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    317a:	ef 85       	ldd	r30, Y+15	; 0x0f
    317c:	f8 89       	ldd	r31, Y+16	; 0x10
    317e:	8b 81       	ldd	r24, Y+3	; 0x03
    3180:	9c 81       	ldd	r25, Y+4	; 0x04
    3182:	91 83       	std	Z+1, r25	; 0x01
    3184:	80 83       	st	Z, r24
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    3186:	0f b6       	in	r0, 0x3f	; 63
    3188:	f8 94       	cli
    318a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    318c:	80 91 de 06 	lds	r24, 0x06DE
    3190:	8f 5f       	subi	r24, 0xFF	; 255
    3192:	80 93 de 06 	sts	0x06DE, r24
			if( pxCurrentTCB == NULL )
    3196:	80 91 db 06 	lds	r24, 0x06DB
    319a:	90 91 dc 06 	lds	r25, 0x06DC
    319e:	00 97       	sbiw	r24, 0x00	; 0
    31a0:	69 f4       	brne	.+26     	; 0x31bc <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    31a2:	8b 81       	ldd	r24, Y+3	; 0x03
    31a4:	9c 81       	ldd	r25, Y+4	; 0x04
    31a6:	90 93 dc 06 	sts	0x06DC, r25
    31aa:	80 93 db 06 	sts	0x06DB, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    31ae:	80 91 de 06 	lds	r24, 0x06DE
    31b2:	81 30       	cpi	r24, 0x01	; 1
    31b4:	a9 f4       	brne	.+42     	; 0x31e0 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    31b6:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <prvInitialiseTaskLists>
    31ba:	12 c0       	rjmp	.+36     	; 0x31e0 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    31bc:	80 91 e2 06 	lds	r24, 0x06E2
    31c0:	88 23       	and	r24, r24
    31c2:	71 f4       	brne	.+28     	; 0x31e0 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    31c4:	e0 91 db 06 	lds	r30, 0x06DB
    31c8:	f0 91 dc 06 	lds	r31, 0x06DC
    31cc:	96 89       	ldd	r25, Z+22	; 0x16
    31ce:	8e 85       	ldd	r24, Y+14	; 0x0e
    31d0:	89 17       	cp	r24, r25
    31d2:	30 f0       	brcs	.+12     	; 0x31e0 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    31d4:	8b 81       	ldd	r24, Y+3	; 0x03
    31d6:	9c 81       	ldd	r25, Y+4	; 0x04
    31d8:	90 93 dc 06 	sts	0x06DC, r25
    31dc:	80 93 db 06 	sts	0x06DB, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    31e0:	80 91 e6 06 	lds	r24, 0x06E6
    31e4:	8f 5f       	subi	r24, 0xFF	; 255
    31e6:	80 93 e6 06 	sts	0x06E6, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    31ea:	eb 81       	ldd	r30, Y+3	; 0x03
    31ec:	fc 81       	ldd	r31, Y+4	; 0x04
    31ee:	96 89       	ldd	r25, Z+22	; 0x16
    31f0:	80 91 e1 06 	lds	r24, 0x06E1
    31f4:	89 17       	cp	r24, r25
    31f6:	28 f4       	brcc	.+10     	; 0x3202 <xTaskGenericCreate+0x13a>
    31f8:	eb 81       	ldd	r30, Y+3	; 0x03
    31fa:	fc 81       	ldd	r31, Y+4	; 0x04
    31fc:	86 89       	ldd	r24, Z+22	; 0x16
    31fe:	80 93 e1 06 	sts	0x06E1, r24
    3202:	eb 81       	ldd	r30, Y+3	; 0x03
    3204:	fc 81       	ldd	r31, Y+4	; 0x04
    3206:	86 89       	ldd	r24, Z+22	; 0x16
    3208:	28 2f       	mov	r18, r24
    320a:	30 e0       	ldi	r19, 0x00	; 0
    320c:	c9 01       	movw	r24, r18
    320e:	88 0f       	add	r24, r24
    3210:	99 1f       	adc	r25, r25
    3212:	88 0f       	add	r24, r24
    3214:	99 1f       	adc	r25, r25
    3216:	88 0f       	add	r24, r24
    3218:	99 1f       	adc	r25, r25
    321a:	82 0f       	add	r24, r18
    321c:	93 1f       	adc	r25, r19
    321e:	ac 01       	movw	r20, r24
    3220:	48 51       	subi	r20, 0x18	; 24
    3222:	59 4f       	sbci	r21, 0xF9	; 249
    3224:	8b 81       	ldd	r24, Y+3	; 0x03
    3226:	9c 81       	ldd	r25, Y+4	; 0x04
    3228:	9c 01       	movw	r18, r24
    322a:	2e 5f       	subi	r18, 0xFE	; 254
    322c:	3f 4f       	sbci	r19, 0xFF	; 255
    322e:	ca 01       	movw	r24, r20
    3230:	b9 01       	movw	r22, r18
    3232:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>

			xReturn = pdPASS;
    3236:	81 e0       	ldi	r24, 0x01	; 1
    3238:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    323a:	0f 90       	pop	r0
    323c:	0f be       	out	0x3f, r0	; 63
    323e:	02 c0       	rjmp	.+4      	; 0x3244 <xTaskGenericCreate+0x17c>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3240:	8f ef       	ldi	r24, 0xFF	; 255
    3242:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    3244:	8d 81       	ldd	r24, Y+5	; 0x05
    3246:	81 30       	cpi	r24, 0x01	; 1
    3248:	71 f4       	brne	.+28     	; 0x3266 <xTaskGenericCreate+0x19e>
	{
		if( xSchedulerRunning != pdFALSE )
    324a:	80 91 e2 06 	lds	r24, 0x06E2
    324e:	88 23       	and	r24, r24
    3250:	51 f0       	breq	.+20     	; 0x3266 <xTaskGenericCreate+0x19e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    3252:	e0 91 db 06 	lds	r30, 0x06DB
    3256:	f0 91 dc 06 	lds	r31, 0x06DC
    325a:	96 89       	ldd	r25, Z+22	; 0x16
    325c:	8e 85       	ldd	r24, Y+14	; 0x0e
    325e:	98 17       	cp	r25, r24
    3260:	10 f4       	brcc	.+4      	; 0x3266 <xTaskGenericCreate+0x19e>
			{
				taskYIELD_IF_USING_PREEMPTION();
    3262:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    3266:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3268:	64 96       	adiw	r28, 0x14	; 20
    326a:	0f b6       	in	r0, 0x3f	; 63
    326c:	f8 94       	cli
    326e:	de bf       	out	0x3e, r29	; 62
    3270:	0f be       	out	0x3f, r0	; 63
    3272:	cd bf       	out	0x3d, r28	; 61
    3274:	cf 91       	pop	r28
    3276:	df 91       	pop	r29
    3278:	1f 91       	pop	r17
    327a:	0f 91       	pop	r16
    327c:	ff 90       	pop	r15
    327e:	ef 90       	pop	r14
    3280:	df 90       	pop	r13
    3282:	cf 90       	pop	r12
    3284:	bf 90       	pop	r11
    3286:	af 90       	pop	r10
    3288:	08 95       	ret

0000328a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    328a:	df 93       	push	r29
    328c:	cf 93       	push	r28
    328e:	00 d0       	rcall	.+0      	; 0x3290 <vTaskDelete+0x6>
    3290:	00 d0       	rcall	.+0      	; 0x3292 <vTaskDelete+0x8>
    3292:	00 d0       	rcall	.+0      	; 0x3294 <vTaskDelete+0xa>
    3294:	cd b7       	in	r28, 0x3d	; 61
    3296:	de b7       	in	r29, 0x3e	; 62
    3298:	9c 83       	std	Y+4, r25	; 0x04
    329a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    329c:	0f b6       	in	r0, 0x3f	; 63
    329e:	f8 94       	cli
    32a0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    32a2:	8b 81       	ldd	r24, Y+3	; 0x03
    32a4:	9c 81       	ldd	r25, Y+4	; 0x04
    32a6:	00 97       	sbiw	r24, 0x00	; 0
    32a8:	39 f4       	brne	.+14     	; 0x32b8 <vTaskDelete+0x2e>
    32aa:	80 91 db 06 	lds	r24, 0x06DB
    32ae:	90 91 dc 06 	lds	r25, 0x06DC
    32b2:	9e 83       	std	Y+6, r25	; 0x06
    32b4:	8d 83       	std	Y+5, r24	; 0x05
    32b6:	04 c0       	rjmp	.+8      	; 0x32c0 <vTaskDelete+0x36>
    32b8:	8b 81       	ldd	r24, Y+3	; 0x03
    32ba:	9c 81       	ldd	r25, Y+4	; 0x04
    32bc:	9e 83       	std	Y+6, r25	; 0x06
    32be:	8d 83       	std	Y+5, r24	; 0x05
    32c0:	8d 81       	ldd	r24, Y+5	; 0x05
    32c2:	9e 81       	ldd	r25, Y+6	; 0x06
    32c4:	9a 83       	std	Y+2, r25	; 0x02
    32c6:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    32c8:	89 81       	ldd	r24, Y+1	; 0x01
    32ca:	9a 81       	ldd	r25, Y+2	; 0x02
    32cc:	02 96       	adiw	r24, 0x02	; 2
    32ce:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    32d2:	e9 81       	ldd	r30, Y+1	; 0x01
    32d4:	fa 81       	ldd	r31, Y+2	; 0x02
    32d6:	84 89       	ldd	r24, Z+20	; 0x14
    32d8:	95 89       	ldd	r25, Z+21	; 0x15
    32da:	00 97       	sbiw	r24, 0x00	; 0
    32dc:	29 f0       	breq	.+10     	; 0x32e8 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    32de:	89 81       	ldd	r24, Y+1	; 0x01
    32e0:	9a 81       	ldd	r25, Y+2	; 0x02
    32e2:	0c 96       	adiw	r24, 0x0c	; 12
    32e4:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    32e8:	89 81       	ldd	r24, Y+1	; 0x01
    32ea:	9a 81       	ldd	r25, Y+2	; 0x02
    32ec:	9c 01       	movw	r18, r24
    32ee:	2e 5f       	subi	r18, 0xFE	; 254
    32f0:	3f 4f       	sbci	r19, 0xFF	; 255
    32f2:	8b e2       	ldi	r24, 0x2B	; 43
    32f4:	97 e0       	ldi	r25, 0x07	; 7
    32f6:	b9 01       	movw	r22, r18
    32f8:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    32fc:	80 91 dd 06 	lds	r24, 0x06DD
    3300:	8f 5f       	subi	r24, 0xFF	; 255
    3302:	80 93 dd 06 	sts	0x06DD, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    3306:	80 91 e6 06 	lds	r24, 0x06E6
    330a:	8f 5f       	subi	r24, 0xFF	; 255
    330c:	80 93 e6 06 	sts	0x06E6, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3310:	0f 90       	pop	r0
    3312:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    3314:	80 91 e2 06 	lds	r24, 0x06E2
    3318:	88 23       	and	r24, r24
    331a:	99 f0       	breq	.+38     	; 0x3342 <vTaskDelete+0xb8>
		{
			if( pxTCB == pxCurrentTCB )
    331c:	20 91 db 06 	lds	r18, 0x06DB
    3320:	30 91 dc 06 	lds	r19, 0x06DC
    3324:	89 81       	ldd	r24, Y+1	; 0x01
    3326:	9a 81       	ldd	r25, Y+2	; 0x02
    3328:	82 17       	cp	r24, r18
    332a:	93 07       	cpc	r25, r19
    332c:	19 f4       	brne	.+6      	; 0x3334 <vTaskDelete+0xaa>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    332e:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
    3332:	07 c0       	rjmp	.+14     	; 0x3342 <vTaskDelete+0xb8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    3334:	0f b6       	in	r0, 0x3f	; 63
    3336:	f8 94       	cli
    3338:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    333a:	0e 94 5a 20 	call	0x40b4	; 0x40b4 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    333e:	0f 90       	pop	r0
    3340:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    3342:	26 96       	adiw	r28, 0x06	; 6
    3344:	0f b6       	in	r0, 0x3f	; 63
    3346:	f8 94       	cli
    3348:	de bf       	out	0x3e, r29	; 62
    334a:	0f be       	out	0x3f, r0	; 63
    334c:	cd bf       	out	0x3d, r28	; 61
    334e:	cf 91       	pop	r28
    3350:	df 91       	pop	r29
    3352:	08 95       	ret

00003354 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    3354:	df 93       	push	r29
    3356:	cf 93       	push	r28
    3358:	cd b7       	in	r28, 0x3d	; 61
    335a:	de b7       	in	r29, 0x3e	; 62
    335c:	2a 97       	sbiw	r28, 0x0a	; 10
    335e:	0f b6       	in	r0, 0x3f	; 63
    3360:	f8 94       	cli
    3362:	de bf       	out	0x3e, r29	; 62
    3364:	0f be       	out	0x3f, r0	; 63
    3366:	cd bf       	out	0x3d, r28	; 61
    3368:	98 87       	std	Y+8, r25	; 0x08
    336a:	8f 83       	std	Y+7, r24	; 0x07
    336c:	7a 87       	std	Y+10, r23	; 0x0a
    336e:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3370:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    3372:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3376:	80 91 df 06 	lds	r24, 0x06DF
    337a:	90 91 e0 06 	lds	r25, 0x06E0
    337e:	9a 83       	std	Y+2, r25	; 0x02
    3380:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3382:	ef 81       	ldd	r30, Y+7	; 0x07
    3384:	f8 85       	ldd	r31, Y+8	; 0x08
    3386:	20 81       	ld	r18, Z
    3388:	31 81       	ldd	r19, Z+1	; 0x01
    338a:	89 85       	ldd	r24, Y+9	; 0x09
    338c:	9a 85       	ldd	r25, Y+10	; 0x0a
    338e:	82 0f       	add	r24, r18
    3390:	93 1f       	adc	r25, r19
    3392:	9e 83       	std	Y+6, r25	; 0x06
    3394:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    3396:	ef 81       	ldd	r30, Y+7	; 0x07
    3398:	f8 85       	ldd	r31, Y+8	; 0x08
    339a:	20 81       	ld	r18, Z
    339c:	31 81       	ldd	r19, Z+1	; 0x01
    339e:	89 81       	ldd	r24, Y+1	; 0x01
    33a0:	9a 81       	ldd	r25, Y+2	; 0x02
    33a2:	82 17       	cp	r24, r18
    33a4:	93 07       	cpc	r25, r19
    33a6:	98 f4       	brcc	.+38     	; 0x33ce <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    33a8:	ef 81       	ldd	r30, Y+7	; 0x07
    33aa:	f8 85       	ldd	r31, Y+8	; 0x08
    33ac:	20 81       	ld	r18, Z
    33ae:	31 81       	ldd	r19, Z+1	; 0x01
    33b0:	8d 81       	ldd	r24, Y+5	; 0x05
    33b2:	9e 81       	ldd	r25, Y+6	; 0x06
    33b4:	82 17       	cp	r24, r18
    33b6:	93 07       	cpc	r25, r19
    33b8:	e0 f4       	brcc	.+56     	; 0x33f2 <vTaskDelayUntil+0x9e>
    33ba:	2d 81       	ldd	r18, Y+5	; 0x05
    33bc:	3e 81       	ldd	r19, Y+6	; 0x06
    33be:	89 81       	ldd	r24, Y+1	; 0x01
    33c0:	9a 81       	ldd	r25, Y+2	; 0x02
    33c2:	82 17       	cp	r24, r18
    33c4:	93 07       	cpc	r25, r19
    33c6:	a8 f4       	brcc	.+42     	; 0x33f2 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    33c8:	81 e0       	ldi	r24, 0x01	; 1
    33ca:	8b 83       	std	Y+3, r24	; 0x03
    33cc:	12 c0       	rjmp	.+36     	; 0x33f2 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    33ce:	ef 81       	ldd	r30, Y+7	; 0x07
    33d0:	f8 85       	ldd	r31, Y+8	; 0x08
    33d2:	20 81       	ld	r18, Z
    33d4:	31 81       	ldd	r19, Z+1	; 0x01
    33d6:	8d 81       	ldd	r24, Y+5	; 0x05
    33d8:	9e 81       	ldd	r25, Y+6	; 0x06
    33da:	82 17       	cp	r24, r18
    33dc:	93 07       	cpc	r25, r19
    33de:	38 f0       	brcs	.+14     	; 0x33ee <vTaskDelayUntil+0x9a>
    33e0:	2d 81       	ldd	r18, Y+5	; 0x05
    33e2:	3e 81       	ldd	r19, Y+6	; 0x06
    33e4:	89 81       	ldd	r24, Y+1	; 0x01
    33e6:	9a 81       	ldd	r25, Y+2	; 0x02
    33e8:	82 17       	cp	r24, r18
    33ea:	93 07       	cpc	r25, r19
    33ec:	10 f4       	brcc	.+4      	; 0x33f2 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    33ee:	81 e0       	ldi	r24, 0x01	; 1
    33f0:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    33f2:	ef 81       	ldd	r30, Y+7	; 0x07
    33f4:	f8 85       	ldd	r31, Y+8	; 0x08
    33f6:	8d 81       	ldd	r24, Y+5	; 0x05
    33f8:	9e 81       	ldd	r25, Y+6	; 0x06
    33fa:	91 83       	std	Z+1, r25	; 0x01
    33fc:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    33fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3400:	88 23       	and	r24, r24
    3402:	59 f0       	breq	.+22     	; 0x341a <vTaskDelayUntil+0xc6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3404:	80 91 db 06 	lds	r24, 0x06DB
    3408:	90 91 dc 06 	lds	r25, 0x06DC
    340c:	02 96       	adiw	r24, 0x02	; 2
    340e:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3412:	8d 81       	ldd	r24, Y+5	; 0x05
    3414:	9e 81       	ldd	r25, Y+6	; 0x06
    3416:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    341a:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>
    341e:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3420:	8c 81       	ldd	r24, Y+4	; 0x04
    3422:	88 23       	and	r24, r24
    3424:	11 f4       	brne	.+4      	; 0x342a <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    3426:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    342a:	2a 96       	adiw	r28, 0x0a	; 10
    342c:	0f b6       	in	r0, 0x3f	; 63
    342e:	f8 94       	cli
    3430:	de bf       	out	0x3e, r29	; 62
    3432:	0f be       	out	0x3f, r0	; 63
    3434:	cd bf       	out	0x3d, r28	; 61
    3436:	cf 91       	pop	r28
    3438:	df 91       	pop	r29
    343a:	08 95       	ret

0000343c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    343c:	df 93       	push	r29
    343e:	cf 93       	push	r28
    3440:	00 d0       	rcall	.+0      	; 0x3442 <vTaskDelay+0x6>
    3442:	00 d0       	rcall	.+0      	; 0x3444 <vTaskDelay+0x8>
    3444:	0f 92       	push	r0
    3446:	cd b7       	in	r28, 0x3d	; 61
    3448:	de b7       	in	r29, 0x3e	; 62
    344a:	9d 83       	std	Y+5, r25	; 0x05
    344c:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    344e:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3450:	8c 81       	ldd	r24, Y+4	; 0x04
    3452:	9d 81       	ldd	r25, Y+5	; 0x05
    3454:	00 97       	sbiw	r24, 0x00	; 0
    3456:	d1 f0       	breq	.+52     	; 0x348c <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3458:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    345c:	20 91 df 06 	lds	r18, 0x06DF
    3460:	30 91 e0 06 	lds	r19, 0x06E0
    3464:	8c 81       	ldd	r24, Y+4	; 0x04
    3466:	9d 81       	ldd	r25, Y+5	; 0x05
    3468:	82 0f       	add	r24, r18
    346a:	93 1f       	adc	r25, r19
    346c:	9b 83       	std	Y+3, r25	; 0x03
    346e:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3470:	80 91 db 06 	lds	r24, 0x06DB
    3474:	90 91 dc 06 	lds	r25, 0x06DC
    3478:	02 96       	adiw	r24, 0x02	; 2
    347a:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    347e:	8a 81       	ldd	r24, Y+2	; 0x02
    3480:	9b 81       	ldd	r25, Y+3	; 0x03
    3482:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3486:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>
    348a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    348c:	89 81       	ldd	r24, Y+1	; 0x01
    348e:	88 23       	and	r24, r24
    3490:	11 f4       	brne	.+4      	; 0x3496 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3492:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3496:	0f 90       	pop	r0
    3498:	0f 90       	pop	r0
    349a:	0f 90       	pop	r0
    349c:	0f 90       	pop	r0
    349e:	0f 90       	pop	r0
    34a0:	cf 91       	pop	r28
    34a2:	df 91       	pop	r29
    34a4:	08 95       	ret

000034a6 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
    34a6:	df 93       	push	r29
    34a8:	cf 93       	push	r28
    34aa:	cd b7       	in	r28, 0x3d	; 61
    34ac:	de b7       	in	r29, 0x3e	; 62
    34ae:	27 97       	sbiw	r28, 0x07	; 7
    34b0:	0f b6       	in	r0, 0x3f	; 63
    34b2:	f8 94       	cli
    34b4:	de bf       	out	0x3e, r29	; 62
    34b6:	0f be       	out	0x3f, r0	; 63
    34b8:	cd bf       	out	0x3d, r28	; 61
    34ba:	9d 83       	std	Y+5, r25	; 0x05
    34bc:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    34be:	0f b6       	in	r0, 0x3f	; 63
    34c0:	f8 94       	cli
    34c2:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
    34c4:	8c 81       	ldd	r24, Y+4	; 0x04
    34c6:	9d 81       	ldd	r25, Y+5	; 0x05
    34c8:	00 97       	sbiw	r24, 0x00	; 0
    34ca:	39 f4       	brne	.+14     	; 0x34da <uxTaskPriorityGet+0x34>
    34cc:	80 91 db 06 	lds	r24, 0x06DB
    34d0:	90 91 dc 06 	lds	r25, 0x06DC
    34d4:	9f 83       	std	Y+7, r25	; 0x07
    34d6:	8e 83       	std	Y+6, r24	; 0x06
    34d8:	04 c0       	rjmp	.+8      	; 0x34e2 <uxTaskPriorityGet+0x3c>
    34da:	8c 81       	ldd	r24, Y+4	; 0x04
    34dc:	9d 81       	ldd	r25, Y+5	; 0x05
    34de:	9f 83       	std	Y+7, r25	; 0x07
    34e0:	8e 83       	std	Y+6, r24	; 0x06
    34e2:	8e 81       	ldd	r24, Y+6	; 0x06
    34e4:	9f 81       	ldd	r25, Y+7	; 0x07
    34e6:	9b 83       	std	Y+3, r25	; 0x03
    34e8:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    34ea:	ea 81       	ldd	r30, Y+2	; 0x02
    34ec:	fb 81       	ldd	r31, Y+3	; 0x03
    34ee:	86 89       	ldd	r24, Z+22	; 0x16
    34f0:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    34f2:	0f 90       	pop	r0
    34f4:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    34f6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    34f8:	27 96       	adiw	r28, 0x07	; 7
    34fa:	0f b6       	in	r0, 0x3f	; 63
    34fc:	f8 94       	cli
    34fe:	de bf       	out	0x3e, r29	; 62
    3500:	0f be       	out	0x3f, r0	; 63
    3502:	cd bf       	out	0x3d, r28	; 61
    3504:	cf 91       	pop	r28
    3506:	df 91       	pop	r29
    3508:	08 95       	ret

0000350a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    350a:	af 92       	push	r10
    350c:	bf 92       	push	r11
    350e:	cf 92       	push	r12
    3510:	df 92       	push	r13
    3512:	ef 92       	push	r14
    3514:	ff 92       	push	r15
    3516:	0f 93       	push	r16
    3518:	df 93       	push	r29
    351a:	cf 93       	push	r28
    351c:	0f 92       	push	r0
    351e:	cd b7       	in	r28, 0x3d	; 61
    3520:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    3522:	81 eb       	ldi	r24, 0xB1	; 177
    3524:	9e e1       	ldi	r25, 0x1E	; 30
    3526:	28 e7       	ldi	r18, 0x78	; 120
    3528:	30 e0       	ldi	r19, 0x00	; 0
    352a:	b9 01       	movw	r22, r18
    352c:	45 e5       	ldi	r20, 0x55	; 85
    352e:	50 e0       	ldi	r21, 0x00	; 0
    3530:	20 e0       	ldi	r18, 0x00	; 0
    3532:	30 e0       	ldi	r19, 0x00	; 0
    3534:	00 e0       	ldi	r16, 0x00	; 0
    3536:	ee 24       	eor	r14, r14
    3538:	ff 24       	eor	r15, r15
    353a:	cc 24       	eor	r12, r12
    353c:	dd 24       	eor	r13, r13
    353e:	aa 24       	eor	r10, r10
    3540:	bb 24       	eor	r11, r11
    3542:	0e 94 64 18 	call	0x30c8	; 0x30c8 <xTaskGenericCreate>
    3546:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    3548:	89 81       	ldd	r24, Y+1	; 0x01
    354a:	81 30       	cpi	r24, 0x01	; 1
    354c:	51 f4       	brne	.+20     	; 0x3562 <vTaskStartScheduler+0x58>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    354e:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    3550:	81 e0       	ldi	r24, 0x01	; 1
    3552:	80 93 e2 06 	sts	0x06E2, r24
		xTickCount = ( TickType_t ) 0U;
    3556:	10 92 e0 06 	sts	0x06E0, r1
    355a:	10 92 df 06 	sts	0x06DF, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    355e:	0e 94 67 0f 	call	0x1ece	; 0x1ece <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    3562:	0f 90       	pop	r0
    3564:	cf 91       	pop	r28
    3566:	df 91       	pop	r29
    3568:	0f 91       	pop	r16
    356a:	ff 90       	pop	r15
    356c:	ef 90       	pop	r14
    356e:	df 90       	pop	r13
    3570:	cf 90       	pop	r12
    3572:	bf 90       	pop	r11
    3574:	af 90       	pop	r10
    3576:	08 95       	ret

00003578 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3578:	df 93       	push	r29
    357a:	cf 93       	push	r28
    357c:	cd b7       	in	r28, 0x3d	; 61
    357e:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3580:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3582:	10 92 e2 06 	sts	0x06E2, r1
	vPortEndScheduler();
    3586:	0e 94 9c 0f 	call	0x1f38	; 0x1f38 <vPortEndScheduler>
}
    358a:	cf 91       	pop	r28
    358c:	df 91       	pop	r29
    358e:	08 95       	ret

00003590 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3590:	df 93       	push	r29
    3592:	cf 93       	push	r28
    3594:	cd b7       	in	r28, 0x3d	; 61
    3596:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3598:	80 91 e7 06 	lds	r24, 0x06E7
    359c:	8f 5f       	subi	r24, 0xFF	; 255
    359e:	80 93 e7 06 	sts	0x06E7, r24
}
    35a2:	cf 91       	pop	r28
    35a4:	df 91       	pop	r29
    35a6:	08 95       	ret

000035a8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    35a8:	df 93       	push	r29
    35aa:	cf 93       	push	r28
    35ac:	00 d0       	rcall	.+0      	; 0x35ae <xTaskResumeAll+0x6>
    35ae:	0f 92       	push	r0
    35b0:	cd b7       	in	r28, 0x3d	; 61
    35b2:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    35b4:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    35b6:	0f b6       	in	r0, 0x3f	; 63
    35b8:	f8 94       	cli
    35ba:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    35bc:	80 91 e7 06 	lds	r24, 0x06E7
    35c0:	81 50       	subi	r24, 0x01	; 1
    35c2:	80 93 e7 06 	sts	0x06E7, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    35c6:	80 91 e7 06 	lds	r24, 0x06E7
    35ca:	88 23       	and	r24, r24
    35cc:	09 f0       	breq	.+2      	; 0x35d0 <xTaskResumeAll+0x28>
    35ce:	6d c0       	rjmp	.+218    	; 0x36aa <xTaskResumeAll+0x102>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    35d0:	80 91 de 06 	lds	r24, 0x06DE
    35d4:	88 23       	and	r24, r24
    35d6:	09 f4       	brne	.+2      	; 0x35da <xTaskResumeAll+0x32>
    35d8:	68 c0       	rjmp	.+208    	; 0x36aa <xTaskResumeAll+0x102>
    35da:	45 c0       	rjmp	.+138    	; 0x3666 <xTaskResumeAll+0xbe>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    35dc:	e0 91 27 07 	lds	r30, 0x0727
    35e0:	f0 91 28 07 	lds	r31, 0x0728
    35e4:	86 81       	ldd	r24, Z+6	; 0x06
    35e6:	97 81       	ldd	r25, Z+7	; 0x07
    35e8:	9b 83       	std	Y+3, r25	; 0x03
    35ea:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    35ec:	8a 81       	ldd	r24, Y+2	; 0x02
    35ee:	9b 81       	ldd	r25, Y+3	; 0x03
    35f0:	0c 96       	adiw	r24, 0x0c	; 12
    35f2:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    35f6:	8a 81       	ldd	r24, Y+2	; 0x02
    35f8:	9b 81       	ldd	r25, Y+3	; 0x03
    35fa:	02 96       	adiw	r24, 0x02	; 2
    35fc:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3600:	ea 81       	ldd	r30, Y+2	; 0x02
    3602:	fb 81       	ldd	r31, Y+3	; 0x03
    3604:	96 89       	ldd	r25, Z+22	; 0x16
    3606:	80 91 e1 06 	lds	r24, 0x06E1
    360a:	89 17       	cp	r24, r25
    360c:	28 f4       	brcc	.+10     	; 0x3618 <xTaskResumeAll+0x70>
    360e:	ea 81       	ldd	r30, Y+2	; 0x02
    3610:	fb 81       	ldd	r31, Y+3	; 0x03
    3612:	86 89       	ldd	r24, Z+22	; 0x16
    3614:	80 93 e1 06 	sts	0x06E1, r24
    3618:	ea 81       	ldd	r30, Y+2	; 0x02
    361a:	fb 81       	ldd	r31, Y+3	; 0x03
    361c:	86 89       	ldd	r24, Z+22	; 0x16
    361e:	28 2f       	mov	r18, r24
    3620:	30 e0       	ldi	r19, 0x00	; 0
    3622:	c9 01       	movw	r24, r18
    3624:	88 0f       	add	r24, r24
    3626:	99 1f       	adc	r25, r25
    3628:	88 0f       	add	r24, r24
    362a:	99 1f       	adc	r25, r25
    362c:	88 0f       	add	r24, r24
    362e:	99 1f       	adc	r25, r25
    3630:	82 0f       	add	r24, r18
    3632:	93 1f       	adc	r25, r19
    3634:	ac 01       	movw	r20, r24
    3636:	48 51       	subi	r20, 0x18	; 24
    3638:	59 4f       	sbci	r21, 0xF9	; 249
    363a:	8a 81       	ldd	r24, Y+2	; 0x02
    363c:	9b 81       	ldd	r25, Y+3	; 0x03
    363e:	9c 01       	movw	r18, r24
    3640:	2e 5f       	subi	r18, 0xFE	; 254
    3642:	3f 4f       	sbci	r19, 0xFF	; 255
    3644:	ca 01       	movw	r24, r20
    3646:	b9 01       	movw	r22, r18
    3648:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    364c:	ea 81       	ldd	r30, Y+2	; 0x02
    364e:	fb 81       	ldd	r31, Y+3	; 0x03
    3650:	96 89       	ldd	r25, Z+22	; 0x16
    3652:	e0 91 db 06 	lds	r30, 0x06DB
    3656:	f0 91 dc 06 	lds	r31, 0x06DC
    365a:	86 89       	ldd	r24, Z+22	; 0x16
    365c:	98 17       	cp	r25, r24
    365e:	18 f0       	brcs	.+6      	; 0x3666 <xTaskResumeAll+0xbe>
					{
						xYieldPending = pdTRUE;
    3660:	81 e0       	ldi	r24, 0x01	; 1
    3662:	80 93 e4 06 	sts	0x06E4, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3666:	80 91 22 07 	lds	r24, 0x0722
    366a:	88 23       	and	r24, r24
    366c:	09 f0       	breq	.+2      	; 0x3670 <xTaskResumeAll+0xc8>
    366e:	b6 cf       	rjmp	.-148    	; 0x35dc <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    3670:	80 91 e3 06 	lds	r24, 0x06E3
    3674:	88 23       	and	r24, r24
    3676:	89 f0       	breq	.+34     	; 0x369a <xTaskResumeAll+0xf2>
    3678:	0c c0       	rjmp	.+24     	; 0x3692 <xTaskResumeAll+0xea>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    367a:	0e 94 93 1b 	call	0x3726	; 0x3726 <xTaskIncrementTick>
    367e:	88 23       	and	r24, r24
    3680:	19 f0       	breq	.+6      	; 0x3688 <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
    3682:	81 e0       	ldi	r24, 0x01	; 1
    3684:	80 93 e4 06 	sts	0x06E4, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    3688:	80 91 e3 06 	lds	r24, 0x06E3
    368c:	81 50       	subi	r24, 0x01	; 1
    368e:	80 93 e3 06 	sts	0x06E3, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    3692:	80 91 e3 06 	lds	r24, 0x06E3
    3696:	88 23       	and	r24, r24
    3698:	81 f7       	brne	.-32     	; 0x367a <xTaskResumeAll+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    369a:	80 91 e4 06 	lds	r24, 0x06E4
    369e:	81 30       	cpi	r24, 0x01	; 1
    36a0:	21 f4       	brne	.+8      	; 0x36aa <xTaskResumeAll+0x102>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    36a2:	81 e0       	ldi	r24, 0x01	; 1
    36a4:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    36a6:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    36aa:	0f 90       	pop	r0
    36ac:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    36ae:	89 81       	ldd	r24, Y+1	; 0x01
}
    36b0:	0f 90       	pop	r0
    36b2:	0f 90       	pop	r0
    36b4:	0f 90       	pop	r0
    36b6:	cf 91       	pop	r28
    36b8:	df 91       	pop	r29
    36ba:	08 95       	ret

000036bc <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    36bc:	df 93       	push	r29
    36be:	cf 93       	push	r28
    36c0:	00 d0       	rcall	.+0      	; 0x36c2 <xTaskGetTickCount+0x6>
    36c2:	cd b7       	in	r28, 0x3d	; 61
    36c4:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    36c6:	0f b6       	in	r0, 0x3f	; 63
    36c8:	f8 94       	cli
    36ca:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    36cc:	80 91 df 06 	lds	r24, 0x06DF
    36d0:	90 91 e0 06 	lds	r25, 0x06E0
    36d4:	9a 83       	std	Y+2, r25	; 0x02
    36d6:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    36d8:	0f 90       	pop	r0
    36da:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    36dc:	89 81       	ldd	r24, Y+1	; 0x01
    36de:	9a 81       	ldd	r25, Y+2	; 0x02
}
    36e0:	0f 90       	pop	r0
    36e2:	0f 90       	pop	r0
    36e4:	cf 91       	pop	r28
    36e6:	df 91       	pop	r29
    36e8:	08 95       	ret

000036ea <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    36ea:	df 93       	push	r29
    36ec:	cf 93       	push	r28
    36ee:	00 d0       	rcall	.+0      	; 0x36f0 <xTaskGetTickCountFromISR+0x6>
    36f0:	0f 92       	push	r0
    36f2:	cd b7       	in	r28, 0x3d	; 61
    36f4:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    36f6:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    36f8:	80 91 df 06 	lds	r24, 0x06DF
    36fc:	90 91 e0 06 	lds	r25, 0x06E0
    3700:	9b 83       	std	Y+3, r25	; 0x03
    3702:	8a 83       	std	Y+2, r24	; 0x02
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3704:	8a 81       	ldd	r24, Y+2	; 0x02
    3706:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3708:	0f 90       	pop	r0
    370a:	0f 90       	pop	r0
    370c:	0f 90       	pop	r0
    370e:	cf 91       	pop	r28
    3710:	df 91       	pop	r29
    3712:	08 95       	ret

00003714 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3714:	df 93       	push	r29
    3716:	cf 93       	push	r28
    3718:	cd b7       	in	r28, 0x3d	; 61
    371a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    371c:	80 91 de 06 	lds	r24, 0x06DE
}
    3720:	cf 91       	pop	r28
    3722:	df 91       	pop	r29
    3724:	08 95       	ret

00003726 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3726:	df 93       	push	r29
    3728:	cf 93       	push	r28
    372a:	cd b7       	in	r28, 0x3d	; 61
    372c:	de b7       	in	r29, 0x3e	; 62
    372e:	29 97       	sbiw	r28, 0x09	; 9
    3730:	0f b6       	in	r0, 0x3f	; 63
    3732:	f8 94       	cli
    3734:	de bf       	out	0x3e, r29	; 62
    3736:	0f be       	out	0x3f, r0	; 63
    3738:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    373a:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    373c:	80 91 e7 06 	lds	r24, 0x06E7
    3740:	88 23       	and	r24, r24
    3742:	09 f0       	breq	.+2      	; 0x3746 <xTaskIncrementTick+0x20>
    3744:	c2 c0       	rjmp	.+388    	; 0x38ca <xTaskIncrementTick+0x1a4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    3746:	80 91 df 06 	lds	r24, 0x06DF
    374a:	90 91 e0 06 	lds	r25, 0x06E0
    374e:	01 96       	adiw	r24, 0x01	; 1
    3750:	90 93 e0 06 	sts	0x06E0, r25
    3754:	80 93 df 06 	sts	0x06DF, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3758:	80 91 df 06 	lds	r24, 0x06DF
    375c:	90 91 e0 06 	lds	r25, 0x06E0
    3760:	9c 83       	std	Y+4, r25	; 0x04
    3762:	8b 83       	std	Y+3, r24	; 0x03

			if( xConstTickCount == ( TickType_t ) 0U )
    3764:	8b 81       	ldd	r24, Y+3	; 0x03
    3766:	9c 81       	ldd	r25, Y+4	; 0x04
    3768:	00 97       	sbiw	r24, 0x00	; 0
    376a:	d9 f4       	brne	.+54     	; 0x37a2 <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    376c:	80 91 1e 07 	lds	r24, 0x071E
    3770:	90 91 1f 07 	lds	r25, 0x071F
    3774:	9a 83       	std	Y+2, r25	; 0x02
    3776:	89 83       	std	Y+1, r24	; 0x01
    3778:	80 91 20 07 	lds	r24, 0x0720
    377c:	90 91 21 07 	lds	r25, 0x0721
    3780:	90 93 1f 07 	sts	0x071F, r25
    3784:	80 93 1e 07 	sts	0x071E, r24
    3788:	89 81       	ldd	r24, Y+1	; 0x01
    378a:	9a 81       	ldd	r25, Y+2	; 0x02
    378c:	90 93 21 07 	sts	0x0721, r25
    3790:	80 93 20 07 	sts	0x0720, r24
    3794:	80 91 e5 06 	lds	r24, 0x06E5
    3798:	8f 5f       	subi	r24, 0xFF	; 255
    379a:	80 93 e5 06 	sts	0x06E5, r24
    379e:	0e 94 5a 20 	call	0x40b4	; 0x40b4 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    37a2:	20 91 b5 00 	lds	r18, 0x00B5
    37a6:	30 91 b6 00 	lds	r19, 0x00B6
    37aa:	8b 81       	ldd	r24, Y+3	; 0x03
    37ac:	9c 81       	ldd	r25, Y+4	; 0x04
    37ae:	82 17       	cp	r24, r18
    37b0:	93 07       	cpc	r25, r19
    37b2:	08 f4       	brcc	.+2      	; 0x37b6 <xTaskIncrementTick+0x90>
    37b4:	71 c0       	rjmp	.+226    	; 0x3898 <xTaskIncrementTick+0x172>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    37b6:	e0 91 1e 07 	lds	r30, 0x071E
    37ba:	f0 91 1f 07 	lds	r31, 0x071F
    37be:	80 81       	ld	r24, Z
    37c0:	88 23       	and	r24, r24
    37c2:	39 f4       	brne	.+14     	; 0x37d2 <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    37c4:	8f ef       	ldi	r24, 0xFF	; 255
    37c6:	9f ef       	ldi	r25, 0xFF	; 255
    37c8:	90 93 b6 00 	sts	0x00B6, r25
    37cc:	80 93 b5 00 	sts	0x00B5, r24
    37d0:	63 c0       	rjmp	.+198    	; 0x3898 <xTaskIncrementTick+0x172>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    37d2:	e0 91 1e 07 	lds	r30, 0x071E
    37d6:	f0 91 1f 07 	lds	r31, 0x071F
    37da:	05 80       	ldd	r0, Z+5	; 0x05
    37dc:	f6 81       	ldd	r31, Z+6	; 0x06
    37de:	e0 2d       	mov	r30, r0
    37e0:	86 81       	ldd	r24, Z+6	; 0x06
    37e2:	97 81       	ldd	r25, Z+7	; 0x07
    37e4:	99 87       	std	Y+9, r25	; 0x09
    37e6:	88 87       	std	Y+8, r24	; 0x08
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    37e8:	e8 85       	ldd	r30, Y+8	; 0x08
    37ea:	f9 85       	ldd	r31, Y+9	; 0x09
    37ec:	82 81       	ldd	r24, Z+2	; 0x02
    37ee:	93 81       	ldd	r25, Z+3	; 0x03
    37f0:	9f 83       	std	Y+7, r25	; 0x07
    37f2:	8e 83       	std	Y+6, r24	; 0x06

						if( xConstTickCount < xItemValue )
    37f4:	2b 81       	ldd	r18, Y+3	; 0x03
    37f6:	3c 81       	ldd	r19, Y+4	; 0x04
    37f8:	8e 81       	ldd	r24, Y+6	; 0x06
    37fa:	9f 81       	ldd	r25, Y+7	; 0x07
    37fc:	28 17       	cp	r18, r24
    37fe:	39 07       	cpc	r19, r25
    3800:	38 f4       	brcc	.+14     	; 0x3810 <xTaskIncrementTick+0xea>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    3802:	8e 81       	ldd	r24, Y+6	; 0x06
    3804:	9f 81       	ldd	r25, Y+7	; 0x07
    3806:	90 93 b6 00 	sts	0x00B6, r25
    380a:	80 93 b5 00 	sts	0x00B5, r24
    380e:	44 c0       	rjmp	.+136    	; 0x3898 <xTaskIncrementTick+0x172>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3810:	88 85       	ldd	r24, Y+8	; 0x08
    3812:	99 85       	ldd	r25, Y+9	; 0x09
    3814:	02 96       	adiw	r24, 0x02	; 2
    3816:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    381a:	e8 85       	ldd	r30, Y+8	; 0x08
    381c:	f9 85       	ldd	r31, Y+9	; 0x09
    381e:	84 89       	ldd	r24, Z+20	; 0x14
    3820:	95 89       	ldd	r25, Z+21	; 0x15
    3822:	00 97       	sbiw	r24, 0x00	; 0
    3824:	29 f0       	breq	.+10     	; 0x3830 <xTaskIncrementTick+0x10a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3826:	88 85       	ldd	r24, Y+8	; 0x08
    3828:	99 85       	ldd	r25, Y+9	; 0x09
    382a:	0c 96       	adiw	r24, 0x0c	; 12
    382c:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    3830:	e8 85       	ldd	r30, Y+8	; 0x08
    3832:	f9 85       	ldd	r31, Y+9	; 0x09
    3834:	96 89       	ldd	r25, Z+22	; 0x16
    3836:	80 91 e1 06 	lds	r24, 0x06E1
    383a:	89 17       	cp	r24, r25
    383c:	28 f4       	brcc	.+10     	; 0x3848 <xTaskIncrementTick+0x122>
    383e:	e8 85       	ldd	r30, Y+8	; 0x08
    3840:	f9 85       	ldd	r31, Y+9	; 0x09
    3842:	86 89       	ldd	r24, Z+22	; 0x16
    3844:	80 93 e1 06 	sts	0x06E1, r24
    3848:	e8 85       	ldd	r30, Y+8	; 0x08
    384a:	f9 85       	ldd	r31, Y+9	; 0x09
    384c:	86 89       	ldd	r24, Z+22	; 0x16
    384e:	28 2f       	mov	r18, r24
    3850:	30 e0       	ldi	r19, 0x00	; 0
    3852:	c9 01       	movw	r24, r18
    3854:	88 0f       	add	r24, r24
    3856:	99 1f       	adc	r25, r25
    3858:	88 0f       	add	r24, r24
    385a:	99 1f       	adc	r25, r25
    385c:	88 0f       	add	r24, r24
    385e:	99 1f       	adc	r25, r25
    3860:	82 0f       	add	r24, r18
    3862:	93 1f       	adc	r25, r19
    3864:	ac 01       	movw	r20, r24
    3866:	48 51       	subi	r20, 0x18	; 24
    3868:	59 4f       	sbci	r21, 0xF9	; 249
    386a:	88 85       	ldd	r24, Y+8	; 0x08
    386c:	99 85       	ldd	r25, Y+9	; 0x09
    386e:	9c 01       	movw	r18, r24
    3870:	2e 5f       	subi	r18, 0xFE	; 254
    3872:	3f 4f       	sbci	r19, 0xFF	; 255
    3874:	ca 01       	movw	r24, r20
    3876:	b9 01       	movw	r22, r18
    3878:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    387c:	e8 85       	ldd	r30, Y+8	; 0x08
    387e:	f9 85       	ldd	r31, Y+9	; 0x09
    3880:	96 89       	ldd	r25, Z+22	; 0x16
    3882:	e0 91 db 06 	lds	r30, 0x06DB
    3886:	f0 91 dc 06 	lds	r31, 0x06DC
    388a:	86 89       	ldd	r24, Z+22	; 0x16
    388c:	98 17       	cp	r25, r24
    388e:	08 f4       	brcc	.+2      	; 0x3892 <xTaskIncrementTick+0x16c>
    3890:	92 cf       	rjmp	.-220    	; 0x37b6 <xTaskIncrementTick+0x90>
							{
								xSwitchRequired = pdTRUE;
    3892:	81 e0       	ldi	r24, 0x01	; 1
    3894:	8d 83       	std	Y+5, r24	; 0x05
    3896:	8f cf       	rjmp	.-226    	; 0x37b6 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3898:	e0 91 db 06 	lds	r30, 0x06DB
    389c:	f0 91 dc 06 	lds	r31, 0x06DC
    38a0:	86 89       	ldd	r24, Z+22	; 0x16
    38a2:	28 2f       	mov	r18, r24
    38a4:	30 e0       	ldi	r19, 0x00	; 0
    38a6:	c9 01       	movw	r24, r18
    38a8:	88 0f       	add	r24, r24
    38aa:	99 1f       	adc	r25, r25
    38ac:	88 0f       	add	r24, r24
    38ae:	99 1f       	adc	r25, r25
    38b0:	88 0f       	add	r24, r24
    38b2:	99 1f       	adc	r25, r25
    38b4:	82 0f       	add	r24, r18
    38b6:	93 1f       	adc	r25, r19
    38b8:	fc 01       	movw	r30, r24
    38ba:	e8 51       	subi	r30, 0x18	; 24
    38bc:	f9 4f       	sbci	r31, 0xF9	; 249
    38be:	80 81       	ld	r24, Z
    38c0:	82 30       	cpi	r24, 0x02	; 2
    38c2:	40 f0       	brcs	.+16     	; 0x38d4 <xTaskIncrementTick+0x1ae>
			{
				xSwitchRequired = pdTRUE;
    38c4:	81 e0       	ldi	r24, 0x01	; 1
    38c6:	8d 83       	std	Y+5, r24	; 0x05
    38c8:	05 c0       	rjmp	.+10     	; 0x38d4 <xTaskIncrementTick+0x1ae>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    38ca:	80 91 e3 06 	lds	r24, 0x06E3
    38ce:	8f 5f       	subi	r24, 0xFF	; 255
    38d0:	80 93 e3 06 	sts	0x06E3, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    38d4:	80 91 e4 06 	lds	r24, 0x06E4
    38d8:	88 23       	and	r24, r24
    38da:	11 f0       	breq	.+4      	; 0x38e0 <xTaskIncrementTick+0x1ba>
		{
			xSwitchRequired = pdTRUE;
    38dc:	81 e0       	ldi	r24, 0x01	; 1
    38de:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    38e0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    38e2:	29 96       	adiw	r28, 0x09	; 9
    38e4:	0f b6       	in	r0, 0x3f	; 63
    38e6:	f8 94       	cli
    38e8:	de bf       	out	0x3e, r29	; 62
    38ea:	0f be       	out	0x3f, r0	; 63
    38ec:	cd bf       	out	0x3d, r28	; 61
    38ee:	cf 91       	pop	r28
    38f0:	df 91       	pop	r29
    38f2:	08 95       	ret

000038f4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    38f4:	df 93       	push	r29
    38f6:	cf 93       	push	r28
    38f8:	00 d0       	rcall	.+0      	; 0x38fa <vTaskSwitchContext+0x6>
    38fa:	cd b7       	in	r28, 0x3d	; 61
    38fc:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    38fe:	80 91 e7 06 	lds	r24, 0x06E7
    3902:	88 23       	and	r24, r24
    3904:	21 f0       	breq	.+8      	; 0x390e <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3906:	81 e0       	ldi	r24, 0x01	; 1
    3908:	80 93 e4 06 	sts	0x06E4, r24
    390c:	57 c0       	rjmp	.+174    	; 0x39bc <vTaskSwitchContext+0xc8>
	}
	else
	{
		xYieldPending = pdFALSE;
    390e:	10 92 e4 06 	sts	0x06E4, r1
    3912:	05 c0       	rjmp	.+10     	; 0x391e <vTaskSwitchContext+0x2a>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    3914:	80 91 e1 06 	lds	r24, 0x06E1
    3918:	81 50       	subi	r24, 0x01	; 1
    391a:	80 93 e1 06 	sts	0x06E1, r24
    391e:	80 91 e1 06 	lds	r24, 0x06E1
    3922:	28 2f       	mov	r18, r24
    3924:	30 e0       	ldi	r19, 0x00	; 0
    3926:	c9 01       	movw	r24, r18
    3928:	88 0f       	add	r24, r24
    392a:	99 1f       	adc	r25, r25
    392c:	88 0f       	add	r24, r24
    392e:	99 1f       	adc	r25, r25
    3930:	88 0f       	add	r24, r24
    3932:	99 1f       	adc	r25, r25
    3934:	82 0f       	add	r24, r18
    3936:	93 1f       	adc	r25, r19
    3938:	fc 01       	movw	r30, r24
    393a:	e8 51       	subi	r30, 0x18	; 24
    393c:	f9 4f       	sbci	r31, 0xF9	; 249
    393e:	80 81       	ld	r24, Z
    3940:	88 23       	and	r24, r24
    3942:	41 f3       	breq	.-48     	; 0x3914 <vTaskSwitchContext+0x20>
    3944:	80 91 e1 06 	lds	r24, 0x06E1
    3948:	28 2f       	mov	r18, r24
    394a:	30 e0       	ldi	r19, 0x00	; 0
    394c:	c9 01       	movw	r24, r18
    394e:	88 0f       	add	r24, r24
    3950:	99 1f       	adc	r25, r25
    3952:	88 0f       	add	r24, r24
    3954:	99 1f       	adc	r25, r25
    3956:	88 0f       	add	r24, r24
    3958:	99 1f       	adc	r25, r25
    395a:	82 0f       	add	r24, r18
    395c:	93 1f       	adc	r25, r19
    395e:	88 51       	subi	r24, 0x18	; 24
    3960:	99 4f       	sbci	r25, 0xF9	; 249
    3962:	9a 83       	std	Y+2, r25	; 0x02
    3964:	89 83       	std	Y+1, r24	; 0x01
    3966:	e9 81       	ldd	r30, Y+1	; 0x01
    3968:	fa 81       	ldd	r31, Y+2	; 0x02
    396a:	01 80       	ldd	r0, Z+1	; 0x01
    396c:	f2 81       	ldd	r31, Z+2	; 0x02
    396e:	e0 2d       	mov	r30, r0
    3970:	82 81       	ldd	r24, Z+2	; 0x02
    3972:	93 81       	ldd	r25, Z+3	; 0x03
    3974:	e9 81       	ldd	r30, Y+1	; 0x01
    3976:	fa 81       	ldd	r31, Y+2	; 0x02
    3978:	92 83       	std	Z+2, r25	; 0x02
    397a:	81 83       	std	Z+1, r24	; 0x01
    397c:	e9 81       	ldd	r30, Y+1	; 0x01
    397e:	fa 81       	ldd	r31, Y+2	; 0x02
    3980:	21 81       	ldd	r18, Z+1	; 0x01
    3982:	32 81       	ldd	r19, Z+2	; 0x02
    3984:	89 81       	ldd	r24, Y+1	; 0x01
    3986:	9a 81       	ldd	r25, Y+2	; 0x02
    3988:	03 96       	adiw	r24, 0x03	; 3
    398a:	28 17       	cp	r18, r24
    398c:	39 07       	cpc	r19, r25
    398e:	59 f4       	brne	.+22     	; 0x39a6 <vTaskSwitchContext+0xb2>
    3990:	e9 81       	ldd	r30, Y+1	; 0x01
    3992:	fa 81       	ldd	r31, Y+2	; 0x02
    3994:	01 80       	ldd	r0, Z+1	; 0x01
    3996:	f2 81       	ldd	r31, Z+2	; 0x02
    3998:	e0 2d       	mov	r30, r0
    399a:	82 81       	ldd	r24, Z+2	; 0x02
    399c:	93 81       	ldd	r25, Z+3	; 0x03
    399e:	e9 81       	ldd	r30, Y+1	; 0x01
    39a0:	fa 81       	ldd	r31, Y+2	; 0x02
    39a2:	92 83       	std	Z+2, r25	; 0x02
    39a4:	81 83       	std	Z+1, r24	; 0x01
    39a6:	e9 81       	ldd	r30, Y+1	; 0x01
    39a8:	fa 81       	ldd	r31, Y+2	; 0x02
    39aa:	01 80       	ldd	r0, Z+1	; 0x01
    39ac:	f2 81       	ldd	r31, Z+2	; 0x02
    39ae:	e0 2d       	mov	r30, r0
    39b0:	86 81       	ldd	r24, Z+6	; 0x06
    39b2:	97 81       	ldd	r25, Z+7	; 0x07
    39b4:	90 93 dc 06 	sts	0x06DC, r25
    39b8:	80 93 db 06 	sts	0x06DB, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    39bc:	0f 90       	pop	r0
    39be:	0f 90       	pop	r0
    39c0:	cf 91       	pop	r28
    39c2:	df 91       	pop	r29
    39c4:	08 95       	ret

000039c6 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    39c6:	df 93       	push	r29
    39c8:	cf 93       	push	r28
    39ca:	00 d0       	rcall	.+0      	; 0x39cc <vTaskPlaceOnEventList+0x6>
    39cc:	00 d0       	rcall	.+0      	; 0x39ce <vTaskPlaceOnEventList+0x8>
    39ce:	00 d0       	rcall	.+0      	; 0x39d0 <vTaskPlaceOnEventList+0xa>
    39d0:	cd b7       	in	r28, 0x3d	; 61
    39d2:	de b7       	in	r29, 0x3e	; 62
    39d4:	9c 83       	std	Y+4, r25	; 0x04
    39d6:	8b 83       	std	Y+3, r24	; 0x03
    39d8:	7e 83       	std	Y+6, r23	; 0x06
    39da:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    39dc:	80 91 db 06 	lds	r24, 0x06DB
    39e0:	90 91 dc 06 	lds	r25, 0x06DC
    39e4:	9c 01       	movw	r18, r24
    39e6:	24 5f       	subi	r18, 0xF4	; 244
    39e8:	3f 4f       	sbci	r19, 0xFF	; 255
    39ea:	8b 81       	ldd	r24, Y+3	; 0x03
    39ec:	9c 81       	ldd	r25, Y+4	; 0x04
    39ee:	b9 01       	movw	r22, r18
    39f0:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    39f4:	80 91 db 06 	lds	r24, 0x06DB
    39f8:	90 91 dc 06 	lds	r25, 0x06DC
    39fc:	02 96       	adiw	r24, 0x02	; 2
    39fe:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    3a02:	20 91 df 06 	lds	r18, 0x06DF
    3a06:	30 91 e0 06 	lds	r19, 0x06E0
    3a0a:	8d 81       	ldd	r24, Y+5	; 0x05
    3a0c:	9e 81       	ldd	r25, Y+6	; 0x06
    3a0e:	82 0f       	add	r24, r18
    3a10:	93 1f       	adc	r25, r19
    3a12:	9a 83       	std	Y+2, r25	; 0x02
    3a14:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3a16:	89 81       	ldd	r24, Y+1	; 0x01
    3a18:	9a 81       	ldd	r25, Y+2	; 0x02
    3a1a:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3a1e:	26 96       	adiw	r28, 0x06	; 6
    3a20:	0f b6       	in	r0, 0x3f	; 63
    3a22:	f8 94       	cli
    3a24:	de bf       	out	0x3e, r29	; 62
    3a26:	0f be       	out	0x3f, r0	; 63
    3a28:	cd bf       	out	0x3d, r28	; 61
    3a2a:	cf 91       	pop	r28
    3a2c:	df 91       	pop	r29
    3a2e:	08 95       	ret

00003a30 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3a30:	df 93       	push	r29
    3a32:	cf 93       	push	r28
    3a34:	cd b7       	in	r28, 0x3d	; 61
    3a36:	de b7       	in	r29, 0x3e	; 62
    3a38:	28 97       	sbiw	r28, 0x08	; 8
    3a3a:	0f b6       	in	r0, 0x3f	; 63
    3a3c:	f8 94       	cli
    3a3e:	de bf       	out	0x3e, r29	; 62
    3a40:	0f be       	out	0x3f, r0	; 63
    3a42:	cd bf       	out	0x3d, r28	; 61
    3a44:	9c 83       	std	Y+4, r25	; 0x04
    3a46:	8b 83       	std	Y+3, r24	; 0x03
    3a48:	7e 83       	std	Y+6, r23	; 0x06
    3a4a:	6d 83       	std	Y+5, r22	; 0x05
    3a4c:	58 87       	std	Y+8, r21	; 0x08
    3a4e:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3a50:	e0 91 db 06 	lds	r30, 0x06DB
    3a54:	f0 91 dc 06 	lds	r31, 0x06DC
    3a58:	8d 81       	ldd	r24, Y+5	; 0x05
    3a5a:	9e 81       	ldd	r25, Y+6	; 0x06
    3a5c:	90 68       	ori	r25, 0x80	; 128
    3a5e:	95 87       	std	Z+13, r25	; 0x0d
    3a60:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3a62:	80 91 db 06 	lds	r24, 0x06DB
    3a66:	90 91 dc 06 	lds	r25, 0x06DC
    3a6a:	9c 01       	movw	r18, r24
    3a6c:	24 5f       	subi	r18, 0xF4	; 244
    3a6e:	3f 4f       	sbci	r19, 0xFF	; 255
    3a70:	8b 81       	ldd	r24, Y+3	; 0x03
    3a72:	9c 81       	ldd	r25, Y+4	; 0x04
    3a74:	b9 01       	movw	r22, r18
    3a76:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3a7a:	80 91 db 06 	lds	r24, 0x06DB
    3a7e:	90 91 dc 06 	lds	r25, 0x06DC
    3a82:	02 96       	adiw	r24, 0x02	; 2
    3a84:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    3a88:	20 91 df 06 	lds	r18, 0x06DF
    3a8c:	30 91 e0 06 	lds	r19, 0x06E0
    3a90:	8f 81       	ldd	r24, Y+7	; 0x07
    3a92:	98 85       	ldd	r25, Y+8	; 0x08
    3a94:	82 0f       	add	r24, r18
    3a96:	93 1f       	adc	r25, r19
    3a98:	9a 83       	std	Y+2, r25	; 0x02
    3a9a:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3a9c:	89 81       	ldd	r24, Y+1	; 0x01
    3a9e:	9a 81       	ldd	r25, Y+2	; 0x02
    3aa0:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3aa4:	28 96       	adiw	r28, 0x08	; 8
    3aa6:	0f b6       	in	r0, 0x3f	; 63
    3aa8:	f8 94       	cli
    3aaa:	de bf       	out	0x3e, r29	; 62
    3aac:	0f be       	out	0x3f, r0	; 63
    3aae:	cd bf       	out	0x3d, r28	; 61
    3ab0:	cf 91       	pop	r28
    3ab2:	df 91       	pop	r29
    3ab4:	08 95       	ret

00003ab6 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3ab6:	df 93       	push	r29
    3ab8:	cf 93       	push	r28
    3aba:	00 d0       	rcall	.+0      	; 0x3abc <xTaskRemoveFromEventList+0x6>
    3abc:	00 d0       	rcall	.+0      	; 0x3abe <xTaskRemoveFromEventList+0x8>
    3abe:	0f 92       	push	r0
    3ac0:	cd b7       	in	r28, 0x3d	; 61
    3ac2:	de b7       	in	r29, 0x3e	; 62
    3ac4:	9d 83       	std	Y+5, r25	; 0x05
    3ac6:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3ac8:	ec 81       	ldd	r30, Y+4	; 0x04
    3aca:	fd 81       	ldd	r31, Y+5	; 0x05
    3acc:	05 80       	ldd	r0, Z+5	; 0x05
    3ace:	f6 81       	ldd	r31, Z+6	; 0x06
    3ad0:	e0 2d       	mov	r30, r0
    3ad2:	86 81       	ldd	r24, Z+6	; 0x06
    3ad4:	97 81       	ldd	r25, Z+7	; 0x07
    3ad6:	9b 83       	std	Y+3, r25	; 0x03
    3ad8:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3ada:	8a 81       	ldd	r24, Y+2	; 0x02
    3adc:	9b 81       	ldd	r25, Y+3	; 0x03
    3ade:	0c 96       	adiw	r24, 0x0c	; 12
    3ae0:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3ae4:	80 91 e7 06 	lds	r24, 0x06E7
    3ae8:	88 23       	and	r24, r24
    3aea:	61 f5       	brne	.+88     	; 0x3b44 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3aec:	8a 81       	ldd	r24, Y+2	; 0x02
    3aee:	9b 81       	ldd	r25, Y+3	; 0x03
    3af0:	02 96       	adiw	r24, 0x02	; 2
    3af2:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3af6:	ea 81       	ldd	r30, Y+2	; 0x02
    3af8:	fb 81       	ldd	r31, Y+3	; 0x03
    3afa:	96 89       	ldd	r25, Z+22	; 0x16
    3afc:	80 91 e1 06 	lds	r24, 0x06E1
    3b00:	89 17       	cp	r24, r25
    3b02:	28 f4       	brcc	.+10     	; 0x3b0e <xTaskRemoveFromEventList+0x58>
    3b04:	ea 81       	ldd	r30, Y+2	; 0x02
    3b06:	fb 81       	ldd	r31, Y+3	; 0x03
    3b08:	86 89       	ldd	r24, Z+22	; 0x16
    3b0a:	80 93 e1 06 	sts	0x06E1, r24
    3b0e:	ea 81       	ldd	r30, Y+2	; 0x02
    3b10:	fb 81       	ldd	r31, Y+3	; 0x03
    3b12:	86 89       	ldd	r24, Z+22	; 0x16
    3b14:	28 2f       	mov	r18, r24
    3b16:	30 e0       	ldi	r19, 0x00	; 0
    3b18:	c9 01       	movw	r24, r18
    3b1a:	88 0f       	add	r24, r24
    3b1c:	99 1f       	adc	r25, r25
    3b1e:	88 0f       	add	r24, r24
    3b20:	99 1f       	adc	r25, r25
    3b22:	88 0f       	add	r24, r24
    3b24:	99 1f       	adc	r25, r25
    3b26:	82 0f       	add	r24, r18
    3b28:	93 1f       	adc	r25, r19
    3b2a:	ac 01       	movw	r20, r24
    3b2c:	48 51       	subi	r20, 0x18	; 24
    3b2e:	59 4f       	sbci	r21, 0xF9	; 249
    3b30:	8a 81       	ldd	r24, Y+2	; 0x02
    3b32:	9b 81       	ldd	r25, Y+3	; 0x03
    3b34:	9c 01       	movw	r18, r24
    3b36:	2e 5f       	subi	r18, 0xFE	; 254
    3b38:	3f 4f       	sbci	r19, 0xFF	; 255
    3b3a:	ca 01       	movw	r24, r20
    3b3c:	b9 01       	movw	r22, r18
    3b3e:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>
    3b42:	0a c0       	rjmp	.+20     	; 0x3b58 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3b44:	8a 81       	ldd	r24, Y+2	; 0x02
    3b46:	9b 81       	ldd	r25, Y+3	; 0x03
    3b48:	9c 01       	movw	r18, r24
    3b4a:	24 5f       	subi	r18, 0xF4	; 244
    3b4c:	3f 4f       	sbci	r19, 0xFF	; 255
    3b4e:	82 e2       	ldi	r24, 0x22	; 34
    3b50:	97 e0       	ldi	r25, 0x07	; 7
    3b52:	b9 01       	movw	r22, r18
    3b54:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3b58:	ea 81       	ldd	r30, Y+2	; 0x02
    3b5a:	fb 81       	ldd	r31, Y+3	; 0x03
    3b5c:	96 89       	ldd	r25, Z+22	; 0x16
    3b5e:	e0 91 db 06 	lds	r30, 0x06DB
    3b62:	f0 91 dc 06 	lds	r31, 0x06DC
    3b66:	86 89       	ldd	r24, Z+22	; 0x16
    3b68:	89 17       	cp	r24, r25
    3b6a:	30 f4       	brcc	.+12     	; 0x3b78 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3b6c:	81 e0       	ldi	r24, 0x01	; 1
    3b6e:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3b70:	81 e0       	ldi	r24, 0x01	; 1
    3b72:	80 93 e4 06 	sts	0x06E4, r24
    3b76:	01 c0       	rjmp	.+2      	; 0x3b7a <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3b78:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3b7a:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b7c:	0f 90       	pop	r0
    3b7e:	0f 90       	pop	r0
    3b80:	0f 90       	pop	r0
    3b82:	0f 90       	pop	r0
    3b84:	0f 90       	pop	r0
    3b86:	cf 91       	pop	r28
    3b88:	df 91       	pop	r29
    3b8a:	08 95       	ret

00003b8c <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3b8c:	df 93       	push	r29
    3b8e:	cf 93       	push	r28
    3b90:	cd b7       	in	r28, 0x3d	; 61
    3b92:	de b7       	in	r29, 0x3e	; 62
    3b94:	27 97       	sbiw	r28, 0x07	; 7
    3b96:	0f b6       	in	r0, 0x3f	; 63
    3b98:	f8 94       	cli
    3b9a:	de bf       	out	0x3e, r29	; 62
    3b9c:	0f be       	out	0x3f, r0	; 63
    3b9e:	cd bf       	out	0x3d, r28	; 61
    3ba0:	9d 83       	std	Y+5, r25	; 0x05
    3ba2:	8c 83       	std	Y+4, r24	; 0x04
    3ba4:	7f 83       	std	Y+7, r23	; 0x07
    3ba6:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3ba8:	8e 81       	ldd	r24, Y+6	; 0x06
    3baa:	9f 81       	ldd	r25, Y+7	; 0x07
    3bac:	90 68       	ori	r25, 0x80	; 128
    3bae:	ec 81       	ldd	r30, Y+4	; 0x04
    3bb0:	fd 81       	ldd	r31, Y+5	; 0x05
    3bb2:	91 83       	std	Z+1, r25	; 0x01
    3bb4:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    3bb6:	ec 81       	ldd	r30, Y+4	; 0x04
    3bb8:	fd 81       	ldd	r31, Y+5	; 0x05
    3bba:	86 81       	ldd	r24, Z+6	; 0x06
    3bbc:	97 81       	ldd	r25, Z+7	; 0x07
    3bbe:	9b 83       	std	Y+3, r25	; 0x03
    3bc0:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3bc2:	8c 81       	ldd	r24, Y+4	; 0x04
    3bc4:	9d 81       	ldd	r25, Y+5	; 0x05
    3bc6:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3bca:	8a 81       	ldd	r24, Y+2	; 0x02
    3bcc:	9b 81       	ldd	r25, Y+3	; 0x03
    3bce:	02 96       	adiw	r24, 0x02	; 2
    3bd0:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3bd4:	ea 81       	ldd	r30, Y+2	; 0x02
    3bd6:	fb 81       	ldd	r31, Y+3	; 0x03
    3bd8:	96 89       	ldd	r25, Z+22	; 0x16
    3bda:	80 91 e1 06 	lds	r24, 0x06E1
    3bde:	89 17       	cp	r24, r25
    3be0:	28 f4       	brcc	.+10     	; 0x3bec <xTaskRemoveFromUnorderedEventList+0x60>
    3be2:	ea 81       	ldd	r30, Y+2	; 0x02
    3be4:	fb 81       	ldd	r31, Y+3	; 0x03
    3be6:	86 89       	ldd	r24, Z+22	; 0x16
    3be8:	80 93 e1 06 	sts	0x06E1, r24
    3bec:	ea 81       	ldd	r30, Y+2	; 0x02
    3bee:	fb 81       	ldd	r31, Y+3	; 0x03
    3bf0:	86 89       	ldd	r24, Z+22	; 0x16
    3bf2:	28 2f       	mov	r18, r24
    3bf4:	30 e0       	ldi	r19, 0x00	; 0
    3bf6:	c9 01       	movw	r24, r18
    3bf8:	88 0f       	add	r24, r24
    3bfa:	99 1f       	adc	r25, r25
    3bfc:	88 0f       	add	r24, r24
    3bfe:	99 1f       	adc	r25, r25
    3c00:	88 0f       	add	r24, r24
    3c02:	99 1f       	adc	r25, r25
    3c04:	82 0f       	add	r24, r18
    3c06:	93 1f       	adc	r25, r19
    3c08:	ac 01       	movw	r20, r24
    3c0a:	48 51       	subi	r20, 0x18	; 24
    3c0c:	59 4f       	sbci	r21, 0xF9	; 249
    3c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    3c10:	9b 81       	ldd	r25, Y+3	; 0x03
    3c12:	9c 01       	movw	r18, r24
    3c14:	2e 5f       	subi	r18, 0xFE	; 254
    3c16:	3f 4f       	sbci	r19, 0xFF	; 255
    3c18:	ca 01       	movw	r24, r20
    3c1a:	b9 01       	movw	r22, r18
    3c1c:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3c20:	ea 81       	ldd	r30, Y+2	; 0x02
    3c22:	fb 81       	ldd	r31, Y+3	; 0x03
    3c24:	96 89       	ldd	r25, Z+22	; 0x16
    3c26:	e0 91 db 06 	lds	r30, 0x06DB
    3c2a:	f0 91 dc 06 	lds	r31, 0x06DC
    3c2e:	86 89       	ldd	r24, Z+22	; 0x16
    3c30:	89 17       	cp	r24, r25
    3c32:	30 f4       	brcc	.+12     	; 0x3c40 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    3c34:	81 e0       	ldi	r24, 0x01	; 1
    3c36:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3c38:	81 e0       	ldi	r24, 0x01	; 1
    3c3a:	80 93 e4 06 	sts	0x06E4, r24
    3c3e:	01 c0       	rjmp	.+2      	; 0x3c42 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    3c40:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3c42:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c44:	27 96       	adiw	r28, 0x07	; 7
    3c46:	0f b6       	in	r0, 0x3f	; 63
    3c48:	f8 94       	cli
    3c4a:	de bf       	out	0x3e, r29	; 62
    3c4c:	0f be       	out	0x3f, r0	; 63
    3c4e:	cd bf       	out	0x3d, r28	; 61
    3c50:	cf 91       	pop	r28
    3c52:	df 91       	pop	r29
    3c54:	08 95       	ret

00003c56 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3c56:	df 93       	push	r29
    3c58:	cf 93       	push	r28
    3c5a:	00 d0       	rcall	.+0      	; 0x3c5c <vTaskSetTimeOutState+0x6>
    3c5c:	cd b7       	in	r28, 0x3d	; 61
    3c5e:	de b7       	in	r29, 0x3e	; 62
    3c60:	9a 83       	std	Y+2, r25	; 0x02
    3c62:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3c64:	80 91 e5 06 	lds	r24, 0x06E5
    3c68:	e9 81       	ldd	r30, Y+1	; 0x01
    3c6a:	fa 81       	ldd	r31, Y+2	; 0x02
    3c6c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3c6e:	80 91 df 06 	lds	r24, 0x06DF
    3c72:	90 91 e0 06 	lds	r25, 0x06E0
    3c76:	e9 81       	ldd	r30, Y+1	; 0x01
    3c78:	fa 81       	ldd	r31, Y+2	; 0x02
    3c7a:	92 83       	std	Z+2, r25	; 0x02
    3c7c:	81 83       	std	Z+1, r24	; 0x01
}
    3c7e:	0f 90       	pop	r0
    3c80:	0f 90       	pop	r0
    3c82:	cf 91       	pop	r28
    3c84:	df 91       	pop	r29
    3c86:	08 95       	ret

00003c88 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3c88:	df 93       	push	r29
    3c8a:	cf 93       	push	r28
    3c8c:	cd b7       	in	r28, 0x3d	; 61
    3c8e:	de b7       	in	r29, 0x3e	; 62
    3c90:	27 97       	sbiw	r28, 0x07	; 7
    3c92:	0f b6       	in	r0, 0x3f	; 63
    3c94:	f8 94       	cli
    3c96:	de bf       	out	0x3e, r29	; 62
    3c98:	0f be       	out	0x3f, r0	; 63
    3c9a:	cd bf       	out	0x3d, r28	; 61
    3c9c:	9d 83       	std	Y+5, r25	; 0x05
    3c9e:	8c 83       	std	Y+4, r24	; 0x04
    3ca0:	7f 83       	std	Y+7, r23	; 0x07
    3ca2:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3ca4:	0f b6       	in	r0, 0x3f	; 63
    3ca6:	f8 94       	cli
    3ca8:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3caa:	80 91 df 06 	lds	r24, 0x06DF
    3cae:	90 91 e0 06 	lds	r25, 0x06E0
    3cb2:	9a 83       	std	Y+2, r25	; 0x02
    3cb4:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3cb6:	ec 81       	ldd	r30, Y+4	; 0x04
    3cb8:	fd 81       	ldd	r31, Y+5	; 0x05
    3cba:	90 81       	ld	r25, Z
    3cbc:	80 91 e5 06 	lds	r24, 0x06E5
    3cc0:	98 17       	cp	r25, r24
    3cc2:	61 f0       	breq	.+24     	; 0x3cdc <xTaskCheckForTimeOut+0x54>
    3cc4:	ec 81       	ldd	r30, Y+4	; 0x04
    3cc6:	fd 81       	ldd	r31, Y+5	; 0x05
    3cc8:	21 81       	ldd	r18, Z+1	; 0x01
    3cca:	32 81       	ldd	r19, Z+2	; 0x02
    3ccc:	89 81       	ldd	r24, Y+1	; 0x01
    3cce:	9a 81       	ldd	r25, Y+2	; 0x02
    3cd0:	82 17       	cp	r24, r18
    3cd2:	93 07       	cpc	r25, r19
    3cd4:	18 f0       	brcs	.+6      	; 0x3cdc <xTaskCheckForTimeOut+0x54>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    3cd6:	81 e0       	ldi	r24, 0x01	; 1
    3cd8:	8b 83       	std	Y+3, r24	; 0x03
    3cda:	2d c0       	rjmp	.+90     	; 0x3d36 <xTaskCheckForTimeOut+0xae>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    3cdc:	ec 81       	ldd	r30, Y+4	; 0x04
    3cde:	fd 81       	ldd	r31, Y+5	; 0x05
    3ce0:	21 81       	ldd	r18, Z+1	; 0x01
    3ce2:	32 81       	ldd	r19, Z+2	; 0x02
    3ce4:	89 81       	ldd	r24, Y+1	; 0x01
    3ce6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ce8:	ac 01       	movw	r20, r24
    3cea:	42 1b       	sub	r20, r18
    3cec:	53 0b       	sbc	r21, r19
    3cee:	9a 01       	movw	r18, r20
    3cf0:	ee 81       	ldd	r30, Y+6	; 0x06
    3cf2:	ff 81       	ldd	r31, Y+7	; 0x07
    3cf4:	80 81       	ld	r24, Z
    3cf6:	91 81       	ldd	r25, Z+1	; 0x01
    3cf8:	28 17       	cp	r18, r24
    3cfa:	39 07       	cpc	r19, r25
    3cfc:	d0 f4       	brcc	.+52     	; 0x3d32 <xTaskCheckForTimeOut+0xaa>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    3cfe:	ee 81       	ldd	r30, Y+6	; 0x06
    3d00:	ff 81       	ldd	r31, Y+7	; 0x07
    3d02:	40 81       	ld	r20, Z
    3d04:	51 81       	ldd	r21, Z+1	; 0x01
    3d06:	ec 81       	ldd	r30, Y+4	; 0x04
    3d08:	fd 81       	ldd	r31, Y+5	; 0x05
    3d0a:	21 81       	ldd	r18, Z+1	; 0x01
    3d0c:	32 81       	ldd	r19, Z+2	; 0x02
    3d0e:	89 81       	ldd	r24, Y+1	; 0x01
    3d10:	9a 81       	ldd	r25, Y+2	; 0x02
    3d12:	b9 01       	movw	r22, r18
    3d14:	68 1b       	sub	r22, r24
    3d16:	79 0b       	sbc	r23, r25
    3d18:	cb 01       	movw	r24, r22
    3d1a:	84 0f       	add	r24, r20
    3d1c:	95 1f       	adc	r25, r21
    3d1e:	ee 81       	ldd	r30, Y+6	; 0x06
    3d20:	ff 81       	ldd	r31, Y+7	; 0x07
    3d22:	91 83       	std	Z+1, r25	; 0x01
    3d24:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    3d26:	8c 81       	ldd	r24, Y+4	; 0x04
    3d28:	9d 81       	ldd	r25, Y+5	; 0x05
    3d2a:	0e 94 2b 1e 	call	0x3c56	; 0x3c56 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3d2e:	1b 82       	std	Y+3, r1	; 0x03
    3d30:	02 c0       	rjmp	.+4      	; 0x3d36 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			xReturn = pdTRUE;
    3d32:	81 e0       	ldi	r24, 0x01	; 1
    3d34:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    3d36:	0f 90       	pop	r0
    3d38:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3d3a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3d3c:	27 96       	adiw	r28, 0x07	; 7
    3d3e:	0f b6       	in	r0, 0x3f	; 63
    3d40:	f8 94       	cli
    3d42:	de bf       	out	0x3e, r29	; 62
    3d44:	0f be       	out	0x3f, r0	; 63
    3d46:	cd bf       	out	0x3d, r28	; 61
    3d48:	cf 91       	pop	r28
    3d4a:	df 91       	pop	r29
    3d4c:	08 95       	ret

00003d4e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3d4e:	df 93       	push	r29
    3d50:	cf 93       	push	r28
    3d52:	cd b7       	in	r28, 0x3d	; 61
    3d54:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    3d56:	81 e0       	ldi	r24, 0x01	; 1
    3d58:	80 93 e4 06 	sts	0x06E4, r24
}
    3d5c:	cf 91       	pop	r28
    3d5e:	df 91       	pop	r29
    3d60:	08 95       	ret

00003d62 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3d62:	df 93       	push	r29
    3d64:	cf 93       	push	r28
    3d66:	00 d0       	rcall	.+0      	; 0x3d68 <prvIdleTask+0x6>
    3d68:	cd b7       	in	r28, 0x3d	; 61
    3d6a:	de b7       	in	r29, 0x3e	; 62
    3d6c:	9a 83       	std	Y+2, r25	; 0x02
    3d6e:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    3d70:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    3d74:	80 91 e8 06 	lds	r24, 0x06E8
    3d78:	82 30       	cpi	r24, 0x02	; 2
    3d7a:	d0 f3       	brcs	.-12     	; 0x3d70 <prvIdleTask+0xe>
			{
				taskYIELD();
    3d7c:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortYield>
    3d80:	f7 cf       	rjmp	.-18     	; 0x3d70 <prvIdleTask+0xe>

00003d82 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3d82:	0f 93       	push	r16
    3d84:	1f 93       	push	r17
    3d86:	df 93       	push	r29
    3d88:	cf 93       	push	r28
    3d8a:	cd b7       	in	r28, 0x3d	; 61
    3d8c:	de b7       	in	r29, 0x3e	; 62
    3d8e:	2a 97       	sbiw	r28, 0x0a	; 10
    3d90:	0f b6       	in	r0, 0x3f	; 63
    3d92:	f8 94       	cli
    3d94:	de bf       	out	0x3e, r29	; 62
    3d96:	0f be       	out	0x3f, r0	; 63
    3d98:	cd bf       	out	0x3d, r28	; 61
    3d9a:	9b 83       	std	Y+3, r25	; 0x03
    3d9c:	8a 83       	std	Y+2, r24	; 0x02
    3d9e:	7d 83       	std	Y+5, r23	; 0x05
    3da0:	6c 83       	std	Y+4, r22	; 0x04
    3da2:	4e 83       	std	Y+6, r20	; 0x06
    3da4:	38 87       	std	Y+8, r19	; 0x08
    3da6:	2f 83       	std	Y+7, r18	; 0x07
    3da8:	1a 87       	std	Y+10, r17	; 0x0a
    3daa:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3dac:	19 82       	std	Y+1, r1	; 0x01
    3dae:	21 c0       	rjmp	.+66     	; 0x3df2 <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    3db0:	89 81       	ldd	r24, Y+1	; 0x01
    3db2:	48 2f       	mov	r20, r24
    3db4:	50 e0       	ldi	r21, 0x00	; 0
    3db6:	89 81       	ldd	r24, Y+1	; 0x01
    3db8:	28 2f       	mov	r18, r24
    3dba:	30 e0       	ldi	r19, 0x00	; 0
    3dbc:	8c 81       	ldd	r24, Y+4	; 0x04
    3dbe:	9d 81       	ldd	r25, Y+5	; 0x05
    3dc0:	fc 01       	movw	r30, r24
    3dc2:	e2 0f       	add	r30, r18
    3dc4:	f3 1f       	adc	r31, r19
    3dc6:	20 81       	ld	r18, Z
    3dc8:	8a 81       	ldd	r24, Y+2	; 0x02
    3dca:	9b 81       	ldd	r25, Y+3	; 0x03
    3dcc:	84 0f       	add	r24, r20
    3dce:	95 1f       	adc	r25, r21
    3dd0:	fc 01       	movw	r30, r24
    3dd2:	79 96       	adiw	r30, 0x19	; 25
    3dd4:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    3dd6:	89 81       	ldd	r24, Y+1	; 0x01
    3dd8:	28 2f       	mov	r18, r24
    3dda:	30 e0       	ldi	r19, 0x00	; 0
    3ddc:	8c 81       	ldd	r24, Y+4	; 0x04
    3dde:	9d 81       	ldd	r25, Y+5	; 0x05
    3de0:	fc 01       	movw	r30, r24
    3de2:	e2 0f       	add	r30, r18
    3de4:	f3 1f       	adc	r31, r19
    3de6:	80 81       	ld	r24, Z
    3de8:	88 23       	and	r24, r24
    3dea:	31 f0       	breq	.+12     	; 0x3df8 <prvInitialiseTCBVariables+0x76>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3dec:	89 81       	ldd	r24, Y+1	; 0x01
    3dee:	8f 5f       	subi	r24, 0xFF	; 255
    3df0:	89 83       	std	Y+1, r24	; 0x01
    3df2:	89 81       	ldd	r24, Y+1	; 0x01
    3df4:	84 31       	cpi	r24, 0x14	; 20
    3df6:	e0 f2       	brcs	.-72     	; 0x3db0 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3df8:	ea 81       	ldd	r30, Y+2	; 0x02
    3dfa:	fb 81       	ldd	r31, Y+3	; 0x03
    3dfc:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3dfe:	8e 81       	ldd	r24, Y+6	; 0x06
    3e00:	84 30       	cpi	r24, 0x04	; 4
    3e02:	10 f0       	brcs	.+4      	; 0x3e08 <prvInitialiseTCBVariables+0x86>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3e04:	83 e0       	ldi	r24, 0x03	; 3
    3e06:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    3e08:	ea 81       	ldd	r30, Y+2	; 0x02
    3e0a:	fb 81       	ldd	r31, Y+3	; 0x03
    3e0c:	8e 81       	ldd	r24, Y+6	; 0x06
    3e0e:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    3e10:	ea 81       	ldd	r30, Y+2	; 0x02
    3e12:	fb 81       	ldd	r31, Y+3	; 0x03
    3e14:	8e 81       	ldd	r24, Y+6	; 0x06
    3e16:	85 a7       	std	Z+45, r24	; 0x2d
		pxTCB->uxMutexesHeld = 0;
    3e18:	ea 81       	ldd	r30, Y+2	; 0x02
    3e1a:	fb 81       	ldd	r31, Y+3	; 0x03
    3e1c:	16 a6       	std	Z+46, r1	; 0x2e
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    3e1e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e20:	9b 81       	ldd	r25, Y+3	; 0x03
    3e22:	02 96       	adiw	r24, 0x02	; 2
    3e24:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    3e28:	8a 81       	ldd	r24, Y+2	; 0x02
    3e2a:	9b 81       	ldd	r25, Y+3	; 0x03
    3e2c:	0c 96       	adiw	r24, 0x0c	; 12
    3e2e:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    3e32:	ea 81       	ldd	r30, Y+2	; 0x02
    3e34:	fb 81       	ldd	r31, Y+3	; 0x03
    3e36:	8a 81       	ldd	r24, Y+2	; 0x02
    3e38:	9b 81       	ldd	r25, Y+3	; 0x03
    3e3a:	91 87       	std	Z+9, r25	; 0x09
    3e3c:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3e3e:	8e 81       	ldd	r24, Y+6	; 0x06
    3e40:	28 2f       	mov	r18, r24
    3e42:	30 e0       	ldi	r19, 0x00	; 0
    3e44:	84 e0       	ldi	r24, 0x04	; 4
    3e46:	90 e0       	ldi	r25, 0x00	; 0
    3e48:	82 1b       	sub	r24, r18
    3e4a:	93 0b       	sbc	r25, r19
    3e4c:	ea 81       	ldd	r30, Y+2	; 0x02
    3e4e:	fb 81       	ldd	r31, Y+3	; 0x03
    3e50:	95 87       	std	Z+13, r25	; 0x0d
    3e52:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    3e54:	ea 81       	ldd	r30, Y+2	; 0x02
    3e56:	fb 81       	ldd	r31, Y+3	; 0x03
    3e58:	8a 81       	ldd	r24, Y+2	; 0x02
    3e5a:	9b 81       	ldd	r25, Y+3	; 0x03
    3e5c:	93 8b       	std	Z+19, r25	; 0x13
    3e5e:	82 8b       	std	Z+18, r24	; 0x12
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    3e60:	2a 96       	adiw	r28, 0x0a	; 10
    3e62:	0f b6       	in	r0, 0x3f	; 63
    3e64:	f8 94       	cli
    3e66:	de bf       	out	0x3e, r29	; 62
    3e68:	0f be       	out	0x3f, r0	; 63
    3e6a:	cd bf       	out	0x3d, r28	; 61
    3e6c:	cf 91       	pop	r28
    3e6e:	df 91       	pop	r29
    3e70:	1f 91       	pop	r17
    3e72:	0f 91       	pop	r16
    3e74:	08 95       	ret

00003e76 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3e76:	df 93       	push	r29
    3e78:	cf 93       	push	r28
    3e7a:	0f 92       	push	r0
    3e7c:	cd b7       	in	r28, 0x3d	; 61
    3e7e:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3e80:	19 82       	std	Y+1, r1	; 0x01
    3e82:	13 c0       	rjmp	.+38     	; 0x3eaa <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3e84:	89 81       	ldd	r24, Y+1	; 0x01
    3e86:	28 2f       	mov	r18, r24
    3e88:	30 e0       	ldi	r19, 0x00	; 0
    3e8a:	c9 01       	movw	r24, r18
    3e8c:	88 0f       	add	r24, r24
    3e8e:	99 1f       	adc	r25, r25
    3e90:	88 0f       	add	r24, r24
    3e92:	99 1f       	adc	r25, r25
    3e94:	88 0f       	add	r24, r24
    3e96:	99 1f       	adc	r25, r25
    3e98:	82 0f       	add	r24, r18
    3e9a:	93 1f       	adc	r25, r19
    3e9c:	88 51       	subi	r24, 0x18	; 24
    3e9e:	99 4f       	sbci	r25, 0xF9	; 249
    3ea0:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3ea4:	89 81       	ldd	r24, Y+1	; 0x01
    3ea6:	8f 5f       	subi	r24, 0xFF	; 255
    3ea8:	89 83       	std	Y+1, r24	; 0x01
    3eaa:	89 81       	ldd	r24, Y+1	; 0x01
    3eac:	84 30       	cpi	r24, 0x04	; 4
    3eae:	50 f3       	brcs	.-44     	; 0x3e84 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    3eb0:	8c e0       	ldi	r24, 0x0C	; 12
    3eb2:	97 e0       	ldi	r25, 0x07	; 7
    3eb4:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3eb8:	85 e1       	ldi	r24, 0x15	; 21
    3eba:	97 e0       	ldi	r25, 0x07	; 7
    3ebc:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>
	vListInitialise( &xPendingReadyList );
    3ec0:	82 e2       	ldi	r24, 0x22	; 34
    3ec2:	97 e0       	ldi	r25, 0x07	; 7
    3ec4:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3ec8:	8b e2       	ldi	r24, 0x2B	; 43
    3eca:	97 e0       	ldi	r25, 0x07	; 7
    3ecc:	0e 94 ae 0c 	call	0x195c	; 0x195c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3ed0:	8c e0       	ldi	r24, 0x0C	; 12
    3ed2:	97 e0       	ldi	r25, 0x07	; 7
    3ed4:	90 93 1f 07 	sts	0x071F, r25
    3ed8:	80 93 1e 07 	sts	0x071E, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3edc:	85 e1       	ldi	r24, 0x15	; 21
    3ede:	97 e0       	ldi	r25, 0x07	; 7
    3ee0:	90 93 21 07 	sts	0x0721, r25
    3ee4:	80 93 20 07 	sts	0x0720, r24
}
    3ee8:	0f 90       	pop	r0
    3eea:	cf 91       	pop	r28
    3eec:	df 91       	pop	r29
    3eee:	08 95       	ret

00003ef0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3ef0:	df 93       	push	r29
    3ef2:	cf 93       	push	r28
    3ef4:	00 d0       	rcall	.+0      	; 0x3ef6 <prvCheckTasksWaitingTermination+0x6>
    3ef6:	0f 92       	push	r0
    3ef8:	cd b7       	in	r28, 0x3d	; 61
    3efa:	de b7       	in	r29, 0x3e	; 62
    3efc:	2e c0       	rjmp	.+92     	; 0x3f5a <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    3efe:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    3f02:	80 91 2b 07 	lds	r24, 0x072B
    3f06:	1b 82       	std	Y+3, r1	; 0x03
    3f08:	88 23       	and	r24, r24
    3f0a:	11 f4       	brne	.+4      	; 0x3f10 <prvCheckTasksWaitingTermination+0x20>
    3f0c:	81 e0       	ldi	r24, 0x01	; 1
    3f0e:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    3f10:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    3f14:	8b 81       	ldd	r24, Y+3	; 0x03
    3f16:	88 23       	and	r24, r24
    3f18:	01 f5       	brne	.+64     	; 0x3f5a <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    3f1a:	0f b6       	in	r0, 0x3f	; 63
    3f1c:	f8 94       	cli
    3f1e:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    3f20:	e0 91 30 07 	lds	r30, 0x0730
    3f24:	f0 91 31 07 	lds	r31, 0x0731
    3f28:	86 81       	ldd	r24, Z+6	; 0x06
    3f2a:	97 81       	ldd	r25, Z+7	; 0x07
    3f2c:	9a 83       	std	Y+2, r25	; 0x02
    3f2e:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3f30:	89 81       	ldd	r24, Y+1	; 0x01
    3f32:	9a 81       	ldd	r25, Y+2	; 0x02
    3f34:	02 96       	adiw	r24, 0x02	; 2
    3f36:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
					--uxCurrentNumberOfTasks;
    3f3a:	80 91 de 06 	lds	r24, 0x06DE
    3f3e:	81 50       	subi	r24, 0x01	; 1
    3f40:	80 93 de 06 	sts	0x06DE, r24
					--uxTasksDeleted;
    3f44:	80 91 dd 06 	lds	r24, 0x06DD
    3f48:	81 50       	subi	r24, 0x01	; 1
    3f4a:	80 93 dd 06 	sts	0x06DD, r24
				}
				taskEXIT_CRITICAL();
    3f4e:	0f 90       	pop	r0
    3f50:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    3f52:	89 81       	ldd	r24, Y+1	; 0x01
    3f54:	9a 81       	ldd	r25, Y+2	; 0x02
    3f56:	0e 94 44 20 	call	0x4088	; 0x4088 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    3f5a:	80 91 dd 06 	lds	r24, 0x06DD
    3f5e:	88 23       	and	r24, r24
    3f60:	71 f6       	brne	.-100    	; 0x3efe <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    3f62:	0f 90       	pop	r0
    3f64:	0f 90       	pop	r0
    3f66:	0f 90       	pop	r0
    3f68:	cf 91       	pop	r28
    3f6a:	df 91       	pop	r29
    3f6c:	08 95       	ret

00003f6e <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    3f6e:	df 93       	push	r29
    3f70:	cf 93       	push	r28
    3f72:	00 d0       	rcall	.+0      	; 0x3f74 <prvAddCurrentTaskToDelayedList+0x6>
    3f74:	cd b7       	in	r28, 0x3d	; 61
    3f76:	de b7       	in	r29, 0x3e	; 62
    3f78:	9a 83       	std	Y+2, r25	; 0x02
    3f7a:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    3f7c:	e0 91 db 06 	lds	r30, 0x06DB
    3f80:	f0 91 dc 06 	lds	r31, 0x06DC
    3f84:	89 81       	ldd	r24, Y+1	; 0x01
    3f86:	9a 81       	ldd	r25, Y+2	; 0x02
    3f88:	93 83       	std	Z+3, r25	; 0x03
    3f8a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    3f8c:	20 91 df 06 	lds	r18, 0x06DF
    3f90:	30 91 e0 06 	lds	r19, 0x06E0
    3f94:	89 81       	ldd	r24, Y+1	; 0x01
    3f96:	9a 81       	ldd	r25, Y+2	; 0x02
    3f98:	82 17       	cp	r24, r18
    3f9a:	93 07       	cpc	r25, r19
    3f9c:	70 f4       	brcc	.+28     	; 0x3fba <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3f9e:	80 91 20 07 	lds	r24, 0x0720
    3fa2:	90 91 21 07 	lds	r25, 0x0721
    3fa6:	20 91 db 06 	lds	r18, 0x06DB
    3faa:	30 91 dc 06 	lds	r19, 0x06DC
    3fae:	2e 5f       	subi	r18, 0xFE	; 254
    3fb0:	3f 4f       	sbci	r19, 0xFF	; 255
    3fb2:	b9 01       	movw	r22, r18
    3fb4:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <vListInsert>
    3fb8:	1e c0       	rjmp	.+60     	; 0x3ff6 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3fba:	40 91 1e 07 	lds	r20, 0x071E
    3fbe:	50 91 1f 07 	lds	r21, 0x071F
    3fc2:	80 91 db 06 	lds	r24, 0x06DB
    3fc6:	90 91 dc 06 	lds	r25, 0x06DC
    3fca:	9c 01       	movw	r18, r24
    3fcc:	2e 5f       	subi	r18, 0xFE	; 254
    3fce:	3f 4f       	sbci	r19, 0xFF	; 255
    3fd0:	ca 01       	movw	r24, r20
    3fd2:	b9 01       	movw	r22, r18
    3fd4:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    3fd8:	20 91 b5 00 	lds	r18, 0x00B5
    3fdc:	30 91 b6 00 	lds	r19, 0x00B6
    3fe0:	89 81       	ldd	r24, Y+1	; 0x01
    3fe2:	9a 81       	ldd	r25, Y+2	; 0x02
    3fe4:	82 17       	cp	r24, r18
    3fe6:	93 07       	cpc	r25, r19
    3fe8:	30 f4       	brcc	.+12     	; 0x3ff6 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3fea:	89 81       	ldd	r24, Y+1	; 0x01
    3fec:	9a 81       	ldd	r25, Y+2	; 0x02
    3fee:	90 93 b6 00 	sts	0x00B6, r25
    3ff2:	80 93 b5 00 	sts	0x00B5, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    3ff6:	0f 90       	pop	r0
    3ff8:	0f 90       	pop	r0
    3ffa:	cf 91       	pop	r28
    3ffc:	df 91       	pop	r29
    3ffe:	08 95       	ret

00004000 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    4000:	df 93       	push	r29
    4002:	cf 93       	push	r28
    4004:	cd b7       	in	r28, 0x3d	; 61
    4006:	de b7       	in	r29, 0x3e	; 62
    4008:	28 97       	sbiw	r28, 0x08	; 8
    400a:	0f b6       	in	r0, 0x3f	; 63
    400c:	f8 94       	cli
    400e:	de bf       	out	0x3e, r29	; 62
    4010:	0f be       	out	0x3f, r0	; 63
    4012:	cd bf       	out	0x3d, r28	; 61
    4014:	9c 83       	std	Y+4, r25	; 0x04
    4016:	8b 83       	std	Y+3, r24	; 0x03
    4018:	7e 83       	std	Y+6, r23	; 0x06
    401a:	6d 83       	std	Y+5, r22	; 0x05
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    401c:	8f e2       	ldi	r24, 0x2F	; 47
    401e:	90 e0       	ldi	r25, 0x00	; 0
    4020:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <pvPortMalloc>
    4024:	9a 83       	std	Y+2, r25	; 0x02
    4026:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4028:	89 81       	ldd	r24, Y+1	; 0x01
    402a:	9a 81       	ldd	r25, Y+2	; 0x02
    402c:	00 97       	sbiw	r24, 0x00	; 0
    402e:	09 f1       	breq	.+66     	; 0x4072 <prvAllocateTCBAndStack+0x72>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4030:	8d 81       	ldd	r24, Y+5	; 0x05
    4032:	9e 81       	ldd	r25, Y+6	; 0x06
    4034:	00 97       	sbiw	r24, 0x00	; 0
    4036:	39 f4       	brne	.+14     	; 0x4046 <prvAllocateTCBAndStack+0x46>
    4038:	8b 81       	ldd	r24, Y+3	; 0x03
    403a:	9c 81       	ldd	r25, Y+4	; 0x04
    403c:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <pvPortMalloc>
    4040:	98 87       	std	Y+8, r25	; 0x08
    4042:	8f 83       	std	Y+7, r24	; 0x07
    4044:	04 c0       	rjmp	.+8      	; 0x404e <prvAllocateTCBAndStack+0x4e>
    4046:	8d 81       	ldd	r24, Y+5	; 0x05
    4048:	9e 81       	ldd	r25, Y+6	; 0x06
    404a:	98 87       	std	Y+8, r25	; 0x08
    404c:	8f 83       	std	Y+7, r24	; 0x07
    404e:	e9 81       	ldd	r30, Y+1	; 0x01
    4050:	fa 81       	ldd	r31, Y+2	; 0x02
    4052:	8f 81       	ldd	r24, Y+7	; 0x07
    4054:	98 85       	ldd	r25, Y+8	; 0x08
    4056:	90 8f       	std	Z+24, r25	; 0x18
    4058:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    405a:	e9 81       	ldd	r30, Y+1	; 0x01
    405c:	fa 81       	ldd	r31, Y+2	; 0x02
    405e:	87 89       	ldd	r24, Z+23	; 0x17
    4060:	90 8d       	ldd	r25, Z+24	; 0x18
    4062:	00 97       	sbiw	r24, 0x00	; 0
    4064:	31 f4       	brne	.+12     	; 0x4072 <prvAllocateTCBAndStack+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    4066:	89 81       	ldd	r24, Y+1	; 0x01
    4068:	9a 81       	ldd	r25, Y+2	; 0x02
    406a:	0e 94 b6 0b 	call	0x176c	; 0x176c <vPortFree>
			pxNewTCB = NULL;
    406e:	1a 82       	std	Y+2, r1	; 0x02
    4070:	19 82       	std	Y+1, r1	; 0x01
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
    4072:	89 81       	ldd	r24, Y+1	; 0x01
    4074:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4076:	28 96       	adiw	r28, 0x08	; 8
    4078:	0f b6       	in	r0, 0x3f	; 63
    407a:	f8 94       	cli
    407c:	de bf       	out	0x3e, r29	; 62
    407e:	0f be       	out	0x3f, r0	; 63
    4080:	cd bf       	out	0x3d, r28	; 61
    4082:	cf 91       	pop	r28
    4084:	df 91       	pop	r29
    4086:	08 95       	ret

00004088 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4088:	df 93       	push	r29
    408a:	cf 93       	push	r28
    408c:	00 d0       	rcall	.+0      	; 0x408e <prvDeleteTCB+0x6>
    408e:	cd b7       	in	r28, 0x3d	; 61
    4090:	de b7       	in	r29, 0x3e	; 62
    4092:	9a 83       	std	Y+2, r25	; 0x02
    4094:	89 83       	std	Y+1, r24	; 0x01
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    4096:	e9 81       	ldd	r30, Y+1	; 0x01
    4098:	fa 81       	ldd	r31, Y+2	; 0x02
    409a:	87 89       	ldd	r24, Z+23	; 0x17
    409c:	90 8d       	ldd	r25, Z+24	; 0x18
    409e:	0e 94 b6 0b 	call	0x176c	; 0x176c <vPortFree>
		vPortFree( pxTCB );
    40a2:	89 81       	ldd	r24, Y+1	; 0x01
    40a4:	9a 81       	ldd	r25, Y+2	; 0x02
    40a6:	0e 94 b6 0b 	call	0x176c	; 0x176c <vPortFree>
	}
    40aa:	0f 90       	pop	r0
    40ac:	0f 90       	pop	r0
    40ae:	cf 91       	pop	r28
    40b0:	df 91       	pop	r29
    40b2:	08 95       	ret

000040b4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    40b4:	df 93       	push	r29
    40b6:	cf 93       	push	r28
    40b8:	00 d0       	rcall	.+0      	; 0x40ba <prvResetNextTaskUnblockTime+0x6>
    40ba:	cd b7       	in	r28, 0x3d	; 61
    40bc:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    40be:	e0 91 1e 07 	lds	r30, 0x071E
    40c2:	f0 91 1f 07 	lds	r31, 0x071F
    40c6:	80 81       	ld	r24, Z
    40c8:	88 23       	and	r24, r24
    40ca:	39 f4       	brne	.+14     	; 0x40da <prvResetNextTaskUnblockTime+0x26>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    40cc:	8f ef       	ldi	r24, 0xFF	; 255
    40ce:	9f ef       	ldi	r25, 0xFF	; 255
    40d0:	90 93 b6 00 	sts	0x00B6, r25
    40d4:	80 93 b5 00 	sts	0x00B5, r24
    40d8:	13 c0       	rjmp	.+38     	; 0x4100 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    40da:	e0 91 1e 07 	lds	r30, 0x071E
    40de:	f0 91 1f 07 	lds	r31, 0x071F
    40e2:	05 80       	ldd	r0, Z+5	; 0x05
    40e4:	f6 81       	ldd	r31, Z+6	; 0x06
    40e6:	e0 2d       	mov	r30, r0
    40e8:	86 81       	ldd	r24, Z+6	; 0x06
    40ea:	97 81       	ldd	r25, Z+7	; 0x07
    40ec:	9a 83       	std	Y+2, r25	; 0x02
    40ee:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    40f0:	e9 81       	ldd	r30, Y+1	; 0x01
    40f2:	fa 81       	ldd	r31, Y+2	; 0x02
    40f4:	82 81       	ldd	r24, Z+2	; 0x02
    40f6:	93 81       	ldd	r25, Z+3	; 0x03
    40f8:	90 93 b6 00 	sts	0x00B6, r25
    40fc:	80 93 b5 00 	sts	0x00B5, r24
	}
}
    4100:	0f 90       	pop	r0
    4102:	0f 90       	pop	r0
    4104:	cf 91       	pop	r28
    4106:	df 91       	pop	r29
    4108:	08 95       	ret

0000410a <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    410a:	df 93       	push	r29
    410c:	cf 93       	push	r28
    410e:	00 d0       	rcall	.+0      	; 0x4110 <xTaskGetCurrentTaskHandle+0x6>
    4110:	cd b7       	in	r28, 0x3d	; 61
    4112:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4114:	80 91 db 06 	lds	r24, 0x06DB
    4118:	90 91 dc 06 	lds	r25, 0x06DC
    411c:	9a 83       	std	Y+2, r25	; 0x02
    411e:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4120:	89 81       	ldd	r24, Y+1	; 0x01
    4122:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4124:	0f 90       	pop	r0
    4126:	0f 90       	pop	r0
    4128:	cf 91       	pop	r28
    412a:	df 91       	pop	r29
    412c:	08 95       	ret

0000412e <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    412e:	df 93       	push	r29
    4130:	cf 93       	push	r28
    4132:	00 d0       	rcall	.+0      	; 0x4134 <vTaskPriorityInherit+0x6>
    4134:	00 d0       	rcall	.+0      	; 0x4136 <vTaskPriorityInherit+0x8>
    4136:	cd b7       	in	r28, 0x3d	; 61
    4138:	de b7       	in	r29, 0x3e	; 62
    413a:	9c 83       	std	Y+4, r25	; 0x04
    413c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    413e:	8b 81       	ldd	r24, Y+3	; 0x03
    4140:	9c 81       	ldd	r25, Y+4	; 0x04
    4142:	9a 83       	std	Y+2, r25	; 0x02
    4144:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    4146:	8b 81       	ldd	r24, Y+3	; 0x03
    4148:	9c 81       	ldd	r25, Y+4	; 0x04
    414a:	00 97       	sbiw	r24, 0x00	; 0
    414c:	09 f4       	brne	.+2      	; 0x4150 <vTaskPriorityInherit+0x22>
    414e:	73 c0       	rjmp	.+230    	; 0x4236 <vTaskPriorityInherit+0x108>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    4150:	e9 81       	ldd	r30, Y+1	; 0x01
    4152:	fa 81       	ldd	r31, Y+2	; 0x02
    4154:	96 89       	ldd	r25, Z+22	; 0x16
    4156:	e0 91 db 06 	lds	r30, 0x06DB
    415a:	f0 91 dc 06 	lds	r31, 0x06DC
    415e:	86 89       	ldd	r24, Z+22	; 0x16
    4160:	98 17       	cp	r25, r24
    4162:	08 f0       	brcs	.+2      	; 0x4166 <vTaskPriorityInherit+0x38>
    4164:	68 c0       	rjmp	.+208    	; 0x4236 <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    4166:	e9 81       	ldd	r30, Y+1	; 0x01
    4168:	fa 81       	ldd	r31, Y+2	; 0x02
    416a:	84 85       	ldd	r24, Z+12	; 0x0c
    416c:	95 85       	ldd	r25, Z+13	; 0x0d
    416e:	99 23       	and	r25, r25
    4170:	7c f0       	brlt	.+30     	; 0x4190 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4172:	e0 91 db 06 	lds	r30, 0x06DB
    4176:	f0 91 dc 06 	lds	r31, 0x06DC
    417a:	86 89       	ldd	r24, Z+22	; 0x16
    417c:	28 2f       	mov	r18, r24
    417e:	30 e0       	ldi	r19, 0x00	; 0
    4180:	84 e0       	ldi	r24, 0x04	; 4
    4182:	90 e0       	ldi	r25, 0x00	; 0
    4184:	82 1b       	sub	r24, r18
    4186:	93 0b       	sbc	r25, r19
    4188:	e9 81       	ldd	r30, Y+1	; 0x01
    418a:	fa 81       	ldd	r31, Y+2	; 0x02
    418c:	95 87       	std	Z+13, r25	; 0x0d
    418e:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    4190:	e9 81       	ldd	r30, Y+1	; 0x01
    4192:	fa 81       	ldd	r31, Y+2	; 0x02
    4194:	42 85       	ldd	r20, Z+10	; 0x0a
    4196:	53 85       	ldd	r21, Z+11	; 0x0b
    4198:	e9 81       	ldd	r30, Y+1	; 0x01
    419a:	fa 81       	ldd	r31, Y+2	; 0x02
    419c:	86 89       	ldd	r24, Z+22	; 0x16
    419e:	28 2f       	mov	r18, r24
    41a0:	30 e0       	ldi	r19, 0x00	; 0
    41a2:	c9 01       	movw	r24, r18
    41a4:	88 0f       	add	r24, r24
    41a6:	99 1f       	adc	r25, r25
    41a8:	88 0f       	add	r24, r24
    41aa:	99 1f       	adc	r25, r25
    41ac:	88 0f       	add	r24, r24
    41ae:	99 1f       	adc	r25, r25
    41b0:	82 0f       	add	r24, r18
    41b2:	93 1f       	adc	r25, r19
    41b4:	88 51       	subi	r24, 0x18	; 24
    41b6:	99 4f       	sbci	r25, 0xF9	; 249
    41b8:	48 17       	cp	r20, r24
    41ba:	59 07       	cpc	r21, r25
    41bc:	a1 f5       	brne	.+104    	; 0x4226 <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    41be:	89 81       	ldd	r24, Y+1	; 0x01
    41c0:	9a 81       	ldd	r25, Y+2	; 0x02
    41c2:	02 96       	adiw	r24, 0x02	; 2
    41c4:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    41c8:	e0 91 db 06 	lds	r30, 0x06DB
    41cc:	f0 91 dc 06 	lds	r31, 0x06DC
    41d0:	86 89       	ldd	r24, Z+22	; 0x16
    41d2:	e9 81       	ldd	r30, Y+1	; 0x01
    41d4:	fa 81       	ldd	r31, Y+2	; 0x02
    41d6:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    41d8:	e9 81       	ldd	r30, Y+1	; 0x01
    41da:	fa 81       	ldd	r31, Y+2	; 0x02
    41dc:	96 89       	ldd	r25, Z+22	; 0x16
    41de:	80 91 e1 06 	lds	r24, 0x06E1
    41e2:	89 17       	cp	r24, r25
    41e4:	28 f4       	brcc	.+10     	; 0x41f0 <vTaskPriorityInherit+0xc2>
    41e6:	e9 81       	ldd	r30, Y+1	; 0x01
    41e8:	fa 81       	ldd	r31, Y+2	; 0x02
    41ea:	86 89       	ldd	r24, Z+22	; 0x16
    41ec:	80 93 e1 06 	sts	0x06E1, r24
    41f0:	e9 81       	ldd	r30, Y+1	; 0x01
    41f2:	fa 81       	ldd	r31, Y+2	; 0x02
    41f4:	86 89       	ldd	r24, Z+22	; 0x16
    41f6:	28 2f       	mov	r18, r24
    41f8:	30 e0       	ldi	r19, 0x00	; 0
    41fa:	c9 01       	movw	r24, r18
    41fc:	88 0f       	add	r24, r24
    41fe:	99 1f       	adc	r25, r25
    4200:	88 0f       	add	r24, r24
    4202:	99 1f       	adc	r25, r25
    4204:	88 0f       	add	r24, r24
    4206:	99 1f       	adc	r25, r25
    4208:	82 0f       	add	r24, r18
    420a:	93 1f       	adc	r25, r19
    420c:	ac 01       	movw	r20, r24
    420e:	48 51       	subi	r20, 0x18	; 24
    4210:	59 4f       	sbci	r21, 0xF9	; 249
    4212:	89 81       	ldd	r24, Y+1	; 0x01
    4214:	9a 81       	ldd	r25, Y+2	; 0x02
    4216:	9c 01       	movw	r18, r24
    4218:	2e 5f       	subi	r18, 0xFE	; 254
    421a:	3f 4f       	sbci	r19, 0xFF	; 255
    421c:	ca 01       	movw	r24, r20
    421e:	b9 01       	movw	r22, r18
    4220:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>
    4224:	08 c0       	rjmp	.+16     	; 0x4236 <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    4226:	e0 91 db 06 	lds	r30, 0x06DB
    422a:	f0 91 dc 06 	lds	r31, 0x06DC
    422e:	86 89       	ldd	r24, Z+22	; 0x16
    4230:	e9 81       	ldd	r30, Y+1	; 0x01
    4232:	fa 81       	ldd	r31, Y+2	; 0x02
    4234:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4236:	0f 90       	pop	r0
    4238:	0f 90       	pop	r0
    423a:	0f 90       	pop	r0
    423c:	0f 90       	pop	r0
    423e:	cf 91       	pop	r28
    4240:	df 91       	pop	r29
    4242:	08 95       	ret

00004244 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    4244:	df 93       	push	r29
    4246:	cf 93       	push	r28
    4248:	00 d0       	rcall	.+0      	; 0x424a <xTaskPriorityDisinherit+0x6>
    424a:	00 d0       	rcall	.+0      	; 0x424c <xTaskPriorityDisinherit+0x8>
    424c:	0f 92       	push	r0
    424e:	cd b7       	in	r28, 0x3d	; 61
    4250:	de b7       	in	r29, 0x3e	; 62
    4252:	9d 83       	std	Y+5, r25	; 0x05
    4254:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    4256:	8c 81       	ldd	r24, Y+4	; 0x04
    4258:	9d 81       	ldd	r25, Y+5	; 0x05
    425a:	9b 83       	std	Y+3, r25	; 0x03
    425c:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    425e:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    4260:	8c 81       	ldd	r24, Y+4	; 0x04
    4262:	9d 81       	ldd	r25, Y+5	; 0x05
    4264:	00 97       	sbiw	r24, 0x00	; 0
    4266:	09 f4       	brne	.+2      	; 0x426a <xTaskPriorityDisinherit+0x26>
    4268:	56 c0       	rjmp	.+172    	; 0x4316 <xTaskPriorityDisinherit+0xd2>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    426a:	ea 81       	ldd	r30, Y+2	; 0x02
    426c:	fb 81       	ldd	r31, Y+3	; 0x03
    426e:	86 a5       	ldd	r24, Z+46	; 0x2e
    4270:	81 50       	subi	r24, 0x01	; 1
    4272:	ea 81       	ldd	r30, Y+2	; 0x02
    4274:	fb 81       	ldd	r31, Y+3	; 0x03
    4276:	86 a7       	std	Z+46, r24	; 0x2e

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    4278:	ea 81       	ldd	r30, Y+2	; 0x02
    427a:	fb 81       	ldd	r31, Y+3	; 0x03
    427c:	96 89       	ldd	r25, Z+22	; 0x16
    427e:	ea 81       	ldd	r30, Y+2	; 0x02
    4280:	fb 81       	ldd	r31, Y+3	; 0x03
    4282:	85 a5       	ldd	r24, Z+45	; 0x2d
    4284:	98 17       	cp	r25, r24
    4286:	09 f4       	brne	.+2      	; 0x428a <xTaskPriorityDisinherit+0x46>
    4288:	46 c0       	rjmp	.+140    	; 0x4316 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    428a:	ea 81       	ldd	r30, Y+2	; 0x02
    428c:	fb 81       	ldd	r31, Y+3	; 0x03
    428e:	86 a5       	ldd	r24, Z+46	; 0x2e
    4290:	88 23       	and	r24, r24
    4292:	09 f0       	breq	.+2      	; 0x4296 <xTaskPriorityDisinherit+0x52>
    4294:	40 c0       	rjmp	.+128    	; 0x4316 <xTaskPriorityDisinherit+0xd2>
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4296:	8a 81       	ldd	r24, Y+2	; 0x02
    4298:	9b 81       	ldd	r25, Y+3	; 0x03
    429a:	02 96       	adiw	r24, 0x02	; 2
    429c:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    42a0:	ea 81       	ldd	r30, Y+2	; 0x02
    42a2:	fb 81       	ldd	r31, Y+3	; 0x03
    42a4:	85 a5       	ldd	r24, Z+45	; 0x2d
    42a6:	ea 81       	ldd	r30, Y+2	; 0x02
    42a8:	fb 81       	ldd	r31, Y+3	; 0x03
    42aa:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    42ac:	ea 81       	ldd	r30, Y+2	; 0x02
    42ae:	fb 81       	ldd	r31, Y+3	; 0x03
    42b0:	86 89       	ldd	r24, Z+22	; 0x16
    42b2:	28 2f       	mov	r18, r24
    42b4:	30 e0       	ldi	r19, 0x00	; 0
    42b6:	84 e0       	ldi	r24, 0x04	; 4
    42b8:	90 e0       	ldi	r25, 0x00	; 0
    42ba:	82 1b       	sub	r24, r18
    42bc:	93 0b       	sbc	r25, r19
    42be:	ea 81       	ldd	r30, Y+2	; 0x02
    42c0:	fb 81       	ldd	r31, Y+3	; 0x03
    42c2:	95 87       	std	Z+13, r25	; 0x0d
    42c4:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    42c6:	ea 81       	ldd	r30, Y+2	; 0x02
    42c8:	fb 81       	ldd	r31, Y+3	; 0x03
    42ca:	96 89       	ldd	r25, Z+22	; 0x16
    42cc:	80 91 e1 06 	lds	r24, 0x06E1
    42d0:	89 17       	cp	r24, r25
    42d2:	28 f4       	brcc	.+10     	; 0x42de <xTaskPriorityDisinherit+0x9a>
    42d4:	ea 81       	ldd	r30, Y+2	; 0x02
    42d6:	fb 81       	ldd	r31, Y+3	; 0x03
    42d8:	86 89       	ldd	r24, Z+22	; 0x16
    42da:	80 93 e1 06 	sts	0x06E1, r24
    42de:	ea 81       	ldd	r30, Y+2	; 0x02
    42e0:	fb 81       	ldd	r31, Y+3	; 0x03
    42e2:	86 89       	ldd	r24, Z+22	; 0x16
    42e4:	28 2f       	mov	r18, r24
    42e6:	30 e0       	ldi	r19, 0x00	; 0
    42e8:	c9 01       	movw	r24, r18
    42ea:	88 0f       	add	r24, r24
    42ec:	99 1f       	adc	r25, r25
    42ee:	88 0f       	add	r24, r24
    42f0:	99 1f       	adc	r25, r25
    42f2:	88 0f       	add	r24, r24
    42f4:	99 1f       	adc	r25, r25
    42f6:	82 0f       	add	r24, r18
    42f8:	93 1f       	adc	r25, r19
    42fa:	ac 01       	movw	r20, r24
    42fc:	48 51       	subi	r20, 0x18	; 24
    42fe:	59 4f       	sbci	r21, 0xF9	; 249
    4300:	8a 81       	ldd	r24, Y+2	; 0x02
    4302:	9b 81       	ldd	r25, Y+3	; 0x03
    4304:	9c 01       	movw	r18, r24
    4306:	2e 5f       	subi	r18, 0xFE	; 254
    4308:	3f 4f       	sbci	r19, 0xFF	; 255
    430a:	ca 01       	movw	r24, r20
    430c:	b9 01       	movw	r22, r18
    430e:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    4312:	81 e0       	ldi	r24, 0x01	; 1
    4314:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4316:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4318:	0f 90       	pop	r0
    431a:	0f 90       	pop	r0
    431c:	0f 90       	pop	r0
    431e:	0f 90       	pop	r0
    4320:	0f 90       	pop	r0
    4322:	cf 91       	pop	r28
    4324:	df 91       	pop	r29
    4326:	08 95       	ret

00004328 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4328:	df 93       	push	r29
    432a:	cf 93       	push	r28
    432c:	00 d0       	rcall	.+0      	; 0x432e <uxTaskResetEventItemValue+0x6>
    432e:	cd b7       	in	r28, 0x3d	; 61
    4330:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4332:	e0 91 db 06 	lds	r30, 0x06DB
    4336:	f0 91 dc 06 	lds	r31, 0x06DC
    433a:	84 85       	ldd	r24, Z+12	; 0x0c
    433c:	95 85       	ldd	r25, Z+13	; 0x0d
    433e:	9a 83       	std	Y+2, r25	; 0x02
    4340:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4342:	a0 91 db 06 	lds	r26, 0x06DB
    4346:	b0 91 dc 06 	lds	r27, 0x06DC
    434a:	e0 91 db 06 	lds	r30, 0x06DB
    434e:	f0 91 dc 06 	lds	r31, 0x06DC
    4352:	86 89       	ldd	r24, Z+22	; 0x16
    4354:	28 2f       	mov	r18, r24
    4356:	30 e0       	ldi	r19, 0x00	; 0
    4358:	84 e0       	ldi	r24, 0x04	; 4
    435a:	90 e0       	ldi	r25, 0x00	; 0
    435c:	82 1b       	sub	r24, r18
    435e:	93 0b       	sbc	r25, r19
    4360:	1d 96       	adiw	r26, 0x0d	; 13
    4362:	9c 93       	st	X, r25
    4364:	8e 93       	st	-X, r24
    4366:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4368:	89 81       	ldd	r24, Y+1	; 0x01
    436a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    436c:	0f 90       	pop	r0
    436e:	0f 90       	pop	r0
    4370:	cf 91       	pop	r28
    4372:	df 91       	pop	r29
    4374:	08 95       	ret

00004376 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    4376:	df 93       	push	r29
    4378:	cf 93       	push	r28
    437a:	cd b7       	in	r28, 0x3d	; 61
    437c:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    437e:	80 91 db 06 	lds	r24, 0x06DB
    4382:	90 91 dc 06 	lds	r25, 0x06DC
    4386:	00 97       	sbiw	r24, 0x00	; 0
    4388:	39 f0       	breq	.+14     	; 0x4398 <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    438a:	e0 91 db 06 	lds	r30, 0x06DB
    438e:	f0 91 dc 06 	lds	r31, 0x06DC
    4392:	86 a5       	ldd	r24, Z+46	; 0x2e
    4394:	8f 5f       	subi	r24, 0xFF	; 255
    4396:	86 a7       	std	Z+46, r24	; 0x2e
		}

		return pxCurrentTCB;
    4398:	80 91 db 06 	lds	r24, 0x06DB
    439c:	90 91 dc 06 	lds	r25, 0x06DC
	}
    43a0:	cf 91       	pop	r28
    43a2:	df 91       	pop	r29
    43a4:	08 95       	ret

000043a6 <main>:
} student_t;



int main(void)
{
    43a6:	af 92       	push	r10
    43a8:	bf 92       	push	r11
    43aa:	cf 92       	push	r12
    43ac:	df 92       	push	r13
    43ae:	ef 92       	push	r14
    43b0:	ff 92       	push	r15
    43b2:	0f 93       	push	r16
    43b4:	df 93       	push	r29
    43b6:	cf 93       	push	r28
    43b8:	cd b7       	in	r28, 0x3d	; 61
    43ba:	de b7       	in	r29, 0x3e	; 62

	/* Init. Pr. */
	system_init();
    43bc:	0e 94 66 23 	call	0x46cc	; 0x46cc <system_init>

	/* OS Object Creat. */
	qStudentStruct = xQueueCreate(3, 20); /* msg size Should be 16bytes or more */
    43c0:	83 e0       	ldi	r24, 0x03	; 3
    43c2:	64 e1       	ldi	r22, 0x14	; 20
    43c4:	40 e0       	ldi	r20, 0x00	; 0
    43c6:	0e 94 3e 11 	call	0x227c	; 0x227c <xQueueGenericCreate>
    43ca:	90 93 37 07 	sts	0x0737, r25
    43ce:	80 93 36 07 	sts	0x0736, r24

	/* Tasks Creation */
	xTaskCreate(T_SystemIndication,NULL,100,NULL,1,NULL);
    43d2:	83 e5       	ldi	r24, 0x53	; 83
    43d4:	93 e2       	ldi	r25, 0x23	; 35
    43d6:	60 e0       	ldi	r22, 0x00	; 0
    43d8:	70 e0       	ldi	r23, 0x00	; 0
    43da:	44 e6       	ldi	r20, 0x64	; 100
    43dc:	50 e0       	ldi	r21, 0x00	; 0
    43de:	20 e0       	ldi	r18, 0x00	; 0
    43e0:	30 e0       	ldi	r19, 0x00	; 0
    43e2:	01 e0       	ldi	r16, 0x01	; 1
    43e4:	ee 24       	eor	r14, r14
    43e6:	ff 24       	eor	r15, r15
    43e8:	cc 24       	eor	r12, r12
    43ea:	dd 24       	eor	r13, r13
    43ec:	aa 24       	eor	r10, r10
    43ee:	bb 24       	eor	r11, r11
    43f0:	0e 94 64 18 	call	0x30c8	; 0x30c8 <xTaskGenericCreate>
	xTaskCreate(T_UserInput,NULL,100,NULL,2,NULL);
    43f4:	8a e2       	ldi	r24, 0x2A	; 42
    43f6:	92 e2       	ldi	r25, 0x22	; 34
    43f8:	60 e0       	ldi	r22, 0x00	; 0
    43fa:	70 e0       	ldi	r23, 0x00	; 0
    43fc:	44 e6       	ldi	r20, 0x64	; 100
    43fe:	50 e0       	ldi	r21, 0x00	; 0
    4400:	20 e0       	ldi	r18, 0x00	; 0
    4402:	30 e0       	ldi	r19, 0x00	; 0
    4404:	02 e0       	ldi	r16, 0x02	; 2
    4406:	ee 24       	eor	r14, r14
    4408:	ff 24       	eor	r15, r15
    440a:	cc 24       	eor	r12, r12
    440c:	dd 24       	eor	r13, r13
    440e:	aa 24       	eor	r10, r10
    4410:	bb 24       	eor	r11, r11
    4412:	0e 94 64 18 	call	0x30c8	; 0x30c8 <xTaskGenericCreate>
	xTaskCreate(T_UserOutput,NULL,250,NULL,3,NULL); /* Higher priority */
    4416:	81 eb       	ldi	r24, 0xB1	; 177
    4418:	92 e2       	ldi	r25, 0x22	; 34
    441a:	60 e0       	ldi	r22, 0x00	; 0
    441c:	70 e0       	ldi	r23, 0x00	; 0
    441e:	4a ef       	ldi	r20, 0xFA	; 250
    4420:	50 e0       	ldi	r21, 0x00	; 0
    4422:	20 e0       	ldi	r18, 0x00	; 0
    4424:	30 e0       	ldi	r19, 0x00	; 0
    4426:	03 e0       	ldi	r16, 0x03	; 3
    4428:	ee 24       	eor	r14, r14
    442a:	ff 24       	eor	r15, r15
    442c:	cc 24       	eor	r12, r12
    442e:	dd 24       	eor	r13, r13
    4430:	aa 24       	eor	r10, r10
    4432:	bb 24       	eor	r11, r11
    4434:	0e 94 64 18 	call	0x30c8	; 0x30c8 <xTaskGenericCreate>

	/* OS Start or sched */
	vTaskStartScheduler();
    4438:	0e 94 85 1a 	call	0x350a	; 0x350a <vTaskStartScheduler>
    443c:	80 e0       	ldi	r24, 0x00	; 0
    443e:	90 e0       	ldi	r25, 0x00	; 0

}
    4440:	cf 91       	pop	r28
    4442:	df 91       	pop	r29
    4444:	0f 91       	pop	r16
    4446:	ff 90       	pop	r15
    4448:	ef 90       	pop	r14
    444a:	df 90       	pop	r13
    444c:	cf 90       	pop	r12
    444e:	bf 90       	pop	r11
    4450:	af 90       	pop	r10
    4452:	08 95       	ret

00004454 <T_UserInput>:


void T_UserInput(void* pvParam)
{
    4454:	df 93       	push	r29
    4456:	cf 93       	push	r28
    4458:	cd b7       	in	r28, 0x3d	; 61
    445a:	de b7       	in	r29, 0x3e	; 62
    445c:	66 97       	sbiw	r28, 0x16	; 22
    445e:	0f b6       	in	r0, 0x3f	; 63
    4460:	f8 94       	cli
    4462:	de bf       	out	0x3e, r29	; 62
    4464:	0f be       	out	0x3f, r0	; 63
    4466:	cd bf       	out	0x3d, r28	; 61
    4468:	9e 8b       	std	Y+22, r25	; 0x16
    446a:	8d 8b       	std	Y+21, r24	; 0x15
	student_t Student;

	u8 ucData = 0;
    446c:	1a 8a       	std	Y+18, r1	; 0x12
	u8 strMark[2];
	while(1)
	{
		if( E_OK == usart_getc_NonBlocking(&ucData) )
    446e:	ce 01       	movw	r24, r28
    4470:	42 96       	adiw	r24, 0x12	; 18
    4472:	0e 94 fe 03 	call	0x7fc	; 0x7fc <usart_getc_NonBlocking>
    4476:	88 23       	and	r24, r24
    4478:	09 f0       	breq	.+2      	; 0x447c <T_UserInput+0x28>
    447a:	6e c0       	rjmp	.+220    	; 0x4558 <T_UserInput+0x104>
		{
			u8 i = 0;
    447c:	19 82       	std	Y+1, r1	; 0x01
			memset(Student.Name, 0, 14);
    447e:	ce 01       	movw	r24, r28
    4480:	02 96       	adiw	r24, 0x02	; 2
    4482:	60 e0       	ldi	r22, 0x00	; 0
    4484:	70 e0       	ldi	r23, 0x00	; 0
    4486:	4e e0       	ldi	r20, 0x0E	; 14
    4488:	50 e0       	ldi	r21, 0x00	; 0
    448a:	0e 94 00 24 	call	0x4800	; 0x4800 <memset>
    448e:	1b c0       	rjmp	.+54     	; 0x44c6 <T_UserInput+0x72>
			while(ucData != '\r') /* while Enter key not pressed yet */
			{
				/* Waiting to receive the full name of buffer full */
				Student.Name[i] = ucData;
    4490:	89 81       	ldd	r24, Y+1	; 0x01
    4492:	28 2f       	mov	r18, r24
    4494:	30 e0       	ldi	r19, 0x00	; 0
    4496:	4a 89       	ldd	r20, Y+18	; 0x12
    4498:	ce 01       	movw	r24, r28
    449a:	02 96       	adiw	r24, 0x02	; 2
    449c:	fc 01       	movw	r30, r24
    449e:	e2 0f       	add	r30, r18
    44a0:	f3 1f       	adc	r31, r19
    44a2:	40 83       	st	Z, r20
				i++;
    44a4:	89 81       	ldd	r24, Y+1	; 0x01
    44a6:	8f 5f       	subi	r24, 0xFF	; 255
    44a8:	89 83       	std	Y+1, r24	; 0x01

				if(i>14)
    44aa:	89 81       	ldd	r24, Y+1	; 0x01
    44ac:	8f 30       	cpi	r24, 0x0F	; 15
    44ae:	98 f4       	brcc	.+38     	; 0x44d6 <T_UserInput+0x82>
    44b0:	04 c0       	rjmp	.+8      	; 0x44ba <T_UserInput+0x66>
					break;
				}

				while( PENDING == usart_getc_NonBlocking(&ucData))
				{
					vTaskDelay(5);
    44b2:	85 e0       	ldi	r24, 0x05	; 5
    44b4:	90 e0       	ldi	r25, 0x00	; 0
    44b6:	0e 94 1e 1a 	call	0x343c	; 0x343c <vTaskDelay>
				if(i>14)
				{
					break;
				}

				while( PENDING == usart_getc_NonBlocking(&ucData))
    44ba:	ce 01       	movw	r24, r28
    44bc:	42 96       	adiw	r24, 0x12	; 18
    44be:	0e 94 fe 03 	call	0x7fc	; 0x7fc <usart_getc_NonBlocking>
    44c2:	82 30       	cpi	r24, 0x02	; 2
    44c4:	b1 f3       	breq	.-20     	; 0x44b2 <T_UserInput+0x5e>
	{
		if( E_OK == usart_getc_NonBlocking(&ucData) )
		{
			u8 i = 0;
			memset(Student.Name, 0, 14);
			while(ucData != '\r') /* while Enter key not pressed yet */
    44c6:	8a 89       	ldd	r24, Y+18	; 0x12
    44c8:	8d 30       	cpi	r24, 0x0D	; 13
    44ca:	11 f7       	brne	.-60     	; 0x4490 <T_UserInput+0x3c>
    44cc:	04 c0       	rjmp	.+8      	; 0x44d6 <T_UserInput+0x82>
				//usart_puts("Task Input While\r\n");
			} 	/* end While the enter not pressed or buffer full */

			while( PENDING == usart_getc_NonBlocking(&ucData))
			{
				vTaskDelay(5);
    44ce:	85 e0       	ldi	r24, 0x05	; 5
    44d0:	90 e0       	ldi	r25, 0x00	; 0
    44d2:	0e 94 1e 1a 	call	0x343c	; 0x343c <vTaskDelay>
					vTaskDelay(5);
				}
				//usart_puts("Task Input While\r\n");
			} 	/* end While the enter not pressed or buffer full */

			while( PENDING == usart_getc_NonBlocking(&ucData))
    44d6:	ce 01       	movw	r24, r28
    44d8:	42 96       	adiw	r24, 0x12	; 18
    44da:	0e 94 fe 03 	call	0x7fc	; 0x7fc <usart_getc_NonBlocking>
    44de:	82 30       	cpi	r24, 0x02	; 2
    44e0:	b1 f3       	breq	.-20     	; 0x44ce <T_UserInput+0x7a>
			{
				vTaskDelay(5);
			}

			Student.Mark = 0;
    44e2:	19 8a       	std	Y+17, r1	; 0x11
			memset(strMark, 0, 2);
    44e4:	ce 01       	movw	r24, r28
    44e6:	43 96       	adiw	r24, 0x13	; 19
    44e8:	60 e0       	ldi	r22, 0x00	; 0
    44ea:	70 e0       	ldi	r23, 0x00	; 0
    44ec:	42 e0       	ldi	r20, 0x02	; 2
    44ee:	50 e0       	ldi	r21, 0x00	; 0
    44f0:	0e 94 00 24 	call	0x4800	; 0x4800 <memset>
			i = 0;
    44f4:	19 82       	std	Y+1, r1	; 0x01
    44f6:	1b c0       	rjmp	.+54     	; 0x452e <T_UserInput+0xda>

			while(ucData != '\r')
			{
				/* Waiting to receive the mark of buffer full */
				strMark[i] = ucData;
    44f8:	89 81       	ldd	r24, Y+1	; 0x01
    44fa:	28 2f       	mov	r18, r24
    44fc:	30 e0       	ldi	r19, 0x00	; 0
    44fe:	4a 89       	ldd	r20, Y+18	; 0x12
    4500:	ce 01       	movw	r24, r28
    4502:	43 96       	adiw	r24, 0x13	; 19
    4504:	fc 01       	movw	r30, r24
    4506:	e2 0f       	add	r30, r18
    4508:	f3 1f       	adc	r31, r19
    450a:	40 83       	st	Z, r20
				i++;
    450c:	89 81       	ldd	r24, Y+1	; 0x01
    450e:	8f 5f       	subi	r24, 0xFF	; 255
    4510:	89 83       	std	Y+1, r24	; 0x01

				if(i>2)
    4512:	89 81       	ldd	r24, Y+1	; 0x01
    4514:	83 30       	cpi	r24, 0x03	; 3
    4516:	70 f4       	brcc	.+28     	; 0x4534 <T_UserInput+0xe0>
    4518:	04 c0       	rjmp	.+8      	; 0x4522 <T_UserInput+0xce>
					break;
				}

				while( PENDING == usart_getc_NonBlocking(&ucData))
				{
					vTaskDelay(5);
    451a:	85 e0       	ldi	r24, 0x05	; 5
    451c:	90 e0       	ldi	r25, 0x00	; 0
    451e:	0e 94 1e 1a 	call	0x343c	; 0x343c <vTaskDelay>
				if(i>2)
				{
					break;
				}

				while( PENDING == usart_getc_NonBlocking(&ucData))
    4522:	ce 01       	movw	r24, r28
    4524:	42 96       	adiw	r24, 0x12	; 18
    4526:	0e 94 fe 03 	call	0x7fc	; 0x7fc <usart_getc_NonBlocking>
    452a:	82 30       	cpi	r24, 0x02	; 2
    452c:	b1 f3       	breq	.-20     	; 0x451a <T_UserInput+0xc6>

			Student.Mark = 0;
			memset(strMark, 0, 2);
			i = 0;

			while(ucData != '\r')
    452e:	8a 89       	ldd	r24, Y+18	; 0x12
    4530:	8d 30       	cpi	r24, 0x0D	; 13
    4532:	11 f7       	brne	.-60     	; 0x44f8 <T_UserInput+0xa4>
			usart_puts(strMark);
			usart_puts("\r\n");
#endif


			Student.Mark = atoi(strMark);		/* Convert from ascii to integer */
    4534:	ce 01       	movw	r24, r28
    4536:	43 96       	adiw	r24, 0x13	; 19
    4538:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <atoi>
    453c:	89 8b       	std	Y+17, r24	; 0x11


			xQueueSend(qStudentStruct, &Student, portMAX_DELAY);	/* Send the student data to the receiving task */
    453e:	80 91 36 07 	lds	r24, 0x0736
    4542:	90 91 37 07 	lds	r25, 0x0737
    4546:	9e 01       	movw	r18, r28
    4548:	2e 5f       	subi	r18, 0xFE	; 254
    454a:	3f 4f       	sbci	r19, 0xFF	; 255
    454c:	b9 01       	movw	r22, r18
    454e:	4f ef       	ldi	r20, 0xFF	; 255
    4550:	5f ef       	ldi	r21, 0xFF	; 255
    4552:	20 e0       	ldi	r18, 0x00	; 0
    4554:	0e 94 09 12 	call	0x2412	; 0x2412 <xQueueGenericSend>
		else
		{

		}

		vTaskDelay(10);
    4558:	8a e0       	ldi	r24, 0x0A	; 10
    455a:	90 e0       	ldi	r25, 0x00	; 0
    455c:	0e 94 1e 1a 	call	0x343c	; 0x343c <vTaskDelay>
    4560:	86 cf       	rjmp	.-244    	; 0x446e <T_UserInput+0x1a>

00004562 <T_UserOutput>:
}



void T_UserOutput(void* pvParam)
{
    4562:	df 93       	push	r29
    4564:	cf 93       	push	r28
    4566:	cd b7       	in	r28, 0x3d	; 61
    4568:	de b7       	in	r29, 0x3e	; 62
    456a:	c7 5a       	subi	r28, 0xA7	; 167
    456c:	d0 40       	sbci	r29, 0x00	; 0
    456e:	0f b6       	in	r0, 0x3f	; 63
    4570:	f8 94       	cli
    4572:	de bf       	out	0x3e, r29	; 62
    4574:	0f be       	out	0x3f, r0	; 63
    4576:	cd bf       	out	0x3d, r28	; 61
    4578:	fe 01       	movw	r30, r28
    457a:	ea 55       	subi	r30, 0x5A	; 90
    457c:	ff 4f       	sbci	r31, 0xFF	; 255
    457e:	91 83       	std	Z+1, r25	; 0x01
    4580:	80 83       	st	Z, r24
	student_t StudentList[10];
	u8 i = 0;
    4582:	19 82       	std	Y+1, r1	; 0x01
	u8 strMark[4];

	/* initializing the student list with Zeros */
	for(i = 0; i < 10; i++)
    4584:	19 82       	std	Y+1, r1	; 0x01
    4586:	28 c0       	rjmp	.+80     	; 0x45d8 <T_UserOutput+0x76>
	{
		memset( StudentList[i].Name, 0, 15);
    4588:	89 81       	ldd	r24, Y+1	; 0x01
    458a:	88 2f       	mov	r24, r24
    458c:	90 e0       	ldi	r25, 0x00	; 0
    458e:	9e 01       	movw	r18, r28
    4590:	2e 5f       	subi	r18, 0xFE	; 254
    4592:	3f 4f       	sbci	r19, 0xFF	; 255
    4594:	82 95       	swap	r24
    4596:	92 95       	swap	r25
    4598:	90 7f       	andi	r25, 0xF0	; 240
    459a:	98 27       	eor	r25, r24
    459c:	80 7f       	andi	r24, 0xF0	; 240
    459e:	98 27       	eor	r25, r24
    45a0:	82 0f       	add	r24, r18
    45a2:	93 1f       	adc	r25, r19
    45a4:	60 e0       	ldi	r22, 0x00	; 0
    45a6:	70 e0       	ldi	r23, 0x00	; 0
    45a8:	4f e0       	ldi	r20, 0x0F	; 15
    45aa:	50 e0       	ldi	r21, 0x00	; 0
    45ac:	0e 94 00 24 	call	0x4800	; 0x4800 <memset>
		StudentList[i].Mark = 0;
    45b0:	89 81       	ldd	r24, Y+1	; 0x01
    45b2:	88 2f       	mov	r24, r24
    45b4:	90 e0       	ldi	r25, 0x00	; 0
    45b6:	9c 01       	movw	r18, r24
    45b8:	22 95       	swap	r18
    45ba:	32 95       	swap	r19
    45bc:	30 7f       	andi	r19, 0xF0	; 240
    45be:	32 27       	eor	r19, r18
    45c0:	20 7f       	andi	r18, 0xF0	; 240
    45c2:	32 27       	eor	r19, r18
    45c4:	ce 01       	movw	r24, r28
    45c6:	01 96       	adiw	r24, 0x01	; 1
    45c8:	82 0f       	add	r24, r18
    45ca:	93 1f       	adc	r25, r19
    45cc:	fc 01       	movw	r30, r24
    45ce:	70 96       	adiw	r30, 0x10	; 16
    45d0:	10 82       	st	Z, r1
	student_t StudentList[10];
	u8 i = 0;
	u8 strMark[4];

	/* initializing the student list with Zeros */
	for(i = 0; i < 10; i++)
    45d2:	89 81       	ldd	r24, Y+1	; 0x01
    45d4:	8f 5f       	subi	r24, 0xFF	; 255
    45d6:	89 83       	std	Y+1, r24	; 0x01
    45d8:	89 81       	ldd	r24, Y+1	; 0x01
    45da:	8a 30       	cpi	r24, 0x0A	; 10
    45dc:	a8 f2       	brcs	.-86     	; 0x4588 <T_UserOutput+0x26>
		memset( StudentList[i].Name, 0, 15);
		StudentList[i].Mark = 0;
	}


	i=0;
    45de:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{


		if(xQueueReceive(qStudentStruct, &StudentList[i], portMAX_DELAY))
    45e0:	40 91 36 07 	lds	r20, 0x0736
    45e4:	50 91 37 07 	lds	r21, 0x0737
    45e8:	89 81       	ldd	r24, Y+1	; 0x01
    45ea:	88 2f       	mov	r24, r24
    45ec:	90 e0       	ldi	r25, 0x00	; 0
    45ee:	82 95       	swap	r24
    45f0:	92 95       	swap	r25
    45f2:	90 7f       	andi	r25, 0xF0	; 240
    45f4:	98 27       	eor	r25, r24
    45f6:	80 7f       	andi	r24, 0xF0	; 240
    45f8:	98 27       	eor	r25, r24
    45fa:	9e 01       	movw	r18, r28
    45fc:	2e 5f       	subi	r18, 0xFE	; 254
    45fe:	3f 4f       	sbci	r19, 0xFF	; 255
    4600:	28 0f       	add	r18, r24
    4602:	39 1f       	adc	r19, r25
    4604:	ca 01       	movw	r24, r20
    4606:	b9 01       	movw	r22, r18
    4608:	4f ef       	ldi	r20, 0xFF	; 255
    460a:	5f ef       	ldi	r21, 0xFF	; 255
    460c:	20 e0       	ldi	r18, 0x00	; 0
    460e:	0e 94 17 13 	call	0x262e	; 0x262e <xQueueGenericReceive>
    4612:	88 23       	and	r24, r24
    4614:	29 f3       	breq	.-54     	; 0x45e0 <T_UserOutput+0x7e>
		{

			usart_puts("New Student data: \r\nStudent ");
    4616:	8d e7       	ldi	r24, 0x7D	; 125
    4618:	90 e0       	ldi	r25, 0x00	; 0
    461a:	0e 94 33 04 	call	0x866	; 0x866 <usart_puts>
			usart_putc(	i  + 1 + 48 );
    461e:	89 81       	ldd	r24, Y+1	; 0x01
    4620:	8f 5c       	subi	r24, 0xCF	; 207
    4622:	0e 94 1c 04 	call	0x838	; 0x838 <usart_putc>
			usart_puts(":\r\n");
    4626:	8a e9       	ldi	r24, 0x9A	; 154
    4628:	90 e0       	ldi	r25, 0x00	; 0
    462a:	0e 94 33 04 	call	0x866	; 0x866 <usart_puts>
			usart_puts(StudentList[i].Name );
    462e:	89 81       	ldd	r24, Y+1	; 0x01
    4630:	88 2f       	mov	r24, r24
    4632:	90 e0       	ldi	r25, 0x00	; 0
    4634:	9e 01       	movw	r18, r28
    4636:	2e 5f       	subi	r18, 0xFE	; 254
    4638:	3f 4f       	sbci	r19, 0xFF	; 255
    463a:	82 95       	swap	r24
    463c:	92 95       	swap	r25
    463e:	90 7f       	andi	r25, 0xF0	; 240
    4640:	98 27       	eor	r25, r24
    4642:	80 7f       	andi	r24, 0xF0	; 240
    4644:	98 27       	eor	r25, r24
    4646:	82 0f       	add	r24, r18
    4648:	93 1f       	adc	r25, r19
    464a:	0e 94 33 04 	call	0x866	; 0x866 <usart_puts>
			usart_puts("\r\n");
    464e:	8e e9       	ldi	r24, 0x9E	; 158
    4650:	90 e0       	ldi	r25, 0x00	; 0
    4652:	0e 94 33 04 	call	0x866	; 0x866 <usart_puts>
			itoa(StudentList[i].Mark, strMark, 10);
    4656:	89 81       	ldd	r24, Y+1	; 0x01
    4658:	88 2f       	mov	r24, r24
    465a:	90 e0       	ldi	r25, 0x00	; 0
    465c:	9c 01       	movw	r18, r24
    465e:	22 95       	swap	r18
    4660:	32 95       	swap	r19
    4662:	30 7f       	andi	r19, 0xF0	; 240
    4664:	32 27       	eor	r19, r18
    4666:	20 7f       	andi	r18, 0xF0	; 240
    4668:	32 27       	eor	r19, r18
    466a:	ce 01       	movw	r24, r28
    466c:	01 96       	adiw	r24, 0x01	; 1
    466e:	82 0f       	add	r24, r18
    4670:	93 1f       	adc	r25, r19
    4672:	fc 01       	movw	r30, r24
    4674:	70 96       	adiw	r30, 0x10	; 16
    4676:	80 81       	ld	r24, Z
    4678:	88 2f       	mov	r24, r24
    467a:	90 e0       	ldi	r25, 0x00	; 0
    467c:	9e 01       	movw	r18, r28
    467e:	2e 55       	subi	r18, 0x5E	; 94
    4680:	3f 4f       	sbci	r19, 0xFF	; 255
    4682:	b9 01       	movw	r22, r18
    4684:	4a e0       	ldi	r20, 0x0A	; 10
    4686:	50 e0       	ldi	r21, 0x00	; 0
    4688:	0e 94 07 24 	call	0x480e	; 0x480e <itoa>
			usart_puts(strMark);
    468c:	ce 01       	movw	r24, r28
    468e:	8e 55       	subi	r24, 0x5E	; 94
    4690:	9f 4f       	sbci	r25, 0xFF	; 255
    4692:	0e 94 33 04 	call	0x866	; 0x866 <usart_puts>
			usart_puts("\r\n");
    4696:	8e e9       	ldi	r24, 0x9E	; 158
    4698:	90 e0       	ldi	r25, 0x00	; 0
    469a:	0e 94 33 04 	call	0x866	; 0x866 <usart_puts>


			i++;
    469e:	89 81       	ldd	r24, Y+1	; 0x01
    46a0:	8f 5f       	subi	r24, 0xFF	; 255
    46a2:	89 83       	std	Y+1, r24	; 0x01
    46a4:	9d cf       	rjmp	.-198    	; 0x45e0 <T_UserOutput+0x7e>

000046a6 <T_SystemIndication>:
}



void T_SystemIndication(void* pvParam)
{
    46a6:	df 93       	push	r29
    46a8:	cf 93       	push	r28
    46aa:	00 d0       	rcall	.+0      	; 0x46ac <T_SystemIndication+0x6>
    46ac:	cd b7       	in	r28, 0x3d	; 61
    46ae:	de b7       	in	r29, 0x3e	; 62
    46b0:	9a 83       	std	Y+2, r25	; 0x02
    46b2:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		PORTC ^= 0xFF;
    46b4:	a5 e3       	ldi	r26, 0x35	; 53
    46b6:	b0 e0       	ldi	r27, 0x00	; 0
    46b8:	e5 e3       	ldi	r30, 0x35	; 53
    46ba:	f0 e0       	ldi	r31, 0x00	; 0
    46bc:	80 81       	ld	r24, Z
    46be:	80 95       	com	r24
    46c0:	8c 93       	st	X, r24
		vTaskDelay(1000);
    46c2:	88 ee       	ldi	r24, 0xE8	; 232
    46c4:	93 e0       	ldi	r25, 0x03	; 3
    46c6:	0e 94 1e 1a 	call	0x343c	; 0x343c <vTaskDelay>
    46ca:	f4 cf       	rjmp	.-24     	; 0x46b4 <T_SystemIndication+0xe>

000046cc <system_init>:




void system_init(void)
{
    46cc:	df 93       	push	r29
    46ce:	cf 93       	push	r28
    46d0:	cd b7       	in	r28, 0x3d	; 61
    46d2:	de b7       	in	r29, 0x3e	; 62



	/* leds  */
	DIO_voidSetPortDirection(DIO_u8_PORTC ,DIO_u8_OUTPUT);
    46d4:	82 e0       	ldi	r24, 0x02	; 2
    46d6:	61 e0       	ldi	r22, 0x01	; 1
    46d8:	0e 94 dd 02 	call	0x5ba	; 0x5ba <DIO_voidSetPortDirection>


	DIO_voidSetPortValue(DIO_u8_PORTC, DIO_u8_LOW);
    46dc:	82 e0       	ldi	r24, 0x02	; 2
    46de:	60 e0       	ldi	r22, 0x00	; 0
    46e0:	0e 94 1e 03 	call	0x63c	; 0x63c <DIO_voidSetPortValue>


	/* UART */
	usart_init(9600);
    46e4:	80 e8       	ldi	r24, 0x80	; 128
    46e6:	95 e2       	ldi	r25, 0x25	; 37
    46e8:	0e 94 a9 03 	call	0x752	; 0x752 <usart_init>
	usart_puts("System Started...\r\n");
    46ec:	81 ea       	ldi	r24, 0xA1	; 161
    46ee:	90 e0       	ldi	r25, 0x00	; 0
    46f0:	0e 94 33 04 	call	0x866	; 0x866 <usart_puts>

}
    46f4:	cf 91       	pop	r28
    46f6:	df 91       	pop	r29
    46f8:	08 95       	ret

000046fa <__mulsi3>:
    46fa:	62 9f       	mul	r22, r18
    46fc:	d0 01       	movw	r26, r0
    46fe:	73 9f       	mul	r23, r19
    4700:	f0 01       	movw	r30, r0
    4702:	82 9f       	mul	r24, r18
    4704:	e0 0d       	add	r30, r0
    4706:	f1 1d       	adc	r31, r1
    4708:	64 9f       	mul	r22, r20
    470a:	e0 0d       	add	r30, r0
    470c:	f1 1d       	adc	r31, r1
    470e:	92 9f       	mul	r25, r18
    4710:	f0 0d       	add	r31, r0
    4712:	83 9f       	mul	r24, r19
    4714:	f0 0d       	add	r31, r0
    4716:	74 9f       	mul	r23, r20
    4718:	f0 0d       	add	r31, r0
    471a:	65 9f       	mul	r22, r21
    471c:	f0 0d       	add	r31, r0
    471e:	99 27       	eor	r25, r25
    4720:	72 9f       	mul	r23, r18
    4722:	b0 0d       	add	r27, r0
    4724:	e1 1d       	adc	r30, r1
    4726:	f9 1f       	adc	r31, r25
    4728:	63 9f       	mul	r22, r19
    472a:	b0 0d       	add	r27, r0
    472c:	e1 1d       	adc	r30, r1
    472e:	f9 1f       	adc	r31, r25
    4730:	bd 01       	movw	r22, r26
    4732:	cf 01       	movw	r24, r30
    4734:	11 24       	eor	r1, r1
    4736:	08 95       	ret

00004738 <__udivmodsi4>:
    4738:	a1 e2       	ldi	r26, 0x21	; 33
    473a:	1a 2e       	mov	r1, r26
    473c:	aa 1b       	sub	r26, r26
    473e:	bb 1b       	sub	r27, r27
    4740:	fd 01       	movw	r30, r26
    4742:	0d c0       	rjmp	.+26     	; 0x475e <__udivmodsi4_ep>

00004744 <__udivmodsi4_loop>:
    4744:	aa 1f       	adc	r26, r26
    4746:	bb 1f       	adc	r27, r27
    4748:	ee 1f       	adc	r30, r30
    474a:	ff 1f       	adc	r31, r31
    474c:	a2 17       	cp	r26, r18
    474e:	b3 07       	cpc	r27, r19
    4750:	e4 07       	cpc	r30, r20
    4752:	f5 07       	cpc	r31, r21
    4754:	20 f0       	brcs	.+8      	; 0x475e <__udivmodsi4_ep>
    4756:	a2 1b       	sub	r26, r18
    4758:	b3 0b       	sbc	r27, r19
    475a:	e4 0b       	sbc	r30, r20
    475c:	f5 0b       	sbc	r31, r21

0000475e <__udivmodsi4_ep>:
    475e:	66 1f       	adc	r22, r22
    4760:	77 1f       	adc	r23, r23
    4762:	88 1f       	adc	r24, r24
    4764:	99 1f       	adc	r25, r25
    4766:	1a 94       	dec	r1
    4768:	69 f7       	brne	.-38     	; 0x4744 <__udivmodsi4_loop>
    476a:	60 95       	com	r22
    476c:	70 95       	com	r23
    476e:	80 95       	com	r24
    4770:	90 95       	com	r25
    4772:	9b 01       	movw	r18, r22
    4774:	ac 01       	movw	r20, r24
    4776:	bd 01       	movw	r22, r26
    4778:	cf 01       	movw	r24, r30
    477a:	08 95       	ret

0000477c <__divmodsi4>:
    477c:	97 fb       	bst	r25, 7
    477e:	09 2e       	mov	r0, r25
    4780:	05 26       	eor	r0, r21
    4782:	0e d0       	rcall	.+28     	; 0x47a0 <__divmodsi4_neg1>
    4784:	57 fd       	sbrc	r21, 7
    4786:	04 d0       	rcall	.+8      	; 0x4790 <__divmodsi4_neg2>
    4788:	d7 df       	rcall	.-82     	; 0x4738 <__udivmodsi4>
    478a:	0a d0       	rcall	.+20     	; 0x47a0 <__divmodsi4_neg1>
    478c:	00 1c       	adc	r0, r0
    478e:	38 f4       	brcc	.+14     	; 0x479e <__divmodsi4_exit>

00004790 <__divmodsi4_neg2>:
    4790:	50 95       	com	r21
    4792:	40 95       	com	r20
    4794:	30 95       	com	r19
    4796:	21 95       	neg	r18
    4798:	3f 4f       	sbci	r19, 0xFF	; 255
    479a:	4f 4f       	sbci	r20, 0xFF	; 255
    479c:	5f 4f       	sbci	r21, 0xFF	; 255

0000479e <__divmodsi4_exit>:
    479e:	08 95       	ret

000047a0 <__divmodsi4_neg1>:
    47a0:	f6 f7       	brtc	.-4      	; 0x479e <__divmodsi4_exit>
    47a2:	90 95       	com	r25
    47a4:	80 95       	com	r24
    47a6:	70 95       	com	r23
    47a8:	61 95       	neg	r22
    47aa:	7f 4f       	sbci	r23, 0xFF	; 255
    47ac:	8f 4f       	sbci	r24, 0xFF	; 255
    47ae:	9f 4f       	sbci	r25, 0xFF	; 255
    47b0:	08 95       	ret

000047b2 <atoi>:
    47b2:	fc 01       	movw	r30, r24
    47b4:	88 27       	eor	r24, r24
    47b6:	99 27       	eor	r25, r25
    47b8:	e8 94       	clt
    47ba:	21 91       	ld	r18, Z+
    47bc:	20 32       	cpi	r18, 0x20	; 32
    47be:	e9 f3       	breq	.-6      	; 0x47ba <atoi+0x8>
    47c0:	29 30       	cpi	r18, 0x09	; 9
    47c2:	10 f0       	brcs	.+4      	; 0x47c8 <atoi+0x16>
    47c4:	2e 30       	cpi	r18, 0x0E	; 14
    47c6:	c8 f3       	brcs	.-14     	; 0x47ba <atoi+0x8>
    47c8:	2b 32       	cpi	r18, 0x2B	; 43
    47ca:	41 f0       	breq	.+16     	; 0x47dc <atoi+0x2a>
    47cc:	2d 32       	cpi	r18, 0x2D	; 45
    47ce:	39 f4       	brne	.+14     	; 0x47de <atoi+0x2c>
    47d0:	68 94       	set
    47d2:	04 c0       	rjmp	.+8      	; 0x47dc <atoi+0x2a>
    47d4:	0e 94 28 24 	call	0x4850	; 0x4850 <__mulhi_const_10>
    47d8:	82 0f       	add	r24, r18
    47da:	91 1d       	adc	r25, r1
    47dc:	21 91       	ld	r18, Z+
    47de:	20 53       	subi	r18, 0x30	; 48
    47e0:	2a 30       	cpi	r18, 0x0A	; 10
    47e2:	c0 f3       	brcs	.-16     	; 0x47d4 <atoi+0x22>
    47e4:	1e f4       	brtc	.+6      	; 0x47ec <atoi+0x3a>
    47e6:	90 95       	com	r25
    47e8:	81 95       	neg	r24
    47ea:	9f 4f       	sbci	r25, 0xFF	; 255
    47ec:	08 95       	ret

000047ee <memcpy>:
    47ee:	fb 01       	movw	r30, r22
    47f0:	dc 01       	movw	r26, r24
    47f2:	02 c0       	rjmp	.+4      	; 0x47f8 <memcpy+0xa>
    47f4:	01 90       	ld	r0, Z+
    47f6:	0d 92       	st	X+, r0
    47f8:	41 50       	subi	r20, 0x01	; 1
    47fa:	50 40       	sbci	r21, 0x00	; 0
    47fc:	d8 f7       	brcc	.-10     	; 0x47f4 <memcpy+0x6>
    47fe:	08 95       	ret

00004800 <memset>:
    4800:	dc 01       	movw	r26, r24
    4802:	01 c0       	rjmp	.+2      	; 0x4806 <memset+0x6>
    4804:	6d 93       	st	X+, r22
    4806:	41 50       	subi	r20, 0x01	; 1
    4808:	50 40       	sbci	r21, 0x00	; 0
    480a:	e0 f7       	brcc	.-8      	; 0x4804 <memset+0x4>
    480c:	08 95       	ret

0000480e <itoa>:
    480e:	fb 01       	movw	r30, r22
    4810:	9f 01       	movw	r18, r30
    4812:	e8 94       	clt
    4814:	42 30       	cpi	r20, 0x02	; 2
    4816:	c4 f0       	brlt	.+48     	; 0x4848 <itoa+0x3a>
    4818:	45 32       	cpi	r20, 0x25	; 37
    481a:	b4 f4       	brge	.+44     	; 0x4848 <itoa+0x3a>
    481c:	4a 30       	cpi	r20, 0x0A	; 10
    481e:	29 f4       	brne	.+10     	; 0x482a <itoa+0x1c>
    4820:	97 fb       	bst	r25, 7
    4822:	1e f4       	brtc	.+6      	; 0x482a <itoa+0x1c>
    4824:	90 95       	com	r25
    4826:	81 95       	neg	r24
    4828:	9f 4f       	sbci	r25, 0xFF	; 255
    482a:	64 2f       	mov	r22, r20
    482c:	77 27       	eor	r23, r23
    482e:	0e 94 40 24 	call	0x4880	; 0x4880 <__udivmodhi4>
    4832:	80 5d       	subi	r24, 0xD0	; 208
    4834:	8a 33       	cpi	r24, 0x3A	; 58
    4836:	0c f0       	brlt	.+2      	; 0x483a <itoa+0x2c>
    4838:	89 5d       	subi	r24, 0xD9	; 217
    483a:	81 93       	st	Z+, r24
    483c:	cb 01       	movw	r24, r22
    483e:	00 97       	sbiw	r24, 0x00	; 0
    4840:	a1 f7       	brne	.-24     	; 0x482a <itoa+0x1c>
    4842:	16 f4       	brtc	.+4      	; 0x4848 <itoa+0x3a>
    4844:	5d e2       	ldi	r21, 0x2D	; 45
    4846:	51 93       	st	Z+, r21
    4848:	10 82       	st	Z, r1
    484a:	c9 01       	movw	r24, r18
    484c:	0c 94 30 24 	jmp	0x4860	; 0x4860 <strrev>

00004850 <__mulhi_const_10>:
    4850:	7a e0       	ldi	r23, 0x0A	; 10
    4852:	97 9f       	mul	r25, r23
    4854:	90 2d       	mov	r25, r0
    4856:	87 9f       	mul	r24, r23
    4858:	80 2d       	mov	r24, r0
    485a:	91 0d       	add	r25, r1
    485c:	11 24       	eor	r1, r1
    485e:	08 95       	ret

00004860 <strrev>:
    4860:	dc 01       	movw	r26, r24
    4862:	fc 01       	movw	r30, r24
    4864:	67 2f       	mov	r22, r23
    4866:	71 91       	ld	r23, Z+
    4868:	77 23       	and	r23, r23
    486a:	e1 f7       	brne	.-8      	; 0x4864 <strrev+0x4>
    486c:	32 97       	sbiw	r30, 0x02	; 2
    486e:	04 c0       	rjmp	.+8      	; 0x4878 <strrev+0x18>
    4870:	7c 91       	ld	r23, X
    4872:	6d 93       	st	X+, r22
    4874:	70 83       	st	Z, r23
    4876:	62 91       	ld	r22, -Z
    4878:	ae 17       	cp	r26, r30
    487a:	bf 07       	cpc	r27, r31
    487c:	c8 f3       	brcs	.-14     	; 0x4870 <strrev+0x10>
    487e:	08 95       	ret

00004880 <__udivmodhi4>:
    4880:	aa 1b       	sub	r26, r26
    4882:	bb 1b       	sub	r27, r27
    4884:	51 e1       	ldi	r21, 0x11	; 17
    4886:	07 c0       	rjmp	.+14     	; 0x4896 <__udivmodhi4_ep>

00004888 <__udivmodhi4_loop>:
    4888:	aa 1f       	adc	r26, r26
    488a:	bb 1f       	adc	r27, r27
    488c:	a6 17       	cp	r26, r22
    488e:	b7 07       	cpc	r27, r23
    4890:	10 f0       	brcs	.+4      	; 0x4896 <__udivmodhi4_ep>
    4892:	a6 1b       	sub	r26, r22
    4894:	b7 0b       	sbc	r27, r23

00004896 <__udivmodhi4_ep>:
    4896:	88 1f       	adc	r24, r24
    4898:	99 1f       	adc	r25, r25
    489a:	5a 95       	dec	r21
    489c:	a9 f7       	brne	.-22     	; 0x4888 <__udivmodhi4_loop>
    489e:	80 95       	com	r24
    48a0:	90 95       	com	r25
    48a2:	bc 01       	movw	r22, r24
    48a4:	cd 01       	movw	r24, r26
    48a6:	08 95       	ret

000048a8 <_exit>:
    48a8:	f8 94       	cli

000048aa <__stop_program>:
    48aa:	ff cf       	rjmp	.-2      	; 0x48aa <__stop_program>
