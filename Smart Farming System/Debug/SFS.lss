
SFS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002708  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000d2  00800060  00002708  0000279c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004e0  00800132  00800132  0000286e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000286e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000028a0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000478  00000000  00000000  000028dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005c30  00000000  00000000  00002d54  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000016a9  00000000  00000000  00008984  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002ebf  00000000  00000000  0000a02d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000bd0  00000000  00000000  0000ceec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000168f  00000000  00000000  0000dabc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004274  00000000  00000000  0000f14b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003e8  00000000  00000000  000133bf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e0       	ldi	r30, 0x08	; 8
      68:	f7 e2       	ldi	r31, 0x27	; 39
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 33       	cpi	r26, 0x32	; 50
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	26 e0       	ldi	r18, 0x06	; 6
      78:	a2 e3       	ldi	r26, 0x32	; 50
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 31       	cpi	r26, 0x12	; 18
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 0b 0f 	call	0x1e16	; 0x1e16 <main>
      8a:	0c 94 82 13 	jmp	0x2704	; 0x2704 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <prvTestWaitCondition>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
      92:	41 11       	cpse	r20, r1
      94:	06 c0       	rjmp	.+12     	; 0xa2 <prvTestWaitCondition+0x10>
      96:	68 23       	and	r22, r24
      98:	79 23       	and	r23, r25
      9a:	67 2b       	or	r22, r23
      9c:	49 f4       	brne	.+18     	; 0xb0 <prvTestWaitCondition+0x1e>
      9e:	80 e0       	ldi	r24, 0x00	; 0
      a0:	08 95       	ret
      a2:	86 23       	and	r24, r22
      a4:	97 23       	and	r25, r23
      a6:	68 17       	cp	r22, r24
      a8:	79 07       	cpc	r23, r25
      aa:	21 f0       	breq	.+8      	; 0xb4 <prvTestWaitCondition+0x22>
      ac:	80 e0       	ldi	r24, 0x00	; 0
      ae:	08 95       	ret
      b0:	81 e0       	ldi	r24, 0x01	; 1
      b2:	08 95       	ret
      b4:	81 e0       	ldi	r24, 0x01	; 1
      b6:	08 95       	ret

000000b8 <xEventGroupCreate>:
      b8:	cf 93       	push	r28
      ba:	df 93       	push	r29
      bc:	8b e0       	ldi	r24, 0x0B	; 11
      be:	90 e0       	ldi	r25, 0x00	; 0
      c0:	0e 94 54 01 	call	0x2a8	; 0x2a8 <pvPortMalloc>
      c4:	ec 01       	movw	r28, r24
      c6:	00 97       	sbiw	r24, 0x00	; 0
      c8:	31 f0       	breq	.+12     	; 0xd6 <xEventGroupCreate+0x1e>
      ca:	fc 01       	movw	r30, r24
      cc:	11 92       	st	Z+, r1
      ce:	11 92       	st	Z+, r1
      d0:	cf 01       	movw	r24, r30
      d2:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
      d6:	ce 01       	movw	r24, r28
      d8:	df 91       	pop	r29
      da:	cf 91       	pop	r28
      dc:	08 95       	ret

000000de <xEventGroupWaitBits>:
      de:	af 92       	push	r10
      e0:	bf 92       	push	r11
      e2:	cf 92       	push	r12
      e4:	df 92       	push	r13
      e6:	ef 92       	push	r14
      e8:	ff 92       	push	r15
      ea:	0f 93       	push	r16
      ec:	1f 93       	push	r17
      ee:	cf 93       	push	r28
      f0:	df 93       	push	r29
      f2:	7c 01       	movw	r14, r24
      f4:	5b 01       	movw	r10, r22
      f6:	c4 2e       	mov	r12, r20
      f8:	d2 2e       	mov	r13, r18
      fa:	0e 94 a2 07 	call	0xf44	; 0xf44 <vTaskSuspendAll>
      fe:	f7 01       	movw	r30, r14
     100:	c0 81       	ld	r28, Z
     102:	d1 81       	ldd	r29, Z+1	; 0x01
     104:	4d 2d       	mov	r20, r13
     106:	b5 01       	movw	r22, r10
     108:	ce 01       	movw	r24, r28
     10a:	0e 94 49 00 	call	0x92	; 0x92 <prvTestWaitCondition>
     10e:	88 23       	and	r24, r24
     110:	69 f0       	breq	.+26     	; 0x12c <xEventGroupWaitBits+0x4e>
     112:	cc 20       	and	r12, r12
     114:	09 f1       	breq	.+66     	; 0x158 <xEventGroupWaitBits+0x7a>
     116:	c5 01       	movw	r24, r10
     118:	80 95       	com	r24
     11a:	90 95       	com	r25
     11c:	8c 23       	and	r24, r28
     11e:	9d 23       	and	r25, r29
     120:	f7 01       	movw	r30, r14
     122:	91 83       	std	Z+1, r25	; 0x01
     124:	80 83       	st	Z, r24
     126:	00 e0       	ldi	r16, 0x00	; 0
     128:	10 e0       	ldi	r17, 0x00	; 0
     12a:	18 c0       	rjmp	.+48     	; 0x15c <xEventGroupWaitBits+0x7e>
     12c:	01 15       	cp	r16, r1
     12e:	11 05       	cpc	r17, r1
     130:	a9 f0       	breq	.+42     	; 0x15c <xEventGroupWaitBits+0x7e>
     132:	c1 10       	cpse	r12, r1
     134:	03 c0       	rjmp	.+6      	; 0x13c <xEventGroupWaitBits+0x5e>
     136:	60 e0       	ldi	r22, 0x00	; 0
     138:	70 e0       	ldi	r23, 0x00	; 0
     13a:	02 c0       	rjmp	.+4      	; 0x140 <xEventGroupWaitBits+0x62>
     13c:	60 e0       	ldi	r22, 0x00	; 0
     13e:	71 e0       	ldi	r23, 0x01	; 1
     140:	d1 10       	cpse	r13, r1
     142:	74 60       	ori	r23, 0x04	; 4
     144:	6a 29       	or	r22, r10
     146:	7b 29       	or	r23, r11
     148:	a8 01       	movw	r20, r16
     14a:	c7 01       	movw	r24, r14
     14c:	02 96       	adiw	r24, 0x02	; 2
     14e:	0e 94 a7 09 	call	0x134e	; 0x134e <vTaskPlaceOnUnorderedEventList>
     152:	c0 e0       	ldi	r28, 0x00	; 0
     154:	d0 e0       	ldi	r29, 0x00	; 0
     156:	02 c0       	rjmp	.+4      	; 0x15c <xEventGroupWaitBits+0x7e>
     158:	00 e0       	ldi	r16, 0x00	; 0
     15a:	10 e0       	ldi	r17, 0x00	; 0
     15c:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskResumeAll>
     160:	01 2b       	or	r16, r17
     162:	19 f1       	breq	.+70     	; 0x1aa <xEventGroupWaitBits+0xcc>
     164:	81 11       	cpse	r24, r1
     166:	02 c0       	rjmp	.+4      	; 0x16c <xEventGroupWaitBits+0x8e>
     168:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     16c:	0e 94 8e 0a 	call	0x151c	; 0x151c <uxTaskResetEventItemValue>
     170:	ec 01       	movw	r28, r24
     172:	91 fd       	sbrc	r25, 1
     174:	19 c0       	rjmp	.+50     	; 0x1a8 <xEventGroupWaitBits+0xca>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	f7 01       	movw	r30, r14
     17e:	c0 81       	ld	r28, Z
     180:	d1 81       	ldd	r29, Z+1	; 0x01
     182:	4d 2d       	mov	r20, r13
     184:	b5 01       	movw	r22, r10
     186:	ce 01       	movw	r24, r28
     188:	0e 94 49 00 	call	0x92	; 0x92 <prvTestWaitCondition>
     18c:	88 23       	and	r24, r24
     18e:	51 f0       	breq	.+20     	; 0x1a4 <xEventGroupWaitBits+0xc6>
     190:	cc 20       	and	r12, r12
     192:	41 f0       	breq	.+16     	; 0x1a4 <xEventGroupWaitBits+0xc6>
     194:	b5 01       	movw	r22, r10
     196:	60 95       	com	r22
     198:	70 95       	com	r23
     19a:	6c 23       	and	r22, r28
     19c:	7d 23       	and	r23, r29
     19e:	f7 01       	movw	r30, r14
     1a0:	71 83       	std	Z+1, r23	; 0x01
     1a2:	60 83       	st	Z, r22
     1a4:	0f 90       	pop	r0
     1a6:	0f be       	out	0x3f, r0	; 63
     1a8:	dd 27       	eor	r29, r29
     1aa:	ce 01       	movw	r24, r28
     1ac:	df 91       	pop	r29
     1ae:	cf 91       	pop	r28
     1b0:	1f 91       	pop	r17
     1b2:	0f 91       	pop	r16
     1b4:	ff 90       	pop	r15
     1b6:	ef 90       	pop	r14
     1b8:	df 90       	pop	r13
     1ba:	cf 90       	pop	r12
     1bc:	bf 90       	pop	r11
     1be:	af 90       	pop	r10
     1c0:	08 95       	ret

000001c2 <xEventGroupClearBits>:
     1c2:	fc 01       	movw	r30, r24
     1c4:	0f b6       	in	r0, 0x3f	; 63
     1c6:	f8 94       	cli
     1c8:	0f 92       	push	r0
     1ca:	80 81       	ld	r24, Z
     1cc:	91 81       	ldd	r25, Z+1	; 0x01
     1ce:	60 95       	com	r22
     1d0:	70 95       	com	r23
     1d2:	68 23       	and	r22, r24
     1d4:	79 23       	and	r23, r25
     1d6:	71 83       	std	Z+1, r23	; 0x01
     1d8:	60 83       	st	Z, r22
     1da:	0f 90       	pop	r0
     1dc:	0f be       	out	0x3f, r0	; 63
     1de:	08 95       	ret

000001e0 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     1e0:	cf 92       	push	r12
     1e2:	df 92       	push	r13
     1e4:	ef 92       	push	r14
     1e6:	ff 92       	push	r15
     1e8:	0f 93       	push	r16
     1ea:	1f 93       	push	r17
     1ec:	cf 93       	push	r28
     1ee:	df 93       	push	r29
     1f0:	7c 01       	movw	r14, r24
     1f2:	8b 01       	movw	r16, r22
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1f4:	ec 01       	movw	r28, r24
     1f6:	25 96       	adiw	r28, 0x05	; 5
	vTaskSuspendAll();
     1f8:	0e 94 a2 07 	call	0xf44	; 0xf44 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     1fc:	d7 01       	movw	r26, r14
     1fe:	17 96       	adiw	r26, 0x07	; 7
     200:	ed 91       	ld	r30, X+
     202:	fc 91       	ld	r31, X
     204:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     206:	8d 91       	ld	r24, X+
     208:	9c 91       	ld	r25, X
     20a:	11 97       	sbiw	r26, 0x01	; 1
     20c:	08 2b       	or	r16, r24
     20e:	19 2b       	or	r17, r25
     210:	0d 93       	st	X+, r16
     212:	1c 93       	st	X, r17
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     214:	00 e0       	ldi	r16, 0x00	; 0
     216:	10 e0       	ldi	r17, 0x00	; 0

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     218:	2d c0       	rjmp	.+90     	; 0x274 <xEventGroupSetBits+0x94>
		{
			pxNext = listGET_NEXT( pxListItem );
     21a:	c2 80       	ldd	r12, Z+2	; 0x02
     21c:	d3 80       	ldd	r13, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     222:	9c 01       	movw	r18, r24
     224:	33 27       	eor	r19, r19

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     226:	92 fd       	sbrc	r25, 2
     228:	09 c0       	rjmp	.+18     	; 0x23c <xEventGroupSetBits+0x5c>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     22a:	d7 01       	movw	r26, r14
     22c:	4d 91       	ld	r20, X+
     22e:	5c 91       	ld	r21, X
     230:	42 23       	and	r20, r18
     232:	53 23       	and	r21, r19
     234:	45 2b       	or	r20, r21
     236:	61 f4       	brne	.+24     	; 0x250 <xEventGroupSetBits+0x70>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     238:	40 e0       	ldi	r20, 0x00	; 0
     23a:	0d c0       	rjmp	.+26     	; 0x256 <xEventGroupSetBits+0x76>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     23c:	d7 01       	movw	r26, r14
     23e:	4d 91       	ld	r20, X+
     240:	5c 91       	ld	r21, X
     242:	42 23       	and	r20, r18
     244:	53 23       	and	r21, r19
     246:	24 17       	cp	r18, r20
     248:	35 07       	cpc	r19, r21
     24a:	21 f0       	breq	.+8      	; 0x254 <xEventGroupSetBits+0x74>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     24c:	40 e0       	ldi	r20, 0x00	; 0
     24e:	03 c0       	rjmp	.+6      	; 0x256 <xEventGroupSetBits+0x76>
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     250:	41 e0       	ldi	r20, 0x01	; 1
     252:	01 c0       	rjmp	.+2      	; 0x256 <xEventGroupSetBits+0x76>
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     254:	41 e0       	ldi	r20, 0x01	; 1
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     256:	44 23       	and	r20, r20
     258:	59 f0       	breq	.+22     	; 0x270 <xEventGroupSetBits+0x90>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     25a:	90 ff       	sbrs	r25, 0
     25c:	02 c0       	rjmp	.+4      	; 0x262 <xEventGroupSetBits+0x82>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     25e:	02 2b       	or	r16, r18
     260:	13 2b       	or	r17, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     262:	d7 01       	movw	r26, r14
     264:	6d 91       	ld	r22, X+
     266:	7c 91       	ld	r23, X
     268:	72 60       	ori	r23, 0x02	; 2
     26a:	cf 01       	movw	r24, r30
     26c:	0e 94 13 0a 	call	0x1426	; 0x1426 <xTaskRemoveFromUnorderedEventList>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     270:	ec 2d       	mov	r30, r12
     272:	fd 2d       	mov	r31, r13

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     274:	ec 17       	cp	r30, r28
     276:	fd 07       	cpc	r31, r29
     278:	81 f6       	brne	.-96     	; 0x21a <xEventGroupSetBits+0x3a>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     27a:	00 95       	com	r16
     27c:	10 95       	com	r17
     27e:	f7 01       	movw	r30, r14
     280:	80 81       	ld	r24, Z
     282:	91 81       	ldd	r25, Z+1	; 0x01
     284:	08 23       	and	r16, r24
     286:	19 23       	and	r17, r25
     288:	11 83       	std	Z+1, r17	; 0x01
     28a:	00 83       	st	Z, r16
	}
	( void ) xTaskResumeAll();
     28c:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     290:	d7 01       	movw	r26, r14
     292:	8d 91       	ld	r24, X+
     294:	9c 91       	ld	r25, X
     296:	df 91       	pop	r29
     298:	cf 91       	pop	r28
     29a:	1f 91       	pop	r17
     29c:	0f 91       	pop	r16
     29e:	ff 90       	pop	r15
     2a0:	ef 90       	pop	r14
     2a2:	df 90       	pop	r13
     2a4:	cf 90       	pop	r12
     2a6:	08 95       	ret

000002a8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     2a8:	cf 93       	push	r28
     2aa:	df 93       	push	r29
     2ac:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     2ae:	0e 94 a2 07 	call	0xf44	; 0xf44 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     2b2:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <__data_end>
     2b6:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <__data_end+0x1>
     2ba:	89 2b       	or	r24, r25
     2bc:	31 f4       	brne	.+12     	; 0x2ca <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     2be:	87 e3       	ldi	r24, 0x37	; 55
     2c0:	91 e0       	ldi	r25, 0x01	; 1
     2c2:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <__data_end+0x1>
     2c6:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     2ca:	20 91 34 01 	lds	r18, 0x0134	; 0x800134 <xNextFreeByte>
     2ce:	30 91 35 01 	lds	r19, 0x0135	; 0x800135 <xNextFreeByte+0x1>
     2d2:	c9 01       	movw	r24, r18
     2d4:	8c 0f       	add	r24, r28
     2d6:	9d 1f       	adc	r25, r29
     2d8:	8b 34       	cpi	r24, 0x4B	; 75
     2da:	44 e0       	ldi	r20, 0x04	; 4
     2dc:	94 07       	cpc	r25, r20
     2de:	70 f4       	brcc	.+28     	; 0x2fc <pvPortMalloc+0x54>
     2e0:	28 17       	cp	r18, r24
     2e2:	39 07       	cpc	r19, r25
     2e4:	70 f4       	brcc	.+28     	; 0x302 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     2e6:	c0 91 32 01 	lds	r28, 0x0132	; 0x800132 <__data_end>
     2ea:	d0 91 33 01 	lds	r29, 0x0133	; 0x800133 <__data_end+0x1>
     2ee:	c2 0f       	add	r28, r18
     2f0:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     2f2:	90 93 35 01 	sts	0x0135, r25	; 0x800135 <xNextFreeByte+0x1>
     2f6:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <xNextFreeByte>
     2fa:	05 c0       	rjmp	.+10     	; 0x306 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     2fc:	c0 e0       	ldi	r28, 0x00	; 0
     2fe:	d0 e0       	ldi	r29, 0x00	; 0
     300:	02 c0       	rjmp	.+4      	; 0x306 <pvPortMalloc+0x5e>
     302:	c0 e0       	ldi	r28, 0x00	; 0
     304:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     306:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     30a:	ce 01       	movw	r24, r28
     30c:	df 91       	pop	r29
     30e:	cf 91       	pop	r28
     310:	08 95       	ret

00000312 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     312:	08 95       	ret

00000314 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     314:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     316:	03 96       	adiw	r24, 0x03	; 3
     318:	92 83       	std	Z+2, r25	; 0x02
     31a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     31c:	2f ef       	ldi	r18, 0xFF	; 255
     31e:	3f ef       	ldi	r19, 0xFF	; 255
     320:	34 83       	std	Z+4, r19	; 0x04
     322:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     324:	96 83       	std	Z+6, r25	; 0x06
     326:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     328:	90 87       	std	Z+8, r25	; 0x08
     32a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     32c:	10 82       	st	Z, r1
     32e:	08 95       	ret

00000330 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     330:	fc 01       	movw	r30, r24
     332:	11 86       	std	Z+9, r1	; 0x09
     334:	10 86       	std	Z+8, r1	; 0x08
     336:	08 95       	ret

00000338 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     338:	cf 93       	push	r28
     33a:	df 93       	push	r29
     33c:	9c 01       	movw	r18, r24
     33e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     340:	dc 01       	movw	r26, r24
     342:	11 96       	adiw	r26, 0x01	; 1
     344:	cd 91       	ld	r28, X+
     346:	dc 91       	ld	r29, X
     348:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     34a:	d3 83       	std	Z+3, r29	; 0x03
     34c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     34e:	8c 81       	ldd	r24, Y+4	; 0x04
     350:	9d 81       	ldd	r25, Y+5	; 0x05
     352:	95 83       	std	Z+5, r25	; 0x05
     354:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     356:	8c 81       	ldd	r24, Y+4	; 0x04
     358:	9d 81       	ldd	r25, Y+5	; 0x05
     35a:	dc 01       	movw	r26, r24
     35c:	13 96       	adiw	r26, 0x03	; 3
     35e:	7c 93       	st	X, r23
     360:	6e 93       	st	-X, r22
     362:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     364:	7d 83       	std	Y+5, r23	; 0x05
     366:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     368:	31 87       	std	Z+9, r19	; 0x09
     36a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     36c:	f9 01       	movw	r30, r18
     36e:	80 81       	ld	r24, Z
     370:	8f 5f       	subi	r24, 0xFF	; 255
     372:	80 83       	st	Z, r24
}
     374:	df 91       	pop	r29
     376:	cf 91       	pop	r28
     378:	08 95       	ret

0000037a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     37a:	cf 93       	push	r28
     37c:	df 93       	push	r29
     37e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     380:	48 81       	ld	r20, Y
     382:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     384:	4f 3f       	cpi	r20, 0xFF	; 255
     386:	2f ef       	ldi	r18, 0xFF	; 255
     388:	52 07       	cpc	r21, r18
     38a:	21 f4       	brne	.+8      	; 0x394 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     38c:	fc 01       	movw	r30, r24
     38e:	a7 81       	ldd	r26, Z+7	; 0x07
     390:	b0 85       	ldd	r27, Z+8	; 0x08
     392:	0d c0       	rjmp	.+26     	; 0x3ae <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     394:	dc 01       	movw	r26, r24
     396:	13 96       	adiw	r26, 0x03	; 3
     398:	01 c0       	rjmp	.+2      	; 0x39c <vListInsert+0x22>
     39a:	df 01       	movw	r26, r30
     39c:	12 96       	adiw	r26, 0x02	; 2
     39e:	ed 91       	ld	r30, X+
     3a0:	fc 91       	ld	r31, X
     3a2:	13 97       	sbiw	r26, 0x03	; 3
     3a4:	20 81       	ld	r18, Z
     3a6:	31 81       	ldd	r19, Z+1	; 0x01
     3a8:	42 17       	cp	r20, r18
     3aa:	53 07       	cpc	r21, r19
     3ac:	b0 f7       	brcc	.-20     	; 0x39a <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     3ae:	12 96       	adiw	r26, 0x02	; 2
     3b0:	ed 91       	ld	r30, X+
     3b2:	fc 91       	ld	r31, X
     3b4:	13 97       	sbiw	r26, 0x03	; 3
     3b6:	fb 83       	std	Y+3, r31	; 0x03
     3b8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     3ba:	d5 83       	std	Z+5, r29	; 0x05
     3bc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     3be:	bd 83       	std	Y+5, r27	; 0x05
     3c0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     3c2:	13 96       	adiw	r26, 0x03	; 3
     3c4:	dc 93       	st	X, r29
     3c6:	ce 93       	st	-X, r28
     3c8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3ca:	99 87       	std	Y+9, r25	; 0x09
     3cc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     3ce:	fc 01       	movw	r30, r24
     3d0:	20 81       	ld	r18, Z
     3d2:	2f 5f       	subi	r18, 0xFF	; 255
     3d4:	20 83       	st	Z, r18
}
     3d6:	df 91       	pop	r29
     3d8:	cf 91       	pop	r28
     3da:	08 95       	ret

000003dc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     3dc:	cf 93       	push	r28
     3de:	df 93       	push	r29
     3e0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     3e2:	a0 85       	ldd	r26, Z+8	; 0x08
     3e4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     3e6:	c2 81       	ldd	r28, Z+2	; 0x02
     3e8:	d3 81       	ldd	r29, Z+3	; 0x03
     3ea:	84 81       	ldd	r24, Z+4	; 0x04
     3ec:	95 81       	ldd	r25, Z+5	; 0x05
     3ee:	9d 83       	std	Y+5, r25	; 0x05
     3f0:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     3f2:	c4 81       	ldd	r28, Z+4	; 0x04
     3f4:	d5 81       	ldd	r29, Z+5	; 0x05
     3f6:	82 81       	ldd	r24, Z+2	; 0x02
     3f8:	93 81       	ldd	r25, Z+3	; 0x03
     3fa:	9b 83       	std	Y+3, r25	; 0x03
     3fc:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     3fe:	11 96       	adiw	r26, 0x01	; 1
     400:	8d 91       	ld	r24, X+
     402:	9c 91       	ld	r25, X
     404:	12 97       	sbiw	r26, 0x02	; 2
     406:	e8 17       	cp	r30, r24
     408:	f9 07       	cpc	r31, r25
     40a:	31 f4       	brne	.+12     	; 0x418 <__EEPROM_REGION_LENGTH__+0x18>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     40c:	84 81       	ldd	r24, Z+4	; 0x04
     40e:	95 81       	ldd	r25, Z+5	; 0x05
     410:	12 96       	adiw	r26, 0x02	; 2
     412:	9c 93       	st	X, r25
     414:	8e 93       	st	-X, r24
     416:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     418:	11 86       	std	Z+9, r1	; 0x09
     41a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     41c:	8c 91       	ld	r24, X
     41e:	81 50       	subi	r24, 0x01	; 1
     420:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     422:	df 91       	pop	r29
     424:	cf 91       	pop	r28
     426:	08 95       	ret

00000428 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     428:	1b bc       	out	0x2b, r1	; 43
     42a:	8c e7       	ldi	r24, 0x7C	; 124
     42c:	8a bd       	out	0x2a, r24	; 42
     42e:	8b e0       	ldi	r24, 0x0B	; 11
     430:	8e bd       	out	0x2e, r24	; 46
     432:	89 b7       	in	r24, 0x39	; 57
     434:	80 61       	ori	r24, 0x10	; 16
     436:	89 bf       	out	0x39, r24	; 57
     438:	08 95       	ret

0000043a <pxPortInitialiseStack>:
     43a:	31 e1       	ldi	r19, 0x11	; 17
     43c:	fc 01       	movw	r30, r24
     43e:	30 83       	st	Z, r19
     440:	31 97       	sbiw	r30, 0x01	; 1
     442:	22 e2       	ldi	r18, 0x22	; 34
     444:	20 83       	st	Z, r18
     446:	31 97       	sbiw	r30, 0x01	; 1
     448:	a3 e3       	ldi	r26, 0x33	; 51
     44a:	a0 83       	st	Z, r26
     44c:	31 97       	sbiw	r30, 0x01	; 1
     44e:	60 83       	st	Z, r22
     450:	31 97       	sbiw	r30, 0x01	; 1
     452:	70 83       	st	Z, r23
     454:	31 97       	sbiw	r30, 0x01	; 1
     456:	10 82       	st	Z, r1
     458:	31 97       	sbiw	r30, 0x01	; 1
     45a:	60 e8       	ldi	r22, 0x80	; 128
     45c:	60 83       	st	Z, r22
     45e:	31 97       	sbiw	r30, 0x01	; 1
     460:	10 82       	st	Z, r1
     462:	31 97       	sbiw	r30, 0x01	; 1
     464:	62 e0       	ldi	r22, 0x02	; 2
     466:	60 83       	st	Z, r22
     468:	31 97       	sbiw	r30, 0x01	; 1
     46a:	63 e0       	ldi	r22, 0x03	; 3
     46c:	60 83       	st	Z, r22
     46e:	31 97       	sbiw	r30, 0x01	; 1
     470:	64 e0       	ldi	r22, 0x04	; 4
     472:	60 83       	st	Z, r22
     474:	31 97       	sbiw	r30, 0x01	; 1
     476:	65 e0       	ldi	r22, 0x05	; 5
     478:	60 83       	st	Z, r22
     47a:	31 97       	sbiw	r30, 0x01	; 1
     47c:	66 e0       	ldi	r22, 0x06	; 6
     47e:	60 83       	st	Z, r22
     480:	31 97       	sbiw	r30, 0x01	; 1
     482:	67 e0       	ldi	r22, 0x07	; 7
     484:	60 83       	st	Z, r22
     486:	31 97       	sbiw	r30, 0x01	; 1
     488:	68 e0       	ldi	r22, 0x08	; 8
     48a:	60 83       	st	Z, r22
     48c:	31 97       	sbiw	r30, 0x01	; 1
     48e:	69 e0       	ldi	r22, 0x09	; 9
     490:	60 83       	st	Z, r22
     492:	31 97       	sbiw	r30, 0x01	; 1
     494:	60 e1       	ldi	r22, 0x10	; 16
     496:	60 83       	st	Z, r22
     498:	31 97       	sbiw	r30, 0x01	; 1
     49a:	30 83       	st	Z, r19
     49c:	31 97       	sbiw	r30, 0x01	; 1
     49e:	32 e1       	ldi	r19, 0x12	; 18
     4a0:	30 83       	st	Z, r19
     4a2:	31 97       	sbiw	r30, 0x01	; 1
     4a4:	33 e1       	ldi	r19, 0x13	; 19
     4a6:	30 83       	st	Z, r19
     4a8:	31 97       	sbiw	r30, 0x01	; 1
     4aa:	34 e1       	ldi	r19, 0x14	; 20
     4ac:	30 83       	st	Z, r19
     4ae:	31 97       	sbiw	r30, 0x01	; 1
     4b0:	35 e1       	ldi	r19, 0x15	; 21
     4b2:	30 83       	st	Z, r19
     4b4:	31 97       	sbiw	r30, 0x01	; 1
     4b6:	36 e1       	ldi	r19, 0x16	; 22
     4b8:	30 83       	st	Z, r19
     4ba:	31 97       	sbiw	r30, 0x01	; 1
     4bc:	37 e1       	ldi	r19, 0x17	; 23
     4be:	30 83       	st	Z, r19
     4c0:	31 97       	sbiw	r30, 0x01	; 1
     4c2:	38 e1       	ldi	r19, 0x18	; 24
     4c4:	30 83       	st	Z, r19
     4c6:	31 97       	sbiw	r30, 0x01	; 1
     4c8:	39 e1       	ldi	r19, 0x19	; 25
     4ca:	30 83       	st	Z, r19
     4cc:	31 97       	sbiw	r30, 0x01	; 1
     4ce:	30 e2       	ldi	r19, 0x20	; 32
     4d0:	30 83       	st	Z, r19
     4d2:	31 97       	sbiw	r30, 0x01	; 1
     4d4:	31 e2       	ldi	r19, 0x21	; 33
     4d6:	30 83       	st	Z, r19
     4d8:	31 97       	sbiw	r30, 0x01	; 1
     4da:	20 83       	st	Z, r18
     4dc:	31 97       	sbiw	r30, 0x01	; 1
     4de:	23 e2       	ldi	r18, 0x23	; 35
     4e0:	20 83       	st	Z, r18
     4e2:	31 97       	sbiw	r30, 0x01	; 1
     4e4:	40 83       	st	Z, r20
     4e6:	31 97       	sbiw	r30, 0x01	; 1
     4e8:	50 83       	st	Z, r21
     4ea:	31 97       	sbiw	r30, 0x01	; 1
     4ec:	26 e2       	ldi	r18, 0x26	; 38
     4ee:	20 83       	st	Z, r18
     4f0:	31 97       	sbiw	r30, 0x01	; 1
     4f2:	27 e2       	ldi	r18, 0x27	; 39
     4f4:	20 83       	st	Z, r18
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	28 e2       	ldi	r18, 0x28	; 40
     4fa:	20 83       	st	Z, r18
     4fc:	31 97       	sbiw	r30, 0x01	; 1
     4fe:	29 e2       	ldi	r18, 0x29	; 41
     500:	20 83       	st	Z, r18
     502:	31 97       	sbiw	r30, 0x01	; 1
     504:	20 e3       	ldi	r18, 0x30	; 48
     506:	20 83       	st	Z, r18
     508:	31 97       	sbiw	r30, 0x01	; 1
     50a:	21 e3       	ldi	r18, 0x31	; 49
     50c:	20 83       	st	Z, r18
     50e:	86 97       	sbiw	r24, 0x26	; 38
     510:	08 95       	ret

00000512 <xPortStartScheduler>:
     512:	0e 94 14 02 	call	0x428	; 0x428 <prvSetupTimerInterrupt>
     516:	a0 91 fd 05 	lds	r26, 0x05FD	; 0x8005fd <pxCurrentTCB>
     51a:	b0 91 fe 05 	lds	r27, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
     51e:	cd 91       	ld	r28, X+
     520:	cd bf       	out	0x3d, r28	; 61
     522:	dd 91       	ld	r29, X+
     524:	de bf       	out	0x3e, r29	; 62
     526:	ff 91       	pop	r31
     528:	ef 91       	pop	r30
     52a:	df 91       	pop	r29
     52c:	cf 91       	pop	r28
     52e:	bf 91       	pop	r27
     530:	af 91       	pop	r26
     532:	9f 91       	pop	r25
     534:	8f 91       	pop	r24
     536:	7f 91       	pop	r23
     538:	6f 91       	pop	r22
     53a:	5f 91       	pop	r21
     53c:	4f 91       	pop	r20
     53e:	3f 91       	pop	r19
     540:	2f 91       	pop	r18
     542:	1f 91       	pop	r17
     544:	0f 91       	pop	r16
     546:	ff 90       	pop	r15
     548:	ef 90       	pop	r14
     54a:	df 90       	pop	r13
     54c:	cf 90       	pop	r12
     54e:	bf 90       	pop	r11
     550:	af 90       	pop	r10
     552:	9f 90       	pop	r9
     554:	8f 90       	pop	r8
     556:	7f 90       	pop	r7
     558:	6f 90       	pop	r6
     55a:	5f 90       	pop	r5
     55c:	4f 90       	pop	r4
     55e:	3f 90       	pop	r3
     560:	2f 90       	pop	r2
     562:	1f 90       	pop	r1
     564:	0f 90       	pop	r0
     566:	0f be       	out	0x3f, r0	; 63
     568:	0f 90       	pop	r0
     56a:	08 95       	ret
     56c:	81 e0       	ldi	r24, 0x01	; 1
     56e:	08 95       	ret

00000570 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     570:	0f 92       	push	r0
     572:	0f b6       	in	r0, 0x3f	; 63
     574:	f8 94       	cli
     576:	0f 92       	push	r0
     578:	1f 92       	push	r1
     57a:	11 24       	eor	r1, r1
     57c:	2f 92       	push	r2
     57e:	3f 92       	push	r3
     580:	4f 92       	push	r4
     582:	5f 92       	push	r5
     584:	6f 92       	push	r6
     586:	7f 92       	push	r7
     588:	8f 92       	push	r8
     58a:	9f 92       	push	r9
     58c:	af 92       	push	r10
     58e:	bf 92       	push	r11
     590:	cf 92       	push	r12
     592:	df 92       	push	r13
     594:	ef 92       	push	r14
     596:	ff 92       	push	r15
     598:	0f 93       	push	r16
     59a:	1f 93       	push	r17
     59c:	2f 93       	push	r18
     59e:	3f 93       	push	r19
     5a0:	4f 93       	push	r20
     5a2:	5f 93       	push	r21
     5a4:	6f 93       	push	r22
     5a6:	7f 93       	push	r23
     5a8:	8f 93       	push	r24
     5aa:	9f 93       	push	r25
     5ac:	af 93       	push	r26
     5ae:	bf 93       	push	r27
     5b0:	cf 93       	push	r28
     5b2:	df 93       	push	r29
     5b4:	ef 93       	push	r30
     5b6:	ff 93       	push	r31
     5b8:	a0 91 fd 05 	lds	r26, 0x05FD	; 0x8005fd <pxCurrentTCB>
     5bc:	b0 91 fe 05 	lds	r27, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
     5c0:	0d b6       	in	r0, 0x3d	; 61
     5c2:	0d 92       	st	X+, r0
     5c4:	0e b6       	in	r0, 0x3e	; 62
     5c6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     5c8:	0e 94 2e 09 	call	0x125c	; 0x125c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     5cc:	a0 91 fd 05 	lds	r26, 0x05FD	; 0x8005fd <pxCurrentTCB>
     5d0:	b0 91 fe 05 	lds	r27, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
     5d4:	cd 91       	ld	r28, X+
     5d6:	cd bf       	out	0x3d, r28	; 61
     5d8:	dd 91       	ld	r29, X+
     5da:	de bf       	out	0x3e, r29	; 62
     5dc:	ff 91       	pop	r31
     5de:	ef 91       	pop	r30
     5e0:	df 91       	pop	r29
     5e2:	cf 91       	pop	r28
     5e4:	bf 91       	pop	r27
     5e6:	af 91       	pop	r26
     5e8:	9f 91       	pop	r25
     5ea:	8f 91       	pop	r24
     5ec:	7f 91       	pop	r23
     5ee:	6f 91       	pop	r22
     5f0:	5f 91       	pop	r21
     5f2:	4f 91       	pop	r20
     5f4:	3f 91       	pop	r19
     5f6:	2f 91       	pop	r18
     5f8:	1f 91       	pop	r17
     5fa:	0f 91       	pop	r16
     5fc:	ff 90       	pop	r15
     5fe:	ef 90       	pop	r14
     600:	df 90       	pop	r13
     602:	cf 90       	pop	r12
     604:	bf 90       	pop	r11
     606:	af 90       	pop	r10
     608:	9f 90       	pop	r9
     60a:	8f 90       	pop	r8
     60c:	7f 90       	pop	r7
     60e:	6f 90       	pop	r6
     610:	5f 90       	pop	r5
     612:	4f 90       	pop	r4
     614:	3f 90       	pop	r3
     616:	2f 90       	pop	r2
     618:	1f 90       	pop	r1
     61a:	0f 90       	pop	r0
     61c:	0f be       	out	0x3f, r0	; 63
     61e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     620:	08 95       	ret

00000622 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     622:	0f 92       	push	r0
     624:	0f b6       	in	r0, 0x3f	; 63
     626:	f8 94       	cli
     628:	0f 92       	push	r0
     62a:	1f 92       	push	r1
     62c:	11 24       	eor	r1, r1
     62e:	2f 92       	push	r2
     630:	3f 92       	push	r3
     632:	4f 92       	push	r4
     634:	5f 92       	push	r5
     636:	6f 92       	push	r6
     638:	7f 92       	push	r7
     63a:	8f 92       	push	r8
     63c:	9f 92       	push	r9
     63e:	af 92       	push	r10
     640:	bf 92       	push	r11
     642:	cf 92       	push	r12
     644:	df 92       	push	r13
     646:	ef 92       	push	r14
     648:	ff 92       	push	r15
     64a:	0f 93       	push	r16
     64c:	1f 93       	push	r17
     64e:	2f 93       	push	r18
     650:	3f 93       	push	r19
     652:	4f 93       	push	r20
     654:	5f 93       	push	r21
     656:	6f 93       	push	r22
     658:	7f 93       	push	r23
     65a:	8f 93       	push	r24
     65c:	9f 93       	push	r25
     65e:	af 93       	push	r26
     660:	bf 93       	push	r27
     662:	cf 93       	push	r28
     664:	df 93       	push	r29
     666:	ef 93       	push	r30
     668:	ff 93       	push	r31
     66a:	a0 91 fd 05 	lds	r26, 0x05FD	; 0x8005fd <pxCurrentTCB>
     66e:	b0 91 fe 05 	lds	r27, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
     672:	0d b6       	in	r0, 0x3d	; 61
     674:	0d 92       	st	X+, r0
     676:	0e b6       	in	r0, 0x3e	; 62
     678:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     67a:	0e 94 a8 07 	call	0xf50	; 0xf50 <xTaskIncrementTick>
     67e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     680:	0e 94 2e 09 	call	0x125c	; 0x125c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     684:	a0 91 fd 05 	lds	r26, 0x05FD	; 0x8005fd <pxCurrentTCB>
     688:	b0 91 fe 05 	lds	r27, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
     68c:	cd 91       	ld	r28, X+
     68e:	cd bf       	out	0x3d, r28	; 61
     690:	dd 91       	ld	r29, X+
     692:	de bf       	out	0x3e, r29	; 62
     694:	ff 91       	pop	r31
     696:	ef 91       	pop	r30
     698:	df 91       	pop	r29
     69a:	cf 91       	pop	r28
     69c:	bf 91       	pop	r27
     69e:	af 91       	pop	r26
     6a0:	9f 91       	pop	r25
     6a2:	8f 91       	pop	r24
     6a4:	7f 91       	pop	r23
     6a6:	6f 91       	pop	r22
     6a8:	5f 91       	pop	r21
     6aa:	4f 91       	pop	r20
     6ac:	3f 91       	pop	r19
     6ae:	2f 91       	pop	r18
     6b0:	1f 91       	pop	r17
     6b2:	0f 91       	pop	r16
     6b4:	ff 90       	pop	r15
     6b6:	ef 90       	pop	r14
     6b8:	df 90       	pop	r13
     6ba:	cf 90       	pop	r12
     6bc:	bf 90       	pop	r11
     6be:	af 90       	pop	r10
     6c0:	9f 90       	pop	r9
     6c2:	8f 90       	pop	r8
     6c4:	7f 90       	pop	r7
     6c6:	6f 90       	pop	r6
     6c8:	5f 90       	pop	r5
     6ca:	4f 90       	pop	r4
     6cc:	3f 90       	pop	r3
     6ce:	2f 90       	pop	r2
     6d0:	1f 90       	pop	r1
     6d2:	0f 90       	pop	r0
     6d4:	0f be       	out	0x3f, r0	; 63
     6d6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6d8:	08 95       	ret

000006da <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     6da:	0e 94 11 03 	call	0x622	; 0x622 <vPortYieldFromTick>
		asm volatile ( "reti" );
     6de:	18 95       	reti

000006e0 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     6e0:	0f b6       	in	r0, 0x3f	; 63
     6e2:	f8 94       	cli
     6e4:	0f 92       	push	r0
     6e6:	fc 01       	movw	r30, r24
     6e8:	82 8d       	ldd	r24, Z+26	; 0x1a
     6ea:	81 11       	cpse	r24, r1
     6ec:	02 c0       	rjmp	.+4      	; 0x6f2 <prvIsQueueEmpty+0x12>
     6ee:	81 e0       	ldi	r24, 0x01	; 1
     6f0:	01 c0       	rjmp	.+2      	; 0x6f4 <prvIsQueueEmpty+0x14>
     6f2:	80 e0       	ldi	r24, 0x00	; 0
     6f4:	0f 90       	pop	r0
     6f6:	0f be       	out	0x3f, r0	; 63
     6f8:	08 95       	ret

000006fa <prvIsQueueFull>:
     6fa:	0f b6       	in	r0, 0x3f	; 63
     6fc:	f8 94       	cli
     6fe:	0f 92       	push	r0
     700:	fc 01       	movw	r30, r24
     702:	22 8d       	ldd	r18, Z+26	; 0x1a
     704:	83 8d       	ldd	r24, Z+27	; 0x1b
     706:	28 13       	cpse	r18, r24
     708:	02 c0       	rjmp	.+4      	; 0x70e <prvIsQueueFull+0x14>
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	01 c0       	rjmp	.+2      	; 0x710 <prvIsQueueFull+0x16>
     70e:	80 e0       	ldi	r24, 0x00	; 0
     710:	0f 90       	pop	r0
     712:	0f be       	out	0x3f, r0	; 63
     714:	08 95       	ret

00000716 <prvCopyDataToQueue>:
     716:	1f 93       	push	r17
     718:	cf 93       	push	r28
     71a:	df 93       	push	r29
     71c:	ec 01       	movw	r28, r24
     71e:	14 2f       	mov	r17, r20
     720:	4c 8d       	ldd	r20, Y+28	; 0x1c
     722:	44 23       	and	r20, r20
     724:	d9 f1       	breq	.+118    	; 0x79c <prvCopyDataToQueue+0x86>
     726:	11 11       	cpse	r17, r1
     728:	16 c0       	rjmp	.+44     	; 0x756 <prvCopyDataToQueue+0x40>
     72a:	50 e0       	ldi	r21, 0x00	; 0
     72c:	8c 81       	ldd	r24, Y+4	; 0x04
     72e:	9d 81       	ldd	r25, Y+5	; 0x05
     730:	0e 94 31 13 	call	0x2662	; 0x2662 <memcpy>
     734:	2c 8d       	ldd	r18, Y+28	; 0x1c
     736:	8c 81       	ldd	r24, Y+4	; 0x04
     738:	9d 81       	ldd	r25, Y+5	; 0x05
     73a:	82 0f       	add	r24, r18
     73c:	91 1d       	adc	r25, r1
     73e:	9d 83       	std	Y+5, r25	; 0x05
     740:	8c 83       	std	Y+4, r24	; 0x04
     742:	2a 81       	ldd	r18, Y+2	; 0x02
     744:	3b 81       	ldd	r19, Y+3	; 0x03
     746:	82 17       	cp	r24, r18
     748:	93 07       	cpc	r25, r19
     74a:	40 f1       	brcs	.+80     	; 0x79c <prvCopyDataToQueue+0x86>
     74c:	88 81       	ld	r24, Y
     74e:	99 81       	ldd	r25, Y+1	; 0x01
     750:	9d 83       	std	Y+5, r25	; 0x05
     752:	8c 83       	std	Y+4, r24	; 0x04
     754:	23 c0       	rjmp	.+70     	; 0x79c <prvCopyDataToQueue+0x86>
     756:	50 e0       	ldi	r21, 0x00	; 0
     758:	8e 81       	ldd	r24, Y+6	; 0x06
     75a:	9f 81       	ldd	r25, Y+7	; 0x07
     75c:	0e 94 31 13 	call	0x2662	; 0x2662 <memcpy>
     760:	8c 8d       	ldd	r24, Y+28	; 0x1c
     762:	90 e0       	ldi	r25, 0x00	; 0
     764:	91 95       	neg	r25
     766:	81 95       	neg	r24
     768:	91 09       	sbc	r25, r1
     76a:	2e 81       	ldd	r18, Y+6	; 0x06
     76c:	3f 81       	ldd	r19, Y+7	; 0x07
     76e:	28 0f       	add	r18, r24
     770:	39 1f       	adc	r19, r25
     772:	3f 83       	std	Y+7, r19	; 0x07
     774:	2e 83       	std	Y+6, r18	; 0x06
     776:	48 81       	ld	r20, Y
     778:	59 81       	ldd	r21, Y+1	; 0x01
     77a:	24 17       	cp	r18, r20
     77c:	35 07       	cpc	r19, r21
     77e:	30 f4       	brcc	.+12     	; 0x78c <prvCopyDataToQueue+0x76>
     780:	2a 81       	ldd	r18, Y+2	; 0x02
     782:	3b 81       	ldd	r19, Y+3	; 0x03
     784:	82 0f       	add	r24, r18
     786:	93 1f       	adc	r25, r19
     788:	9f 83       	std	Y+7, r25	; 0x07
     78a:	8e 83       	std	Y+6, r24	; 0x06
     78c:	12 30       	cpi	r17, 0x02	; 2
     78e:	31 f4       	brne	.+12     	; 0x79c <prvCopyDataToQueue+0x86>
     790:	8a 8d       	ldd	r24, Y+26	; 0x1a
     792:	88 23       	and	r24, r24
     794:	19 f0       	breq	.+6      	; 0x79c <prvCopyDataToQueue+0x86>
     796:	8a 8d       	ldd	r24, Y+26	; 0x1a
     798:	81 50       	subi	r24, 0x01	; 1
     79a:	8a 8f       	std	Y+26, r24	; 0x1a
     79c:	8a 8d       	ldd	r24, Y+26	; 0x1a
     79e:	8f 5f       	subi	r24, 0xFF	; 255
     7a0:	8a 8f       	std	Y+26, r24	; 0x1a
     7a2:	80 e0       	ldi	r24, 0x00	; 0
     7a4:	df 91       	pop	r29
     7a6:	cf 91       	pop	r28
     7a8:	1f 91       	pop	r17
     7aa:	08 95       	ret

000007ac <prvCopyDataFromQueue>:
     7ac:	fc 01       	movw	r30, r24
     7ae:	44 8d       	ldd	r20, Z+28	; 0x1c
     7b0:	44 23       	and	r20, r20
     7b2:	a9 f0       	breq	.+42     	; 0x7de <prvCopyDataFromQueue+0x32>
     7b4:	50 e0       	ldi	r21, 0x00	; 0
     7b6:	26 81       	ldd	r18, Z+6	; 0x06
     7b8:	37 81       	ldd	r19, Z+7	; 0x07
     7ba:	24 0f       	add	r18, r20
     7bc:	35 1f       	adc	r19, r21
     7be:	37 83       	std	Z+7, r19	; 0x07
     7c0:	26 83       	std	Z+6, r18	; 0x06
     7c2:	82 81       	ldd	r24, Z+2	; 0x02
     7c4:	93 81       	ldd	r25, Z+3	; 0x03
     7c6:	28 17       	cp	r18, r24
     7c8:	39 07       	cpc	r19, r25
     7ca:	20 f0       	brcs	.+8      	; 0x7d4 <prvCopyDataFromQueue+0x28>
     7cc:	80 81       	ld	r24, Z
     7ce:	91 81       	ldd	r25, Z+1	; 0x01
     7d0:	97 83       	std	Z+7, r25	; 0x07
     7d2:	86 83       	std	Z+6, r24	; 0x06
     7d4:	cb 01       	movw	r24, r22
     7d6:	66 81       	ldd	r22, Z+6	; 0x06
     7d8:	77 81       	ldd	r23, Z+7	; 0x07
     7da:	0e 94 31 13 	call	0x2662	; 0x2662 <memcpy>
     7de:	08 95       	ret

000007e0 <prvUnlockQueue>:
     7e0:	cf 93       	push	r28
     7e2:	df 93       	push	r29
     7e4:	ec 01       	movw	r28, r24
     7e6:	0f b6       	in	r0, 0x3f	; 63
     7e8:	f8 94       	cli
     7ea:	0f 92       	push	r0
     7ec:	0d c0       	rjmp	.+26     	; 0x808 <__DATA_REGION_LENGTH__+0x8>
     7ee:	89 89       	ldd	r24, Y+17	; 0x11
     7f0:	88 23       	and	r24, r24
     7f2:	69 f0       	breq	.+26     	; 0x80e <__DATA_REGION_LENGTH__+0xe>
     7f4:	ce 01       	movw	r24, r28
     7f6:	41 96       	adiw	r24, 0x11	; 17
     7f8:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     7fc:	81 11       	cpse	r24, r1
     7fe:	0e 94 8a 0a 	call	0x1514	; 0x1514 <vTaskMissedYield>
     802:	8e 8d       	ldd	r24, Y+30	; 0x1e
     804:	81 50       	subi	r24, 0x01	; 1
     806:	8e 8f       	std	Y+30, r24	; 0x1e
     808:	8e 8d       	ldd	r24, Y+30	; 0x1e
     80a:	18 16       	cp	r1, r24
     80c:	84 f3       	brlt	.-32     	; 0x7ee <prvUnlockQueue+0xe>
     80e:	8f ef       	ldi	r24, 0xFF	; 255
     810:	8e 8f       	std	Y+30, r24	; 0x1e
     812:	0f 90       	pop	r0
     814:	0f be       	out	0x3f, r0	; 63
     816:	0f b6       	in	r0, 0x3f	; 63
     818:	f8 94       	cli
     81a:	0f 92       	push	r0
     81c:	0d c0       	rjmp	.+26     	; 0x838 <__DATA_REGION_LENGTH__+0x38>
     81e:	88 85       	ldd	r24, Y+8	; 0x08
     820:	88 23       	and	r24, r24
     822:	69 f0       	breq	.+26     	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
     824:	ce 01       	movw	r24, r28
     826:	08 96       	adiw	r24, 0x08	; 8
     828:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     82c:	81 11       	cpse	r24, r1
     82e:	0e 94 8a 0a 	call	0x1514	; 0x1514 <vTaskMissedYield>
     832:	8d 8d       	ldd	r24, Y+29	; 0x1d
     834:	81 50       	subi	r24, 0x01	; 1
     836:	8d 8f       	std	Y+29, r24	; 0x1d
     838:	8d 8d       	ldd	r24, Y+29	; 0x1d
     83a:	18 16       	cp	r1, r24
     83c:	84 f3       	brlt	.-32     	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
     83e:	8f ef       	ldi	r24, 0xFF	; 255
     840:	8d 8f       	std	Y+29, r24	; 0x1d
     842:	0f 90       	pop	r0
     844:	0f be       	out	0x3f, r0	; 63
     846:	df 91       	pop	r29
     848:	cf 91       	pop	r28
     84a:	08 95       	ret

0000084c <xQueueGenericReset>:
     84c:	cf 93       	push	r28
     84e:	df 93       	push	r29
     850:	ec 01       	movw	r28, r24
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	0f 92       	push	r0
     858:	e8 81       	ld	r30, Y
     85a:	f9 81       	ldd	r31, Y+1	; 0x01
     85c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	2c 8d       	ldd	r18, Y+28	; 0x1c
     862:	30 e0       	ldi	r19, 0x00	; 0
     864:	82 9f       	mul	r24, r18
     866:	a0 01       	movw	r20, r0
     868:	83 9f       	mul	r24, r19
     86a:	50 0d       	add	r21, r0
     86c:	92 9f       	mul	r25, r18
     86e:	50 0d       	add	r21, r0
     870:	11 24       	eor	r1, r1
     872:	4e 0f       	add	r20, r30
     874:	5f 1f       	adc	r21, r31
     876:	5b 83       	std	Y+3, r21	; 0x03
     878:	4a 83       	std	Y+2, r20	; 0x02
     87a:	1a 8e       	std	Y+26, r1	; 0x1a
     87c:	fd 83       	std	Y+5, r31	; 0x05
     87e:	ec 83       	std	Y+4, r30	; 0x04
     880:	01 97       	sbiw	r24, 0x01	; 1
     882:	28 9f       	mul	r18, r24
     884:	a0 01       	movw	r20, r0
     886:	29 9f       	mul	r18, r25
     888:	50 0d       	add	r21, r0
     88a:	38 9f       	mul	r19, r24
     88c:	50 0d       	add	r21, r0
     88e:	11 24       	eor	r1, r1
     890:	cf 01       	movw	r24, r30
     892:	84 0f       	add	r24, r20
     894:	95 1f       	adc	r25, r21
     896:	9f 83       	std	Y+7, r25	; 0x07
     898:	8e 83       	std	Y+6, r24	; 0x06
     89a:	8f ef       	ldi	r24, 0xFF	; 255
     89c:	8d 8f       	std	Y+29, r24	; 0x1d
     89e:	8e 8f       	std	Y+30, r24	; 0x1e
     8a0:	61 11       	cpse	r22, r1
     8a2:	0c c0       	rjmp	.+24     	; 0x8bc <__stack+0x5d>
     8a4:	88 85       	ldd	r24, Y+8	; 0x08
     8a6:	88 23       	and	r24, r24
     8a8:	89 f0       	breq	.+34     	; 0x8cc <__stack+0x6d>
     8aa:	ce 01       	movw	r24, r28
     8ac:	08 96       	adiw	r24, 0x08	; 8
     8ae:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     8b2:	81 30       	cpi	r24, 0x01	; 1
     8b4:	59 f4       	brne	.+22     	; 0x8cc <__stack+0x6d>
     8b6:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     8ba:	08 c0       	rjmp	.+16     	; 0x8cc <__stack+0x6d>
     8bc:	ce 01       	movw	r24, r28
     8be:	08 96       	adiw	r24, 0x08	; 8
     8c0:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     8c4:	ce 01       	movw	r24, r28
     8c6:	41 96       	adiw	r24, 0x11	; 17
     8c8:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     8cc:	0f 90       	pop	r0
     8ce:	0f be       	out	0x3f, r0	; 63
     8d0:	81 e0       	ldi	r24, 0x01	; 1
     8d2:	df 91       	pop	r29
     8d4:	cf 91       	pop	r28
     8d6:	08 95       	ret

000008d8 <xQueueGenericCreate>:
     8d8:	0f 93       	push	r16
     8da:	1f 93       	push	r17
     8dc:	cf 93       	push	r28
     8de:	df 93       	push	r29
     8e0:	88 23       	and	r24, r24
     8e2:	01 f1       	breq	.+64     	; 0x924 <xQueueGenericCreate+0x4c>
     8e4:	06 2f       	mov	r16, r22
     8e6:	18 2f       	mov	r17, r24
     8e8:	8f e1       	ldi	r24, 0x1F	; 31
     8ea:	90 e0       	ldi	r25, 0x00	; 0
     8ec:	0e 94 54 01 	call	0x2a8	; 0x2a8 <pvPortMalloc>
     8f0:	ec 01       	movw	r28, r24
     8f2:	89 2b       	or	r24, r25
     8f4:	c9 f0       	breq	.+50     	; 0x928 <xQueueGenericCreate+0x50>
     8f6:	10 9f       	mul	r17, r16
     8f8:	c0 01       	movw	r24, r0
     8fa:	11 24       	eor	r1, r1
     8fc:	01 96       	adiw	r24, 0x01	; 1
     8fe:	0e 94 54 01 	call	0x2a8	; 0x2a8 <pvPortMalloc>
     902:	99 83       	std	Y+1, r25	; 0x01
     904:	88 83       	st	Y, r24
     906:	89 2b       	or	r24, r25
     908:	39 f0       	breq	.+14     	; 0x918 <xQueueGenericCreate+0x40>
     90a:	1b 8f       	std	Y+27, r17	; 0x1b
     90c:	0c 8f       	std	Y+28, r16	; 0x1c
     90e:	61 e0       	ldi	r22, 0x01	; 1
     910:	ce 01       	movw	r24, r28
     912:	0e 94 26 04 	call	0x84c	; 0x84c <xQueueGenericReset>
     916:	08 c0       	rjmp	.+16     	; 0x928 <xQueueGenericCreate+0x50>
     918:	ce 01       	movw	r24, r28
     91a:	0e 94 89 01 	call	0x312	; 0x312 <vPortFree>
     91e:	c0 e0       	ldi	r28, 0x00	; 0
     920:	d0 e0       	ldi	r29, 0x00	; 0
     922:	02 c0       	rjmp	.+4      	; 0x928 <xQueueGenericCreate+0x50>
     924:	c0 e0       	ldi	r28, 0x00	; 0
     926:	d0 e0       	ldi	r29, 0x00	; 0
     928:	ce 01       	movw	r24, r28
     92a:	df 91       	pop	r29
     92c:	cf 91       	pop	r28
     92e:	1f 91       	pop	r17
     930:	0f 91       	pop	r16
     932:	08 95       	ret

00000934 <xQueueGenericSend>:
     934:	cf 92       	push	r12
     936:	df 92       	push	r13
     938:	ef 92       	push	r14
     93a:	ff 92       	push	r15
     93c:	0f 93       	push	r16
     93e:	1f 93       	push	r17
     940:	cf 93       	push	r28
     942:	df 93       	push	r29
     944:	00 d0       	rcall	.+0      	; 0x946 <xQueueGenericSend+0x12>
     946:	00 d0       	rcall	.+0      	; 0x948 <xQueueGenericSend+0x14>
     948:	1f 92       	push	r1
     94a:	cd b7       	in	r28, 0x3d	; 61
     94c:	de b7       	in	r29, 0x3e	; 62
     94e:	8c 01       	movw	r16, r24
     950:	7b 01       	movw	r14, r22
     952:	5d 83       	std	Y+5, r21	; 0x05
     954:	4c 83       	std	Y+4, r20	; 0x04
     956:	c2 2e       	mov	r12, r18
     958:	d1 2c       	mov	r13, r1
     95a:	0f b6       	in	r0, 0x3f	; 63
     95c:	f8 94       	cli
     95e:	0f 92       	push	r0
     960:	f8 01       	movw	r30, r16
     962:	92 8d       	ldd	r25, Z+26	; 0x1a
     964:	83 8d       	ldd	r24, Z+27	; 0x1b
     966:	98 17       	cp	r25, r24
     968:	18 f0       	brcs	.+6      	; 0x970 <xQueueGenericSend+0x3c>
     96a:	f2 e0       	ldi	r31, 0x02	; 2
     96c:	cf 12       	cpse	r12, r31
     96e:	19 c0       	rjmp	.+50     	; 0x9a2 <xQueueGenericSend+0x6e>
     970:	4c 2d       	mov	r20, r12
     972:	b7 01       	movw	r22, r14
     974:	c8 01       	movw	r24, r16
     976:	0e 94 8b 03 	call	0x716	; 0x716 <prvCopyDataToQueue>
     97a:	f8 01       	movw	r30, r16
     97c:	91 89       	ldd	r25, Z+17	; 0x11
     97e:	99 23       	and	r25, r25
     980:	49 f0       	breq	.+18     	; 0x994 <xQueueGenericSend+0x60>
     982:	c8 01       	movw	r24, r16
     984:	41 96       	adiw	r24, 0x11	; 17
     986:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     98a:	81 30       	cpi	r24, 0x01	; 1
     98c:	31 f4       	brne	.+12     	; 0x99a <xQueueGenericSend+0x66>
     98e:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     992:	03 c0       	rjmp	.+6      	; 0x99a <xQueueGenericSend+0x66>
     994:	81 11       	cpse	r24, r1
     996:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     99a:	0f 90       	pop	r0
     99c:	0f be       	out	0x3f, r0	; 63
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	4d c0       	rjmp	.+154    	; 0xa3c <xQueueGenericSend+0x108>
     9a2:	8c 81       	ldd	r24, Y+4	; 0x04
     9a4:	9d 81       	ldd	r25, Y+5	; 0x05
     9a6:	89 2b       	or	r24, r25
     9a8:	21 f4       	brne	.+8      	; 0x9b2 <xQueueGenericSend+0x7e>
     9aa:	0f 90       	pop	r0
     9ac:	0f be       	out	0x3f, r0	; 63
     9ae:	80 e0       	ldi	r24, 0x00	; 0
     9b0:	45 c0       	rjmp	.+138    	; 0xa3c <xQueueGenericSend+0x108>
     9b2:	d1 10       	cpse	r13, r1
     9b4:	06 c0       	rjmp	.+12     	; 0x9c2 <xQueueGenericSend+0x8e>
     9b6:	ce 01       	movw	r24, r28
     9b8:	01 96       	adiw	r24, 0x01	; 1
     9ba:	0e 94 4d 0a 	call	0x149a	; 0x149a <vTaskSetTimeOutState>
     9be:	dd 24       	eor	r13, r13
     9c0:	d3 94       	inc	r13
     9c2:	0f 90       	pop	r0
     9c4:	0f be       	out	0x3f, r0	; 63
     9c6:	0e 94 a2 07 	call	0xf44	; 0xf44 <vTaskSuspendAll>
     9ca:	0f b6       	in	r0, 0x3f	; 63
     9cc:	f8 94       	cli
     9ce:	0f 92       	push	r0
     9d0:	f8 01       	movw	r30, r16
     9d2:	85 8d       	ldd	r24, Z+29	; 0x1d
     9d4:	8f 3f       	cpi	r24, 0xFF	; 255
     9d6:	09 f4       	brne	.+2      	; 0x9da <xQueueGenericSend+0xa6>
     9d8:	15 8e       	std	Z+29, r1	; 0x1d
     9da:	f8 01       	movw	r30, r16
     9dc:	86 8d       	ldd	r24, Z+30	; 0x1e
     9de:	8f 3f       	cpi	r24, 0xFF	; 255
     9e0:	09 f4       	brne	.+2      	; 0x9e4 <xQueueGenericSend+0xb0>
     9e2:	16 8e       	std	Z+30, r1	; 0x1e
     9e4:	0f 90       	pop	r0
     9e6:	0f be       	out	0x3f, r0	; 63
     9e8:	be 01       	movw	r22, r28
     9ea:	6c 5f       	subi	r22, 0xFC	; 252
     9ec:	7f 4f       	sbci	r23, 0xFF	; 255
     9ee:	ce 01       	movw	r24, r28
     9f0:	01 96       	adiw	r24, 0x01	; 1
     9f2:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <xTaskCheckForTimeOut>
     9f6:	81 11       	cpse	r24, r1
     9f8:	1b c0       	rjmp	.+54     	; 0xa30 <xQueueGenericSend+0xfc>
     9fa:	c8 01       	movw	r24, r16
     9fc:	0e 94 7d 03 	call	0x6fa	; 0x6fa <prvIsQueueFull>
     a00:	88 23       	and	r24, r24
     a02:	81 f0       	breq	.+32     	; 0xa24 <xQueueGenericSend+0xf0>
     a04:	6c 81       	ldd	r22, Y+4	; 0x04
     a06:	7d 81       	ldd	r23, Y+5	; 0x05
     a08:	c8 01       	movw	r24, r16
     a0a:	08 96       	adiw	r24, 0x08	; 8
     a0c:	0e 94 8a 09 	call	0x1314	; 0x1314 <vTaskPlaceOnEventList>
     a10:	c8 01       	movw	r24, r16
     a12:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <prvUnlockQueue>
     a16:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskResumeAll>
     a1a:	81 11       	cpse	r24, r1
     a1c:	9e cf       	rjmp	.-196    	; 0x95a <xQueueGenericSend+0x26>
     a1e:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     a22:	9b cf       	rjmp	.-202    	; 0x95a <xQueueGenericSend+0x26>
     a24:	c8 01       	movw	r24, r16
     a26:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <prvUnlockQueue>
     a2a:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskResumeAll>
     a2e:	95 cf       	rjmp	.-214    	; 0x95a <xQueueGenericSend+0x26>
     a30:	c8 01       	movw	r24, r16
     a32:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <prvUnlockQueue>
     a36:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskResumeAll>
     a3a:	80 e0       	ldi	r24, 0x00	; 0
     a3c:	0f 90       	pop	r0
     a3e:	0f 90       	pop	r0
     a40:	0f 90       	pop	r0
     a42:	0f 90       	pop	r0
     a44:	0f 90       	pop	r0
     a46:	df 91       	pop	r29
     a48:	cf 91       	pop	r28
     a4a:	1f 91       	pop	r17
     a4c:	0f 91       	pop	r16
     a4e:	ff 90       	pop	r15
     a50:	ef 90       	pop	r14
     a52:	df 90       	pop	r13
     a54:	cf 90       	pop	r12
     a56:	08 95       	ret

00000a58 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     a58:	af 92       	push	r10
     a5a:	bf 92       	push	r11
     a5c:	cf 92       	push	r12
     a5e:	df 92       	push	r13
     a60:	ef 92       	push	r14
     a62:	ff 92       	push	r15
     a64:	0f 93       	push	r16
     a66:	1f 93       	push	r17
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
     a6c:	00 d0       	rcall	.+0      	; 0xa6e <xQueueGenericReceive+0x16>
     a6e:	00 d0       	rcall	.+0      	; 0xa70 <xQueueGenericReceive+0x18>
     a70:	1f 92       	push	r1
     a72:	cd b7       	in	r28, 0x3d	; 61
     a74:	de b7       	in	r29, 0x3e	; 62
     a76:	8c 01       	movw	r16, r24
     a78:	6b 01       	movw	r12, r22
     a7a:	5d 83       	std	Y+5, r21	; 0x05
     a7c:	4c 83       	std	Y+4, r20	; 0x04
     a7e:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
     a80:	f1 2c       	mov	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     a82:	0f b6       	in	r0, 0x3f	; 63
     a84:	f8 94       	cli
     a86:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     a88:	f8 01       	movw	r30, r16
     a8a:	82 8d       	ldd	r24, Z+26	; 0x1a
     a8c:	88 23       	and	r24, r24
     a8e:	49 f1       	breq	.+82     	; 0xae2 <xQueueGenericReceive+0x8a>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     a90:	a6 80       	ldd	r10, Z+6	; 0x06
     a92:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     a94:	b6 01       	movw	r22, r12
     a96:	c8 01       	movw	r24, r16
     a98:	0e 94 d6 03 	call	0x7ac	; 0x7ac <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     a9c:	e1 10       	cpse	r14, r1
     a9e:	10 c0       	rjmp	.+32     	; 0xac0 <xQueueGenericReceive+0x68>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     aa0:	f8 01       	movw	r30, r16
     aa2:	82 8d       	ldd	r24, Z+26	; 0x1a
     aa4:	81 50       	subi	r24, 0x01	; 1
     aa6:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     aa8:	80 85       	ldd	r24, Z+8	; 0x08
     aaa:	88 23       	and	r24, r24
     aac:	b1 f0       	breq	.+44     	; 0xada <xQueueGenericReceive+0x82>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     aae:	c8 01       	movw	r24, r16
     ab0:	08 96       	adiw	r24, 0x08	; 8
     ab2:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     ab6:	81 30       	cpi	r24, 0x01	; 1
     ab8:	81 f4       	brne	.+32     	; 0xada <xQueueGenericReceive+0x82>
						{
							queueYIELD_IF_USING_PREEMPTION();
     aba:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     abe:	0d c0       	rjmp	.+26     	; 0xada <xQueueGenericReceive+0x82>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     ac0:	f8 01       	movw	r30, r16
     ac2:	b7 82       	std	Z+7, r11	; 0x07
     ac4:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ac6:	81 89       	ldd	r24, Z+17	; 0x11
     ac8:	88 23       	and	r24, r24
     aca:	39 f0       	breq	.+14     	; 0xada <xQueueGenericReceive+0x82>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     acc:	c8 01       	movw	r24, r16
     ace:	41 96       	adiw	r24, 0x11	; 17
     ad0:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     ad4:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     ad6:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     ada:	0f 90       	pop	r0
     adc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     ade:	81 e0       	ldi	r24, 0x01	; 1
     ae0:	4d c0       	rjmp	.+154    	; 0xb7c <xQueueGenericReceive+0x124>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     ae2:	8c 81       	ldd	r24, Y+4	; 0x04
     ae4:	9d 81       	ldd	r25, Y+5	; 0x05
     ae6:	89 2b       	or	r24, r25
     ae8:	21 f4       	brne	.+8      	; 0xaf2 <xQueueGenericReceive+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     aea:	0f 90       	pop	r0
     aec:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     aee:	80 e0       	ldi	r24, 0x00	; 0
     af0:	45 c0       	rjmp	.+138    	; 0xb7c <xQueueGenericReceive+0x124>
				}
				else if( xEntryTimeSet == pdFALSE )
     af2:	f1 10       	cpse	r15, r1
     af4:	06 c0       	rjmp	.+12     	; 0xb02 <xQueueGenericReceive+0xaa>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     af6:	ce 01       	movw	r24, r28
     af8:	01 96       	adiw	r24, 0x01	; 1
     afa:	0e 94 4d 0a 	call	0x149a	; 0x149a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     afe:	ff 24       	eor	r15, r15
     b00:	f3 94       	inc	r15
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     b02:	0f 90       	pop	r0
     b04:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b06:	0e 94 a2 07 	call	0xf44	; 0xf44 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b0a:	0f b6       	in	r0, 0x3f	; 63
     b0c:	f8 94       	cli
     b0e:	0f 92       	push	r0
     b10:	f8 01       	movw	r30, r16
     b12:	85 8d       	ldd	r24, Z+29	; 0x1d
     b14:	8f 3f       	cpi	r24, 0xFF	; 255
     b16:	09 f4       	brne	.+2      	; 0xb1a <xQueueGenericReceive+0xc2>
     b18:	15 8e       	std	Z+29, r1	; 0x1d
     b1a:	f8 01       	movw	r30, r16
     b1c:	86 8d       	ldd	r24, Z+30	; 0x1e
     b1e:	8f 3f       	cpi	r24, 0xFF	; 255
     b20:	09 f4       	brne	.+2      	; 0xb24 <xQueueGenericReceive+0xcc>
     b22:	16 8e       	std	Z+30, r1	; 0x1e
     b24:	0f 90       	pop	r0
     b26:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b28:	be 01       	movw	r22, r28
     b2a:	6c 5f       	subi	r22, 0xFC	; 252
     b2c:	7f 4f       	sbci	r23, 0xFF	; 255
     b2e:	ce 01       	movw	r24, r28
     b30:	01 96       	adiw	r24, 0x01	; 1
     b32:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <xTaskCheckForTimeOut>
     b36:	81 11       	cpse	r24, r1
     b38:	1b c0       	rjmp	.+54     	; 0xb70 <xQueueGenericReceive+0x118>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b3a:	c8 01       	movw	r24, r16
     b3c:	0e 94 70 03 	call	0x6e0	; 0x6e0 <prvIsQueueEmpty>
     b40:	88 23       	and	r24, r24
     b42:	81 f0       	breq	.+32     	; 0xb64 <xQueueGenericReceive+0x10c>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b44:	6c 81       	ldd	r22, Y+4	; 0x04
     b46:	7d 81       	ldd	r23, Y+5	; 0x05
     b48:	c8 01       	movw	r24, r16
     b4a:	41 96       	adiw	r24, 0x11	; 17
     b4c:	0e 94 8a 09 	call	0x1314	; 0x1314 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     b50:	c8 01       	movw	r24, r16
     b52:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     b56:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskResumeAll>
     b5a:	81 11       	cpse	r24, r1
     b5c:	92 cf       	rjmp	.-220    	; 0xa82 <xQueueGenericReceive+0x2a>
				{
					portYIELD_WITHIN_API();
     b5e:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     b62:	8f cf       	rjmp	.-226    	; 0xa82 <xQueueGenericReceive+0x2a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     b64:	c8 01       	movw	r24, r16
     b66:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b6a:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskResumeAll>
     b6e:	89 cf       	rjmp	.-238    	; 0xa82 <xQueueGenericReceive+0x2a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     b70:	c8 01       	movw	r24, r16
     b72:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b76:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     b7a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     b7c:	0f 90       	pop	r0
     b7e:	0f 90       	pop	r0
     b80:	0f 90       	pop	r0
     b82:	0f 90       	pop	r0
     b84:	0f 90       	pop	r0
     b86:	df 91       	pop	r29
     b88:	cf 91       	pop	r28
     b8a:	1f 91       	pop	r17
     b8c:	0f 91       	pop	r16
     b8e:	ff 90       	pop	r15
     b90:	ef 90       	pop	r14
     b92:	df 90       	pop	r13
     b94:	cf 90       	pop	r12
     b96:	bf 90       	pop	r11
     b98:	af 90       	pop	r10
     b9a:	08 95       	ret

00000b9c <prvResetNextTaskUnblockTime>:
UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
}
     b9c:	e0 91 a1 05 	lds	r30, 0x05A1	; 0x8005a1 <pxDelayedTaskList>
     ba0:	f0 91 a2 05 	lds	r31, 0x05A2	; 0x8005a2 <pxDelayedTaskList+0x1>
     ba4:	80 81       	ld	r24, Z
     ba6:	81 11       	cpse	r24, r1
     ba8:	07 c0       	rjmp	.+14     	; 0xbb8 <prvResetNextTaskUnblockTime+0x1c>
     baa:	8f ef       	ldi	r24, 0xFF	; 255
     bac:	9f ef       	ldi	r25, 0xFF	; 255
     bae:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     bb2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     bb6:	08 95       	ret
     bb8:	e0 91 a1 05 	lds	r30, 0x05A1	; 0x8005a1 <pxDelayedTaskList>
     bbc:	f0 91 a2 05 	lds	r31, 0x05A2	; 0x8005a2 <pxDelayedTaskList+0x1>
     bc0:	05 80       	ldd	r0, Z+5	; 0x05
     bc2:	f6 81       	ldd	r31, Z+6	; 0x06
     bc4:	e0 2d       	mov	r30, r0
     bc6:	06 80       	ldd	r0, Z+6	; 0x06
     bc8:	f7 81       	ldd	r31, Z+7	; 0x07
     bca:	e0 2d       	mov	r30, r0
     bcc:	82 81       	ldd	r24, Z+2	; 0x02
     bce:	93 81       	ldd	r25, Z+3	; 0x03
     bd0:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     bd4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     bd8:	08 95       	ret

00000bda <prvAllocateTCBAndStack>:
     bda:	ef 92       	push	r14
     bdc:	ff 92       	push	r15
     bde:	0f 93       	push	r16
     be0:	1f 93       	push	r17
     be2:	cf 93       	push	r28
     be4:	df 93       	push	r29
     be6:	7c 01       	movw	r14, r24
     be8:	eb 01       	movw	r28, r22
     bea:	8d e2       	ldi	r24, 0x2D	; 45
     bec:	90 e0       	ldi	r25, 0x00	; 0
     bee:	0e 94 54 01 	call	0x2a8	; 0x2a8 <pvPortMalloc>
     bf2:	8c 01       	movw	r16, r24
     bf4:	89 2b       	or	r24, r25
     bf6:	89 f0       	breq	.+34     	; 0xc1a <prvAllocateTCBAndStack+0x40>
     bf8:	20 97       	sbiw	r28, 0x00	; 0
     bfa:	21 f4       	brne	.+8      	; 0xc04 <prvAllocateTCBAndStack+0x2a>
     bfc:	c7 01       	movw	r24, r14
     bfe:	0e 94 54 01 	call	0x2a8	; 0x2a8 <pvPortMalloc>
     c02:	01 c0       	rjmp	.+2      	; 0xc06 <prvAllocateTCBAndStack+0x2c>
     c04:	ce 01       	movw	r24, r28
     c06:	f8 01       	movw	r30, r16
     c08:	90 8f       	std	Z+24, r25	; 0x18
     c0a:	87 8b       	std	Z+23, r24	; 0x17
     c0c:	89 2b       	or	r24, r25
     c0e:	29 f4       	brne	.+10     	; 0xc1a <prvAllocateTCBAndStack+0x40>
     c10:	c8 01       	movw	r24, r16
     c12:	0e 94 89 01 	call	0x312	; 0x312 <vPortFree>
     c16:	00 e0       	ldi	r16, 0x00	; 0
     c18:	10 e0       	ldi	r17, 0x00	; 0
     c1a:	c8 01       	movw	r24, r16
     c1c:	df 91       	pop	r29
     c1e:	cf 91       	pop	r28
     c20:	1f 91       	pop	r17
     c22:	0f 91       	pop	r16
     c24:	ff 90       	pop	r15
     c26:	ef 90       	pop	r14
     c28:	08 95       	ret

00000c2a <prvDeleteTCB>:
     c2a:	cf 93       	push	r28
     c2c:	df 93       	push	r29
     c2e:	ec 01       	movw	r28, r24
     c30:	8f 89       	ldd	r24, Y+23	; 0x17
     c32:	98 8d       	ldd	r25, Y+24	; 0x18
     c34:	0e 94 89 01 	call	0x312	; 0x312 <vPortFree>
     c38:	ce 01       	movw	r24, r28
     c3a:	0e 94 89 01 	call	0x312	; 0x312 <vPortFree>
     c3e:	df 91       	pop	r29
     c40:	cf 91       	pop	r28
     c42:	08 95       	ret

00000c44 <prvInitialiseTCBVariables>:
     c44:	1f 93       	push	r17
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
     c4a:	ec 01       	movw	r28, r24
     c4c:	14 2f       	mov	r17, r20
     c4e:	20 e0       	ldi	r18, 0x00	; 0
     c50:	0f c0       	rjmp	.+30     	; 0xc70 <prvInitialiseTCBVariables+0x2c>
     c52:	82 2f       	mov	r24, r18
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	fb 01       	movw	r30, r22
     c58:	e8 0f       	add	r30, r24
     c5a:	f9 1f       	adc	r31, r25
     c5c:	30 81       	ld	r19, Z
     c5e:	de 01       	movw	r26, r28
     c60:	a8 0f       	add	r26, r24
     c62:	b9 1f       	adc	r27, r25
     c64:	59 96       	adiw	r26, 0x19	; 25
     c66:	3c 93       	st	X, r19
     c68:	80 81       	ld	r24, Z
     c6a:	88 23       	and	r24, r24
     c6c:	19 f0       	breq	.+6      	; 0xc74 <prvInitialiseTCBVariables+0x30>
     c6e:	2f 5f       	subi	r18, 0xFF	; 255
     c70:	24 31       	cpi	r18, 0x14	; 20
     c72:	78 f3       	brcs	.-34     	; 0xc52 <prvInitialiseTCBVariables+0xe>
     c74:	1c a6       	std	Y+44, r1	; 0x2c
     c76:	18 30       	cpi	r17, 0x08	; 8
     c78:	08 f0       	brcs	.+2      	; 0xc7c <prvInitialiseTCBVariables+0x38>
     c7a:	17 e0       	ldi	r17, 0x07	; 7
     c7c:	1e 8b       	std	Y+22, r17	; 0x16
     c7e:	ce 01       	movw	r24, r28
     c80:	02 96       	adiw	r24, 0x02	; 2
     c82:	0e 94 98 01 	call	0x330	; 0x330 <vListInitialiseItem>
     c86:	ce 01       	movw	r24, r28
     c88:	0c 96       	adiw	r24, 0x0c	; 12
     c8a:	0e 94 98 01 	call	0x330	; 0x330 <vListInitialiseItem>
     c8e:	d9 87       	std	Y+9, r29	; 0x09
     c90:	c8 87       	std	Y+8, r28	; 0x08
     c92:	88 e0       	ldi	r24, 0x08	; 8
     c94:	90 e0       	ldi	r25, 0x00	; 0
     c96:	81 1b       	sub	r24, r17
     c98:	91 09       	sbc	r25, r1
     c9a:	9d 87       	std	Y+13, r25	; 0x0d
     c9c:	8c 87       	std	Y+12, r24	; 0x0c
     c9e:	db 8b       	std	Y+19, r29	; 0x13
     ca0:	ca 8b       	std	Y+18, r28	; 0x12
     ca2:	df 91       	pop	r29
     ca4:	cf 91       	pop	r28
     ca6:	1f 91       	pop	r17
     ca8:	08 95       	ret

00000caa <prvInitialiseTaskLists>:
     caa:	cf 93       	push	r28
     cac:	c0 e0       	ldi	r28, 0x00	; 0
     cae:	10 c0       	rjmp	.+32     	; 0xcd0 <prvInitialiseTaskLists+0x26>
     cb0:	8c 2f       	mov	r24, r28
     cb2:	90 e0       	ldi	r25, 0x00	; 0
     cb4:	9c 01       	movw	r18, r24
     cb6:	22 0f       	add	r18, r18
     cb8:	33 1f       	adc	r19, r19
     cba:	22 0f       	add	r18, r18
     cbc:	33 1f       	adc	r19, r19
     cbe:	22 0f       	add	r18, r18
     cc0:	33 1f       	adc	r19, r19
     cc2:	82 0f       	add	r24, r18
     cc4:	93 1f       	adc	r25, r19
     cc6:	8b 54       	subi	r24, 0x4B	; 75
     cc8:	9a 4f       	sbci	r25, 0xFA	; 250
     cca:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     cce:	cf 5f       	subi	r28, 0xFF	; 255
     cd0:	c8 30       	cpi	r28, 0x08	; 8
     cd2:	70 f3       	brcs	.-36     	; 0xcb0 <prvInitialiseTaskLists+0x6>
     cd4:	8c ea       	ldi	r24, 0xAC	; 172
     cd6:	95 e0       	ldi	r25, 0x05	; 5
     cd8:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     cdc:	83 ea       	ldi	r24, 0xA3	; 163
     cde:	95 e0       	ldi	r25, 0x05	; 5
     ce0:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     ce4:	86 e9       	ldi	r24, 0x96	; 150
     ce6:	95 e0       	ldi	r25, 0x05	; 5
     ce8:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     cec:	8d e8       	ldi	r24, 0x8D	; 141
     cee:	95 e0       	ldi	r25, 0x05	; 5
     cf0:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialise>
     cf4:	8c ea       	ldi	r24, 0xAC	; 172
     cf6:	95 e0       	ldi	r25, 0x05	; 5
     cf8:	90 93 a2 05 	sts	0x05A2, r25	; 0x8005a2 <pxDelayedTaskList+0x1>
     cfc:	80 93 a1 05 	sts	0x05A1, r24	; 0x8005a1 <pxDelayedTaskList>
     d00:	83 ea       	ldi	r24, 0xA3	; 163
     d02:	95 e0       	ldi	r25, 0x05	; 5
     d04:	90 93 a0 05 	sts	0x05A0, r25	; 0x8005a0 <pxOverflowDelayedTaskList+0x1>
     d08:	80 93 9f 05 	sts	0x059F, r24	; 0x80059f <pxOverflowDelayedTaskList>
     d0c:	cf 91       	pop	r28
     d0e:	08 95       	ret

00000d10 <prvAddCurrentTaskToDelayedList>:
     d10:	cf 93       	push	r28
     d12:	df 93       	push	r29
     d14:	ec 01       	movw	r28, r24
     d16:	e0 91 fd 05 	lds	r30, 0x05FD	; 0x8005fd <pxCurrentTCB>
     d1a:	f0 91 fe 05 	lds	r31, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
     d1e:	93 83       	std	Z+3, r25	; 0x03
     d20:	82 83       	std	Z+2, r24	; 0x02
     d22:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <xTickCount>
     d26:	90 91 8a 05 	lds	r25, 0x058A	; 0x80058a <xTickCount+0x1>
     d2a:	c8 17       	cp	r28, r24
     d2c:	d9 07       	cpc	r29, r25
     d2e:	68 f4       	brcc	.+26     	; 0xd4a <prvAddCurrentTaskToDelayedList+0x3a>
     d30:	60 91 fd 05 	lds	r22, 0x05FD	; 0x8005fd <pxCurrentTCB>
     d34:	70 91 fe 05 	lds	r23, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
     d38:	80 91 9f 05 	lds	r24, 0x059F	; 0x80059f <pxOverflowDelayedTaskList>
     d3c:	90 91 a0 05 	lds	r25, 0x05A0	; 0x8005a0 <pxOverflowDelayedTaskList+0x1>
     d40:	6e 5f       	subi	r22, 0xFE	; 254
     d42:	7f 4f       	sbci	r23, 0xFF	; 255
     d44:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsert>
     d48:	17 c0       	rjmp	.+46     	; 0xd78 <prvAddCurrentTaskToDelayedList+0x68>
     d4a:	60 91 fd 05 	lds	r22, 0x05FD	; 0x8005fd <pxCurrentTCB>
     d4e:	70 91 fe 05 	lds	r23, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
     d52:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <pxDelayedTaskList>
     d56:	90 91 a2 05 	lds	r25, 0x05A2	; 0x8005a2 <pxDelayedTaskList+0x1>
     d5a:	6e 5f       	subi	r22, 0xFE	; 254
     d5c:	7f 4f       	sbci	r23, 0xFF	; 255
     d5e:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsert>
     d62:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     d66:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     d6a:	c8 17       	cp	r28, r24
     d6c:	d9 07       	cpc	r29, r25
     d6e:	20 f4       	brcc	.+8      	; 0xd78 <prvAddCurrentTaskToDelayedList+0x68>
     d70:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     d74:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__DATA_REGION_ORIGIN__>
     d78:	df 91       	pop	r29
     d7a:	cf 91       	pop	r28
     d7c:	08 95       	ret

00000d7e <xTaskGenericCreate>:
     d7e:	2f 92       	push	r2
     d80:	3f 92       	push	r3
     d82:	4f 92       	push	r4
     d84:	5f 92       	push	r5
     d86:	7f 92       	push	r7
     d88:	8f 92       	push	r8
     d8a:	9f 92       	push	r9
     d8c:	af 92       	push	r10
     d8e:	bf 92       	push	r11
     d90:	cf 92       	push	r12
     d92:	df 92       	push	r13
     d94:	ef 92       	push	r14
     d96:	ff 92       	push	r15
     d98:	0f 93       	push	r16
     d9a:	1f 93       	push	r17
     d9c:	cf 93       	push	r28
     d9e:	df 93       	push	r29
     da0:	00 d0       	rcall	.+0      	; 0xda2 <xTaskGenericCreate+0x24>
     da2:	00 d0       	rcall	.+0      	; 0xda4 <xTaskGenericCreate+0x26>
     da4:	cd b7       	in	r28, 0x3d	; 61
     da6:	de b7       	in	r29, 0x3e	; 62
     da8:	9a 83       	std	Y+2, r25	; 0x02
     daa:	89 83       	std	Y+1, r24	; 0x01
     dac:	4b 01       	movw	r8, r22
     dae:	5c 83       	std	Y+4, r21	; 0x04
     db0:	4b 83       	std	Y+3, r20	; 0x03
     db2:	19 01       	movw	r2, r18
     db4:	70 2e       	mov	r7, r16
     db6:	b6 01       	movw	r22, r12
     db8:	25 01       	movw	r4, r10
     dba:	ca 01       	movw	r24, r20
     dbc:	0e 94 ed 05 	call	0xbda	; 0xbda <prvAllocateTCBAndStack>
     dc0:	5c 01       	movw	r10, r24
     dc2:	00 97       	sbiw	r24, 0x00	; 0
     dc4:	09 f4       	brne	.+2      	; 0xdc8 <xTaskGenericCreate+0x4a>
     dc6:	6a c0       	rjmp	.+212    	; 0xe9c <xTaskGenericCreate+0x11e>
     dc8:	fc 01       	movw	r30, r24
     dca:	c7 88       	ldd	r12, Z+23	; 0x17
     dcc:	d0 8c       	ldd	r13, Z+24	; 0x18
     dce:	8b 81       	ldd	r24, Y+3	; 0x03
     dd0:	9c 81       	ldd	r25, Y+4	; 0x04
     dd2:	01 97       	sbiw	r24, 0x01	; 1
     dd4:	c8 0e       	add	r12, r24
     dd6:	d9 1e       	adc	r13, r25
     dd8:	0b 81       	ldd	r16, Y+3	; 0x03
     dda:	1c 81       	ldd	r17, Y+4	; 0x04
     ddc:	92 01       	movw	r18, r4
     dde:	47 2d       	mov	r20, r7
     de0:	b4 01       	movw	r22, r8
     de2:	c5 01       	movw	r24, r10
     de4:	0e 94 22 06 	call	0xc44	; 0xc44 <prvInitialiseTCBVariables>
     de8:	a1 01       	movw	r20, r2
     dea:	69 81       	ldd	r22, Y+1	; 0x01
     dec:	7a 81       	ldd	r23, Y+2	; 0x02
     dee:	c6 01       	movw	r24, r12
     df0:	0e 94 1d 02 	call	0x43a	; 0x43a <pxPortInitialiseStack>
     df4:	f5 01       	movw	r30, r10
     df6:	91 83       	std	Z+1, r25	; 0x01
     df8:	80 83       	st	Z, r24
     dfa:	e1 14       	cp	r14, r1
     dfc:	f1 04       	cpc	r15, r1
     dfe:	19 f0       	breq	.+6      	; 0xe06 <xTaskGenericCreate+0x88>
     e00:	f7 01       	movw	r30, r14
     e02:	b1 82       	std	Z+1, r11	; 0x01
     e04:	a0 82       	st	Z, r10
     e06:	0f b6       	in	r0, 0x3f	; 63
     e08:	f8 94       	cli
     e0a:	0f 92       	push	r0
     e0c:	80 91 8b 05 	lds	r24, 0x058B	; 0x80058b <uxCurrentNumberOfTasks>
     e10:	8f 5f       	subi	r24, 0xFF	; 255
     e12:	80 93 8b 05 	sts	0x058B, r24	; 0x80058b <uxCurrentNumberOfTasks>
     e16:	80 91 fd 05 	lds	r24, 0x05FD	; 0x8005fd <pxCurrentTCB>
     e1a:	90 91 fe 05 	lds	r25, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
     e1e:	89 2b       	or	r24, r25
     e20:	59 f4       	brne	.+22     	; 0xe38 <xTaskGenericCreate+0xba>
     e22:	b0 92 fe 05 	sts	0x05FE, r11	; 0x8005fe <pxCurrentTCB+0x1>
     e26:	a0 92 fd 05 	sts	0x05FD, r10	; 0x8005fd <pxCurrentTCB>
     e2a:	80 91 8b 05 	lds	r24, 0x058B	; 0x80058b <uxCurrentNumberOfTasks>
     e2e:	81 30       	cpi	r24, 0x01	; 1
     e30:	91 f4       	brne	.+36     	; 0xe56 <xTaskGenericCreate+0xd8>
     e32:	0e 94 55 06 	call	0xcaa	; 0xcaa <prvInitialiseTaskLists>
     e36:	0f c0       	rjmp	.+30     	; 0xe56 <xTaskGenericCreate+0xd8>
     e38:	80 91 87 05 	lds	r24, 0x0587	; 0x800587 <xSchedulerRunning>
     e3c:	81 11       	cpse	r24, r1
     e3e:	0b c0       	rjmp	.+22     	; 0xe56 <xTaskGenericCreate+0xd8>
     e40:	e0 91 fd 05 	lds	r30, 0x05FD	; 0x8005fd <pxCurrentTCB>
     e44:	f0 91 fe 05 	lds	r31, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
     e48:	86 89       	ldd	r24, Z+22	; 0x16
     e4a:	78 16       	cp	r7, r24
     e4c:	20 f0       	brcs	.+8      	; 0xe56 <xTaskGenericCreate+0xd8>
     e4e:	b0 92 fe 05 	sts	0x05FE, r11	; 0x8005fe <pxCurrentTCB+0x1>
     e52:	a0 92 fd 05 	sts	0x05FD, r10	; 0x8005fd <pxCurrentTCB>
     e56:	80 91 83 05 	lds	r24, 0x0583	; 0x800583 <uxTaskNumber>
     e5a:	8f 5f       	subi	r24, 0xFF	; 255
     e5c:	80 93 83 05 	sts	0x0583, r24	; 0x800583 <uxTaskNumber>
     e60:	f5 01       	movw	r30, r10
     e62:	86 89       	ldd	r24, Z+22	; 0x16
     e64:	90 91 88 05 	lds	r25, 0x0588	; 0x800588 <uxTopReadyPriority>
     e68:	98 17       	cp	r25, r24
     e6a:	10 f4       	brcc	.+4      	; 0xe70 <xTaskGenericCreate+0xf2>
     e6c:	80 93 88 05 	sts	0x0588, r24	; 0x800588 <uxTopReadyPriority>
     e70:	90 e0       	ldi	r25, 0x00	; 0
     e72:	b5 01       	movw	r22, r10
     e74:	6e 5f       	subi	r22, 0xFE	; 254
     e76:	7f 4f       	sbci	r23, 0xFF	; 255
     e78:	9c 01       	movw	r18, r24
     e7a:	22 0f       	add	r18, r18
     e7c:	33 1f       	adc	r19, r19
     e7e:	22 0f       	add	r18, r18
     e80:	33 1f       	adc	r19, r19
     e82:	22 0f       	add	r18, r18
     e84:	33 1f       	adc	r19, r19
     e86:	82 0f       	add	r24, r18
     e88:	93 1f       	adc	r25, r19
     e8a:	8b 54       	subi	r24, 0x4B	; 75
     e8c:	9a 4f       	sbci	r25, 0xFA	; 250
     e8e:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>
     e92:	0f 90       	pop	r0
     e94:	0f be       	out	0x3f, r0	; 63
     e96:	f1 e0       	ldi	r31, 0x01	; 1
     e98:	f9 83       	std	Y+1, r31	; 0x01
     e9a:	02 c0       	rjmp	.+4      	; 0xea0 <xTaskGenericCreate+0x122>
     e9c:	8f ef       	ldi	r24, 0xFF	; 255
     e9e:	89 83       	std	Y+1, r24	; 0x01
     ea0:	e9 81       	ldd	r30, Y+1	; 0x01
     ea2:	e1 30       	cpi	r30, 0x01	; 1
     ea4:	69 f4       	brne	.+26     	; 0xec0 <xTaskGenericCreate+0x142>
     ea6:	80 91 87 05 	lds	r24, 0x0587	; 0x800587 <xSchedulerRunning>
     eaa:	88 23       	and	r24, r24
     eac:	49 f0       	breq	.+18     	; 0xec0 <xTaskGenericCreate+0x142>
     eae:	e0 91 fd 05 	lds	r30, 0x05FD	; 0x8005fd <pxCurrentTCB>
     eb2:	f0 91 fe 05 	lds	r31, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
     eb6:	86 89       	ldd	r24, Z+22	; 0x16
     eb8:	87 15       	cp	r24, r7
     eba:	10 f4       	brcc	.+4      	; 0xec0 <xTaskGenericCreate+0x142>
     ebc:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
     ec0:	89 81       	ldd	r24, Y+1	; 0x01
     ec2:	0f 90       	pop	r0
     ec4:	0f 90       	pop	r0
     ec6:	0f 90       	pop	r0
     ec8:	0f 90       	pop	r0
     eca:	df 91       	pop	r29
     ecc:	cf 91       	pop	r28
     ece:	1f 91       	pop	r17
     ed0:	0f 91       	pop	r16
     ed2:	ff 90       	pop	r15
     ed4:	ef 90       	pop	r14
     ed6:	df 90       	pop	r13
     ed8:	cf 90       	pop	r12
     eda:	bf 90       	pop	r11
     edc:	af 90       	pop	r10
     ede:	9f 90       	pop	r9
     ee0:	8f 90       	pop	r8
     ee2:	7f 90       	pop	r7
     ee4:	5f 90       	pop	r5
     ee6:	4f 90       	pop	r4
     ee8:	3f 90       	pop	r3
     eea:	2f 90       	pop	r2
     eec:	08 95       	ret

00000eee <vTaskStartScheduler>:
     eee:	af 92       	push	r10
     ef0:	bf 92       	push	r11
     ef2:	cf 92       	push	r12
     ef4:	df 92       	push	r13
     ef6:	ef 92       	push	r14
     ef8:	ff 92       	push	r15
     efa:	0f 93       	push	r16
     efc:	a1 2c       	mov	r10, r1
     efe:	b1 2c       	mov	r11, r1
     f00:	c1 2c       	mov	r12, r1
     f02:	d1 2c       	mov	r13, r1
     f04:	e1 2c       	mov	r14, r1
     f06:	f1 2c       	mov	r15, r1
     f08:	00 e0       	ldi	r16, 0x00	; 0
     f0a:	20 e0       	ldi	r18, 0x00	; 0
     f0c:	30 e0       	ldi	r19, 0x00	; 0
     f0e:	45 e5       	ldi	r20, 0x55	; 85
     f10:	50 e0       	ldi	r21, 0x00	; 0
     f12:	62 e6       	ldi	r22, 0x62	; 98
     f14:	70 e0       	ldi	r23, 0x00	; 0
     f16:	85 e2       	ldi	r24, 0x25	; 37
     f18:	99 e0       	ldi	r25, 0x09	; 9
     f1a:	0e 94 bf 06 	call	0xd7e	; 0xd7e <xTaskGenericCreate>
     f1e:	81 30       	cpi	r24, 0x01	; 1
     f20:	49 f4       	brne	.+18     	; 0xf34 <vTaskStartScheduler+0x46>
     f22:	f8 94       	cli
     f24:	80 93 87 05 	sts	0x0587, r24	; 0x800587 <xSchedulerRunning>
     f28:	10 92 8a 05 	sts	0x058A, r1	; 0x80058a <xTickCount+0x1>
     f2c:	10 92 89 05 	sts	0x0589, r1	; 0x800589 <xTickCount>
     f30:	0e 94 89 02 	call	0x512	; 0x512 <xPortStartScheduler>
     f34:	0f 91       	pop	r16
     f36:	ff 90       	pop	r15
     f38:	ef 90       	pop	r14
     f3a:	df 90       	pop	r13
     f3c:	cf 90       	pop	r12
     f3e:	bf 90       	pop	r11
     f40:	af 90       	pop	r10
     f42:	08 95       	ret

00000f44 <vTaskSuspendAll>:
     f44:	80 91 82 05 	lds	r24, 0x0582	; 0x800582 <uxSchedulerSuspended>
     f48:	8f 5f       	subi	r24, 0xFF	; 255
     f4a:	80 93 82 05 	sts	0x0582, r24	; 0x800582 <uxSchedulerSuspended>
     f4e:	08 95       	ret

00000f50 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     f50:	df 92       	push	r13
     f52:	ef 92       	push	r14
     f54:	ff 92       	push	r15
     f56:	0f 93       	push	r16
     f58:	1f 93       	push	r17
     f5a:	cf 93       	push	r28
     f5c:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     f5e:	80 91 82 05 	lds	r24, 0x0582	; 0x800582 <uxSchedulerSuspended>
     f62:	81 11       	cpse	r24, r1
     f64:	99 c0       	rjmp	.+306    	; 0x1098 <xTaskIncrementTick+0x148>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     f66:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <xTickCount>
     f6a:	90 91 8a 05 	lds	r25, 0x058A	; 0x80058a <xTickCount+0x1>
     f6e:	01 96       	adiw	r24, 0x01	; 1
     f70:	90 93 8a 05 	sts	0x058A, r25	; 0x80058a <xTickCount+0x1>
     f74:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <xTickCount>

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     f78:	e0 90 89 05 	lds	r14, 0x0589	; 0x800589 <xTickCount>
     f7c:	f0 90 8a 05 	lds	r15, 0x058A	; 0x80058a <xTickCount+0x1>

			if( xConstTickCount == ( TickType_t ) 0U )
     f80:	e1 14       	cp	r14, r1
     f82:	f1 04       	cpc	r15, r1
     f84:	b9 f4       	brne	.+46     	; 0xfb4 <xTaskIncrementTick+0x64>
			{
				taskSWITCH_DELAYED_LISTS();
     f86:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <pxDelayedTaskList>
     f8a:	90 91 a2 05 	lds	r25, 0x05A2	; 0x8005a2 <pxDelayedTaskList+0x1>
     f8e:	20 91 9f 05 	lds	r18, 0x059F	; 0x80059f <pxOverflowDelayedTaskList>
     f92:	30 91 a0 05 	lds	r19, 0x05A0	; 0x8005a0 <pxOverflowDelayedTaskList+0x1>
     f96:	30 93 a2 05 	sts	0x05A2, r19	; 0x8005a2 <pxDelayedTaskList+0x1>
     f9a:	20 93 a1 05 	sts	0x05A1, r18	; 0x8005a1 <pxDelayedTaskList>
     f9e:	90 93 a0 05 	sts	0x05A0, r25	; 0x8005a0 <pxOverflowDelayedTaskList+0x1>
     fa2:	80 93 9f 05 	sts	0x059F, r24	; 0x80059f <pxOverflowDelayedTaskList>
     fa6:	80 91 84 05 	lds	r24, 0x0584	; 0x800584 <xNumOfOverflows>
     faa:	8f 5f       	subi	r24, 0xFF	; 255
     fac:	80 93 84 05 	sts	0x0584, r24	; 0x800584 <xNumOfOverflows>
     fb0:	0e 94 ce 05 	call	0xb9c	; 0xb9c <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     fb4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     fb8:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     fbc:	e8 16       	cp	r14, r24
     fbe:	f9 06       	cpc	r15, r25
     fc0:	28 f4       	brcc	.+10     	; 0xfcc <xTaskIncrementTick+0x7c>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     fc2:	d1 2c       	mov	r13, r1
     fc4:	53 c0       	rjmp	.+166    	; 0x106c <xTaskIncrementTick+0x11c>
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
     fc6:	dd 24       	eor	r13, r13
     fc8:	d3 94       	inc	r13
     fca:	01 c0       	rjmp	.+2      	; 0xfce <xTaskIncrementTick+0x7e>
     fcc:	d1 2c       	mov	r13, r1
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     fce:	e0 91 a1 05 	lds	r30, 0x05A1	; 0x8005a1 <pxDelayedTaskList>
     fd2:	f0 91 a2 05 	lds	r31, 0x05A2	; 0x8005a2 <pxDelayedTaskList+0x1>
     fd6:	80 81       	ld	r24, Z
     fd8:	81 11       	cpse	r24, r1
     fda:	07 c0       	rjmp	.+14     	; 0xfea <xTaskIncrementTick+0x9a>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     fdc:	8f ef       	ldi	r24, 0xFF	; 255
     fde:	9f ef       	ldi	r25, 0xFF	; 255
     fe0:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     fe4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
						break;
     fe8:	41 c0       	rjmp	.+130    	; 0x106c <xTaskIncrementTick+0x11c>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     fea:	e0 91 a1 05 	lds	r30, 0x05A1	; 0x8005a1 <pxDelayedTaskList>
     fee:	f0 91 a2 05 	lds	r31, 0x05A2	; 0x8005a2 <pxDelayedTaskList+0x1>
     ff2:	05 80       	ldd	r0, Z+5	; 0x05
     ff4:	f6 81       	ldd	r31, Z+6	; 0x06
     ff6:	e0 2d       	mov	r30, r0
     ff8:	c6 81       	ldd	r28, Z+6	; 0x06
     ffa:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     ffc:	8a 81       	ldd	r24, Y+2	; 0x02
     ffe:	9b 81       	ldd	r25, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
    1000:	e8 16       	cp	r14, r24
    1002:	f9 06       	cpc	r15, r25
    1004:	28 f4       	brcc	.+10     	; 0x1010 <xTaskIncrementTick+0xc0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    1006:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    100a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
							break;
    100e:	2e c0       	rjmp	.+92     	; 0x106c <xTaskIncrementTick+0x11c>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1010:	8e 01       	movw	r16, r28
    1012:	0e 5f       	subi	r16, 0xFE	; 254
    1014:	1f 4f       	sbci	r17, 0xFF	; 255
    1016:	c8 01       	movw	r24, r16
    1018:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    101c:	8c 89       	ldd	r24, Y+20	; 0x14
    101e:	9d 89       	ldd	r25, Y+21	; 0x15
    1020:	89 2b       	or	r24, r25
    1022:	21 f0       	breq	.+8      	; 0x102c <xTaskIncrementTick+0xdc>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1024:	ce 01       	movw	r24, r28
    1026:	0c 96       	adiw	r24, 0x0c	; 12
    1028:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    102c:	8e 89       	ldd	r24, Y+22	; 0x16
    102e:	90 91 88 05 	lds	r25, 0x0588	; 0x800588 <uxTopReadyPriority>
    1032:	98 17       	cp	r25, r24
    1034:	10 f4       	brcc	.+4      	; 0x103a <xTaskIncrementTick+0xea>
    1036:	80 93 88 05 	sts	0x0588, r24	; 0x800588 <uxTopReadyPriority>
    103a:	90 e0       	ldi	r25, 0x00	; 0
    103c:	9c 01       	movw	r18, r24
    103e:	22 0f       	add	r18, r18
    1040:	33 1f       	adc	r19, r19
    1042:	22 0f       	add	r18, r18
    1044:	33 1f       	adc	r19, r19
    1046:	22 0f       	add	r18, r18
    1048:	33 1f       	adc	r19, r19
    104a:	82 0f       	add	r24, r18
    104c:	93 1f       	adc	r25, r19
    104e:	b8 01       	movw	r22, r16
    1050:	8b 54       	subi	r24, 0x4B	; 75
    1052:	9a 4f       	sbci	r25, 0xFA	; 250
    1054:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1058:	9e 89       	ldd	r25, Y+22	; 0x16
    105a:	e0 91 fd 05 	lds	r30, 0x05FD	; 0x8005fd <pxCurrentTCB>
    105e:	f0 91 fe 05 	lds	r31, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    1062:	86 89       	ldd	r24, Z+22	; 0x16
    1064:	98 17       	cp	r25, r24
    1066:	08 f0       	brcs	.+2      	; 0x106a <xTaskIncrementTick+0x11a>
    1068:	ae cf       	rjmp	.-164    	; 0xfc6 <xTaskIncrementTick+0x76>
    106a:	b1 cf       	rjmp	.-158    	; 0xfce <xTaskIncrementTick+0x7e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    106c:	e0 91 fd 05 	lds	r30, 0x05FD	; 0x8005fd <pxCurrentTCB>
    1070:	f0 91 fe 05 	lds	r31, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    1074:	86 89       	ldd	r24, Z+22	; 0x16
    1076:	90 e0       	ldi	r25, 0x00	; 0
    1078:	fc 01       	movw	r30, r24
    107a:	ee 0f       	add	r30, r30
    107c:	ff 1f       	adc	r31, r31
    107e:	ee 0f       	add	r30, r30
    1080:	ff 1f       	adc	r31, r31
    1082:	ee 0f       	add	r30, r30
    1084:	ff 1f       	adc	r31, r31
    1086:	8e 0f       	add	r24, r30
    1088:	9f 1f       	adc	r25, r31
    108a:	fc 01       	movw	r30, r24
    108c:	eb 54       	subi	r30, 0x4B	; 75
    108e:	fa 4f       	sbci	r31, 0xFA	; 250
    1090:	80 81       	ld	r24, Z
    1092:	82 30       	cpi	r24, 0x02	; 2
    1094:	40 f4       	brcc	.+16     	; 0x10a6 <xTaskIncrementTick+0x156>
    1096:	09 c0       	rjmp	.+18     	; 0x10aa <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1098:	80 91 86 05 	lds	r24, 0x0586	; 0x800586 <uxPendedTicks>
    109c:	8f 5f       	subi	r24, 0xFF	; 255
    109e:	80 93 86 05 	sts	0x0586, r24	; 0x800586 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    10a2:	d1 2c       	mov	r13, r1
    10a4:	02 c0       	rjmp	.+4      	; 0x10aa <xTaskIncrementTick+0x15a>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    10a6:	dd 24       	eor	r13, r13
    10a8:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    10aa:	80 91 85 05 	lds	r24, 0x0585	; 0x800585 <xYieldPending>
    10ae:	88 23       	and	r24, r24
    10b0:	11 f0       	breq	.+4      	; 0x10b6 <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
    10b2:	dd 24       	eor	r13, r13
    10b4:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    10b6:	8d 2d       	mov	r24, r13
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	1f 91       	pop	r17
    10be:	0f 91       	pop	r16
    10c0:	ff 90       	pop	r15
    10c2:	ef 90       	pop	r14
    10c4:	df 90       	pop	r13
    10c6:	08 95       	ret

000010c8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    10c8:	0f 93       	push	r16
    10ca:	1f 93       	push	r17
    10cc:	cf 93       	push	r28
    10ce:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    10d0:	0f b6       	in	r0, 0x3f	; 63
    10d2:	f8 94       	cli
    10d4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    10d6:	80 91 82 05 	lds	r24, 0x0582	; 0x800582 <uxSchedulerSuspended>
    10da:	81 50       	subi	r24, 0x01	; 1
    10dc:	80 93 82 05 	sts	0x0582, r24	; 0x800582 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    10e0:	80 91 82 05 	lds	r24, 0x0582	; 0x800582 <uxSchedulerSuspended>
    10e4:	81 11       	cpse	r24, r1
    10e6:	57 c0       	rjmp	.+174    	; 0x1196 <xTaskResumeAll+0xce>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    10e8:	80 91 8b 05 	lds	r24, 0x058B	; 0x80058b <uxCurrentNumberOfTasks>
    10ec:	81 11       	cpse	r24, r1
    10ee:	32 c0       	rjmp	.+100    	; 0x1154 <xTaskResumeAll+0x8c>
    10f0:	55 c0       	rjmp	.+170    	; 0x119c <xTaskResumeAll+0xd4>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    10f2:	e0 91 9b 05 	lds	r30, 0x059B	; 0x80059b <xPendingReadyList+0x5>
    10f6:	f0 91 9c 05 	lds	r31, 0x059C	; 0x80059c <xPendingReadyList+0x6>
    10fa:	c6 81       	ldd	r28, Z+6	; 0x06
    10fc:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    10fe:	ce 01       	movw	r24, r28
    1100:	0c 96       	adiw	r24, 0x0c	; 12
    1102:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1106:	8e 01       	movw	r16, r28
    1108:	0e 5f       	subi	r16, 0xFE	; 254
    110a:	1f 4f       	sbci	r17, 0xFF	; 255
    110c:	c8 01       	movw	r24, r16
    110e:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1112:	8e 89       	ldd	r24, Y+22	; 0x16
    1114:	90 91 88 05 	lds	r25, 0x0588	; 0x800588 <uxTopReadyPriority>
    1118:	98 17       	cp	r25, r24
    111a:	10 f4       	brcc	.+4      	; 0x1120 <xTaskResumeAll+0x58>
    111c:	80 93 88 05 	sts	0x0588, r24	; 0x800588 <uxTopReadyPriority>
    1120:	90 e0       	ldi	r25, 0x00	; 0
    1122:	9c 01       	movw	r18, r24
    1124:	22 0f       	add	r18, r18
    1126:	33 1f       	adc	r19, r19
    1128:	22 0f       	add	r18, r18
    112a:	33 1f       	adc	r19, r19
    112c:	22 0f       	add	r18, r18
    112e:	33 1f       	adc	r19, r19
    1130:	82 0f       	add	r24, r18
    1132:	93 1f       	adc	r25, r19
    1134:	b8 01       	movw	r22, r16
    1136:	8b 54       	subi	r24, 0x4B	; 75
    1138:	9a 4f       	sbci	r25, 0xFA	; 250
    113a:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    113e:	9e 89       	ldd	r25, Y+22	; 0x16
    1140:	e0 91 fd 05 	lds	r30, 0x05FD	; 0x8005fd <pxCurrentTCB>
    1144:	f0 91 fe 05 	lds	r31, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    1148:	86 89       	ldd	r24, Z+22	; 0x16
    114a:	98 17       	cp	r25, r24
    114c:	18 f0       	brcs	.+6      	; 0x1154 <xTaskResumeAll+0x8c>
					{
						xYieldPending = pdTRUE;
    114e:	81 e0       	ldi	r24, 0x01	; 1
    1150:	80 93 85 05 	sts	0x0585, r24	; 0x800585 <xYieldPending>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1154:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <xPendingReadyList>
    1158:	81 11       	cpse	r24, r1
    115a:	cb cf       	rjmp	.-106    	; 0x10f2 <xTaskResumeAll+0x2a>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    115c:	80 91 86 05 	lds	r24, 0x0586	; 0x800586 <uxPendedTicks>
    1160:	81 11       	cpse	r24, r1
    1162:	0d c0       	rjmp	.+26     	; 0x117e <xTaskResumeAll+0xb6>
    1164:	10 c0       	rjmp	.+32     	; 0x1186 <xTaskResumeAll+0xbe>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    1166:	0e 94 a8 07 	call	0xf50	; 0xf50 <xTaskIncrementTick>
    116a:	88 23       	and	r24, r24
    116c:	19 f0       	breq	.+6      	; 0x1174 <xTaskResumeAll+0xac>
						{
							xYieldPending = pdTRUE;
    116e:	81 e0       	ldi	r24, 0x01	; 1
    1170:	80 93 85 05 	sts	0x0585, r24	; 0x800585 <xYieldPending>
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    1174:	80 91 86 05 	lds	r24, 0x0586	; 0x800586 <uxPendedTicks>
    1178:	81 50       	subi	r24, 0x01	; 1
    117a:	80 93 86 05 	sts	0x0586, r24	; 0x800586 <uxPendedTicks>
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    117e:	80 91 86 05 	lds	r24, 0x0586	; 0x800586 <uxPendedTicks>
    1182:	81 11       	cpse	r24, r1
    1184:	f0 cf       	rjmp	.-32     	; 0x1166 <xTaskResumeAll+0x9e>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    1186:	80 91 85 05 	lds	r24, 0x0585	; 0x800585 <xYieldPending>
    118a:	81 30       	cpi	r24, 0x01	; 1
    118c:	31 f4       	brne	.+12     	; 0x119a <xTaskResumeAll+0xd2>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    118e:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    1192:	81 e0       	ldi	r24, 0x01	; 1
    1194:	03 c0       	rjmp	.+6      	; 0x119c <xTaskResumeAll+0xd4>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    1196:	80 e0       	ldi	r24, 0x00	; 0
    1198:	01 c0       	rjmp	.+2      	; 0x119c <xTaskResumeAll+0xd4>
    119a:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    119c:	0f 90       	pop	r0
    119e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    11a0:	df 91       	pop	r29
    11a2:	cf 91       	pop	r28
    11a4:	1f 91       	pop	r17
    11a6:	0f 91       	pop	r16
    11a8:	08 95       	ret

000011aa <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    11aa:	cf 93       	push	r28
    11ac:	df 93       	push	r29
    11ae:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    11b0:	89 2b       	or	r24, r25
    11b2:	a9 f0       	breq	.+42     	; 0x11de <vTaskDelay+0x34>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    11b4:	0e 94 a2 07 	call	0xf44	; 0xf44 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    11b8:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <xTickCount>
    11bc:	90 91 8a 05 	lds	r25, 0x058A	; 0x80058a <xTickCount+0x1>
    11c0:	c8 0f       	add	r28, r24
    11c2:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    11c4:	80 91 fd 05 	lds	r24, 0x05FD	; 0x8005fd <pxCurrentTCB>
    11c8:	90 91 fe 05 	lds	r25, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    11cc:	02 96       	adiw	r24, 0x02	; 2
    11ce:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    11d2:	ce 01       	movw	r24, r28
    11d4:	0e 94 88 06 	call	0xd10	; 0xd10 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    11d8:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskResumeAll>
    11dc:	01 c0       	rjmp	.+2      	; 0x11e0 <vTaskDelay+0x36>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    11de:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    11e0:	81 11       	cpse	r24, r1
    11e2:	02 c0       	rjmp	.+4      	; 0x11e8 <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
    11e4:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    11e8:	df 91       	pop	r29
    11ea:	cf 91       	pop	r28
    11ec:	08 95       	ret

000011ee <prvCheckTasksWaitingTermination>:
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    11ee:	cf 93       	push	r28
    11f0:	df 93       	push	r29
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    11f2:	24 c0       	rjmp	.+72     	; 0x123c <prvCheckTasksWaitingTermination+0x4e>
		{
			vTaskSuspendAll();
    11f4:	0e 94 a2 07 	call	0xf44	; 0xf44 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    11f8:	c0 91 8d 05 	lds	r28, 0x058D	; 0x80058d <xTasksWaitingTermination>
			}
			( void ) xTaskResumeAll();
    11fc:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1200:	cc 23       	and	r28, r28
    1202:	e1 f0       	breq	.+56     	; 0x123c <prvCheckTasksWaitingTermination+0x4e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1204:	0f b6       	in	r0, 0x3f	; 63
    1206:	f8 94       	cli
    1208:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    120a:	e0 91 92 05 	lds	r30, 0x0592	; 0x800592 <xTasksWaitingTermination+0x5>
    120e:	f0 91 93 05 	lds	r31, 0x0593	; 0x800593 <xTasksWaitingTermination+0x6>
    1212:	c6 81       	ldd	r28, Z+6	; 0x06
    1214:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1216:	ce 01       	movw	r24, r28
    1218:	02 96       	adiw	r24, 0x02	; 2
    121a:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
					--uxCurrentNumberOfTasks;
    121e:	80 91 8b 05 	lds	r24, 0x058B	; 0x80058b <uxCurrentNumberOfTasks>
    1222:	81 50       	subi	r24, 0x01	; 1
    1224:	80 93 8b 05 	sts	0x058B, r24	; 0x80058b <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    1228:	80 91 8c 05 	lds	r24, 0x058C	; 0x80058c <uxTasksDeleted>
    122c:	81 50       	subi	r24, 0x01	; 1
    122e:	80 93 8c 05 	sts	0x058C, r24	; 0x80058c <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    1232:	0f 90       	pop	r0
    1234:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    1236:	ce 01       	movw	r24, r28
    1238:	0e 94 15 06 	call	0xc2a	; 0xc2a <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    123c:	80 91 8c 05 	lds	r24, 0x058C	; 0x80058c <uxTasksDeleted>
    1240:	81 11       	cpse	r24, r1
    1242:	d8 cf       	rjmp	.-80     	; 0x11f4 <prvCheckTasksWaitingTermination+0x6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    1244:	df 91       	pop	r29
    1246:	cf 91       	pop	r28
    1248:	08 95       	ret

0000124a <prvIdleTask>:
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    124a:	0e 94 f7 08 	call	0x11ee	; 0x11ee <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    124e:	80 91 b5 05 	lds	r24, 0x05B5	; 0x8005b5 <pxReadyTasksLists>
    1252:	82 30       	cpi	r24, 0x02	; 2
    1254:	d0 f3       	brcs	.-12     	; 0x124a <prvIdleTask>
			{
				taskYIELD();
    1256:	0e 94 b8 02 	call	0x570	; 0x570 <vPortYield>
    125a:	f7 cf       	rjmp	.-18     	; 0x124a <prvIdleTask>

0000125c <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    125c:	80 91 82 05 	lds	r24, 0x0582	; 0x800582 <uxSchedulerSuspended>
    1260:	88 23       	and	r24, r24
    1262:	21 f0       	breq	.+8      	; 0x126c <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1264:	81 e0       	ldi	r24, 0x01	; 1
    1266:	80 93 85 05 	sts	0x0585, r24	; 0x800585 <xYieldPending>
    126a:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    126c:	10 92 85 05 	sts	0x0585, r1	; 0x800585 <xYieldPending>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1270:	05 c0       	rjmp	.+10     	; 0x127c <vTaskSwitchContext+0x20>
    1272:	80 91 88 05 	lds	r24, 0x0588	; 0x800588 <uxTopReadyPriority>
    1276:	81 50       	subi	r24, 0x01	; 1
    1278:	80 93 88 05 	sts	0x0588, r24	; 0x800588 <uxTopReadyPriority>
    127c:	80 91 88 05 	lds	r24, 0x0588	; 0x800588 <uxTopReadyPriority>
    1280:	90 e0       	ldi	r25, 0x00	; 0
    1282:	fc 01       	movw	r30, r24
    1284:	ee 0f       	add	r30, r30
    1286:	ff 1f       	adc	r31, r31
    1288:	ee 0f       	add	r30, r30
    128a:	ff 1f       	adc	r31, r31
    128c:	ee 0f       	add	r30, r30
    128e:	ff 1f       	adc	r31, r31
    1290:	8e 0f       	add	r24, r30
    1292:	9f 1f       	adc	r25, r31
    1294:	fc 01       	movw	r30, r24
    1296:	eb 54       	subi	r30, 0x4B	; 75
    1298:	fa 4f       	sbci	r31, 0xFA	; 250
    129a:	80 81       	ld	r24, Z
    129c:	88 23       	and	r24, r24
    129e:	49 f3       	breq	.-46     	; 0x1272 <vTaskSwitchContext+0x16>
    12a0:	80 91 88 05 	lds	r24, 0x0588	; 0x800588 <uxTopReadyPriority>
    12a4:	90 e0       	ldi	r25, 0x00	; 0
    12a6:	9c 01       	movw	r18, r24
    12a8:	22 0f       	add	r18, r18
    12aa:	33 1f       	adc	r19, r19
    12ac:	22 0f       	add	r18, r18
    12ae:	33 1f       	adc	r19, r19
    12b0:	22 0f       	add	r18, r18
    12b2:	33 1f       	adc	r19, r19
    12b4:	28 0f       	add	r18, r24
    12b6:	39 1f       	adc	r19, r25
    12b8:	d9 01       	movw	r26, r18
    12ba:	ab 54       	subi	r26, 0x4B	; 75
    12bc:	ba 4f       	sbci	r27, 0xFA	; 250
    12be:	11 96       	adiw	r26, 0x01	; 1
    12c0:	ed 91       	ld	r30, X+
    12c2:	fc 91       	ld	r31, X
    12c4:	12 97       	sbiw	r26, 0x02	; 2
    12c6:	02 80       	ldd	r0, Z+2	; 0x02
    12c8:	f3 81       	ldd	r31, Z+3	; 0x03
    12ca:	e0 2d       	mov	r30, r0
    12cc:	12 96       	adiw	r26, 0x02	; 2
    12ce:	fc 93       	st	X, r31
    12d0:	ee 93       	st	-X, r30
    12d2:	11 97       	sbiw	r26, 0x01	; 1
    12d4:	28 54       	subi	r18, 0x48	; 72
    12d6:	3a 4f       	sbci	r19, 0xFA	; 250
    12d8:	e2 17       	cp	r30, r18
    12da:	f3 07       	cpc	r31, r19
    12dc:	29 f4       	brne	.+10     	; 0x12e8 <vTaskSwitchContext+0x8c>
    12de:	22 81       	ldd	r18, Z+2	; 0x02
    12e0:	33 81       	ldd	r19, Z+3	; 0x03
    12e2:	fd 01       	movw	r30, r26
    12e4:	32 83       	std	Z+2, r19	; 0x02
    12e6:	21 83       	std	Z+1, r18	; 0x01
    12e8:	fc 01       	movw	r30, r24
    12ea:	ee 0f       	add	r30, r30
    12ec:	ff 1f       	adc	r31, r31
    12ee:	ee 0f       	add	r30, r30
    12f0:	ff 1f       	adc	r31, r31
    12f2:	ee 0f       	add	r30, r30
    12f4:	ff 1f       	adc	r31, r31
    12f6:	8e 0f       	add	r24, r30
    12f8:	9f 1f       	adc	r25, r31
    12fa:	fc 01       	movw	r30, r24
    12fc:	eb 54       	subi	r30, 0x4B	; 75
    12fe:	fa 4f       	sbci	r31, 0xFA	; 250
    1300:	01 80       	ldd	r0, Z+1	; 0x01
    1302:	f2 81       	ldd	r31, Z+2	; 0x02
    1304:	e0 2d       	mov	r30, r0
    1306:	86 81       	ldd	r24, Z+6	; 0x06
    1308:	97 81       	ldd	r25, Z+7	; 0x07
    130a:	90 93 fe 05 	sts	0x05FE, r25	; 0x8005fe <pxCurrentTCB+0x1>
    130e:	80 93 fd 05 	sts	0x05FD, r24	; 0x8005fd <pxCurrentTCB>
    1312:	08 95       	ret

00001314 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1314:	cf 93       	push	r28
    1316:	df 93       	push	r29
    1318:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    131a:	60 91 fd 05 	lds	r22, 0x05FD	; 0x8005fd <pxCurrentTCB>
    131e:	70 91 fe 05 	lds	r23, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    1322:	64 5f       	subi	r22, 0xF4	; 244
    1324:	7f 4f       	sbci	r23, 0xFF	; 255
    1326:	0e 94 bd 01 	call	0x37a	; 0x37a <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    132a:	80 91 fd 05 	lds	r24, 0x05FD	; 0x8005fd <pxCurrentTCB>
    132e:	90 91 fe 05 	lds	r25, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    1332:	02 96       	adiw	r24, 0x02	; 2
    1334:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    1338:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <xTickCount>
    133c:	90 91 8a 05 	lds	r25, 0x058A	; 0x80058a <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1340:	8c 0f       	add	r24, r28
    1342:	9d 1f       	adc	r25, r29
    1344:	0e 94 88 06 	call	0xd10	; 0xd10 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1348:	df 91       	pop	r29
    134a:	cf 91       	pop	r28
    134c:	08 95       	ret

0000134e <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    134e:	cf 93       	push	r28
    1350:	df 93       	push	r29
    1352:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1354:	e0 91 fd 05 	lds	r30, 0x05FD	; 0x8005fd <pxCurrentTCB>
    1358:	f0 91 fe 05 	lds	r31, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    135c:	70 68       	ori	r23, 0x80	; 128
    135e:	75 87       	std	Z+13, r23	; 0x0d
    1360:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1362:	60 91 fd 05 	lds	r22, 0x05FD	; 0x8005fd <pxCurrentTCB>
    1366:	70 91 fe 05 	lds	r23, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    136a:	64 5f       	subi	r22, 0xF4	; 244
    136c:	7f 4f       	sbci	r23, 0xFF	; 255
    136e:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1372:	80 91 fd 05 	lds	r24, 0x05FD	; 0x8005fd <pxCurrentTCB>
    1376:	90 91 fe 05 	lds	r25, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    137a:	02 96       	adiw	r24, 0x02	; 2
    137c:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    1380:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <xTickCount>
    1384:	90 91 8a 05 	lds	r25, 0x058A	; 0x80058a <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1388:	8c 0f       	add	r24, r28
    138a:	9d 1f       	adc	r25, r29
    138c:	0e 94 88 06 	call	0xd10	; 0xd10 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1390:	df 91       	pop	r29
    1392:	cf 91       	pop	r28
    1394:	08 95       	ret

00001396 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1396:	0f 93       	push	r16
    1398:	1f 93       	push	r17
    139a:	cf 93       	push	r28
    139c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    139e:	dc 01       	movw	r26, r24
    13a0:	15 96       	adiw	r26, 0x05	; 5
    13a2:	ed 91       	ld	r30, X+
    13a4:	fc 91       	ld	r31, X
    13a6:	16 97       	sbiw	r26, 0x06	; 6
    13a8:	c6 81       	ldd	r28, Z+6	; 0x06
    13aa:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    13ac:	8e 01       	movw	r16, r28
    13ae:	04 5f       	subi	r16, 0xF4	; 244
    13b0:	1f 4f       	sbci	r17, 0xFF	; 255
    13b2:	c8 01       	movw	r24, r16
    13b4:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    13b8:	80 91 82 05 	lds	r24, 0x0582	; 0x800582 <uxSchedulerSuspended>
    13bc:	81 11       	cpse	r24, r1
    13be:	1c c0       	rjmp	.+56     	; 0x13f8 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    13c0:	0a 50       	subi	r16, 0x0A	; 10
    13c2:	11 09       	sbc	r17, r1
    13c4:	c8 01       	movw	r24, r16
    13c6:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    13ca:	8e 89       	ldd	r24, Y+22	; 0x16
    13cc:	90 91 88 05 	lds	r25, 0x0588	; 0x800588 <uxTopReadyPriority>
    13d0:	98 17       	cp	r25, r24
    13d2:	10 f4       	brcc	.+4      	; 0x13d8 <xTaskRemoveFromEventList+0x42>
    13d4:	80 93 88 05 	sts	0x0588, r24	; 0x800588 <uxTopReadyPriority>
    13d8:	90 e0       	ldi	r25, 0x00	; 0
    13da:	9c 01       	movw	r18, r24
    13dc:	22 0f       	add	r18, r18
    13de:	33 1f       	adc	r19, r19
    13e0:	22 0f       	add	r18, r18
    13e2:	33 1f       	adc	r19, r19
    13e4:	22 0f       	add	r18, r18
    13e6:	33 1f       	adc	r19, r19
    13e8:	82 0f       	add	r24, r18
    13ea:	93 1f       	adc	r25, r19
    13ec:	b8 01       	movw	r22, r16
    13ee:	8b 54       	subi	r24, 0x4B	; 75
    13f0:	9a 4f       	sbci	r25, 0xFA	; 250
    13f2:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>
    13f6:	05 c0       	rjmp	.+10     	; 0x1402 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    13f8:	b8 01       	movw	r22, r16
    13fa:	86 e9       	ldi	r24, 0x96	; 150
    13fc:	95 e0       	ldi	r25, 0x05	; 5
    13fe:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1402:	9e 89       	ldd	r25, Y+22	; 0x16
    1404:	e0 91 fd 05 	lds	r30, 0x05FD	; 0x8005fd <pxCurrentTCB>
    1408:	f0 91 fe 05 	lds	r31, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    140c:	86 89       	ldd	r24, Z+22	; 0x16
    140e:	89 17       	cp	r24, r25
    1410:	20 f4       	brcc	.+8      	; 0x141a <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1412:	81 e0       	ldi	r24, 0x01	; 1
    1414:	80 93 85 05 	sts	0x0585, r24	; 0x800585 <xYieldPending>
    1418:	01 c0       	rjmp	.+2      	; 0x141c <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    141a:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	1f 91       	pop	r17
    1422:	0f 91       	pop	r16
    1424:	08 95       	ret

00001426 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    1426:	0f 93       	push	r16
    1428:	1f 93       	push	r17
    142a:	cf 93       	push	r28
    142c:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    142e:	70 68       	ori	r23, 0x80	; 128
    1430:	fc 01       	movw	r30, r24
    1432:	71 83       	std	Z+1, r23	; 0x01
    1434:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    1436:	c6 81       	ldd	r28, Z+6	; 0x06
    1438:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    143a:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    143e:	8e 01       	movw	r16, r28
    1440:	0e 5f       	subi	r16, 0xFE	; 254
    1442:	1f 4f       	sbci	r17, 0xFF	; 255
    1444:	c8 01       	movw	r24, r16
    1446:	0e 94 ee 01 	call	0x3dc	; 0x3dc <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    144a:	8e 89       	ldd	r24, Y+22	; 0x16
    144c:	90 91 88 05 	lds	r25, 0x0588	; 0x800588 <uxTopReadyPriority>
    1450:	98 17       	cp	r25, r24
    1452:	10 f4       	brcc	.+4      	; 0x1458 <xTaskRemoveFromUnorderedEventList+0x32>
    1454:	80 93 88 05 	sts	0x0588, r24	; 0x800588 <uxTopReadyPriority>
    1458:	90 e0       	ldi	r25, 0x00	; 0
    145a:	9c 01       	movw	r18, r24
    145c:	22 0f       	add	r18, r18
    145e:	33 1f       	adc	r19, r19
    1460:	22 0f       	add	r18, r18
    1462:	33 1f       	adc	r19, r19
    1464:	22 0f       	add	r18, r18
    1466:	33 1f       	adc	r19, r19
    1468:	82 0f       	add	r24, r18
    146a:	93 1f       	adc	r25, r19
    146c:	b8 01       	movw	r22, r16
    146e:	8b 54       	subi	r24, 0x4B	; 75
    1470:	9a 4f       	sbci	r25, 0xFA	; 250
    1472:	0e 94 9c 01 	call	0x338	; 0x338 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1476:	9e 89       	ldd	r25, Y+22	; 0x16
    1478:	e0 91 fd 05 	lds	r30, 0x05FD	; 0x8005fd <pxCurrentTCB>
    147c:	f0 91 fe 05 	lds	r31, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    1480:	86 89       	ldd	r24, Z+22	; 0x16
    1482:	89 17       	cp	r24, r25
    1484:	20 f4       	brcc	.+8      	; 0x148e <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1486:	81 e0       	ldi	r24, 0x01	; 1
    1488:	80 93 85 05 	sts	0x0585, r24	; 0x800585 <xYieldPending>
    148c:	01 c0       	rjmp	.+2      	; 0x1490 <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    148e:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    1490:	df 91       	pop	r29
    1492:	cf 91       	pop	r28
    1494:	1f 91       	pop	r17
    1496:	0f 91       	pop	r16
    1498:	08 95       	ret

0000149a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    149a:	20 91 84 05 	lds	r18, 0x0584	; 0x800584 <xNumOfOverflows>
    149e:	fc 01       	movw	r30, r24
    14a0:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    14a2:	20 91 89 05 	lds	r18, 0x0589	; 0x800589 <xTickCount>
    14a6:	30 91 8a 05 	lds	r19, 0x058A	; 0x80058a <xTickCount+0x1>
    14aa:	32 83       	std	Z+2, r19	; 0x02
    14ac:	21 83       	std	Z+1, r18	; 0x01
    14ae:	08 95       	ret

000014b0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    14b0:	cf 93       	push	r28
    14b2:	df 93       	push	r29
    14b4:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    14b6:	0f b6       	in	r0, 0x3f	; 63
    14b8:	f8 94       	cli
    14ba:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    14bc:	40 91 89 05 	lds	r20, 0x0589	; 0x800589 <xTickCount>
    14c0:	50 91 8a 05 	lds	r21, 0x058A	; 0x80058a <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    14c4:	90 81       	ld	r25, Z
    14c6:	80 91 84 05 	lds	r24, 0x0584	; 0x800584 <xNumOfOverflows>
    14ca:	98 17       	cp	r25, r24
    14cc:	29 f0       	breq	.+10     	; 0x14d8 <xTaskCheckForTimeOut+0x28>
    14ce:	81 81       	ldd	r24, Z+1	; 0x01
    14d0:	92 81       	ldd	r25, Z+2	; 0x02
    14d2:	48 17       	cp	r20, r24
    14d4:	59 07       	cpc	r21, r25
    14d6:	b0 f4       	brcc	.+44     	; 0x1504 <xTaskCheckForTimeOut+0x54>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    14d8:	21 81       	ldd	r18, Z+1	; 0x01
    14da:	32 81       	ldd	r19, Z+2	; 0x02
    14dc:	ca 01       	movw	r24, r20
    14de:	82 1b       	sub	r24, r18
    14e0:	93 0b       	sbc	r25, r19
    14e2:	eb 01       	movw	r28, r22
    14e4:	a8 81       	ld	r26, Y
    14e6:	b9 81       	ldd	r27, Y+1	; 0x01
    14e8:	8a 17       	cp	r24, r26
    14ea:	9b 07       	cpc	r25, r27
    14ec:	68 f4       	brcc	.+26     	; 0x1508 <xTaskCheckForTimeOut+0x58>
    14ee:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    14f0:	24 1b       	sub	r18, r20
    14f2:	35 0b       	sbc	r19, r21
    14f4:	2a 0f       	add	r18, r26
    14f6:	3b 1f       	adc	r19, r27
    14f8:	39 83       	std	Y+1, r19	; 0x01
    14fa:	28 83       	st	Y, r18
			vTaskSetTimeOutState( pxTimeOut );
    14fc:	0e 94 4d 0a 	call	0x149a	; 0x149a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1500:	80 e0       	ldi	r24, 0x00	; 0
    1502:	03 c0       	rjmp	.+6      	; 0x150a <xTaskCheckForTimeOut+0x5a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1504:	81 e0       	ldi	r24, 0x01	; 1
    1506:	01 c0       	rjmp	.+2      	; 0x150a <xTaskCheckForTimeOut+0x5a>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1508:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    150a:	0f 90       	pop	r0
    150c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    150e:	df 91       	pop	r29
    1510:	cf 91       	pop	r28
    1512:	08 95       	ret

00001514 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1514:	81 e0       	ldi	r24, 0x01	; 1
    1516:	80 93 85 05 	sts	0x0585, r24	; 0x800585 <xYieldPending>
    151a:	08 95       	ret

0000151c <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    151c:	e0 91 fd 05 	lds	r30, 0x05FD	; 0x8005fd <pxCurrentTCB>
    1520:	f0 91 fe 05 	lds	r31, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    1524:	84 85       	ldd	r24, Z+12	; 0x0c
    1526:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1528:	e0 91 fd 05 	lds	r30, 0x05FD	; 0x8005fd <pxCurrentTCB>
    152c:	f0 91 fe 05 	lds	r31, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    1530:	a0 91 fd 05 	lds	r26, 0x05FD	; 0x8005fd <pxCurrentTCB>
    1534:	b0 91 fe 05 	lds	r27, 0x05FE	; 0x8005fe <pxCurrentTCB+0x1>
    1538:	56 96       	adiw	r26, 0x16	; 22
    153a:	4c 91       	ld	r20, X
    153c:	28 e0       	ldi	r18, 0x08	; 8
    153e:	30 e0       	ldi	r19, 0x00	; 0
    1540:	24 1b       	sub	r18, r20
    1542:	31 09       	sbc	r19, r1
    1544:	35 87       	std	Z+13, r19	; 0x0d
    1546:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    1548:	08 95       	ret

0000154a <T_Control>:
			{

				DIO_voidSetPinValue(DIO_u8_PORTA ,  DIO_u8_PIN0, DIO_u8_HIGH);
				vTaskDelay(500);
				DIO_voidSetPinValue(DIO_u8_PORTA ,  DIO_u8_PIN0, DIO_u8_LOW);
				vTaskDelay(500);
    154a:	0f ef       	ldi	r16, 0xFF	; 255
    154c:	1f ef       	ldi	r17, 0xFF	; 255
    154e:	20 e0       	ldi	r18, 0x00	; 0
    1550:	40 e0       	ldi	r20, 0x00	; 0
    1552:	67 e0       	ldi	r22, 0x07	; 7
    1554:	70 e0       	ldi	r23, 0x00	; 0
    1556:	80 91 02 06 	lds	r24, 0x0602	; 0x800602 <egControl>
    155a:	90 91 03 06 	lds	r25, 0x0603	; 0x800603 <egControl+0x1>
    155e:	0e 94 6f 00 	call	0xde	; 0xde <xEventGroupWaitBits>
    1562:	80 93 10 06 	sts	0x0610, r24	; 0x800610 <ebControlBits>
    1566:	90 93 11 06 	sts	0x0611, r25	; 0x800611 <ebControlBits+0x1>
    156a:	81 ff       	sbrs	r24, 1
    156c:	0f c0       	rjmp	.+30     	; 0x158c <T_Control+0x42>
    156e:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <Motors_State+0x1>
    1572:	81 30       	cpi	r24, 0x01	; 1
    1574:	31 f4       	brne	.+12     	; 0x1582 <T_Control+0x38>
    1576:	41 e0       	ldi	r20, 0x01	; 1
    1578:	63 e0       	ldi	r22, 0x03	; 3
    157a:	83 e0       	ldi	r24, 0x03	; 3
    157c:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <DIO_voidSetPinValue>
    1580:	05 c0       	rjmp	.+10     	; 0x158c <T_Control+0x42>
    1582:	40 e0       	ldi	r20, 0x00	; 0
    1584:	63 e0       	ldi	r22, 0x03	; 3
    1586:	83 e0       	ldi	r24, 0x03	; 3
    1588:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <DIO_voidSetPinValue>
    158c:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <ebControlBits>
    1590:	82 ff       	sbrs	r24, 2
    1592:	0f c0       	rjmp	.+30     	; 0x15b2 <T_Control+0x68>
    1594:	80 91 0f 06 	lds	r24, 0x060F	; 0x80060f <Motors_State+0x2>
    1598:	81 30       	cpi	r24, 0x01	; 1
    159a:	31 f4       	brne	.+12     	; 0x15a8 <T_Control+0x5e>
    159c:	41 e0       	ldi	r20, 0x01	; 1
    159e:	64 e0       	ldi	r22, 0x04	; 4
    15a0:	83 e0       	ldi	r24, 0x03	; 3
    15a2:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <DIO_voidSetPinValue>
    15a6:	05 c0       	rjmp	.+10     	; 0x15b2 <T_Control+0x68>
    15a8:	40 e0       	ldi	r20, 0x00	; 0
    15aa:	64 e0       	ldi	r22, 0x04	; 4
    15ac:	83 e0       	ldi	r24, 0x03	; 3
    15ae:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <DIO_voidSetPinValue>
    15b2:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <ebControlBits>
    15b6:	80 ff       	sbrs	r24, 0
    15b8:	0f c0       	rjmp	.+30     	; 0x15d8 <T_Control+0x8e>
    15ba:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <Motors_State>
    15be:	81 30       	cpi	r24, 0x01	; 1
    15c0:	31 f4       	brne	.+12     	; 0x15ce <T_Control+0x84>
    15c2:	41 e0       	ldi	r20, 0x01	; 1
    15c4:	62 e0       	ldi	r22, 0x02	; 2
    15c6:	83 e0       	ldi	r24, 0x03	; 3
    15c8:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <DIO_voidSetPinValue>
    15cc:	05 c0       	rjmp	.+10     	; 0x15d8 <T_Control+0x8e>
    15ce:	40 e0       	ldi	r20, 0x00	; 0
    15d0:	62 e0       	ldi	r22, 0x02	; 2
    15d2:	83 e0       	ldi	r24, 0x03	; 3
    15d4:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <DIO_voidSetPinValue>
    15d8:	85 e0       	ldi	r24, 0x05	; 5
    15da:	90 e0       	ldi	r25, 0x00	; 0
    15dc:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vTaskDelay>
    15e0:	b4 cf       	rjmp	.-152    	; 0x154a <T_Control>

000015e2 <T_SysCheck>:
    15e2:	61 e0       	ldi	r22, 0x01	; 1
    15e4:	70 e0       	ldi	r23, 0x00	; 0
    15e6:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    15ea:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    15ee:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    15f2:	67 e0       	ldi	r22, 0x07	; 7
    15f4:	70 e0       	ldi	r23, 0x00	; 0
    15f6:	80 91 02 06 	lds	r24, 0x0602	; 0x800602 <egControl>
    15fa:	90 91 03 06 	lds	r25, 0x0603	; 0x800603 <egControl+0x1>
    15fe:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <xEventGroupClearBits>
    1602:	20 e0       	ldi	r18, 0x00	; 0
    1604:	4f ef       	ldi	r20, 0xFF	; 255
    1606:	5f ef       	ldi	r21, 0xFF	; 255
    1608:	60 e0       	ldi	r22, 0x00	; 0
    160a:	70 e0       	ldi	r23, 0x00	; 0
    160c:	80 91 04 06 	lds	r24, 0x0604	; 0x800604 <bsCheck>
    1610:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <bsCheck+0x1>
    1614:	0e 94 2c 05 	call	0xa58	; 0xa58 <xQueueGenericReceive>
    1618:	88 23       	and	r24, r24
    161a:	99 f3       	breq	.-26     	; 0x1602 <T_SysCheck+0x20>
    161c:	e6 e0       	ldi	r30, 0x06	; 6
    161e:	f6 e0       	ldi	r31, 0x06	; 6
    1620:	91 81       	ldd	r25, Z+1	; 0x01
    1622:	83 81       	ldd	r24, Z+3	; 0x03
    1624:	89 17       	cp	r24, r25
    1626:	30 f4       	brcc	.+12     	; 0x1634 <T_SysCheck+0x52>
    1628:	ed e0       	ldi	r30, 0x0D	; 13
    162a:	f6 e0       	ldi	r31, 0x06	; 6
    162c:	81 e0       	ldi	r24, 0x01	; 1
    162e:	82 83       	std	Z+2, r24	; 0x02
    1630:	11 82       	std	Z+1, r1	; 0x01
    1632:	0c c0       	rjmp	.+24     	; 0x164c <T_SysCheck+0x6a>
    1634:	98 17       	cp	r25, r24
    1636:	30 f4       	brcc	.+12     	; 0x1644 <T_SysCheck+0x62>
    1638:	ed e0       	ldi	r30, 0x0D	; 13
    163a:	f6 e0       	ldi	r31, 0x06	; 6
    163c:	12 82       	std	Z+2, r1	; 0x02
    163e:	81 e0       	ldi	r24, 0x01	; 1
    1640:	81 83       	std	Z+1, r24	; 0x01
    1642:	04 c0       	rjmp	.+8      	; 0x164c <T_SysCheck+0x6a>
    1644:	ed e0       	ldi	r30, 0x0D	; 13
    1646:	f6 e0       	ldi	r31, 0x06	; 6
    1648:	12 82       	std	Z+2, r1	; 0x02
    164a:	11 82       	std	Z+1, r1	; 0x01
    164c:	66 e0       	ldi	r22, 0x06	; 6
    164e:	70 e0       	ldi	r23, 0x00	; 0
    1650:	80 91 02 06 	lds	r24, 0x0602	; 0x800602 <egControl>
    1654:	90 91 03 06 	lds	r25, 0x0603	; 0x800603 <egControl+0x1>
    1658:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    165c:	8a e0       	ldi	r24, 0x0A	; 10
    165e:	90 e0       	ldi	r25, 0x00	; 0
    1660:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vTaskDelay>
    1664:	66 e0       	ldi	r22, 0x06	; 6
    1666:	70 e0       	ldi	r23, 0x00	; 0
    1668:	80 91 02 06 	lds	r24, 0x0602	; 0x800602 <egControl>
    166c:	90 91 03 06 	lds	r25, 0x0603	; 0x800603 <egControl+0x1>
    1670:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <xEventGroupClearBits>
    1674:	e6 e0       	ldi	r30, 0x06	; 6
    1676:	f6 e0       	ldi	r31, 0x06	; 6
    1678:	92 81       	ldd	r25, Z+2	; 0x02
    167a:	84 81       	ldd	r24, Z+4	; 0x04
    167c:	89 17       	cp	r24, r25
    167e:	18 f4       	brcc	.+6      	; 0x1686 <T_SysCheck+0xa4>
    1680:	10 92 0d 06 	sts	0x060D, r1	; 0x80060d <Motors_State>
    1684:	03 c0       	rjmp	.+6      	; 0x168c <T_SysCheck+0xaa>
    1686:	81 e0       	ldi	r24, 0x01	; 1
    1688:	80 93 0d 06 	sts	0x060D, r24	; 0x80060d <Motors_State>
    168c:	61 e0       	ldi	r22, 0x01	; 1
    168e:	70 e0       	ldi	r23, 0x00	; 0
    1690:	80 91 02 06 	lds	r24, 0x0602	; 0x800602 <egControl>
    1694:	90 91 03 06 	lds	r25, 0x0603	; 0x800603 <egControl+0x1>
    1698:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    169c:	8a e0       	ldi	r24, 0x0A	; 10
    169e:	90 e0       	ldi	r25, 0x00	; 0
    16a0:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vTaskDelay>
    16a4:	61 e0       	ldi	r22, 0x01	; 1
    16a6:	70 e0       	ldi	r23, 0x00	; 0
    16a8:	80 91 02 06 	lds	r24, 0x0602	; 0x800602 <egControl>
    16ac:	90 91 03 06 	lds	r25, 0x0603	; 0x800603 <egControl+0x1>
    16b0:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <xEventGroupClearBits>
    16b4:	60 e4       	ldi	r22, 0x40	; 64
    16b6:	70 e0       	ldi	r23, 0x00	; 0
    16b8:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    16bc:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    16c0:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    16c4:	9e cf       	rjmp	.-196    	; 0x1602 <T_SysCheck+0x20>

000016c6 <T_Terminal>:
    16c6:	cf 93       	push	r28
    16c8:	df 93       	push	r29
    16ca:	cd b7       	in	r28, 0x3d	; 61
    16cc:	de b7       	in	r29, 0x3e	; 62
    16ce:	2f 97       	sbiw	r28, 0x0f	; 15
    16d0:	0f b6       	in	r0, 0x3f	; 63
    16d2:	f8 94       	cli
    16d4:	de bf       	out	0x3e, r29	; 62
    16d6:	0f be       	out	0x3f, r0	; 63
    16d8:	cd bf       	out	0x3d, r28	; 61
    16da:	fe 01       	movw	r30, r28
    16dc:	32 96       	adiw	r30, 0x02	; 2
    16de:	83 e0       	ldi	r24, 0x03	; 3
    16e0:	df 01       	movw	r26, r30
    16e2:	98 2f       	mov	r25, r24
    16e4:	1d 92       	st	X+, r1
    16e6:	9a 95       	dec	r25
    16e8:	e9 f7       	brne	.-6      	; 0x16e4 <T_Terminal+0x1e>
    16ea:	34 96       	adiw	r30, 0x04	; 4
    16ec:	df 01       	movw	r26, r30
    16ee:	1d 92       	st	X+, r1
    16f0:	8a 95       	dec	r24
    16f2:	e9 f7       	brne	.-6      	; 0x16ee <T_Terminal+0x28>
    16f4:	8d e0       	ldi	r24, 0x0D	; 13
    16f6:	80 93 ff 05 	sts	0x05FF, r24	; 0x8005ff <ReceivingState.2419>
    16fa:	61 e0       	ldi	r22, 0x01	; 1
    16fc:	70 e0       	ldi	r23, 0x00	; 0
    16fe:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    1702:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    1706:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    170a:	10 e0       	ldi	r17, 0x00	; 0
    170c:	80 91 ff 05 	lds	r24, 0x05FF	; 0x8005ff <ReceivingState.2419>
    1710:	8d 30       	cpi	r24, 0x0D	; 13
    1712:	21 f0       	breq	.+8      	; 0x171c <T_Terminal+0x56>
    1714:	8e 30       	cpi	r24, 0x0E	; 14
    1716:	09 f4       	brne	.+2      	; 0x171a <T_Terminal+0x54>
    1718:	7e c0       	rjmp	.+252    	; 0x1816 <T_Terminal+0x150>
    171a:	14 c1       	rjmp	.+552    	; 0x1944 <T_Terminal+0x27e>
    171c:	ce 01       	movw	r24, r28
    171e:	01 96       	adiw	r24, 0x01	; 1
    1720:	0e 94 95 11 	call	0x232a	; 0x232a <usart_getc_NonBlocking>
    1724:	81 11       	cpse	r24, r1
    1726:	0e c1       	rjmp	.+540    	; 0x1944 <T_Terminal+0x27e>
    1728:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <SFS>
    172c:	81 11       	cpse	r24, r1
    172e:	18 c0       	rjmp	.+48     	; 0x1760 <T_Terminal+0x9a>
    1730:	89 81       	ldd	r24, Y+1	; 0x01
    1732:	83 34       	cpi	r24, 0x43	; 67
    1734:	09 f0       	breq	.+2      	; 0x1738 <T_Terminal+0x72>
    1736:	06 c1       	rjmp	.+524    	; 0x1944 <T_Terminal+0x27e>
    1738:	81 e0       	ldi	r24, 0x01	; 1
    173a:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <SFS>
    173e:	fe 01       	movw	r30, r28
    1740:	32 96       	adiw	r30, 0x02	; 2
    1742:	83 e0       	ldi	r24, 0x03	; 3
    1744:	df 01       	movw	r26, r30
    1746:	1d 92       	st	X+, r1
    1748:	8a 95       	dec	r24
    174a:	e9 f7       	brne	.-6      	; 0x1746 <T_Terminal+0x80>
    174c:	62 e0       	ldi	r22, 0x02	; 2
    174e:	70 e0       	ldi	r23, 0x00	; 0
    1750:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    1754:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    1758:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    175c:	10 e0       	ldi	r17, 0x00	; 0
    175e:	f2 c0       	rjmp	.+484    	; 0x1944 <T_Terminal+0x27e>
    1760:	81 30       	cpi	r24, 0x01	; 1
    1762:	09 f0       	breq	.+2      	; 0x1766 <T_Terminal+0xa0>
    1764:	ef c0       	rjmp	.+478    	; 0x1944 <T_Terminal+0x27e>
    1766:	89 81       	ldd	r24, Y+1	; 0x01
    1768:	83 34       	cpi	r24, 0x43	; 67
    176a:	59 f4       	brne	.+22     	; 0x1782 <T_Terminal+0xbc>
    176c:	10 92 06 06 	sts	0x0606, r1	; 0x800606 <SFS>
    1770:	61 e0       	ldi	r22, 0x01	; 1
    1772:	70 e0       	ldi	r23, 0x00	; 0
    1774:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    1778:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    177c:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    1780:	e1 c0       	rjmp	.+450    	; 0x1944 <T_Terminal+0x27e>
    1782:	90 ed       	ldi	r25, 0xD0	; 208
    1784:	98 0f       	add	r25, r24
    1786:	9a 30       	cpi	r25, 0x0A	; 10
    1788:	60 f4       	brcc	.+24     	; 0x17a2 <T_Terminal+0xdc>
    178a:	13 30       	cpi	r17, 0x03	; 3
    178c:	08 f0       	brcs	.+2      	; 0x1790 <T_Terminal+0xca>
    178e:	da c0       	rjmp	.+436    	; 0x1944 <T_Terminal+0x27e>
    1790:	e2 e0       	ldi	r30, 0x02	; 2
    1792:	f0 e0       	ldi	r31, 0x00	; 0
    1794:	ec 0f       	add	r30, r28
    1796:	fd 1f       	adc	r31, r29
    1798:	e1 0f       	add	r30, r17
    179a:	f1 1d       	adc	r31, r1
    179c:	80 83       	st	Z, r24
    179e:	1f 5f       	subi	r17, 0xFF	; 255
    17a0:	d1 c0       	rjmp	.+418    	; 0x1944 <T_Terminal+0x27e>
    17a2:	8f 34       	cpi	r24, 0x4F	; 79
    17a4:	41 f5       	brne	.+80     	; 0x17f6 <T_Terminal+0x130>
    17a6:	ce 01       	movw	r24, r28
    17a8:	02 96       	adiw	r24, 0x02	; 2
    17aa:	0e 94 13 13 	call	0x2626	; 0x2626 <atoi>
    17ae:	00 97       	sbiw	r24, 0x00	; 0
    17b0:	a9 f0       	breq	.+42     	; 0x17dc <T_Terminal+0x116>
    17b2:	80 93 09 06 	sts	0x0609, r24	; 0x800609 <SFS+0x3>
    17b6:	20 e0       	ldi	r18, 0x00	; 0
    17b8:	40 e0       	ldi	r20, 0x00	; 0
    17ba:	50 e0       	ldi	r21, 0x00	; 0
    17bc:	60 e0       	ldi	r22, 0x00	; 0
    17be:	70 e0       	ldi	r23, 0x00	; 0
    17c0:	80 91 04 06 	lds	r24, 0x0604	; 0x800604 <bsCheck>
    17c4:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <bsCheck+0x1>
    17c8:	0e 94 9a 04 	call	0x934	; 0x934 <xQueueGenericSend>
    17cc:	60 e1       	ldi	r22, 0x10	; 16
    17ce:	70 e0       	ldi	r23, 0x00	; 0
    17d0:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    17d4:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    17d8:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    17dc:	8e e0       	ldi	r24, 0x0E	; 14
    17de:	80 93 ff 05 	sts	0x05FF, r24	; 0x8005ff <ReceivingState.2419>
    17e2:	60 e8       	ldi	r22, 0x80	; 128
    17e4:	70 e0       	ldi	r23, 0x00	; 0
    17e6:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    17ea:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    17ee:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    17f2:	10 e0       	ldi	r17, 0x00	; 0
    17f4:	a7 c0       	rjmp	.+334    	; 0x1944 <T_Terminal+0x27e>
    17f6:	8e 34       	cpi	r24, 0x4E	; 78
    17f8:	09 f0       	breq	.+2      	; 0x17fc <T_Terminal+0x136>
    17fa:	a4 c0       	rjmp	.+328    	; 0x1944 <T_Terminal+0x27e>
    17fc:	8e e0       	ldi	r24, 0x0E	; 14
    17fe:	80 93 ff 05 	sts	0x05FF, r24	; 0x8005ff <ReceivingState.2419>
    1802:	60 e8       	ldi	r22, 0x80	; 128
    1804:	70 e0       	ldi	r23, 0x00	; 0
    1806:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    180a:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    180e:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    1812:	10 e0       	ldi	r17, 0x00	; 0
    1814:	97 c0       	rjmp	.+302    	; 0x1944 <T_Terminal+0x27e>
    1816:	ce 01       	movw	r24, r28
    1818:	01 96       	adiw	r24, 0x01	; 1
    181a:	0e 94 95 11 	call	0x232a	; 0x232a <usart_getc_NonBlocking>
    181e:	81 11       	cpse	r24, r1
    1820:	91 c0       	rjmp	.+290    	; 0x1944 <T_Terminal+0x27e>
    1822:	89 81       	ldd	r24, Y+1	; 0x01
    1824:	83 34       	cpi	r24, 0x43	; 67
    1826:	b1 f4       	brne	.+44     	; 0x1854 <T_Terminal+0x18e>
    1828:	8d e0       	ldi	r24, 0x0D	; 13
    182a:	80 93 ff 05 	sts	0x05FF, r24	; 0x8005ff <ReceivingState.2419>
    182e:	fe 01       	movw	r30, r28
    1830:	36 96       	adiw	r30, 0x06	; 6
    1832:	83 e0       	ldi	r24, 0x03	; 3
    1834:	df 01       	movw	r26, r30
    1836:	1d 92       	st	X+, r1
    1838:	8a 95       	dec	r24
    183a:	e9 f7       	brne	.-6      	; 0x1836 <T_Terminal+0x170>
    183c:	10 92 06 06 	sts	0x0606, r1	; 0x800606 <SFS>
    1840:	61 e0       	ldi	r22, 0x01	; 1
    1842:	70 e0       	ldi	r23, 0x00	; 0
    1844:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    1848:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    184c:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    1850:	10 e0       	ldi	r17, 0x00	; 0
    1852:	78 c0       	rjmp	.+240    	; 0x1944 <T_Terminal+0x27e>
    1854:	90 ed       	ldi	r25, 0xD0	; 208
    1856:	98 0f       	add	r25, r24
    1858:	9a 30       	cpi	r25, 0x0A	; 10
    185a:	60 f4       	brcc	.+24     	; 0x1874 <T_Terminal+0x1ae>
    185c:	13 30       	cpi	r17, 0x03	; 3
    185e:	08 f0       	brcs	.+2      	; 0x1862 <T_Terminal+0x19c>
    1860:	71 c0       	rjmp	.+226    	; 0x1944 <T_Terminal+0x27e>
    1862:	e6 e0       	ldi	r30, 0x06	; 6
    1864:	f0 e0       	ldi	r31, 0x00	; 0
    1866:	ec 0f       	add	r30, r28
    1868:	fd 1f       	adc	r31, r29
    186a:	e1 0f       	add	r30, r17
    186c:	f1 1d       	adc	r31, r1
    186e:	80 83       	st	Z, r24
    1870:	1f 5f       	subi	r17, 0xFF	; 255
    1872:	68 c0       	rjmp	.+208    	; 0x1944 <T_Terminal+0x27e>
    1874:	8f 34       	cpi	r24, 0x4F	; 79
    1876:	09 f0       	breq	.+2      	; 0x187a <T_Terminal+0x1b4>
    1878:	56 c0       	rjmp	.+172    	; 0x1926 <T_Terminal+0x260>
    187a:	ce 01       	movw	r24, r28
    187c:	06 96       	adiw	r24, 0x06	; 6
    187e:	0e 94 13 13 	call	0x2626	; 0x2626 <atoi>
    1882:	89 2b       	or	r24, r25
    1884:	09 f4       	brne	.+2      	; 0x1888 <T_Terminal+0x1c2>
    1886:	41 c0       	rjmp	.+130    	; 0x190a <T_Terminal+0x244>
    1888:	ce 01       	movw	r24, r28
    188a:	06 96       	adiw	r24, 0x06	; 6
    188c:	0e 94 a2 11 	call	0x2344	; 0x2344 <usart_puts>
    1890:	ce 01       	movw	r24, r28
    1892:	06 96       	adiw	r24, 0x06	; 6
    1894:	0e 94 13 13 	call	0x2626	; 0x2626 <atoi>
    1898:	0f 2e       	mov	r0, r31
    189a:	f6 e0       	ldi	r31, 0x06	; 6
    189c:	cf 2e       	mov	r12, r31
    189e:	f6 e0       	ldi	r31, 0x06	; 6
    18a0:	df 2e       	mov	r13, r31
    18a2:	f0 2d       	mov	r31, r0
    18a4:	f6 01       	movw	r30, r12
    18a6:	84 83       	std	Z+4, r24	; 0x04
    18a8:	60 e0       	ldi	r22, 0x00	; 0
    18aa:	81 e0       	ldi	r24, 0x01	; 1
    18ac:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    18b0:	d6 01       	movw	r26, r12
    18b2:	14 96       	adiw	r26, 0x04	; 4
    18b4:	8c 91       	ld	r24, X
    18b6:	90 e0       	ldi	r25, 0x00	; 0
    18b8:	0e 94 0f 11 	call	0x221e	; 0x221e <LCD_intgerToString>
    18bc:	7e 01       	movw	r14, r28
    18be:	ba e0       	ldi	r27, 0x0A	; 10
    18c0:	eb 0e       	add	r14, r27
    18c2:	f1 1c       	adc	r15, r1
    18c4:	85 e0       	ldi	r24, 0x05	; 5
    18c6:	f7 01       	movw	r30, r14
    18c8:	11 92       	st	Z+, r1
    18ca:	8a 95       	dec	r24
    18cc:	e9 f7       	brne	.-6      	; 0x18c8 <T_Terminal+0x202>
    18ce:	d6 01       	movw	r26, r12
    18d0:	14 96       	adiw	r26, 0x04	; 4
    18d2:	8c 91       	ld	r24, X
    18d4:	4a e0       	ldi	r20, 0x0A	; 10
    18d6:	b7 01       	movw	r22, r14
    18d8:	90 e0       	ldi	r25, 0x00	; 0
    18da:	0e 94 45 13 	call	0x268a	; 0x268a <__itoa_ncheck>
    18de:	c7 01       	movw	r24, r14
    18e0:	0e 94 a2 11 	call	0x2344	; 0x2344 <usart_puts>
    18e4:	20 e0       	ldi	r18, 0x00	; 0
    18e6:	40 e0       	ldi	r20, 0x00	; 0
    18e8:	50 e0       	ldi	r21, 0x00	; 0
    18ea:	60 e0       	ldi	r22, 0x00	; 0
    18ec:	70 e0       	ldi	r23, 0x00	; 0
    18ee:	80 91 04 06 	lds	r24, 0x0604	; 0x800604 <bsCheck>
    18f2:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <bsCheck+0x1>
    18f6:	0e 94 9a 04 	call	0x934	; 0x934 <xQueueGenericSend>
    18fa:	60 e2       	ldi	r22, 0x20	; 32
    18fc:	70 e0       	ldi	r23, 0x00	; 0
    18fe:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    1902:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    1906:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    190a:	8d e0       	ldi	r24, 0x0D	; 13
    190c:	80 93 ff 05 	sts	0x05FF, r24	; 0x8005ff <ReceivingState.2419>
    1910:	10 92 06 06 	sts	0x0606, r1	; 0x800606 <SFS>
    1914:	61 e0       	ldi	r22, 0x01	; 1
    1916:	70 e0       	ldi	r23, 0x00	; 0
    1918:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    191c:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    1920:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    1924:	0f c0       	rjmp	.+30     	; 0x1944 <T_Terminal+0x27e>
    1926:	8e 34       	cpi	r24, 0x4E	; 78
    1928:	69 f4       	brne	.+26     	; 0x1944 <T_Terminal+0x27e>
    192a:	8d e0       	ldi	r24, 0x0D	; 13
    192c:	80 93 ff 05 	sts	0x05FF, r24	; 0x8005ff <ReceivingState.2419>
    1930:	10 92 06 06 	sts	0x0606, r1	; 0x800606 <SFS>
    1934:	61 e0       	ldi	r22, 0x01	; 1
    1936:	70 e0       	ldi	r23, 0x00	; 0
    1938:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    193c:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    1940:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    1944:	82 e3       	ldi	r24, 0x32	; 50
    1946:	90 e0       	ldi	r25, 0x00	; 0
    1948:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vTaskDelay>
    194c:	df ce       	rjmp	.-578    	; 0x170c <T_Terminal+0x46>

0000194e <T_Sensing>:
    194e:	cf 93       	push	r28
    1950:	df 93       	push	r29
    1952:	00 d0       	rcall	.+0      	; 0x1954 <T_Sensing+0x6>
    1954:	cd b7       	in	r28, 0x3d	; 61
    1956:	de b7       	in	r29, 0x3e	; 62
    1958:	19 82       	std	Y+1, r1	; 0x01
    195a:	1a 82       	std	Y+2, r1	; 0x02
    195c:	ce 01       	movw	r24, r28
    195e:	01 96       	adiw	r24, 0x01	; 1
    1960:	0e 94 2b 11 	call	0x2256	; 0x2256 <TEMP_u16_Read>
    1964:	81 11       	cpse	r24, r1
    1966:	1a c0       	rjmp	.+52     	; 0x199c <T_Sensing+0x4e>
    1968:	90 91 07 06 	lds	r25, 0x0607	; 0x800607 <SFS+0x1>
    196c:	89 81       	ldd	r24, Y+1	; 0x01
    196e:	98 17       	cp	r25, r24
    1970:	a9 f0       	breq	.+42     	; 0x199c <T_Sensing+0x4e>
    1972:	80 93 07 06 	sts	0x0607, r24	; 0x800607 <SFS+0x1>
    1976:	20 e0       	ldi	r18, 0x00	; 0
    1978:	40 e0       	ldi	r20, 0x00	; 0
    197a:	50 e0       	ldi	r21, 0x00	; 0
    197c:	60 e0       	ldi	r22, 0x00	; 0
    197e:	70 e0       	ldi	r23, 0x00	; 0
    1980:	80 91 04 06 	lds	r24, 0x0604	; 0x800604 <bsCheck>
    1984:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <bsCheck+0x1>
    1988:	0e 94 9a 04 	call	0x934	; 0x934 <xQueueGenericSend>
    198c:	68 e0       	ldi	r22, 0x08	; 8
    198e:	70 e0       	ldi	r23, 0x00	; 0
    1990:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    1994:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    1998:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    199c:	ce 01       	movw	r24, r28
    199e:	02 96       	adiw	r24, 0x02	; 2
    19a0:	0e 94 4f 11 	call	0x229e	; 0x229e <Humit_u16_Read>
    19a4:	81 11       	cpse	r24, r1
    19a6:	1a c0       	rjmp	.+52     	; 0x19dc <T_Sensing+0x8e>
    19a8:	90 91 08 06 	lds	r25, 0x0608	; 0x800608 <SFS+0x2>
    19ac:	8a 81       	ldd	r24, Y+2	; 0x02
    19ae:	98 17       	cp	r25, r24
    19b0:	a9 f0       	breq	.+42     	; 0x19dc <T_Sensing+0x8e>
    19b2:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <SFS+0x2>
    19b6:	20 e0       	ldi	r18, 0x00	; 0
    19b8:	40 e0       	ldi	r20, 0x00	; 0
    19ba:	50 e0       	ldi	r21, 0x00	; 0
    19bc:	60 e0       	ldi	r22, 0x00	; 0
    19be:	70 e0       	ldi	r23, 0x00	; 0
    19c0:	80 91 04 06 	lds	r24, 0x0604	; 0x800604 <bsCheck>
    19c4:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <bsCheck+0x1>
    19c8:	0e 94 9a 04 	call	0x934	; 0x934 <xQueueGenericSend>
    19cc:	64 e0       	ldi	r22, 0x04	; 4
    19ce:	70 e0       	ldi	r23, 0x00	; 0
    19d0:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    19d4:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    19d8:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <xEventGroupSetBits>
    19dc:	84 ef       	ldi	r24, 0xF4	; 244
    19de:	91 e0       	ldi	r25, 0x01	; 1
    19e0:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vTaskDelay>
    19e4:	bb cf       	rjmp	.-138    	; 0x195c <T_Sensing+0xe>

000019e6 <T_Display>:
    19e6:	0f ef       	ldi	r16, 0xFF	; 255
    19e8:	1f ef       	ldi	r17, 0xFF	; 255
    19ea:	20 e0       	ldi	r18, 0x00	; 0
    19ec:	41 e0       	ldi	r20, 0x01	; 1
    19ee:	6f ef       	ldi	r22, 0xFF	; 255
    19f0:	70 e0       	ldi	r23, 0x00	; 0
    19f2:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <egDisplay>
    19f6:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <egDisplay+0x1>
    19fa:	0e 94 6f 00 	call	0xde	; 0xde <xEventGroupWaitBits>
    19fe:	90 93 0c 06 	sts	0x060C, r25	; 0x80060c <ebDisplayBits+0x1>
    1a02:	80 93 0b 06 	sts	0x060B, r24	; 0x80060b <ebDisplayBits>
    1a06:	87 e6       	ldi	r24, 0x67	; 103
    1a08:	90 e0       	ldi	r25, 0x00	; 0
    1a0a:	0e 94 a2 11 	call	0x2344	; 0x2344 <usart_puts>
    1a0e:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <ebDisplayBits>
    1a12:	80 ff       	sbrs	r24, 0
    1a14:	d7 c0       	rjmp	.+430    	; 0x1bc4 <T_Display+0x1de>
    1a16:	80 ed       	ldi	r24, 0xD0	; 208
    1a18:	97 e0       	ldi	r25, 0x07	; 7
    1a1a:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vTaskDelay>
    1a1e:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <SFS>
    1a22:	81 11       	cpse	r24, r1
    1a24:	cf c0       	rjmp	.+414    	; 0x1bc4 <T_Display+0x1de>
    1a26:	0e 94 27 11 	call	0x224e	; 0x224e <LCD_clearScreen>
    1a2a:	8b e7       	ldi	r24, 0x7B	; 123
    1a2c:	90 e0       	ldi	r25, 0x00	; 0
    1a2e:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1a32:	64 e0       	ldi	r22, 0x04	; 4
    1a34:	80 e0       	ldi	r24, 0x00	; 0
    1a36:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1a3a:	86 eb       	ldi	r24, 0xB6	; 182
    1a3c:	90 e0       	ldi	r25, 0x00	; 0
    1a3e:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1a42:	64 e0       	ldi	r22, 0x04	; 4
    1a44:	80 e0       	ldi	r24, 0x00	; 0
    1a46:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1a4a:	c6 e0       	ldi	r28, 0x06	; 6
    1a4c:	d6 e0       	ldi	r29, 0x06	; 6
    1a4e:	89 81       	ldd	r24, Y+1	; 0x01
    1a50:	90 e0       	ldi	r25, 0x00	; 0
    1a52:	0e 94 0f 11 	call	0x221e	; 0x221e <LCD_intgerToString>
    1a56:	60 e1       	ldi	r22, 0x10	; 16
    1a58:	80 e0       	ldi	r24, 0x00	; 0
    1a5a:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1a5e:	86 eb       	ldi	r24, 0xB6	; 182
    1a60:	90 e0       	ldi	r25, 0x00	; 0
    1a62:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1a66:	60 e1       	ldi	r22, 0x10	; 16
    1a68:	80 e0       	ldi	r24, 0x00	; 0
    1a6a:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1a6e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a70:	90 e0       	ldi	r25, 0x00	; 0
    1a72:	0e 94 0f 11 	call	0x221e	; 0x221e <LCD_intgerToString>
    1a76:	60 e0       	ldi	r22, 0x00	; 0
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1a7e:	80 e9       	ldi	r24, 0x90	; 144
    1a80:	90 e0       	ldi	r25, 0x00	; 0
    1a82:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1a86:	64 e0       	ldi	r22, 0x04	; 4
    1a88:	81 e0       	ldi	r24, 0x01	; 1
    1a8a:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1a8e:	86 eb       	ldi	r24, 0xB6	; 182
    1a90:	90 e0       	ldi	r25, 0x00	; 0
    1a92:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1a96:	64 e0       	ldi	r22, 0x04	; 4
    1a98:	81 e0       	ldi	r24, 0x01	; 1
    1a9a:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1aa0:	90 e0       	ldi	r25, 0x00	; 0
    1aa2:	0e 94 0f 11 	call	0x221e	; 0x221e <LCD_intgerToString>
    1aa6:	60 e1       	ldi	r22, 0x10	; 16
    1aa8:	81 e0       	ldi	r24, 0x01	; 1
    1aaa:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1aae:	86 eb       	ldi	r24, 0xB6	; 182
    1ab0:	90 e0       	ldi	r25, 0x00	; 0
    1ab2:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1ab6:	60 e1       	ldi	r22, 0x10	; 16
    1ab8:	81 e0       	ldi	r24, 0x01	; 1
    1aba:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1abe:	8c 81       	ldd	r24, Y+4	; 0x04
    1ac0:	90 e0       	ldi	r25, 0x00	; 0
    1ac2:	0e 94 0f 11 	call	0x221e	; 0x221e <LCD_intgerToString>
    1ac6:	60 e0       	ldi	r22, 0x00	; 0
    1ac8:	82 e0       	ldi	r24, 0x02	; 2
    1aca:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1ace:	85 ea       	ldi	r24, 0xA5	; 165
    1ad0:	90 e0       	ldi	r25, 0x00	; 0
    1ad2:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1ad6:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <Motors_State>
    1ada:	81 30       	cpi	r24, 0x01	; 1
    1adc:	89 f4       	brne	.+34     	; 0x1b00 <T_Display+0x11a>
    1ade:	62 e0       	ldi	r22, 0x02	; 2
    1ae0:	82 e0       	ldi	r24, 0x02	; 2
    1ae2:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1ae6:	86 eb       	ldi	r24, 0xB6	; 182
    1ae8:	90 e0       	ldi	r25, 0x00	; 0
    1aea:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1aee:	62 e0       	ldi	r22, 0x02	; 2
    1af0:	82 e0       	ldi	r24, 0x02	; 2
    1af2:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1af6:	8a eb       	ldi	r24, 0xBA	; 186
    1af8:	90 e0       	ldi	r25, 0x00	; 0
    1afa:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1afe:	10 c0       	rjmp	.+32     	; 0x1b20 <T_Display+0x13a>
    1b00:	62 e0       	ldi	r22, 0x02	; 2
    1b02:	82 e0       	ldi	r24, 0x02	; 2
    1b04:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1b08:	86 eb       	ldi	r24, 0xB6	; 182
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1b10:	62 e0       	ldi	r22, 0x02	; 2
    1b12:	82 e0       	ldi	r24, 0x02	; 2
    1b14:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1b18:	8d eb       	ldi	r24, 0xBD	; 189
    1b1a:	90 e0       	ldi	r25, 0x00	; 0
    1b1c:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1b20:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <Motors_State+0x1>
    1b24:	81 30       	cpi	r24, 0x01	; 1
    1b26:	89 f4       	brne	.+34     	; 0x1b4a <T_Display+0x164>
    1b28:	6a e0       	ldi	r22, 0x0A	; 10
    1b2a:	82 e0       	ldi	r24, 0x02	; 2
    1b2c:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1b30:	86 eb       	ldi	r24, 0xB6	; 182
    1b32:	90 e0       	ldi	r25, 0x00	; 0
    1b34:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1b38:	6a e0       	ldi	r22, 0x0A	; 10
    1b3a:	82 e0       	ldi	r24, 0x02	; 2
    1b3c:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1b40:	8a eb       	ldi	r24, 0xBA	; 186
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1b48:	10 c0       	rjmp	.+32     	; 0x1b6a <T_Display+0x184>
    1b4a:	6a e0       	ldi	r22, 0x0A	; 10
    1b4c:	82 e0       	ldi	r24, 0x02	; 2
    1b4e:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1b52:	86 eb       	ldi	r24, 0xB6	; 182
    1b54:	90 e0       	ldi	r25, 0x00	; 0
    1b56:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1b5a:	6a e0       	ldi	r22, 0x0A	; 10
    1b5c:	82 e0       	ldi	r24, 0x02	; 2
    1b5e:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1b62:	8d eb       	ldi	r24, 0xBD	; 189
    1b64:	90 e0       	ldi	r25, 0x00	; 0
    1b66:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1b6a:	80 91 0f 06 	lds	r24, 0x060F	; 0x80060f <Motors_State+0x2>
    1b6e:	81 30       	cpi	r24, 0x01	; 1
    1b70:	89 f4       	brne	.+34     	; 0x1b94 <T_Display+0x1ae>
    1b72:	61 e1       	ldi	r22, 0x11	; 17
    1b74:	82 e0       	ldi	r24, 0x02	; 2
    1b76:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1b7a:	86 eb       	ldi	r24, 0xB6	; 182
    1b7c:	90 e0       	ldi	r25, 0x00	; 0
    1b7e:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1b82:	61 e1       	ldi	r22, 0x11	; 17
    1b84:	82 e0       	ldi	r24, 0x02	; 2
    1b86:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1b8a:	8a eb       	ldi	r24, 0xBA	; 186
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1b92:	10 c0       	rjmp	.+32     	; 0x1bb4 <T_Display+0x1ce>
    1b94:	61 e1       	ldi	r22, 0x11	; 17
    1b96:	82 e0       	ldi	r24, 0x02	; 2
    1b98:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1b9c:	86 eb       	ldi	r24, 0xB6	; 182
    1b9e:	90 e0       	ldi	r25, 0x00	; 0
    1ba0:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1ba4:	61 e1       	ldi	r22, 0x11	; 17
    1ba6:	82 e0       	ldi	r24, 0x02	; 2
    1ba8:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1bac:	8d eb       	ldi	r24, 0xBD	; 189
    1bae:	90 e0       	ldi	r25, 0x00	; 0
    1bb0:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1bb4:	60 e0       	ldi	r22, 0x00	; 0
    1bb6:	83 e0       	ldi	r24, 0x03	; 3
    1bb8:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1bbc:	81 ec       	ldi	r24, 0xC1	; 193
    1bbe:	90 e0       	ldi	r25, 0x00	; 0
    1bc0:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1bc4:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <ebDisplayBits>
    1bc8:	81 ff       	sbrs	r24, 1
    1bca:	19 c0       	rjmp	.+50     	; 0x1bfe <T_Display+0x218>
    1bcc:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <SFS>
    1bd0:	81 30       	cpi	r24, 0x01	; 1
    1bd2:	a9 f4       	brne	.+42     	; 0x1bfe <T_Display+0x218>
    1bd4:	0e 94 27 11 	call	0x224e	; 0x224e <LCD_clearScreen>
    1bd8:	86 ed       	ldi	r24, 0xD6	; 214
    1bda:	90 e0       	ldi	r25, 0x00	; 0
    1bdc:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1be0:	8b ee       	ldi	r24, 0xEB	; 235
    1be2:	90 e0       	ldi	r25, 0x00	; 0
    1be4:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1be8:	80 e0       	ldi	r24, 0x00	; 0
    1bea:	91 e0       	ldi	r25, 0x01	; 1
    1bec:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1bf0:	6e e0       	ldi	r22, 0x0E	; 14
    1bf2:	80 e0       	ldi	r24, 0x00	; 0
    1bf4:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1bf8:	8f e0       	ldi	r24, 0x0F	; 15
    1bfa:	0e 94 8a 10 	call	0x2114	; 0x2114 <LCD_sendCommand>
    1bfe:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <ebDisplayBits>
    1c02:	84 ff       	sbrs	r24, 4
    1c04:	0c c0       	rjmp	.+24     	; 0x1c1e <T_Display+0x238>
    1c06:	6e e0       	ldi	r22, 0x0E	; 14
    1c08:	80 e0       	ldi	r24, 0x00	; 0
    1c0a:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1c0e:	8c e0       	ldi	r24, 0x0C	; 12
    1c10:	0e 94 8a 10 	call	0x2114	; 0x2114 <LCD_sendCommand>
    1c14:	80 91 09 06 	lds	r24, 0x0609	; 0x800609 <SFS+0x3>
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	0e 94 0f 11 	call	0x221e	; 0x221e <LCD_intgerToString>
    1c1e:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <ebDisplayBits>
    1c22:	85 ff       	sbrs	r24, 5
    1c24:	10 c0       	rjmp	.+32     	; 0x1c46 <T_Display+0x260>
    1c26:	85 e1       	ldi	r24, 0x15	; 21
    1c28:	91 e0       	ldi	r25, 0x01	; 1
    1c2a:	0e 94 a2 11 	call	0x2344	; 0x2344 <usart_puts>
    1c2e:	6e e0       	ldi	r22, 0x0E	; 14
    1c30:	82 e0       	ldi	r24, 0x02	; 2
    1c32:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1c36:	8c e0       	ldi	r24, 0x0C	; 12
    1c38:	0e 94 8a 10 	call	0x2114	; 0x2114 <LCD_sendCommand>
    1c3c:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <SFS+0x4>
    1c40:	90 e0       	ldi	r25, 0x00	; 0
    1c42:	0e 94 0f 11 	call	0x221e	; 0x221e <LCD_intgerToString>
    1c46:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <ebDisplayBits>
    1c4a:	87 ff       	sbrs	r24, 7
    1c4c:	07 c0       	rjmp	.+14     	; 0x1c5c <T_Display+0x276>
    1c4e:	6e e0       	ldi	r22, 0x0E	; 14
    1c50:	82 e0       	ldi	r24, 0x02	; 2
    1c52:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1c56:	8f e0       	ldi	r24, 0x0F	; 15
    1c58:	0e 94 8a 10 	call	0x2114	; 0x2114 <LCD_sendCommand>
    1c5c:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <ebDisplayBits>
    1c60:	83 ff       	sbrs	r24, 3
    1c62:	11 c0       	rjmp	.+34     	; 0x1c86 <T_Display+0x2a0>
    1c64:	64 e0       	ldi	r22, 0x04	; 4
    1c66:	80 e0       	ldi	r24, 0x00	; 0
    1c68:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1c6c:	86 eb       	ldi	r24, 0xB6	; 182
    1c6e:	90 e0       	ldi	r25, 0x00	; 0
    1c70:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1c74:	64 e0       	ldi	r22, 0x04	; 4
    1c76:	80 e0       	ldi	r24, 0x00	; 0
    1c78:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1c7c:	80 91 07 06 	lds	r24, 0x0607	; 0x800607 <SFS+0x1>
    1c80:	90 e0       	ldi	r25, 0x00	; 0
    1c82:	0e 94 0f 11 	call	0x221e	; 0x221e <LCD_intgerToString>
    1c86:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <ebDisplayBits>
    1c8a:	82 ff       	sbrs	r24, 2
    1c8c:	11 c0       	rjmp	.+34     	; 0x1cb0 <T_Display+0x2ca>
    1c8e:	60 e1       	ldi	r22, 0x10	; 16
    1c90:	80 e0       	ldi	r24, 0x00	; 0
    1c92:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1c96:	86 eb       	ldi	r24, 0xB6	; 182
    1c98:	90 e0       	ldi	r25, 0x00	; 0
    1c9a:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1c9e:	60 e1       	ldi	r22, 0x10	; 16
    1ca0:	80 e0       	ldi	r24, 0x00	; 0
    1ca2:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1ca6:	80 91 08 06 	lds	r24, 0x0608	; 0x800608 <SFS+0x2>
    1caa:	90 e0       	ldi	r25, 0x00	; 0
    1cac:	0e 94 0f 11 	call	0x221e	; 0x221e <LCD_intgerToString>
    1cb0:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <SFS>
    1cb4:	81 11       	cpse	r24, r1
    1cb6:	97 ce       	rjmp	.-722    	; 0x19e6 <T_Display>
    1cb8:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <ebDisplayBits>
    1cbc:	86 ff       	sbrs	r24, 6
    1cbe:	93 ce       	rjmp	.-730    	; 0x19e6 <T_Display>
    1cc0:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <Motors_State>
    1cc4:	81 30       	cpi	r24, 0x01	; 1
    1cc6:	89 f4       	brne	.+34     	; 0x1cea <T_Display+0x304>
    1cc8:	62 e0       	ldi	r22, 0x02	; 2
    1cca:	82 e0       	ldi	r24, 0x02	; 2
    1ccc:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1cd0:	86 eb       	ldi	r24, 0xB6	; 182
    1cd2:	90 e0       	ldi	r25, 0x00	; 0
    1cd4:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1cd8:	62 e0       	ldi	r22, 0x02	; 2
    1cda:	82 e0       	ldi	r24, 0x02	; 2
    1cdc:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1ce0:	8a eb       	ldi	r24, 0xBA	; 186
    1ce2:	90 e0       	ldi	r25, 0x00	; 0
    1ce4:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1ce8:	10 c0       	rjmp	.+32     	; 0x1d0a <T_Display+0x324>
    1cea:	62 e0       	ldi	r22, 0x02	; 2
    1cec:	82 e0       	ldi	r24, 0x02	; 2
    1cee:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1cf2:	86 eb       	ldi	r24, 0xB6	; 182
    1cf4:	90 e0       	ldi	r25, 0x00	; 0
    1cf6:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1cfa:	62 e0       	ldi	r22, 0x02	; 2
    1cfc:	82 e0       	ldi	r24, 0x02	; 2
    1cfe:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1d02:	8d eb       	ldi	r24, 0xBD	; 189
    1d04:	90 e0       	ldi	r25, 0x00	; 0
    1d06:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1d0a:	80 91 0e 06 	lds	r24, 0x060E	; 0x80060e <Motors_State+0x1>
    1d0e:	81 30       	cpi	r24, 0x01	; 1
    1d10:	89 f4       	brne	.+34     	; 0x1d34 <T_Display+0x34e>
    1d12:	6a e0       	ldi	r22, 0x0A	; 10
    1d14:	82 e0       	ldi	r24, 0x02	; 2
    1d16:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1d1a:	86 eb       	ldi	r24, 0xB6	; 182
    1d1c:	90 e0       	ldi	r25, 0x00	; 0
    1d1e:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1d22:	6a e0       	ldi	r22, 0x0A	; 10
    1d24:	82 e0       	ldi	r24, 0x02	; 2
    1d26:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1d2a:	8a eb       	ldi	r24, 0xBA	; 186
    1d2c:	90 e0       	ldi	r25, 0x00	; 0
    1d2e:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1d32:	10 c0       	rjmp	.+32     	; 0x1d54 <T_Display+0x36e>
    1d34:	6a e0       	ldi	r22, 0x0A	; 10
    1d36:	82 e0       	ldi	r24, 0x02	; 2
    1d38:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1d3c:	86 eb       	ldi	r24, 0xB6	; 182
    1d3e:	90 e0       	ldi	r25, 0x00	; 0
    1d40:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1d44:	6a e0       	ldi	r22, 0x0A	; 10
    1d46:	82 e0       	ldi	r24, 0x02	; 2
    1d48:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1d4c:	8d eb       	ldi	r24, 0xBD	; 189
    1d4e:	90 e0       	ldi	r25, 0x00	; 0
    1d50:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1d54:	80 91 0f 06 	lds	r24, 0x060F	; 0x80060f <Motors_State+0x2>
    1d58:	81 30       	cpi	r24, 0x01	; 1
    1d5a:	89 f4       	brne	.+34     	; 0x1d7e <T_Display+0x398>
    1d5c:	61 e1       	ldi	r22, 0x11	; 17
    1d5e:	82 e0       	ldi	r24, 0x02	; 2
    1d60:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1d64:	86 eb       	ldi	r24, 0xB6	; 182
    1d66:	90 e0       	ldi	r25, 0x00	; 0
    1d68:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1d6c:	61 e1       	ldi	r22, 0x11	; 17
    1d6e:	82 e0       	ldi	r24, 0x02	; 2
    1d70:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1d74:	8a eb       	ldi	r24, 0xBA	; 186
    1d76:	90 e0       	ldi	r25, 0x00	; 0
    1d78:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1d7c:	34 ce       	rjmp	.-920    	; 0x19e6 <T_Display>
    1d7e:	61 e1       	ldi	r22, 0x11	; 17
    1d80:	82 e0       	ldi	r24, 0x02	; 2
    1d82:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1d86:	86 eb       	ldi	r24, 0xB6	; 182
    1d88:	90 e0       	ldi	r25, 0x00	; 0
    1d8a:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1d8e:	61 e1       	ldi	r22, 0x11	; 17
    1d90:	82 e0       	ldi	r24, 0x02	; 2
    1d92:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <LCD_goToRowColumn>
    1d96:	8d eb       	ldi	r24, 0xBD	; 189
    1d98:	90 e0       	ldi	r25, 0x00	; 0
    1d9a:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
    1d9e:	23 ce       	rjmp	.-954    	; 0x19e6 <T_Display>

00001da0 <System_Init>:

	/*initial system parameters*/


	/* lcd init */
	LCD_init();
    1da0:	0e 94 b0 10 	call	0x2160	; 0x2160 <LCD_init>

	/* ADC init */
	ADC_voidInit();
    1da4:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <ADC_voidInit>


	/* MOTORS */
	DIO_voidSetPinDirection(CONTROL_PORT, WATER_PUMP, DIO_u8_OUTPUT);
    1da8:	41 e0       	ldi	r20, 0x01	; 1
    1daa:	62 e0       	ldi	r22, 0x02	; 2
    1dac:	83 e0       	ldi	r24, 0x03	; 3
    1dae:	0e 94 14 10 	call	0x2028	; 0x2028 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(CONTROL_PORT, HEATER, DIO_u8_OUTPUT);
    1db2:	41 e0       	ldi	r20, 0x01	; 1
    1db4:	63 e0       	ldi	r22, 0x03	; 3
    1db6:	83 e0       	ldi	r24, 0x03	; 3
    1db8:	0e 94 14 10 	call	0x2028	; 0x2028 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(CONTROL_PORT, COOLER, DIO_u8_OUTPUT);
    1dbc:	41 e0       	ldi	r20, 0x01	; 1
    1dbe:	64 e0       	ldi	r22, 0x04	; 4
    1dc0:	83 e0       	ldi	r24, 0x03	; 3
    1dc2:	0e 94 14 10 	call	0x2028	; 0x2028 <DIO_voidSetPinDirection>

	/* initialize to defaults Zero*/
	DIO_voidSetPinValue(CONTROL_PORT, WATER_PUMP, DIO_u8_LOW);
    1dc6:	40 e0       	ldi	r20, 0x00	; 0
    1dc8:	62 e0       	ldi	r22, 0x02	; 2
    1dca:	83 e0       	ldi	r24, 0x03	; 3
    1dcc:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <DIO_voidSetPinValue>
	DIO_voidSetPinValue(CONTROL_PORT, HEATER, DIO_u8_LOW);
    1dd0:	40 e0       	ldi	r20, 0x00	; 0
    1dd2:	63 e0       	ldi	r22, 0x03	; 3
    1dd4:	83 e0       	ldi	r24, 0x03	; 3
    1dd6:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <DIO_voidSetPinValue>
	DIO_voidSetPinValue(CONTROL_PORT, COOLER, DIO_u8_LOW);
    1dda:	40 e0       	ldi	r20, 0x00	; 0
    1ddc:	64 e0       	ldi	r22, 0x04	; 4
    1dde:	83 e0       	ldi	r24, 0x03	; 3
    1de0:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <DIO_voidSetPinValue>

	/* indication led */
	DIO_voidSetPinDirection(DIO_u8_PORTB, DIO_u8_PIN0, DIO_u8_OUTPUT);
    1de4:	41 e0       	ldi	r20, 0x01	; 1
    1de6:	60 e0       	ldi	r22, 0x00	; 0
    1de8:	81 e0       	ldi	r24, 0x01	; 1
    1dea:	0e 94 14 10 	call	0x2028	; 0x2028 <DIO_voidSetPinDirection>
	DIO_voidSetPinValue(DIO_u8_PORTB, DIO_u8_PIN0, DIO_u8_LOW);
    1dee:	40 e0       	ldi	r20, 0x00	; 0
    1df0:	60 e0       	ldi	r22, 0x00	; 0
    1df2:	81 e0       	ldi	r24, 0x01	; 1
    1df4:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <DIO_voidSetPinValue>


	/*Defaults initialize */
	SFS.SensorThreshold.TempT = 20;
    1df8:	e6 e0       	ldi	r30, 0x06	; 6
    1dfa:	f6 e0       	ldi	r31, 0x06	; 6
    1dfc:	84 e1       	ldi	r24, 0x14	; 20
    1dfe:	83 83       	std	Z+3, r24	; 0x03
	SFS.SensorThreshold.HumiT = 30;
    1e00:	8e e1       	ldi	r24, 0x1E	; 30
    1e02:	84 83       	std	Z+4, r24	; 0x04




	/* uart init*/
	usart_init(9600);
    1e04:	80 e8       	ldi	r24, 0x80	; 128
    1e06:	95 e2       	ldi	r25, 0x25	; 37
    1e08:	0e 94 72 11 	call	0x22e4	; 0x22e4 <usart_init>
	usart_puts("System started\r\n");
    1e0c:	81 e2       	ldi	r24, 0x21	; 33
    1e0e:	91 e0       	ldi	r25, 0x01	; 1
    1e10:	0e 94 a2 11 	call	0x2344	; 0x2344 <usart_puts>
    1e14:	08 95       	ret

00001e16 <main>:
#include "App.h"



int main(void)
{
    1e16:	af 92       	push	r10
    1e18:	bf 92       	push	r11
    1e1a:	cf 92       	push	r12
    1e1c:	df 92       	push	r13
    1e1e:	ef 92       	push	r14
    1e20:	ff 92       	push	r15
    1e22:	0f 93       	push	r16
	System_Init();
    1e24:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <System_Init>


	/* OS Object Creation */
	egControl = xEventGroupCreate();
    1e28:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupCreate>
    1e2c:	90 93 03 06 	sts	0x0603, r25	; 0x800603 <egControl+0x1>
    1e30:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <egControl>
	egDisplay = xEventGroupCreate();
    1e34:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupCreate>
    1e38:	90 93 01 06 	sts	0x0601, r25	; 0x800601 <egDisplay+0x1>
    1e3c:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <egDisplay>
	bsCheck = xSemaphoreCreateBinary();
    1e40:	43 e0       	ldi	r20, 0x03	; 3
    1e42:	60 e0       	ldi	r22, 0x00	; 0
    1e44:	81 e0       	ldi	r24, 0x01	; 1
    1e46:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <xQueueGenericCreate>
    1e4a:	90 93 05 06 	sts	0x0605, r25	; 0x800605 <bsCheck+0x1>
    1e4e:	80 93 04 06 	sts	0x0604, r24	; 0x800604 <bsCheck>


	//xTaskCreate(T_Indication, )
	xTaskCreate(T_Display, 	 NULL, 170, NULL, 2, NULL);
    1e52:	a1 2c       	mov	r10, r1
    1e54:	b1 2c       	mov	r11, r1
    1e56:	c1 2c       	mov	r12, r1
    1e58:	d1 2c       	mov	r13, r1
    1e5a:	e1 2c       	mov	r14, r1
    1e5c:	f1 2c       	mov	r15, r1
    1e5e:	02 e0       	ldi	r16, 0x02	; 2
    1e60:	20 e0       	ldi	r18, 0x00	; 0
    1e62:	30 e0       	ldi	r19, 0x00	; 0
    1e64:	4a ea       	ldi	r20, 0xAA	; 170
    1e66:	50 e0       	ldi	r21, 0x00	; 0
    1e68:	60 e0       	ldi	r22, 0x00	; 0
    1e6a:	70 e0       	ldi	r23, 0x00	; 0
    1e6c:	83 ef       	ldi	r24, 0xF3	; 243
    1e6e:	9c e0       	ldi	r25, 0x0C	; 12
    1e70:	0e 94 bf 06 	call	0xd7e	; 0xd7e <xTaskGenericCreate>
	xTaskCreate(T_Sensing, 	 NULL, 100,  NULL, 3, NULL);
    1e74:	03 e0       	ldi	r16, 0x03	; 3
    1e76:	20 e0       	ldi	r18, 0x00	; 0
    1e78:	30 e0       	ldi	r19, 0x00	; 0
    1e7a:	44 e6       	ldi	r20, 0x64	; 100
    1e7c:	50 e0       	ldi	r21, 0x00	; 0
    1e7e:	60 e0       	ldi	r22, 0x00	; 0
    1e80:	70 e0       	ldi	r23, 0x00	; 0
    1e82:	87 ea       	ldi	r24, 0xA7	; 167
    1e84:	9c e0       	ldi	r25, 0x0C	; 12
    1e86:	0e 94 bf 06 	call	0xd7e	; 0xd7e <xTaskGenericCreate>
	xTaskCreate(T_Terminal,  NULL, 70, NULL, 4, NULL);
    1e8a:	04 e0       	ldi	r16, 0x04	; 4
    1e8c:	20 e0       	ldi	r18, 0x00	; 0
    1e8e:	30 e0       	ldi	r19, 0x00	; 0
    1e90:	46 e4       	ldi	r20, 0x46	; 70
    1e92:	50 e0       	ldi	r21, 0x00	; 0
    1e94:	60 e0       	ldi	r22, 0x00	; 0
    1e96:	70 e0       	ldi	r23, 0x00	; 0
    1e98:	83 e6       	ldi	r24, 0x63	; 99
    1e9a:	9b e0       	ldi	r25, 0x0B	; 11
    1e9c:	0e 94 bf 06 	call	0xd7e	; 0xd7e <xTaskGenericCreate>
	xTaskCreate(T_SysCheck,  NULL, 70,  NULL, 5, NULL);
    1ea0:	05 e0       	ldi	r16, 0x05	; 5
    1ea2:	20 e0       	ldi	r18, 0x00	; 0
    1ea4:	30 e0       	ldi	r19, 0x00	; 0
    1ea6:	46 e4       	ldi	r20, 0x46	; 70
    1ea8:	50 e0       	ldi	r21, 0x00	; 0
    1eaa:	60 e0       	ldi	r22, 0x00	; 0
    1eac:	70 e0       	ldi	r23, 0x00	; 0
    1eae:	81 ef       	ldi	r24, 0xF1	; 241
    1eb0:	9a e0       	ldi	r25, 0x0A	; 10
    1eb2:	0e 94 bf 06 	call	0xd7e	; 0xd7e <xTaskGenericCreate>
	xTaskCreate(T_Control,	 NULL, 150, NULL, 6, NULL);
    1eb6:	06 e0       	ldi	r16, 0x06	; 6
    1eb8:	20 e0       	ldi	r18, 0x00	; 0
    1eba:	30 e0       	ldi	r19, 0x00	; 0
    1ebc:	46 e9       	ldi	r20, 0x96	; 150
    1ebe:	50 e0       	ldi	r21, 0x00	; 0
    1ec0:	60 e0       	ldi	r22, 0x00	; 0
    1ec2:	70 e0       	ldi	r23, 0x00	; 0
    1ec4:	85 ea       	ldi	r24, 0xA5	; 165
    1ec6:	9a e0       	ldi	r25, 0x0A	; 10
    1ec8:	0e 94 bf 06 	call	0xd7e	; 0xd7e <xTaskGenericCreate>


	vTaskStartScheduler();
    1ecc:	0e 94 77 07 	call	0xeee	; 0xeee <vTaskStartScheduler>

}
    1ed0:	80 e0       	ldi	r24, 0x00	; 0
    1ed2:	90 e0       	ldi	r25, 0x00	; 0
    1ed4:	0f 91       	pop	r16
    1ed6:	ff 90       	pop	r15
    1ed8:	ef 90       	pop	r14
    1eda:	df 90       	pop	r13
    1edc:	cf 90       	pop	r12
    1ede:	bf 90       	pop	r11
    1ee0:	af 90       	pop	r10
    1ee2:	08 95       	ret

00001ee4 <ADC_voidInit>:

void ADC_voidInit(void)
{

	/* Select the Voltage reference AVCC */
	CLR_BIT(ADMUX,ADMUX_REFS1);
    1ee4:	87 b1       	in	r24, 0x07	; 7
    1ee6:	8f 77       	andi	r24, 0x7F	; 127
    1ee8:	87 b9       	out	0x07, r24	; 7
	SET_BIT(ADMUX,ADMUX_REFS0);
    1eea:	87 b1       	in	r24, 0x07	; 7
    1eec:	80 64       	ori	r24, 0x40	; 64
    1eee:	87 b9       	out	0x07, r24	; 7

	/* Select the right Adjustment */
	CLR_BIT(ADMUX,ADMUX_ADLAR);
    1ef0:	87 b1       	in	r24, 0x07	; 7
    1ef2:	8f 7d       	andi	r24, 0xDF	; 223
    1ef4:	87 b9       	out	0x07, r24	; 7
	/* Select The Prescaler value => 64 */
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
    1ef6:	86 b1       	in	r24, 0x06	; 6
    1ef8:	84 60       	ori	r24, 0x04	; 4
    1efa:	86 b9       	out	0x06, r24	; 6
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
    1efc:	86 b1       	in	r24, 0x06	; 6
    1efe:	82 60       	ori	r24, 0x02	; 2
    1f00:	86 b9       	out	0x06, r24	; 6
	CLR_BIT(ADCSRA,ADCSRA_ADPS0);
    1f02:	86 b1       	in	r24, 0x06	; 6
    1f04:	8e 7f       	andi	r24, 0xFE	; 254
    1f06:	86 b9       	out	0x06, r24	; 6

	/* Enable ADC peripheral */
	SET_BIT(ADCSRA,ADCSRA_ADEN);
    1f08:	86 b1       	in	r24, 0x06	; 6
    1f0a:	80 68       	ori	r24, 0x80	; 128
    1f0c:	86 b9       	out	0x06, r24	; 6
    1f0e:	08 95       	ret

00001f10 <ADC_u16GetDigitalValue>:
}

u16  ADC_u16GetDigitalValue (u8 Copy_u8ChannelNb)
{
	/* Clear The Channel Number bits */
		ADMUX &= (ADMUX_CHANNEL_NUM_MASK);
    1f10:	97 b1       	in	r25, 0x07	; 7
    1f12:	90 7e       	andi	r25, 0xE0	; 224
    1f14:	97 b9       	out	0x07, r25	; 7
		/* Select The Channel Number */
		ADMUX |= Copy_u8ChannelNb;
    1f16:	97 b1       	in	r25, 0x07	; 7
    1f18:	89 2b       	or	r24, r25
    1f1a:	87 b9       	out	0x07, r24	; 7

		/* Start Conversion */
		SET_BIT(ADCSRA,ADCSRA_ADSC);
    1f1c:	86 b1       	in	r24, 0x06	; 6
    1f1e:	80 64       	ori	r24, 0x40	; 64
    1f20:	86 b9       	out	0x06, r24	; 6

		/* Polling on the flag */
		while(GET_BIT(ADCSRA,ADCSRA_ADIF) == 0) { vTaskDelay(5);}
    1f22:	04 c0       	rjmp	.+8      	; 0x1f2c <ADC_u16GetDigitalValue+0x1c>
    1f24:	85 e0       	ldi	r24, 0x05	; 5
    1f26:	90 e0       	ldi	r25, 0x00	; 0
    1f28:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vTaskDelay>
    1f2c:	34 9b       	sbis	0x06, 4	; 6
    1f2e:	fa cf       	rjmp	.-12     	; 0x1f24 <ADC_u16GetDigitalValue+0x14>

		/* Clear Flag */
		SET_BIT(ADCSRA,ADCSRA_ADIF);
    1f30:	86 b1       	in	r24, 0x06	; 6
    1f32:	80 61       	ori	r24, 0x10	; 16
    1f34:	86 b9       	out	0x06, r24	; 6

		/* Read the ADC value */
		return ADC;
    1f36:	84 b1       	in	r24, 0x04	; 4
    1f38:	95 b1       	in	r25, 0x05	; 5
}
    1f3a:	08 95       	ret

00001f3c <DIO_voidSetPinValue>:
		/* return 0xff in case of error in the Pin ID or PORT ID */
		u8ResultLocal = 0xFF;
	}
	
	return u8ResultLocal;
}
    1f3c:	84 30       	cpi	r24, 0x04	; 4
    1f3e:	08 f0       	brcs	.+2      	; 0x1f42 <DIO_voidSetPinValue+0x6>
    1f40:	72 c0       	rjmp	.+228    	; 0x2026 <DIO_voidSetPinValue+0xea>
    1f42:	68 30       	cpi	r22, 0x08	; 8
    1f44:	08 f0       	brcs	.+2      	; 0x1f48 <DIO_voidSetPinValue+0xc>
    1f46:	6f c0       	rjmp	.+222    	; 0x2026 <DIO_voidSetPinValue+0xea>
    1f48:	41 30       	cpi	r20, 0x01	; 1
    1f4a:	a1 f5       	brne	.+104    	; 0x1fb4 <DIO_voidSetPinValue+0x78>
    1f4c:	81 30       	cpi	r24, 0x01	; 1
    1f4e:	89 f0       	breq	.+34     	; 0x1f72 <DIO_voidSetPinValue+0x36>
    1f50:	28 f0       	brcs	.+10     	; 0x1f5c <DIO_voidSetPinValue+0x20>
    1f52:	82 30       	cpi	r24, 0x02	; 2
    1f54:	c9 f0       	breq	.+50     	; 0x1f88 <DIO_voidSetPinValue+0x4c>
    1f56:	83 30       	cpi	r24, 0x03	; 3
    1f58:	11 f1       	breq	.+68     	; 0x1f9e <DIO_voidSetPinValue+0x62>
    1f5a:	08 95       	ret
    1f5c:	2b b3       	in	r18, 0x1b	; 27
    1f5e:	81 e0       	ldi	r24, 0x01	; 1
    1f60:	90 e0       	ldi	r25, 0x00	; 0
    1f62:	02 c0       	rjmp	.+4      	; 0x1f68 <DIO_voidSetPinValue+0x2c>
    1f64:	88 0f       	add	r24, r24
    1f66:	99 1f       	adc	r25, r25
    1f68:	6a 95       	dec	r22
    1f6a:	e2 f7       	brpl	.-8      	; 0x1f64 <DIO_voidSetPinValue+0x28>
    1f6c:	82 2b       	or	r24, r18
    1f6e:	8b bb       	out	0x1b, r24	; 27
    1f70:	08 95       	ret
    1f72:	28 b3       	in	r18, 0x18	; 24
    1f74:	81 e0       	ldi	r24, 0x01	; 1
    1f76:	90 e0       	ldi	r25, 0x00	; 0
    1f78:	02 c0       	rjmp	.+4      	; 0x1f7e <DIO_voidSetPinValue+0x42>
    1f7a:	88 0f       	add	r24, r24
    1f7c:	99 1f       	adc	r25, r25
    1f7e:	6a 95       	dec	r22
    1f80:	e2 f7       	brpl	.-8      	; 0x1f7a <DIO_voidSetPinValue+0x3e>
    1f82:	82 2b       	or	r24, r18
    1f84:	88 bb       	out	0x18, r24	; 24
    1f86:	08 95       	ret
    1f88:	25 b3       	in	r18, 0x15	; 21
    1f8a:	81 e0       	ldi	r24, 0x01	; 1
    1f8c:	90 e0       	ldi	r25, 0x00	; 0
    1f8e:	02 c0       	rjmp	.+4      	; 0x1f94 <DIO_voidSetPinValue+0x58>
    1f90:	88 0f       	add	r24, r24
    1f92:	99 1f       	adc	r25, r25
    1f94:	6a 95       	dec	r22
    1f96:	e2 f7       	brpl	.-8      	; 0x1f90 <DIO_voidSetPinValue+0x54>
    1f98:	82 2b       	or	r24, r18
    1f9a:	85 bb       	out	0x15, r24	; 21
    1f9c:	08 95       	ret
    1f9e:	22 b3       	in	r18, 0x12	; 18
    1fa0:	81 e0       	ldi	r24, 0x01	; 1
    1fa2:	90 e0       	ldi	r25, 0x00	; 0
    1fa4:	02 c0       	rjmp	.+4      	; 0x1faa <DIO_voidSetPinValue+0x6e>
    1fa6:	88 0f       	add	r24, r24
    1fa8:	99 1f       	adc	r25, r25
    1faa:	6a 95       	dec	r22
    1fac:	e2 f7       	brpl	.-8      	; 0x1fa6 <DIO_voidSetPinValue+0x6a>
    1fae:	82 2b       	or	r24, r18
    1fb0:	82 bb       	out	0x12, r24	; 18
    1fb2:	08 95       	ret
    1fb4:	41 11       	cpse	r20, r1
    1fb6:	37 c0       	rjmp	.+110    	; 0x2026 <DIO_voidSetPinValue+0xea>
    1fb8:	81 30       	cpi	r24, 0x01	; 1
    1fba:	91 f0       	breq	.+36     	; 0x1fe0 <DIO_voidSetPinValue+0xa4>
    1fbc:	28 f0       	brcs	.+10     	; 0x1fc8 <DIO_voidSetPinValue+0x8c>
    1fbe:	82 30       	cpi	r24, 0x02	; 2
    1fc0:	d9 f0       	breq	.+54     	; 0x1ff8 <DIO_voidSetPinValue+0xbc>
    1fc2:	83 30       	cpi	r24, 0x03	; 3
    1fc4:	29 f1       	breq	.+74     	; 0x2010 <DIO_voidSetPinValue+0xd4>
    1fc6:	08 95       	ret
    1fc8:	2b b3       	in	r18, 0x1b	; 27
    1fca:	81 e0       	ldi	r24, 0x01	; 1
    1fcc:	90 e0       	ldi	r25, 0x00	; 0
    1fce:	02 c0       	rjmp	.+4      	; 0x1fd4 <DIO_voidSetPinValue+0x98>
    1fd0:	88 0f       	add	r24, r24
    1fd2:	99 1f       	adc	r25, r25
    1fd4:	6a 95       	dec	r22
    1fd6:	e2 f7       	brpl	.-8      	; 0x1fd0 <DIO_voidSetPinValue+0x94>
    1fd8:	80 95       	com	r24
    1fda:	82 23       	and	r24, r18
    1fdc:	8b bb       	out	0x1b, r24	; 27
    1fde:	08 95       	ret
    1fe0:	28 b3       	in	r18, 0x18	; 24
    1fe2:	81 e0       	ldi	r24, 0x01	; 1
    1fe4:	90 e0       	ldi	r25, 0x00	; 0
    1fe6:	02 c0       	rjmp	.+4      	; 0x1fec <DIO_voidSetPinValue+0xb0>
    1fe8:	88 0f       	add	r24, r24
    1fea:	99 1f       	adc	r25, r25
    1fec:	6a 95       	dec	r22
    1fee:	e2 f7       	brpl	.-8      	; 0x1fe8 <DIO_voidSetPinValue+0xac>
    1ff0:	80 95       	com	r24
    1ff2:	82 23       	and	r24, r18
    1ff4:	88 bb       	out	0x18, r24	; 24
    1ff6:	08 95       	ret
    1ff8:	25 b3       	in	r18, 0x15	; 21
    1ffa:	81 e0       	ldi	r24, 0x01	; 1
    1ffc:	90 e0       	ldi	r25, 0x00	; 0
    1ffe:	02 c0       	rjmp	.+4      	; 0x2004 <DIO_voidSetPinValue+0xc8>
    2000:	88 0f       	add	r24, r24
    2002:	99 1f       	adc	r25, r25
    2004:	6a 95       	dec	r22
    2006:	e2 f7       	brpl	.-8      	; 0x2000 <DIO_voidSetPinValue+0xc4>
    2008:	80 95       	com	r24
    200a:	82 23       	and	r24, r18
    200c:	85 bb       	out	0x15, r24	; 21
    200e:	08 95       	ret
    2010:	22 b3       	in	r18, 0x12	; 18
    2012:	81 e0       	ldi	r24, 0x01	; 1
    2014:	90 e0       	ldi	r25, 0x00	; 0
    2016:	02 c0       	rjmp	.+4      	; 0x201c <DIO_voidSetPinValue+0xe0>
    2018:	88 0f       	add	r24, r24
    201a:	99 1f       	adc	r25, r25
    201c:	6a 95       	dec	r22
    201e:	e2 f7       	brpl	.-8      	; 0x2018 <DIO_voidSetPinValue+0xdc>
    2020:	80 95       	com	r24
    2022:	82 23       	and	r24, r18
    2024:	82 bb       	out	0x12, r24	; 18
    2026:	08 95       	ret

00002028 <DIO_voidSetPinDirection>:

void DIO_voidSetPinDirection  (u8 u8PortIdCopy, u8 u8PinIdCopy, u8 u8PinDirCopy)
{
	/* Make sure that the Port ID and Pin ID are in the valid range */
	if ((u8PortIdCopy <= DIO_u8_PORTD) && (u8PinIdCopy <= DIO_u8_PIN7))
    2028:	84 30       	cpi	r24, 0x04	; 4
    202a:	08 f0       	brcs	.+2      	; 0x202e <DIO_voidSetPinDirection+0x6>
    202c:	72 c0       	rjmp	.+228    	; 0x2112 <DIO_voidSetPinDirection+0xea>
    202e:	68 30       	cpi	r22, 0x08	; 8
    2030:	08 f0       	brcs	.+2      	; 0x2034 <DIO_voidSetPinDirection+0xc>
    2032:	6f c0       	rjmp	.+222    	; 0x2112 <DIO_voidSetPinDirection+0xea>
	{
		if ( u8PinDirCopy == DIO_u8_OUTPUT )
    2034:	41 30       	cpi	r20, 0x01	; 1
    2036:	a1 f5       	brne	.+104    	; 0x20a0 <DIO_voidSetPinDirection+0x78>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
    2038:	81 30       	cpi	r24, 0x01	; 1
    203a:	89 f0       	breq	.+34     	; 0x205e <DIO_voidSetPinDirection+0x36>
    203c:	28 f0       	brcs	.+10     	; 0x2048 <DIO_voidSetPinDirection+0x20>
    203e:	82 30       	cpi	r24, 0x02	; 2
    2040:	c9 f0       	breq	.+50     	; 0x2074 <DIO_voidSetPinDirection+0x4c>
    2042:	83 30       	cpi	r24, 0x03	; 3
    2044:	11 f1       	breq	.+68     	; 0x208a <DIO_voidSetPinDirection+0x62>
    2046:	08 95       	ret
			{
				case DIO_u8_PORTA: SET_BIT(DDRA_Register,u8PinIdCopy); break;
    2048:	2a b3       	in	r18, 0x1a	; 26
    204a:	81 e0       	ldi	r24, 0x01	; 1
    204c:	90 e0       	ldi	r25, 0x00	; 0
    204e:	02 c0       	rjmp	.+4      	; 0x2054 <DIO_voidSetPinDirection+0x2c>
    2050:	88 0f       	add	r24, r24
    2052:	99 1f       	adc	r25, r25
    2054:	6a 95       	dec	r22
    2056:	e2 f7       	brpl	.-8      	; 0x2050 <DIO_voidSetPinDirection+0x28>
    2058:	82 2b       	or	r24, r18
    205a:	8a bb       	out	0x1a, r24	; 26
    205c:	08 95       	ret
				case DIO_u8_PORTB: SET_BIT(DDRB_Register,u8PinIdCopy); break;
    205e:	27 b3       	in	r18, 0x17	; 23
    2060:	81 e0       	ldi	r24, 0x01	; 1
    2062:	90 e0       	ldi	r25, 0x00	; 0
    2064:	02 c0       	rjmp	.+4      	; 0x206a <DIO_voidSetPinDirection+0x42>
    2066:	88 0f       	add	r24, r24
    2068:	99 1f       	adc	r25, r25
    206a:	6a 95       	dec	r22
    206c:	e2 f7       	brpl	.-8      	; 0x2066 <DIO_voidSetPinDirection+0x3e>
    206e:	82 2b       	or	r24, r18
    2070:	87 bb       	out	0x17, r24	; 23
    2072:	08 95       	ret
				case DIO_u8_PORTC: SET_BIT(DDRC_Register,u8PinIdCopy); break;
    2074:	24 b3       	in	r18, 0x14	; 20
    2076:	81 e0       	ldi	r24, 0x01	; 1
    2078:	90 e0       	ldi	r25, 0x00	; 0
    207a:	02 c0       	rjmp	.+4      	; 0x2080 <DIO_voidSetPinDirection+0x58>
    207c:	88 0f       	add	r24, r24
    207e:	99 1f       	adc	r25, r25
    2080:	6a 95       	dec	r22
    2082:	e2 f7       	brpl	.-8      	; 0x207c <DIO_voidSetPinDirection+0x54>
    2084:	82 2b       	or	r24, r18
    2086:	84 bb       	out	0x14, r24	; 20
    2088:	08 95       	ret
				case DIO_u8_PORTD: SET_BIT(DDRD_Register,u8PinIdCopy); break;
    208a:	21 b3       	in	r18, 0x11	; 17
    208c:	81 e0       	ldi	r24, 0x01	; 1
    208e:	90 e0       	ldi	r25, 0x00	; 0
    2090:	02 c0       	rjmp	.+4      	; 0x2096 <DIO_voidSetPinDirection+0x6e>
    2092:	88 0f       	add	r24, r24
    2094:	99 1f       	adc	r25, r25
    2096:	6a 95       	dec	r22
    2098:	e2 f7       	brpl	.-8      	; 0x2092 <DIO_voidSetPinDirection+0x6a>
    209a:	82 2b       	or	r24, r18
    209c:	81 bb       	out	0x11, r24	; 17
    209e:	08 95       	ret
			}
		}
		
		else if ( u8PinDirCopy == DIO_u8_INPUT )
    20a0:	41 11       	cpse	r20, r1
    20a2:	37 c0       	rjmp	.+110    	; 0x2112 <DIO_voidSetPinDirection+0xea>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
    20a4:	81 30       	cpi	r24, 0x01	; 1
    20a6:	91 f0       	breq	.+36     	; 0x20cc <DIO_voidSetPinDirection+0xa4>
    20a8:	28 f0       	brcs	.+10     	; 0x20b4 <DIO_voidSetPinDirection+0x8c>
    20aa:	82 30       	cpi	r24, 0x02	; 2
    20ac:	d9 f0       	breq	.+54     	; 0x20e4 <DIO_voidSetPinDirection+0xbc>
    20ae:	83 30       	cpi	r24, 0x03	; 3
    20b0:	29 f1       	breq	.+74     	; 0x20fc <DIO_voidSetPinDirection+0xd4>
    20b2:	08 95       	ret
			{
				case DIO_u8_PORTA: CLR_BIT(DDRA_Register,u8PinIdCopy); break;
    20b4:	2a b3       	in	r18, 0x1a	; 26
    20b6:	81 e0       	ldi	r24, 0x01	; 1
    20b8:	90 e0       	ldi	r25, 0x00	; 0
    20ba:	02 c0       	rjmp	.+4      	; 0x20c0 <DIO_voidSetPinDirection+0x98>
    20bc:	88 0f       	add	r24, r24
    20be:	99 1f       	adc	r25, r25
    20c0:	6a 95       	dec	r22
    20c2:	e2 f7       	brpl	.-8      	; 0x20bc <DIO_voidSetPinDirection+0x94>
    20c4:	80 95       	com	r24
    20c6:	82 23       	and	r24, r18
    20c8:	8a bb       	out	0x1a, r24	; 26
    20ca:	08 95       	ret
				case DIO_u8_PORTB: CLR_BIT(DDRB_Register,u8PinIdCopy); break;
    20cc:	27 b3       	in	r18, 0x17	; 23
    20ce:	81 e0       	ldi	r24, 0x01	; 1
    20d0:	90 e0       	ldi	r25, 0x00	; 0
    20d2:	02 c0       	rjmp	.+4      	; 0x20d8 <DIO_voidSetPinDirection+0xb0>
    20d4:	88 0f       	add	r24, r24
    20d6:	99 1f       	adc	r25, r25
    20d8:	6a 95       	dec	r22
    20da:	e2 f7       	brpl	.-8      	; 0x20d4 <DIO_voidSetPinDirection+0xac>
    20dc:	80 95       	com	r24
    20de:	82 23       	and	r24, r18
    20e0:	87 bb       	out	0x17, r24	; 23
    20e2:	08 95       	ret
				case DIO_u8_PORTC: CLR_BIT(DDRC_Register,u8PinIdCopy); break;
    20e4:	24 b3       	in	r18, 0x14	; 20
    20e6:	81 e0       	ldi	r24, 0x01	; 1
    20e8:	90 e0       	ldi	r25, 0x00	; 0
    20ea:	02 c0       	rjmp	.+4      	; 0x20f0 <DIO_voidSetPinDirection+0xc8>
    20ec:	88 0f       	add	r24, r24
    20ee:	99 1f       	adc	r25, r25
    20f0:	6a 95       	dec	r22
    20f2:	e2 f7       	brpl	.-8      	; 0x20ec <DIO_voidSetPinDirection+0xc4>
    20f4:	80 95       	com	r24
    20f6:	82 23       	and	r24, r18
    20f8:	84 bb       	out	0x14, r24	; 20
    20fa:	08 95       	ret
				case DIO_u8_PORTD: CLR_BIT(DDRD_Register,u8PinIdCopy); break;
    20fc:	21 b3       	in	r18, 0x11	; 17
    20fe:	81 e0       	ldi	r24, 0x01	; 1
    2100:	90 e0       	ldi	r25, 0x00	; 0
    2102:	02 c0       	rjmp	.+4      	; 0x2108 <DIO_voidSetPinDirection+0xe0>
    2104:	88 0f       	add	r24, r24
    2106:	99 1f       	adc	r25, r25
    2108:	6a 95       	dec	r22
    210a:	e2 f7       	brpl	.-8      	; 0x2104 <DIO_voidSetPinDirection+0xdc>
    210c:	80 95       	com	r24
    210e:	82 23       	and	r24, r18
    2110:	81 bb       	out	0x11, r24	; 17
    2112:	08 95       	ret

00002114 <LCD_sendCommand>:

void LCD_displayStringRowColumn(uint8 row,uint8 col,const char *Str)
{
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
	LCD_displayString(Str); /* display the string */
}
    2114:	92 b3       	in	r25, 0x12	; 18
    2116:	9f 7d       	andi	r25, 0xDF	; 223
    2118:	92 bb       	out	0x12, r25	; 18
    211a:	92 b3       	in	r25, 0x12	; 18
    211c:	9f 7b       	andi	r25, 0xBF	; 191
    211e:	92 bb       	out	0x12, r25	; 18
    2120:	e9 ef       	ldi	r30, 0xF9	; 249
    2122:	f0 e0       	ldi	r31, 0x00	; 0
    2124:	31 97       	sbiw	r30, 0x01	; 1
    2126:	f1 f7       	brne	.-4      	; 0x2124 <LCD_sendCommand+0x10>
    2128:	00 c0       	rjmp	.+0      	; 0x212a <LCD_sendCommand+0x16>
    212a:	00 00       	nop
    212c:	92 b3       	in	r25, 0x12	; 18
    212e:	90 68       	ori	r25, 0x80	; 128
    2130:	92 bb       	out	0x12, r25	; 18
    2132:	e9 ef       	ldi	r30, 0xF9	; 249
    2134:	f0 e0       	ldi	r31, 0x00	; 0
    2136:	31 97       	sbiw	r30, 0x01	; 1
    2138:	f1 f7       	brne	.-4      	; 0x2136 <LCD_sendCommand+0x22>
    213a:	00 c0       	rjmp	.+0      	; 0x213c <LCD_sendCommand+0x28>
    213c:	00 00       	nop
    213e:	85 bb       	out	0x15, r24	; 21
    2140:	89 ef       	ldi	r24, 0xF9	; 249
    2142:	90 e0       	ldi	r25, 0x00	; 0
    2144:	01 97       	sbiw	r24, 0x01	; 1
    2146:	f1 f7       	brne	.-4      	; 0x2144 <LCD_sendCommand+0x30>
    2148:	00 c0       	rjmp	.+0      	; 0x214a <LCD_sendCommand+0x36>
    214a:	00 00       	nop
    214c:	82 b3       	in	r24, 0x12	; 18
    214e:	8f 77       	andi	r24, 0x7F	; 127
    2150:	82 bb       	out	0x12, r24	; 18
    2152:	e9 ef       	ldi	r30, 0xF9	; 249
    2154:	f0 e0       	ldi	r31, 0x00	; 0
    2156:	31 97       	sbiw	r30, 0x01	; 1
    2158:	f1 f7       	brne	.-4      	; 0x2156 <LCD_sendCommand+0x42>
    215a:	00 c0       	rjmp	.+0      	; 0x215c <LCD_sendCommand+0x48>
    215c:	00 00       	nop
    215e:	08 95       	ret

00002160 <LCD_init>:
    2160:	81 b3       	in	r24, 0x11	; 17
    2162:	80 6e       	ori	r24, 0xE0	; 224
    2164:	81 bb       	out	0x11, r24	; 17
    2166:	8f ef       	ldi	r24, 0xFF	; 255
    2168:	84 bb       	out	0x14, r24	; 20
    216a:	88 e3       	ldi	r24, 0x38	; 56
    216c:	0e 94 8a 10 	call	0x2114	; 0x2114 <LCD_sendCommand>
    2170:	8c e0       	ldi	r24, 0x0C	; 12
    2172:	0e 94 8a 10 	call	0x2114	; 0x2114 <LCD_sendCommand>
    2176:	81 e0       	ldi	r24, 0x01	; 1
    2178:	0e 94 8a 10 	call	0x2114	; 0x2114 <LCD_sendCommand>
    217c:	08 95       	ret

0000217e <LCD_displayCharacter>:
    217e:	92 b3       	in	r25, 0x12	; 18
    2180:	90 62       	ori	r25, 0x20	; 32
    2182:	92 bb       	out	0x12, r25	; 18
    2184:	92 b3       	in	r25, 0x12	; 18
    2186:	9f 7b       	andi	r25, 0xBF	; 191
    2188:	92 bb       	out	0x12, r25	; 18
    218a:	e9 ef       	ldi	r30, 0xF9	; 249
    218c:	f0 e0       	ldi	r31, 0x00	; 0
    218e:	31 97       	sbiw	r30, 0x01	; 1
    2190:	f1 f7       	brne	.-4      	; 0x218e <LCD_displayCharacter+0x10>
    2192:	00 c0       	rjmp	.+0      	; 0x2194 <LCD_displayCharacter+0x16>
    2194:	00 00       	nop
    2196:	92 b3       	in	r25, 0x12	; 18
    2198:	90 68       	ori	r25, 0x80	; 128
    219a:	92 bb       	out	0x12, r25	; 18
    219c:	e9 ef       	ldi	r30, 0xF9	; 249
    219e:	f0 e0       	ldi	r31, 0x00	; 0
    21a0:	31 97       	sbiw	r30, 0x01	; 1
    21a2:	f1 f7       	brne	.-4      	; 0x21a0 <LCD_displayCharacter+0x22>
    21a4:	00 c0       	rjmp	.+0      	; 0x21a6 <LCD_displayCharacter+0x28>
    21a6:	00 00       	nop
    21a8:	85 bb       	out	0x15, r24	; 21
    21aa:	89 ef       	ldi	r24, 0xF9	; 249
    21ac:	90 e0       	ldi	r25, 0x00	; 0
    21ae:	01 97       	sbiw	r24, 0x01	; 1
    21b0:	f1 f7       	brne	.-4      	; 0x21ae <LCD_displayCharacter+0x30>
    21b2:	00 c0       	rjmp	.+0      	; 0x21b4 <LCD_displayCharacter+0x36>
    21b4:	00 00       	nop
    21b6:	82 b3       	in	r24, 0x12	; 18
    21b8:	8f 77       	andi	r24, 0x7F	; 127
    21ba:	82 bb       	out	0x12, r24	; 18
    21bc:	e9 ef       	ldi	r30, 0xF9	; 249
    21be:	f0 e0       	ldi	r31, 0x00	; 0
    21c0:	31 97       	sbiw	r30, 0x01	; 1
    21c2:	f1 f7       	brne	.-4      	; 0x21c0 <LCD_displayCharacter+0x42>
    21c4:	00 c0       	rjmp	.+0      	; 0x21c6 <LCD_displayCharacter+0x48>
    21c6:	00 00       	nop
    21c8:	08 95       	ret

000021ca <LCD_displayString>:
    21ca:	0f 93       	push	r16
    21cc:	1f 93       	push	r17
    21ce:	cf 93       	push	r28
    21d0:	8c 01       	movw	r16, r24
    21d2:	c0 e0       	ldi	r28, 0x00	; 0
    21d4:	03 c0       	rjmp	.+6      	; 0x21dc <LCD_displayString+0x12>
    21d6:	0e 94 bf 10 	call	0x217e	; 0x217e <LCD_displayCharacter>
    21da:	cf 5f       	subi	r28, 0xFF	; 255
    21dc:	f8 01       	movw	r30, r16
    21de:	ec 0f       	add	r30, r28
    21e0:	f1 1d       	adc	r31, r1
    21e2:	80 81       	ld	r24, Z
    21e4:	81 11       	cpse	r24, r1
    21e6:	f7 cf       	rjmp	.-18     	; 0x21d6 <LCD_displayString+0xc>
    21e8:	cf 91       	pop	r28
    21ea:	1f 91       	pop	r17
    21ec:	0f 91       	pop	r16
    21ee:	08 95       	ret

000021f0 <LCD_goToRowColumn>:
    21f0:	81 30       	cpi	r24, 0x01	; 1
    21f2:	31 f0       	breq	.+12     	; 0x2200 <LCD_goToRowColumn+0x10>
    21f4:	70 f0       	brcs	.+28     	; 0x2212 <LCD_goToRowColumn+0x22>
    21f6:	82 30       	cpi	r24, 0x02	; 2
    21f8:	31 f0       	breq	.+12     	; 0x2206 <LCD_goToRowColumn+0x16>
    21fa:	83 30       	cpi	r24, 0x03	; 3
    21fc:	39 f0       	breq	.+14     	; 0x220c <LCD_goToRowColumn+0x1c>
    21fe:	0a c0       	rjmp	.+20     	; 0x2214 <LCD_goToRowColumn+0x24>
    2200:	90 e4       	ldi	r25, 0x40	; 64
    2202:	96 0f       	add	r25, r22
    2204:	07 c0       	rjmp	.+14     	; 0x2214 <LCD_goToRowColumn+0x24>
    2206:	94 e1       	ldi	r25, 0x14	; 20
    2208:	96 0f       	add	r25, r22
    220a:	04 c0       	rjmp	.+8      	; 0x2214 <LCD_goToRowColumn+0x24>
    220c:	94 e5       	ldi	r25, 0x54	; 84
    220e:	96 0f       	add	r25, r22
    2210:	01 c0       	rjmp	.+2      	; 0x2214 <LCD_goToRowColumn+0x24>
    2212:	96 2f       	mov	r25, r22
    2214:	89 2f       	mov	r24, r25
    2216:	80 68       	ori	r24, 0x80	; 128
    2218:	0e 94 8a 10 	call	0x2114	; 0x2114 <LCD_sendCommand>
    221c:	08 95       	ret

0000221e <LCD_intgerToString>:

void LCD_intgerToString(int data)
{
    221e:	cf 93       	push	r28
    2220:	df 93       	push	r29
    2222:	00 d0       	rcall	.+0      	; 0x2224 <LCD_intgerToString+0x6>
    2224:	00 d0       	rcall	.+0      	; 0x2226 <LCD_intgerToString+0x8>
    2226:	cd b7       	in	r28, 0x3d	; 61
    2228:	de b7       	in	r29, 0x3e	; 62
   char buff[4]; /* String to hold the ascii result */
   itoa(data,buff,10); /* 10 for decimal */
    222a:	4a e0       	ldi	r20, 0x0A	; 10
    222c:	50 e0       	ldi	r21, 0x00	; 0
    222e:	be 01       	movw	r22, r28
    2230:	6f 5f       	subi	r22, 0xFF	; 255
    2232:	7f 4f       	sbci	r23, 0xFF	; 255
    2234:	0e 94 3a 13 	call	0x2674	; 0x2674 <itoa>
   LCD_displayString(buff);
    2238:	ce 01       	movw	r24, r28
    223a:	01 96       	adiw	r24, 0x01	; 1
    223c:	0e 94 e5 10 	call	0x21ca	; 0x21ca <LCD_displayString>
}
    2240:	0f 90       	pop	r0
    2242:	0f 90       	pop	r0
    2244:	0f 90       	pop	r0
    2246:	0f 90       	pop	r0
    2248:	df 91       	pop	r29
    224a:	cf 91       	pop	r28
    224c:	08 95       	ret

0000224e <LCD_clearScreen>:

void LCD_clearScreen(void)
{
	LCD_sendCommand(CLEAR_COMMAND); /* clear display */ 
    224e:	81 e0       	ldi	r24, 0x01	; 1
    2250:	0e 94 8a 10 	call	0x2114	; 0x2114 <LCD_sendCommand>
    2254:	08 95       	ret

00002256 <TEMP_u16_Read>:
#include "sensors.h"
#include "STD_TYPES.h"
#include "ADC_interface.h"
ERROR_t TEMP_u16_Read(u16 * pTemp)
{
    2256:	cf 93       	push	r28
    2258:	df 93       	push	r29
    225a:	ec 01       	movw	r28, r24
		*pTemp = (adc_read*150*5)/(1023*1.5);
		return E_OK;
	}
#else
	/* ILLEGAL NON Blocking */
	adc_read = ADC_u16GetDigitalValue(0);
    225c:	80 e0       	ldi	r24, 0x00	; 0
    225e:	0e 94 88 0f 	call	0x1f10	; 0x1f10 <ADC_u16GetDigitalValue>

	*pTemp = (u16)(adc_read * 48.80) / 100;
    2262:	bc 01       	movw	r22, r24
    2264:	80 e0       	ldi	r24, 0x00	; 0
    2266:	90 e0       	ldi	r25, 0x00	; 0
    2268:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__floatunsisf>
    226c:	23 e3       	ldi	r18, 0x33	; 51
    226e:	33 e3       	ldi	r19, 0x33	; 51
    2270:	43 e4       	ldi	r20, 0x43	; 67
    2272:	52 e4       	ldi	r21, 0x42	; 66
    2274:	0e 94 4d 12 	call	0x249a	; 0x249a <__mulsf3>
    2278:	0e 94 b8 11 	call	0x2370	; 0x2370 <__fixunssfsi>
    227c:	9b 01       	movw	r18, r22
    227e:	36 95       	lsr	r19
    2280:	27 95       	ror	r18
    2282:	36 95       	lsr	r19
    2284:	27 95       	ror	r18
    2286:	ab e7       	ldi	r26, 0x7B	; 123
    2288:	b4 e1       	ldi	r27, 0x14	; 20
    228a:	0e 94 04 13 	call	0x2608	; 0x2608 <__umulhisi3>
    228e:	96 95       	lsr	r25
    2290:	87 95       	ror	r24
    2292:	99 83       	std	Y+1, r25	; 0x01
    2294:	88 83       	st	Y, r24

#endif

	return E_OK;

}
    2296:	80 e0       	ldi	r24, 0x00	; 0
    2298:	df 91       	pop	r29
    229a:	cf 91       	pop	r28
    229c:	08 95       	ret

0000229e <Humit_u16_Read>:

ERROR_t Humit_u16_Read(u8 * pHumi)
{
    229e:	cf 93       	push	r28
    22a0:	df 93       	push	r29
    22a2:	ec 01       	movw	r28, r24
		*pHumi = adc_read;
		return E_OK;
	}
#else
	/* ILLEGAL NON Blocking */
	adc_read = ADC_u16GetDigitalValue(1);
    22a4:	81 e0       	ldi	r24, 0x01	; 1
    22a6:	0e 94 88 0f 	call	0x1f10	; 0x1f10 <ADC_u16GetDigitalValue>
	usart_puts("adc: ");
	usart_puts(str);
	usart_puts("\r\n");
    */

	*pHumi = (u16)(adc_read * 48.80) / 100;
    22aa:	bc 01       	movw	r22, r24
    22ac:	80 e0       	ldi	r24, 0x00	; 0
    22ae:	90 e0       	ldi	r25, 0x00	; 0
    22b0:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__floatunsisf>
    22b4:	23 e3       	ldi	r18, 0x33	; 51
    22b6:	33 e3       	ldi	r19, 0x33	; 51
    22b8:	43 e4       	ldi	r20, 0x43	; 67
    22ba:	52 e4       	ldi	r21, 0x42	; 66
    22bc:	0e 94 4d 12 	call	0x249a	; 0x249a <__mulsf3>
    22c0:	0e 94 b8 11 	call	0x2370	; 0x2370 <__fixunssfsi>
    22c4:	9b 01       	movw	r18, r22
    22c6:	36 95       	lsr	r19
    22c8:	27 95       	ror	r18
    22ca:	36 95       	lsr	r19
    22cc:	27 95       	ror	r18
    22ce:	ab e7       	ldi	r26, 0x7B	; 123
    22d0:	b4 e1       	ldi	r27, 0x14	; 20
    22d2:	0e 94 04 13 	call	0x2608	; 0x2608 <__umulhisi3>
    22d6:	96 95       	lsr	r25
    22d8:	87 95       	ror	r24
    22da:	88 83       	st	Y, r24


#endif
	return E_OK;

}
    22dc:	80 e0       	ldi	r24, 0x00	; 0
    22de:	df 91       	pop	r29
    22e0:	cf 91       	pop	r28
    22e2:	08 95       	ret

000022e4 <usart_init>:
{
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<RXC)) );
	/* Get and return received data from buffer */
	return UDR;
}
    22e4:	a0 e0       	ldi	r26, 0x00	; 0
    22e6:	b0 e0       	ldi	r27, 0x00	; 0
    22e8:	88 0f       	add	r24, r24
    22ea:	99 1f       	adc	r25, r25
    22ec:	aa 1f       	adc	r26, r26
    22ee:	bb 1f       	adc	r27, r27
    22f0:	88 0f       	add	r24, r24
    22f2:	99 1f       	adc	r25, r25
    22f4:	aa 1f       	adc	r26, r26
    22f6:	bb 1f       	adc	r27, r27
    22f8:	9c 01       	movw	r18, r24
    22fa:	ad 01       	movw	r20, r26
    22fc:	22 0f       	add	r18, r18
    22fe:	33 1f       	adc	r19, r19
    2300:	44 1f       	adc	r20, r20
    2302:	55 1f       	adc	r21, r21
    2304:	22 0f       	add	r18, r18
    2306:	33 1f       	adc	r19, r19
    2308:	44 1f       	adc	r20, r20
    230a:	55 1f       	adc	r21, r21
    230c:	60 e0       	ldi	r22, 0x00	; 0
    230e:	72 e1       	ldi	r23, 0x12	; 18
    2310:	8a e7       	ldi	r24, 0x7A	; 122
    2312:	90 e0       	ldi	r25, 0x00	; 0
    2314:	0e 94 e2 12 	call	0x25c4	; 0x25c4 <__udivmodsi4>
    2318:	21 50       	subi	r18, 0x01	; 1
    231a:	31 09       	sbc	r19, r1
    231c:	29 b9       	out	0x09, r18	; 9
    231e:	30 bd       	out	0x20, r19	; 32
    2320:	86 e8       	ldi	r24, 0x86	; 134
    2322:	80 bd       	out	0x20, r24	; 32
    2324:	88 e1       	ldi	r24, 0x18	; 24
    2326:	8a b9       	out	0x0a, r24	; 10
    2328:	08 95       	ret

0000232a <usart_getc_NonBlocking>:

ERROR_t usart_getc_NonBlocking(u8 * pData )
{
	/* Wait for data to be received */
	if ( (UCSRA & (1<<RXC)) )
    232a:	5f 9b       	sbis	0x0b, 7	; 11
    232c:	05 c0       	rjmp	.+10     	; 0x2338 <usart_getc_NonBlocking+0xe>
	{
		*pData = UDR;
    232e:	2c b1       	in	r18, 0x0c	; 12
    2330:	fc 01       	movw	r30, r24
    2332:	20 83       	st	Z, r18
		return E_OK;
    2334:	80 e0       	ldi	r24, 0x00	; 0
    2336:	08 95       	ret
	}
	else
	{
		return PENDING;
    2338:	82 e0       	ldi	r24, 0x02	; 2
	}

}
    233a:	08 95       	ret

0000233c <usart_putc>:
void usart_putc( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)));
    233c:	5d 9b       	sbis	0x0b, 5	; 11
    233e:	fe cf       	rjmp	.-4      	; 0x233c <usart_putc>
	/* Put data into buffer, sends the data */
	UDR = data;
    2340:	8c b9       	out	0x0c, r24	; 12
    2342:	08 95       	ret

00002344 <usart_puts>:
}
void usart_puts( char* str )
{
    2344:	0f 93       	push	r16
    2346:	1f 93       	push	r17
    2348:	cf 93       	push	r28
    234a:	df 93       	push	r29
    234c:	8c 01       	movw	r16, r24
	short int i=0;
    234e:	c0 e0       	ldi	r28, 0x00	; 0
    2350:	d0 e0       	ldi	r29, 0x00	; 0
	while(str[i])
    2352:	03 c0       	rjmp	.+6      	; 0x235a <usart_puts+0x16>
	{
		usart_putc(str[i]);
    2354:	0e 94 9e 11 	call	0x233c	; 0x233c <usart_putc>
		i++;
    2358:	21 96       	adiw	r28, 0x01	; 1
	UDR = data;
}
void usart_puts( char* str )
{
	short int i=0;
	while(str[i])
    235a:	f8 01       	movw	r30, r16
    235c:	ec 0f       	add	r30, r28
    235e:	fd 1f       	adc	r31, r29
    2360:	80 81       	ld	r24, Z
    2362:	81 11       	cpse	r24, r1
    2364:	f7 cf       	rjmp	.-18     	; 0x2354 <usart_puts+0x10>
	{
		usart_putc(str[i]);
		i++;
	}
}
    2366:	df 91       	pop	r29
    2368:	cf 91       	pop	r28
    236a:	1f 91       	pop	r17
    236c:	0f 91       	pop	r16
    236e:	08 95       	ret

00002370 <__fixunssfsi>:
    2370:	0e 94 2c 12 	call	0x2458	; 0x2458 <__fp_splitA>
    2374:	88 f0       	brcs	.+34     	; 0x2398 <__fixunssfsi+0x28>
    2376:	9f 57       	subi	r25, 0x7F	; 127
    2378:	98 f0       	brcs	.+38     	; 0x23a0 <__fixunssfsi+0x30>
    237a:	b9 2f       	mov	r27, r25
    237c:	99 27       	eor	r25, r25
    237e:	b7 51       	subi	r27, 0x17	; 23
    2380:	b0 f0       	brcs	.+44     	; 0x23ae <__fixunssfsi+0x3e>
    2382:	e1 f0       	breq	.+56     	; 0x23bc <__fixunssfsi+0x4c>
    2384:	66 0f       	add	r22, r22
    2386:	77 1f       	adc	r23, r23
    2388:	88 1f       	adc	r24, r24
    238a:	99 1f       	adc	r25, r25
    238c:	1a f0       	brmi	.+6      	; 0x2394 <__fixunssfsi+0x24>
    238e:	ba 95       	dec	r27
    2390:	c9 f7       	brne	.-14     	; 0x2384 <__fixunssfsi+0x14>
    2392:	14 c0       	rjmp	.+40     	; 0x23bc <__fixunssfsi+0x4c>
    2394:	b1 30       	cpi	r27, 0x01	; 1
    2396:	91 f0       	breq	.+36     	; 0x23bc <__fixunssfsi+0x4c>
    2398:	0e 94 46 12 	call	0x248c	; 0x248c <__fp_zero>
    239c:	b1 e0       	ldi	r27, 0x01	; 1
    239e:	08 95       	ret
    23a0:	0c 94 46 12 	jmp	0x248c	; 0x248c <__fp_zero>
    23a4:	67 2f       	mov	r22, r23
    23a6:	78 2f       	mov	r23, r24
    23a8:	88 27       	eor	r24, r24
    23aa:	b8 5f       	subi	r27, 0xF8	; 248
    23ac:	39 f0       	breq	.+14     	; 0x23bc <__fixunssfsi+0x4c>
    23ae:	b9 3f       	cpi	r27, 0xF9	; 249
    23b0:	cc f3       	brlt	.-14     	; 0x23a4 <__fixunssfsi+0x34>
    23b2:	86 95       	lsr	r24
    23b4:	77 95       	ror	r23
    23b6:	67 95       	ror	r22
    23b8:	b3 95       	inc	r27
    23ba:	d9 f7       	brne	.-10     	; 0x23b2 <__fixunssfsi+0x42>
    23bc:	3e f4       	brtc	.+14     	; 0x23cc <__fixunssfsi+0x5c>
    23be:	90 95       	com	r25
    23c0:	80 95       	com	r24
    23c2:	70 95       	com	r23
    23c4:	61 95       	neg	r22
    23c6:	7f 4f       	sbci	r23, 0xFF	; 255
    23c8:	8f 4f       	sbci	r24, 0xFF	; 255
    23ca:	9f 4f       	sbci	r25, 0xFF	; 255
    23cc:	08 95       	ret

000023ce <__floatunsisf>:
    23ce:	e8 94       	clt
    23d0:	09 c0       	rjmp	.+18     	; 0x23e4 <__floatsisf+0x12>

000023d2 <__floatsisf>:
    23d2:	97 fb       	bst	r25, 7
    23d4:	3e f4       	brtc	.+14     	; 0x23e4 <__floatsisf+0x12>
    23d6:	90 95       	com	r25
    23d8:	80 95       	com	r24
    23da:	70 95       	com	r23
    23dc:	61 95       	neg	r22
    23de:	7f 4f       	sbci	r23, 0xFF	; 255
    23e0:	8f 4f       	sbci	r24, 0xFF	; 255
    23e2:	9f 4f       	sbci	r25, 0xFF	; 255
    23e4:	99 23       	and	r25, r25
    23e6:	a9 f0       	breq	.+42     	; 0x2412 <__floatsisf+0x40>
    23e8:	f9 2f       	mov	r31, r25
    23ea:	96 e9       	ldi	r25, 0x96	; 150
    23ec:	bb 27       	eor	r27, r27
    23ee:	93 95       	inc	r25
    23f0:	f6 95       	lsr	r31
    23f2:	87 95       	ror	r24
    23f4:	77 95       	ror	r23
    23f6:	67 95       	ror	r22
    23f8:	b7 95       	ror	r27
    23fa:	f1 11       	cpse	r31, r1
    23fc:	f8 cf       	rjmp	.-16     	; 0x23ee <__floatsisf+0x1c>
    23fe:	fa f4       	brpl	.+62     	; 0x243e <__floatsisf+0x6c>
    2400:	bb 0f       	add	r27, r27
    2402:	11 f4       	brne	.+4      	; 0x2408 <__floatsisf+0x36>
    2404:	60 ff       	sbrs	r22, 0
    2406:	1b c0       	rjmp	.+54     	; 0x243e <__floatsisf+0x6c>
    2408:	6f 5f       	subi	r22, 0xFF	; 255
    240a:	7f 4f       	sbci	r23, 0xFF	; 255
    240c:	8f 4f       	sbci	r24, 0xFF	; 255
    240e:	9f 4f       	sbci	r25, 0xFF	; 255
    2410:	16 c0       	rjmp	.+44     	; 0x243e <__floatsisf+0x6c>
    2412:	88 23       	and	r24, r24
    2414:	11 f0       	breq	.+4      	; 0x241a <__floatsisf+0x48>
    2416:	96 e9       	ldi	r25, 0x96	; 150
    2418:	11 c0       	rjmp	.+34     	; 0x243c <__floatsisf+0x6a>
    241a:	77 23       	and	r23, r23
    241c:	21 f0       	breq	.+8      	; 0x2426 <__floatsisf+0x54>
    241e:	9e e8       	ldi	r25, 0x8E	; 142
    2420:	87 2f       	mov	r24, r23
    2422:	76 2f       	mov	r23, r22
    2424:	05 c0       	rjmp	.+10     	; 0x2430 <__floatsisf+0x5e>
    2426:	66 23       	and	r22, r22
    2428:	71 f0       	breq	.+28     	; 0x2446 <__floatsisf+0x74>
    242a:	96 e8       	ldi	r25, 0x86	; 134
    242c:	86 2f       	mov	r24, r22
    242e:	70 e0       	ldi	r23, 0x00	; 0
    2430:	60 e0       	ldi	r22, 0x00	; 0
    2432:	2a f0       	brmi	.+10     	; 0x243e <__floatsisf+0x6c>
    2434:	9a 95       	dec	r25
    2436:	66 0f       	add	r22, r22
    2438:	77 1f       	adc	r23, r23
    243a:	88 1f       	adc	r24, r24
    243c:	da f7       	brpl	.-10     	; 0x2434 <__floatsisf+0x62>
    243e:	88 0f       	add	r24, r24
    2440:	96 95       	lsr	r25
    2442:	87 95       	ror	r24
    2444:	97 f9       	bld	r25, 7
    2446:	08 95       	ret

00002448 <__fp_split3>:
    2448:	57 fd       	sbrc	r21, 7
    244a:	90 58       	subi	r25, 0x80	; 128
    244c:	44 0f       	add	r20, r20
    244e:	55 1f       	adc	r21, r21
    2450:	59 f0       	breq	.+22     	; 0x2468 <__fp_splitA+0x10>
    2452:	5f 3f       	cpi	r21, 0xFF	; 255
    2454:	71 f0       	breq	.+28     	; 0x2472 <__fp_splitA+0x1a>
    2456:	47 95       	ror	r20

00002458 <__fp_splitA>:
    2458:	88 0f       	add	r24, r24
    245a:	97 fb       	bst	r25, 7
    245c:	99 1f       	adc	r25, r25
    245e:	61 f0       	breq	.+24     	; 0x2478 <__fp_splitA+0x20>
    2460:	9f 3f       	cpi	r25, 0xFF	; 255
    2462:	79 f0       	breq	.+30     	; 0x2482 <__fp_splitA+0x2a>
    2464:	87 95       	ror	r24
    2466:	08 95       	ret
    2468:	12 16       	cp	r1, r18
    246a:	13 06       	cpc	r1, r19
    246c:	14 06       	cpc	r1, r20
    246e:	55 1f       	adc	r21, r21
    2470:	f2 cf       	rjmp	.-28     	; 0x2456 <__fp_split3+0xe>
    2472:	46 95       	lsr	r20
    2474:	f1 df       	rcall	.-30     	; 0x2458 <__fp_splitA>
    2476:	08 c0       	rjmp	.+16     	; 0x2488 <__fp_splitA+0x30>
    2478:	16 16       	cp	r1, r22
    247a:	17 06       	cpc	r1, r23
    247c:	18 06       	cpc	r1, r24
    247e:	99 1f       	adc	r25, r25
    2480:	f1 cf       	rjmp	.-30     	; 0x2464 <__fp_splitA+0xc>
    2482:	86 95       	lsr	r24
    2484:	71 05       	cpc	r23, r1
    2486:	61 05       	cpc	r22, r1
    2488:	08 94       	sec
    248a:	08 95       	ret

0000248c <__fp_zero>:
    248c:	e8 94       	clt

0000248e <__fp_szero>:
    248e:	bb 27       	eor	r27, r27
    2490:	66 27       	eor	r22, r22
    2492:	77 27       	eor	r23, r23
    2494:	cb 01       	movw	r24, r22
    2496:	97 f9       	bld	r25, 7
    2498:	08 95       	ret

0000249a <__mulsf3>:
    249a:	0e 94 60 12 	call	0x24c0	; 0x24c0 <__mulsf3x>
    249e:	0c 94 d1 12 	jmp	0x25a2	; 0x25a2 <__fp_round>
    24a2:	0e 94 c3 12 	call	0x2586	; 0x2586 <__fp_pscA>
    24a6:	38 f0       	brcs	.+14     	; 0x24b6 <__mulsf3+0x1c>
    24a8:	0e 94 ca 12 	call	0x2594	; 0x2594 <__fp_pscB>
    24ac:	20 f0       	brcs	.+8      	; 0x24b6 <__mulsf3+0x1c>
    24ae:	95 23       	and	r25, r21
    24b0:	11 f0       	breq	.+4      	; 0x24b6 <__mulsf3+0x1c>
    24b2:	0c 94 ba 12 	jmp	0x2574	; 0x2574 <__fp_inf>
    24b6:	0c 94 c0 12 	jmp	0x2580	; 0x2580 <__fp_nan>
    24ba:	11 24       	eor	r1, r1
    24bc:	0c 94 47 12 	jmp	0x248e	; 0x248e <__fp_szero>

000024c0 <__mulsf3x>:
    24c0:	0e 94 24 12 	call	0x2448	; 0x2448 <__fp_split3>
    24c4:	70 f3       	brcs	.-36     	; 0x24a2 <__mulsf3+0x8>

000024c6 <__mulsf3_pse>:
    24c6:	95 9f       	mul	r25, r21
    24c8:	c1 f3       	breq	.-16     	; 0x24ba <__mulsf3+0x20>
    24ca:	95 0f       	add	r25, r21
    24cc:	50 e0       	ldi	r21, 0x00	; 0
    24ce:	55 1f       	adc	r21, r21
    24d0:	62 9f       	mul	r22, r18
    24d2:	f0 01       	movw	r30, r0
    24d4:	72 9f       	mul	r23, r18
    24d6:	bb 27       	eor	r27, r27
    24d8:	f0 0d       	add	r31, r0
    24da:	b1 1d       	adc	r27, r1
    24dc:	63 9f       	mul	r22, r19
    24de:	aa 27       	eor	r26, r26
    24e0:	f0 0d       	add	r31, r0
    24e2:	b1 1d       	adc	r27, r1
    24e4:	aa 1f       	adc	r26, r26
    24e6:	64 9f       	mul	r22, r20
    24e8:	66 27       	eor	r22, r22
    24ea:	b0 0d       	add	r27, r0
    24ec:	a1 1d       	adc	r26, r1
    24ee:	66 1f       	adc	r22, r22
    24f0:	82 9f       	mul	r24, r18
    24f2:	22 27       	eor	r18, r18
    24f4:	b0 0d       	add	r27, r0
    24f6:	a1 1d       	adc	r26, r1
    24f8:	62 1f       	adc	r22, r18
    24fa:	73 9f       	mul	r23, r19
    24fc:	b0 0d       	add	r27, r0
    24fe:	a1 1d       	adc	r26, r1
    2500:	62 1f       	adc	r22, r18
    2502:	83 9f       	mul	r24, r19
    2504:	a0 0d       	add	r26, r0
    2506:	61 1d       	adc	r22, r1
    2508:	22 1f       	adc	r18, r18
    250a:	74 9f       	mul	r23, r20
    250c:	33 27       	eor	r19, r19
    250e:	a0 0d       	add	r26, r0
    2510:	61 1d       	adc	r22, r1
    2512:	23 1f       	adc	r18, r19
    2514:	84 9f       	mul	r24, r20
    2516:	60 0d       	add	r22, r0
    2518:	21 1d       	adc	r18, r1
    251a:	82 2f       	mov	r24, r18
    251c:	76 2f       	mov	r23, r22
    251e:	6a 2f       	mov	r22, r26
    2520:	11 24       	eor	r1, r1
    2522:	9f 57       	subi	r25, 0x7F	; 127
    2524:	50 40       	sbci	r21, 0x00	; 0
    2526:	9a f0       	brmi	.+38     	; 0x254e <__mulsf3_pse+0x88>
    2528:	f1 f0       	breq	.+60     	; 0x2566 <__mulsf3_pse+0xa0>
    252a:	88 23       	and	r24, r24
    252c:	4a f0       	brmi	.+18     	; 0x2540 <__mulsf3_pse+0x7a>
    252e:	ee 0f       	add	r30, r30
    2530:	ff 1f       	adc	r31, r31
    2532:	bb 1f       	adc	r27, r27
    2534:	66 1f       	adc	r22, r22
    2536:	77 1f       	adc	r23, r23
    2538:	88 1f       	adc	r24, r24
    253a:	91 50       	subi	r25, 0x01	; 1
    253c:	50 40       	sbci	r21, 0x00	; 0
    253e:	a9 f7       	brne	.-22     	; 0x252a <__mulsf3_pse+0x64>
    2540:	9e 3f       	cpi	r25, 0xFE	; 254
    2542:	51 05       	cpc	r21, r1
    2544:	80 f0       	brcs	.+32     	; 0x2566 <__mulsf3_pse+0xa0>
    2546:	0c 94 ba 12 	jmp	0x2574	; 0x2574 <__fp_inf>
    254a:	0c 94 47 12 	jmp	0x248e	; 0x248e <__fp_szero>
    254e:	5f 3f       	cpi	r21, 0xFF	; 255
    2550:	e4 f3       	brlt	.-8      	; 0x254a <__mulsf3_pse+0x84>
    2552:	98 3e       	cpi	r25, 0xE8	; 232
    2554:	d4 f3       	brlt	.-12     	; 0x254a <__mulsf3_pse+0x84>
    2556:	86 95       	lsr	r24
    2558:	77 95       	ror	r23
    255a:	67 95       	ror	r22
    255c:	b7 95       	ror	r27
    255e:	f7 95       	ror	r31
    2560:	e7 95       	ror	r30
    2562:	9f 5f       	subi	r25, 0xFF	; 255
    2564:	c1 f7       	brne	.-16     	; 0x2556 <__mulsf3_pse+0x90>
    2566:	fe 2b       	or	r31, r30
    2568:	88 0f       	add	r24, r24
    256a:	91 1d       	adc	r25, r1
    256c:	96 95       	lsr	r25
    256e:	87 95       	ror	r24
    2570:	97 f9       	bld	r25, 7
    2572:	08 95       	ret

00002574 <__fp_inf>:
    2574:	97 f9       	bld	r25, 7
    2576:	9f 67       	ori	r25, 0x7F	; 127
    2578:	80 e8       	ldi	r24, 0x80	; 128
    257a:	70 e0       	ldi	r23, 0x00	; 0
    257c:	60 e0       	ldi	r22, 0x00	; 0
    257e:	08 95       	ret

00002580 <__fp_nan>:
    2580:	9f ef       	ldi	r25, 0xFF	; 255
    2582:	80 ec       	ldi	r24, 0xC0	; 192
    2584:	08 95       	ret

00002586 <__fp_pscA>:
    2586:	00 24       	eor	r0, r0
    2588:	0a 94       	dec	r0
    258a:	16 16       	cp	r1, r22
    258c:	17 06       	cpc	r1, r23
    258e:	18 06       	cpc	r1, r24
    2590:	09 06       	cpc	r0, r25
    2592:	08 95       	ret

00002594 <__fp_pscB>:
    2594:	00 24       	eor	r0, r0
    2596:	0a 94       	dec	r0
    2598:	12 16       	cp	r1, r18
    259a:	13 06       	cpc	r1, r19
    259c:	14 06       	cpc	r1, r20
    259e:	05 06       	cpc	r0, r21
    25a0:	08 95       	ret

000025a2 <__fp_round>:
    25a2:	09 2e       	mov	r0, r25
    25a4:	03 94       	inc	r0
    25a6:	00 0c       	add	r0, r0
    25a8:	11 f4       	brne	.+4      	; 0x25ae <__fp_round+0xc>
    25aa:	88 23       	and	r24, r24
    25ac:	52 f0       	brmi	.+20     	; 0x25c2 <__fp_round+0x20>
    25ae:	bb 0f       	add	r27, r27
    25b0:	40 f4       	brcc	.+16     	; 0x25c2 <__fp_round+0x20>
    25b2:	bf 2b       	or	r27, r31
    25b4:	11 f4       	brne	.+4      	; 0x25ba <__fp_round+0x18>
    25b6:	60 ff       	sbrs	r22, 0
    25b8:	04 c0       	rjmp	.+8      	; 0x25c2 <__fp_round+0x20>
    25ba:	6f 5f       	subi	r22, 0xFF	; 255
    25bc:	7f 4f       	sbci	r23, 0xFF	; 255
    25be:	8f 4f       	sbci	r24, 0xFF	; 255
    25c0:	9f 4f       	sbci	r25, 0xFF	; 255
    25c2:	08 95       	ret

000025c4 <__udivmodsi4>:
    25c4:	a1 e2       	ldi	r26, 0x21	; 33
    25c6:	1a 2e       	mov	r1, r26
    25c8:	aa 1b       	sub	r26, r26
    25ca:	bb 1b       	sub	r27, r27
    25cc:	fd 01       	movw	r30, r26
    25ce:	0d c0       	rjmp	.+26     	; 0x25ea <__udivmodsi4_ep>

000025d0 <__udivmodsi4_loop>:
    25d0:	aa 1f       	adc	r26, r26
    25d2:	bb 1f       	adc	r27, r27
    25d4:	ee 1f       	adc	r30, r30
    25d6:	ff 1f       	adc	r31, r31
    25d8:	a2 17       	cp	r26, r18
    25da:	b3 07       	cpc	r27, r19
    25dc:	e4 07       	cpc	r30, r20
    25de:	f5 07       	cpc	r31, r21
    25e0:	20 f0       	brcs	.+8      	; 0x25ea <__udivmodsi4_ep>
    25e2:	a2 1b       	sub	r26, r18
    25e4:	b3 0b       	sbc	r27, r19
    25e6:	e4 0b       	sbc	r30, r20
    25e8:	f5 0b       	sbc	r31, r21

000025ea <__udivmodsi4_ep>:
    25ea:	66 1f       	adc	r22, r22
    25ec:	77 1f       	adc	r23, r23
    25ee:	88 1f       	adc	r24, r24
    25f0:	99 1f       	adc	r25, r25
    25f2:	1a 94       	dec	r1
    25f4:	69 f7       	brne	.-38     	; 0x25d0 <__udivmodsi4_loop>
    25f6:	60 95       	com	r22
    25f8:	70 95       	com	r23
    25fa:	80 95       	com	r24
    25fc:	90 95       	com	r25
    25fe:	9b 01       	movw	r18, r22
    2600:	ac 01       	movw	r20, r24
    2602:	bd 01       	movw	r22, r26
    2604:	cf 01       	movw	r24, r30
    2606:	08 95       	ret

00002608 <__umulhisi3>:
    2608:	a2 9f       	mul	r26, r18
    260a:	b0 01       	movw	r22, r0
    260c:	b3 9f       	mul	r27, r19
    260e:	c0 01       	movw	r24, r0
    2610:	a3 9f       	mul	r26, r19
    2612:	70 0d       	add	r23, r0
    2614:	81 1d       	adc	r24, r1
    2616:	11 24       	eor	r1, r1
    2618:	91 1d       	adc	r25, r1
    261a:	b2 9f       	mul	r27, r18
    261c:	70 0d       	add	r23, r0
    261e:	81 1d       	adc	r24, r1
    2620:	11 24       	eor	r1, r1
    2622:	91 1d       	adc	r25, r1
    2624:	08 95       	ret

00002626 <atoi>:
    2626:	fc 01       	movw	r30, r24
    2628:	88 27       	eor	r24, r24
    262a:	99 27       	eor	r25, r25
    262c:	e8 94       	clt
    262e:	21 91       	ld	r18, Z+
    2630:	20 32       	cpi	r18, 0x20	; 32
    2632:	e9 f3       	breq	.-6      	; 0x262e <atoi+0x8>
    2634:	29 30       	cpi	r18, 0x09	; 9
    2636:	10 f0       	brcs	.+4      	; 0x263c <atoi+0x16>
    2638:	2e 30       	cpi	r18, 0x0E	; 14
    263a:	c8 f3       	brcs	.-14     	; 0x262e <atoi+0x8>
    263c:	2b 32       	cpi	r18, 0x2B	; 43
    263e:	41 f0       	breq	.+16     	; 0x2650 <atoi+0x2a>
    2640:	2d 32       	cpi	r18, 0x2D	; 45
    2642:	39 f4       	brne	.+14     	; 0x2652 <atoi+0x2c>
    2644:	68 94       	set
    2646:	04 c0       	rjmp	.+8      	; 0x2650 <atoi+0x2a>
    2648:	0e 94 50 13 	call	0x26a0	; 0x26a0 <__mulhi_const_10>
    264c:	82 0f       	add	r24, r18
    264e:	91 1d       	adc	r25, r1
    2650:	21 91       	ld	r18, Z+
    2652:	20 53       	subi	r18, 0x30	; 48
    2654:	2a 30       	cpi	r18, 0x0A	; 10
    2656:	c0 f3       	brcs	.-16     	; 0x2648 <atoi+0x22>
    2658:	1e f4       	brtc	.+6      	; 0x2660 <atoi+0x3a>
    265a:	90 95       	com	r25
    265c:	81 95       	neg	r24
    265e:	9f 4f       	sbci	r25, 0xFF	; 255
    2660:	08 95       	ret

00002662 <memcpy>:
    2662:	fb 01       	movw	r30, r22
    2664:	dc 01       	movw	r26, r24
    2666:	02 c0       	rjmp	.+4      	; 0x266c <memcpy+0xa>
    2668:	01 90       	ld	r0, Z+
    266a:	0d 92       	st	X+, r0
    266c:	41 50       	subi	r20, 0x01	; 1
    266e:	50 40       	sbci	r21, 0x00	; 0
    2670:	d8 f7       	brcc	.-10     	; 0x2668 <memcpy+0x6>
    2672:	08 95       	ret

00002674 <itoa>:
    2674:	45 32       	cpi	r20, 0x25	; 37
    2676:	51 05       	cpc	r21, r1
    2678:	20 f4       	brcc	.+8      	; 0x2682 <itoa+0xe>
    267a:	42 30       	cpi	r20, 0x02	; 2
    267c:	10 f0       	brcs	.+4      	; 0x2682 <itoa+0xe>
    267e:	0c 94 45 13 	jmp	0x268a	; 0x268a <__itoa_ncheck>
    2682:	fb 01       	movw	r30, r22
    2684:	10 82       	st	Z, r1
    2686:	cb 01       	movw	r24, r22
    2688:	08 95       	ret

0000268a <__itoa_ncheck>:
    268a:	bb 27       	eor	r27, r27
    268c:	4a 30       	cpi	r20, 0x0A	; 10
    268e:	31 f4       	brne	.+12     	; 0x269c <__itoa_ncheck+0x12>
    2690:	99 23       	and	r25, r25
    2692:	22 f4       	brpl	.+8      	; 0x269c <__itoa_ncheck+0x12>
    2694:	bd e2       	ldi	r27, 0x2D	; 45
    2696:	90 95       	com	r25
    2698:	81 95       	neg	r24
    269a:	9f 4f       	sbci	r25, 0xFF	; 255
    269c:	0c 94 59 13 	jmp	0x26b2	; 0x26b2 <__utoa_common>

000026a0 <__mulhi_const_10>:
    26a0:	7a e0       	ldi	r23, 0x0A	; 10
    26a2:	97 9f       	mul	r25, r23
    26a4:	90 2d       	mov	r25, r0
    26a6:	87 9f       	mul	r24, r23
    26a8:	80 2d       	mov	r24, r0
    26aa:	91 0d       	add	r25, r1
    26ac:	11 24       	eor	r1, r1
    26ae:	08 95       	ret

000026b0 <__utoa_ncheck>:
    26b0:	bb 27       	eor	r27, r27

000026b2 <__utoa_common>:
    26b2:	fb 01       	movw	r30, r22
    26b4:	55 27       	eor	r21, r21
    26b6:	aa 27       	eor	r26, r26
    26b8:	88 0f       	add	r24, r24
    26ba:	99 1f       	adc	r25, r25
    26bc:	aa 1f       	adc	r26, r26
    26be:	a4 17       	cp	r26, r20
    26c0:	10 f0       	brcs	.+4      	; 0x26c6 <__utoa_common+0x14>
    26c2:	a4 1b       	sub	r26, r20
    26c4:	83 95       	inc	r24
    26c6:	50 51       	subi	r21, 0x10	; 16
    26c8:	b9 f7       	brne	.-18     	; 0x26b8 <__utoa_common+0x6>
    26ca:	a0 5d       	subi	r26, 0xD0	; 208
    26cc:	aa 33       	cpi	r26, 0x3A	; 58
    26ce:	08 f0       	brcs	.+2      	; 0x26d2 <__utoa_common+0x20>
    26d0:	a9 5d       	subi	r26, 0xD9	; 217
    26d2:	a1 93       	st	Z+, r26
    26d4:	00 97       	sbiw	r24, 0x00	; 0
    26d6:	79 f7       	brne	.-34     	; 0x26b6 <__utoa_common+0x4>
    26d8:	b1 11       	cpse	r27, r1
    26da:	b1 93       	st	Z+, r27
    26dc:	11 92       	st	Z+, r1
    26de:	cb 01       	movw	r24, r22
    26e0:	0c 94 72 13 	jmp	0x26e4	; 0x26e4 <strrev>

000026e4 <strrev>:
    26e4:	dc 01       	movw	r26, r24
    26e6:	fc 01       	movw	r30, r24
    26e8:	67 2f       	mov	r22, r23
    26ea:	71 91       	ld	r23, Z+
    26ec:	77 23       	and	r23, r23
    26ee:	e1 f7       	brne	.-8      	; 0x26e8 <strrev+0x4>
    26f0:	32 97       	sbiw	r30, 0x02	; 2
    26f2:	04 c0       	rjmp	.+8      	; 0x26fc <strrev+0x18>
    26f4:	7c 91       	ld	r23, X
    26f6:	6d 93       	st	X+, r22
    26f8:	70 83       	st	Z, r23
    26fa:	62 91       	ld	r22, -Z
    26fc:	ae 17       	cp	r26, r30
    26fe:	bf 07       	cpc	r27, r31
    2700:	c8 f3       	brcs	.-14     	; 0x26f4 <strrev+0x10>
    2702:	08 95       	ret

00002704 <_exit>:
    2704:	f8 94       	cli

00002706 <__stop_program>:
    2706:	ff cf       	rjmp	.-2      	; 0x2706 <__stop_program>
