
TempAlarmingSystem.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006678  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000142  00800060  00006678  0000670c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000056d  008001a2  008001a2  0000684e  2**0
                  ALLOC
  3 .stab         00008814  00000000  00000000  00006850  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004045  00000000  00000000  0000f064  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  000130a9  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  000131e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00013359  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00014fa2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00015e8d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00016c3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00016d9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00017029  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  000177f7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 e5 21 	jmp	0x43ca	; 0x43ca <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e7       	ldi	r30, 0x78	; 120
      68:	f6 e6       	ldi	r31, 0x66	; 102
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 3a       	cpi	r26, 0xA2	; 162
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a2 ea       	ldi	r26, 0xA2	; 162
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 30       	cpi	r26, 0x0F	; 15
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ae 11 	call	0x235c	; 0x235c <main>
      8a:	0c 94 3a 33 	jmp	0x6674	; 0x6674 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 cd 32 	jmp	0x659a	; 0x659a <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a7 e5       	ldi	r26, 0x57	; 87
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 e9 32 	jmp	0x65d2	; 0x65d2 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 d9 32 	jmp	0x65b2	; 0x65b2 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 f5 32 	jmp	0x65ea	; 0x65ea <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 d9 32 	jmp	0x65b2	; 0x65b2 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 f5 32 	jmp	0x65ea	; 0x65ea <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 cd 32 	jmp	0x659a	; 0x659a <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	87 e5       	ldi	r24, 0x57	; 87
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 e9 32 	jmp	0x65d2	; 0x65d2 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 d9 32 	jmp	0x65b2	; 0x65b2 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 f5 32 	jmp	0x65ea	; 0x65ea <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 d9 32 	jmp	0x65b2	; 0x65b2 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 f5 32 	jmp	0x65ea	; 0x65ea <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 d9 32 	jmp	0x65b2	; 0x65b2 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 f5 32 	jmp	0x65ea	; 0x65ea <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 dd 32 	jmp	0x65ba	; 0x65ba <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 f9 32 	jmp	0x65f2	; 0x65f2 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <ADC_voidInit>:
#include "BIT_MATH.h"
#include "ADC_interface.h"
#include "ADC_register.h"

void ADC_voidInit(void)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62

	/* Select the Voltage reference AVCC */
	CLR_BIT(ADMUX,ADMUX_REFS1);
     b4e:	a7 e2       	ldi	r26, 0x27	; 39
     b50:	b0 e0       	ldi	r27, 0x00	; 0
     b52:	e7 e2       	ldi	r30, 0x27	; 39
     b54:	f0 e0       	ldi	r31, 0x00	; 0
     b56:	80 81       	ld	r24, Z
     b58:	8f 77       	andi	r24, 0x7F	; 127
     b5a:	8c 93       	st	X, r24
	SET_BIT(ADMUX,ADMUX_REFS0);
     b5c:	a7 e2       	ldi	r26, 0x27	; 39
     b5e:	b0 e0       	ldi	r27, 0x00	; 0
     b60:	e7 e2       	ldi	r30, 0x27	; 39
     b62:	f0 e0       	ldi	r31, 0x00	; 0
     b64:	80 81       	ld	r24, Z
     b66:	80 64       	ori	r24, 0x40	; 64
     b68:	8c 93       	st	X, r24

	/* Select the right Adjustment */
	CLR_BIT(ADMUX,ADMUX_ADLAR);
     b6a:	a7 e2       	ldi	r26, 0x27	; 39
     b6c:	b0 e0       	ldi	r27, 0x00	; 0
     b6e:	e7 e2       	ldi	r30, 0x27	; 39
     b70:	f0 e0       	ldi	r31, 0x00	; 0
     b72:	80 81       	ld	r24, Z
     b74:	8f 7d       	andi	r24, 0xDF	; 223
     b76:	8c 93       	st	X, r24
	/* Select The Prescaler value => 64 */
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
     b78:	a6 e2       	ldi	r26, 0x26	; 38
     b7a:	b0 e0       	ldi	r27, 0x00	; 0
     b7c:	e6 e2       	ldi	r30, 0x26	; 38
     b7e:	f0 e0       	ldi	r31, 0x00	; 0
     b80:	80 81       	ld	r24, Z
     b82:	84 60       	ori	r24, 0x04	; 4
     b84:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
     b86:	a6 e2       	ldi	r26, 0x26	; 38
     b88:	b0 e0       	ldi	r27, 0x00	; 0
     b8a:	e6 e2       	ldi	r30, 0x26	; 38
     b8c:	f0 e0       	ldi	r31, 0x00	; 0
     b8e:	80 81       	ld	r24, Z
     b90:	82 60       	ori	r24, 0x02	; 2
     b92:	8c 93       	st	X, r24
	CLR_BIT(ADCSRA,ADCSRA_ADPS0);
     b94:	a6 e2       	ldi	r26, 0x26	; 38
     b96:	b0 e0       	ldi	r27, 0x00	; 0
     b98:	e6 e2       	ldi	r30, 0x26	; 38
     b9a:	f0 e0       	ldi	r31, 0x00	; 0
     b9c:	80 81       	ld	r24, Z
     b9e:	8e 7f       	andi	r24, 0xFE	; 254
     ba0:	8c 93       	st	X, r24

	/* Enable ADC peripheral */
	SET_BIT(ADCSRA,ADCSRA_ADEN);
     ba2:	a6 e2       	ldi	r26, 0x26	; 38
     ba4:	b0 e0       	ldi	r27, 0x00	; 0
     ba6:	e6 e2       	ldi	r30, 0x26	; 38
     ba8:	f0 e0       	ldi	r31, 0x00	; 0
     baa:	80 81       	ld	r24, Z
     bac:	80 68       	ori	r24, 0x80	; 128
     bae:	8c 93       	st	X, r24

}
     bb0:	cf 91       	pop	r28
     bb2:	df 91       	pop	r29
     bb4:	08 95       	ret

00000bb6 <ADC_u16GetDigitalValue>:

u16  ADC_u16GetDigitalValue (u8 Copy_u8ChannelNb)
{
     bb6:	df 93       	push	r29
     bb8:	cf 93       	push	r28
     bba:	0f 92       	push	r0
     bbc:	cd b7       	in	r28, 0x3d	; 61
     bbe:	de b7       	in	r29, 0x3e	; 62
     bc0:	89 83       	std	Y+1, r24	; 0x01
	/* Clear The Channel Number bits */
		ADMUX &= (ADMUX_CHANNEL_NUM_MASK);
     bc2:	a7 e2       	ldi	r26, 0x27	; 39
     bc4:	b0 e0       	ldi	r27, 0x00	; 0
     bc6:	e7 e2       	ldi	r30, 0x27	; 39
     bc8:	f0 e0       	ldi	r31, 0x00	; 0
     bca:	80 81       	ld	r24, Z
     bcc:	80 7e       	andi	r24, 0xE0	; 224
     bce:	8c 93       	st	X, r24
		/* Select The Channel Number */
		ADMUX |= Copy_u8ChannelNb;
     bd0:	a7 e2       	ldi	r26, 0x27	; 39
     bd2:	b0 e0       	ldi	r27, 0x00	; 0
     bd4:	e7 e2       	ldi	r30, 0x27	; 39
     bd6:	f0 e0       	ldi	r31, 0x00	; 0
     bd8:	90 81       	ld	r25, Z
     bda:	89 81       	ldd	r24, Y+1	; 0x01
     bdc:	89 2b       	or	r24, r25
     bde:	8c 93       	st	X, r24

		/* Start Conversion */
		SET_BIT(ADCSRA,ADCSRA_ADSC);
     be0:	a6 e2       	ldi	r26, 0x26	; 38
     be2:	b0 e0       	ldi	r27, 0x00	; 0
     be4:	e6 e2       	ldi	r30, 0x26	; 38
     be6:	f0 e0       	ldi	r31, 0x00	; 0
     be8:	80 81       	ld	r24, Z
     bea:	80 64       	ori	r24, 0x40	; 64
     bec:	8c 93       	st	X, r24
     bee:	04 c0       	rjmp	.+8      	; 0xbf8 <ADC_u16GetDigitalValue+0x42>

		/* Polling on the flag */
		while(GET_BIT(ADCSRA,ADCSRA_ADIF) == 0) { vTaskDelay(10);}
     bf0:	8a e0       	ldi	r24, 0x0A	; 10
     bf2:	90 e0       	ldi	r25, 0x00	; 0
     bf4:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <vTaskDelay>
     bf8:	e6 e2       	ldi	r30, 0x26	; 38
     bfa:	f0 e0       	ldi	r31, 0x00	; 0
     bfc:	80 81       	ld	r24, Z
     bfe:	82 95       	swap	r24
     c00:	8f 70       	andi	r24, 0x0F	; 15
     c02:	88 2f       	mov	r24, r24
     c04:	90 e0       	ldi	r25, 0x00	; 0
     c06:	81 70       	andi	r24, 0x01	; 1
     c08:	90 70       	andi	r25, 0x00	; 0
     c0a:	00 97       	sbiw	r24, 0x00	; 0
     c0c:	89 f3       	breq	.-30     	; 0xbf0 <ADC_u16GetDigitalValue+0x3a>

		/* Clear Flag */
		SET_BIT(ADCSRA,ADCSRA_ADIF);
     c0e:	a6 e2       	ldi	r26, 0x26	; 38
     c10:	b0 e0       	ldi	r27, 0x00	; 0
     c12:	e6 e2       	ldi	r30, 0x26	; 38
     c14:	f0 e0       	ldi	r31, 0x00	; 0
     c16:	80 81       	ld	r24, Z
     c18:	80 61       	ori	r24, 0x10	; 16
     c1a:	8c 93       	st	X, r24

		/* Read the ADC value */
		return ADC;
     c1c:	e4 e2       	ldi	r30, 0x24	; 36
     c1e:	f0 e0       	ldi	r31, 0x00	; 0
     c20:	80 81       	ld	r24, Z
     c22:	91 81       	ldd	r25, Z+1	; 0x01
}
     c24:	0f 90       	pop	r0
     c26:	cf 91       	pop	r28
     c28:	df 91       	pop	r29
     c2a:	08 95       	ret

00000c2c <ADC_u16GetDigitalValue_NonBlocking>:

ERROR_t  ADC_u16GetDigitalValue_NonBlocking(u8 Copy_u8ChannelNb, u8* pData)
{
     c2c:	df 93       	push	r29
     c2e:	cf 93       	push	r28
     c30:	00 d0       	rcall	.+0      	; 0xc32 <ADC_u16GetDigitalValue_NonBlocking+0x6>
     c32:	00 d0       	rcall	.+0      	; 0xc34 <ADC_u16GetDigitalValue_NonBlocking+0x8>
     c34:	cd b7       	in	r28, 0x3d	; 61
     c36:	de b7       	in	r29, 0x3e	; 62
     c38:	89 83       	std	Y+1, r24	; 0x01
     c3a:	7b 83       	std	Y+3, r23	; 0x03
     c3c:	6a 83       	std	Y+2, r22	; 0x02
		/* Clear The Channel Number bits */
		ADMUX &= (ADMUX_CHANNEL_NUM_MASK);
     c3e:	a7 e2       	ldi	r26, 0x27	; 39
     c40:	b0 e0       	ldi	r27, 0x00	; 0
     c42:	e7 e2       	ldi	r30, 0x27	; 39
     c44:	f0 e0       	ldi	r31, 0x00	; 0
     c46:	80 81       	ld	r24, Z
     c48:	80 7e       	andi	r24, 0xE0	; 224
     c4a:	8c 93       	st	X, r24
		/* Select The Channel Number */
		ADMUX |= Copy_u8ChannelNb;
     c4c:	a7 e2       	ldi	r26, 0x27	; 39
     c4e:	b0 e0       	ldi	r27, 0x00	; 0
     c50:	e7 e2       	ldi	r30, 0x27	; 39
     c52:	f0 e0       	ldi	r31, 0x00	; 0
     c54:	90 81       	ld	r25, Z
     c56:	89 81       	ldd	r24, Y+1	; 0x01
     c58:	89 2b       	or	r24, r25
     c5a:	8c 93       	st	X, r24

		/* Start Conversion */ /* Start conv. on start conv. ?!*/
		if( GET_BIT(ADCSRA, ADCSRA_ADSC))
     c5c:	e6 e2       	ldi	r30, 0x26	; 38
     c5e:	f0 e0       	ldi	r31, 0x00	; 0
     c60:	80 81       	ld	r24, Z
     c62:	82 95       	swap	r24
     c64:	86 95       	lsr	r24
     c66:	86 95       	lsr	r24
     c68:	83 70       	andi	r24, 0x03	; 3
     c6a:	88 2f       	mov	r24, r24
     c6c:	90 e0       	ldi	r25, 0x00	; 0
     c6e:	81 70       	andi	r24, 0x01	; 1
     c70:	90 70       	andi	r25, 0x00	; 0
     c72:	98 2f       	mov	r25, r24
     c74:	81 e0       	ldi	r24, 0x01	; 1
     c76:	89 27       	eor	r24, r25
     c78:	88 23       	and	r24, r24
     c7a:	39 f0       	breq	.+14     	; 0xc8a <ADC_u16GetDigitalValue_NonBlocking+0x5e>
		{
			/* Already Set */
		}
		else
		{
			SET_BIT(ADCSRA, ADCSRA_ADSC);
     c7c:	a6 e2       	ldi	r26, 0x26	; 38
     c7e:	b0 e0       	ldi	r27, 0x00	; 0
     c80:	e6 e2       	ldi	r30, 0x26	; 38
     c82:	f0 e0       	ldi	r31, 0x00	; 0
     c84:	80 81       	ld	r24, Z
     c86:	80 64       	ori	r24, 0x40	; 64
     c88:	8c 93       	st	X, r24
		}


		/* checking the flag */
		if( GET_BIT(ADCSRA, ADCSRA_ADIF) == 0)	/*if not ready */
     c8a:	e6 e2       	ldi	r30, 0x26	; 38
     c8c:	f0 e0       	ldi	r31, 0x00	; 0
     c8e:	80 81       	ld	r24, Z
     c90:	82 95       	swap	r24
     c92:	8f 70       	andi	r24, 0x0F	; 15
     c94:	88 2f       	mov	r24, r24
     c96:	90 e0       	ldi	r25, 0x00	; 0
     c98:	81 70       	andi	r24, 0x01	; 1
     c9a:	90 70       	andi	r25, 0x00	; 0
     c9c:	00 97       	sbiw	r24, 0x00	; 0
     c9e:	19 f4       	brne	.+6      	; 0xca6 <ADC_u16GetDigitalValue_NonBlocking+0x7a>
		{
			return PENDING;
     ca0:	82 e0       	ldi	r24, 0x02	; 2
     ca2:	8c 83       	std	Y+4, r24	; 0x04
     ca4:	0f c0       	rjmp	.+30     	; 0xcc4 <ADC_u16GetDigitalValue_NonBlocking+0x98>
		}


		/* Clear Flag */
		SET_BIT(ADCSRA,ADCSRA_ADIF);
     ca6:	a6 e2       	ldi	r26, 0x26	; 38
     ca8:	b0 e0       	ldi	r27, 0x00	; 0
     caa:	e6 e2       	ldi	r30, 0x26	; 38
     cac:	f0 e0       	ldi	r31, 0x00	; 0
     cae:	80 81       	ld	r24, Z
     cb0:	80 61       	ori	r24, 0x10	; 16
     cb2:	8c 93       	st	X, r24

		*pData = ADC;
     cb4:	e4 e2       	ldi	r30, 0x24	; 36
     cb6:	f0 e0       	ldi	r31, 0x00	; 0
     cb8:	80 81       	ld	r24, Z
     cba:	91 81       	ldd	r25, Z+1	; 0x01
     cbc:	ea 81       	ldd	r30, Y+2	; 0x02
     cbe:	fb 81       	ldd	r31, Y+3	; 0x03
     cc0:	80 83       	st	Z, r24
		/* Read the ADC value */
		return E_OK;
     cc2:	1c 82       	std	Y+4, r1	; 0x04
     cc4:	8c 81       	ldd	r24, Y+4	; 0x04
}
     cc6:	0f 90       	pop	r0
     cc8:	0f 90       	pop	r0
     cca:	0f 90       	pop	r0
     ccc:	0f 90       	pop	r0
     cce:	cf 91       	pop	r28
     cd0:	df 91       	pop	r29
     cd2:	08 95       	ret

00000cd4 <DIO_voidSetPinValue>:



/* IO Pins */
void DIO_voidSetPinValue(u8 u8PortIdCopy , u8 u8PinIdCopy, u8 u8PinValCopy)
{
     cd4:	df 93       	push	r29
     cd6:	cf 93       	push	r28
     cd8:	cd b7       	in	r28, 0x3d	; 61
     cda:	de b7       	in	r29, 0x3e	; 62
     cdc:	27 97       	sbiw	r28, 0x07	; 7
     cde:	0f b6       	in	r0, 0x3f	; 63
     ce0:	f8 94       	cli
     ce2:	de bf       	out	0x3e, r29	; 62
     ce4:	0f be       	out	0x3f, r0	; 63
     ce6:	cd bf       	out	0x3d, r28	; 61
     ce8:	89 83       	std	Y+1, r24	; 0x01
     cea:	6a 83       	std	Y+2, r22	; 0x02
     cec:	4b 83       	std	Y+3, r20	; 0x03
	/* Make sure that the Port ID and Pin ID are in the valid range */
	if ((u8PortIdCopy <= DIO_u8_PORTD) && (u8PinIdCopy <= DIO_u8_PIN7))
     cee:	89 81       	ldd	r24, Y+1	; 0x01
     cf0:	84 30       	cpi	r24, 0x04	; 4
     cf2:	08 f0       	brcs	.+2      	; 0xcf6 <DIO_voidSetPinValue+0x22>
     cf4:	ee c0       	rjmp	.+476    	; 0xed2 <DIO_voidSetPinValue+0x1fe>
     cf6:	8a 81       	ldd	r24, Y+2	; 0x02
     cf8:	88 30       	cpi	r24, 0x08	; 8
     cfa:	08 f0       	brcs	.+2      	; 0xcfe <DIO_voidSetPinValue+0x2a>
     cfc:	ea c0       	rjmp	.+468    	; 0xed2 <DIO_voidSetPinValue+0x1fe>
	{
		if (u8PinValCopy == DIO_u8_HIGH)
     cfe:	8b 81       	ldd	r24, Y+3	; 0x03
     d00:	81 30       	cpi	r24, 0x01	; 1
     d02:	09 f0       	breq	.+2      	; 0xd06 <DIO_voidSetPinValue+0x32>
     d04:	6f c0       	rjmp	.+222    	; 0xde4 <DIO_voidSetPinValue+0x110>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
     d06:	89 81       	ldd	r24, Y+1	; 0x01
     d08:	28 2f       	mov	r18, r24
     d0a:	30 e0       	ldi	r19, 0x00	; 0
     d0c:	3f 83       	std	Y+7, r19	; 0x07
     d0e:	2e 83       	std	Y+6, r18	; 0x06
     d10:	8e 81       	ldd	r24, Y+6	; 0x06
     d12:	9f 81       	ldd	r25, Y+7	; 0x07
     d14:	81 30       	cpi	r24, 0x01	; 1
     d16:	91 05       	cpc	r25, r1
     d18:	49 f1       	breq	.+82     	; 0xd6c <DIO_voidSetPinValue+0x98>
     d1a:	2e 81       	ldd	r18, Y+6	; 0x06
     d1c:	3f 81       	ldd	r19, Y+7	; 0x07
     d1e:	22 30       	cpi	r18, 0x02	; 2
     d20:	31 05       	cpc	r19, r1
     d22:	2c f4       	brge	.+10     	; 0xd2e <DIO_voidSetPinValue+0x5a>
     d24:	8e 81       	ldd	r24, Y+6	; 0x06
     d26:	9f 81       	ldd	r25, Y+7	; 0x07
     d28:	00 97       	sbiw	r24, 0x00	; 0
     d2a:	61 f0       	breq	.+24     	; 0xd44 <DIO_voidSetPinValue+0x70>
     d2c:	d2 c0       	rjmp	.+420    	; 0xed2 <DIO_voidSetPinValue+0x1fe>
     d2e:	2e 81       	ldd	r18, Y+6	; 0x06
     d30:	3f 81       	ldd	r19, Y+7	; 0x07
     d32:	22 30       	cpi	r18, 0x02	; 2
     d34:	31 05       	cpc	r19, r1
     d36:	71 f1       	breq	.+92     	; 0xd94 <DIO_voidSetPinValue+0xc0>
     d38:	8e 81       	ldd	r24, Y+6	; 0x06
     d3a:	9f 81       	ldd	r25, Y+7	; 0x07
     d3c:	83 30       	cpi	r24, 0x03	; 3
     d3e:	91 05       	cpc	r25, r1
     d40:	e9 f1       	breq	.+122    	; 0xdbc <DIO_voidSetPinValue+0xe8>
     d42:	c7 c0       	rjmp	.+398    	; 0xed2 <DIO_voidSetPinValue+0x1fe>
			{
				case DIO_u8_PORTA: SET_BIT(PORTA_Register,u8PinIdCopy); break;
     d44:	ab e3       	ldi	r26, 0x3B	; 59
     d46:	b0 e0       	ldi	r27, 0x00	; 0
     d48:	eb e3       	ldi	r30, 0x3B	; 59
     d4a:	f0 e0       	ldi	r31, 0x00	; 0
     d4c:	80 81       	ld	r24, Z
     d4e:	48 2f       	mov	r20, r24
     d50:	8a 81       	ldd	r24, Y+2	; 0x02
     d52:	28 2f       	mov	r18, r24
     d54:	30 e0       	ldi	r19, 0x00	; 0
     d56:	81 e0       	ldi	r24, 0x01	; 1
     d58:	90 e0       	ldi	r25, 0x00	; 0
     d5a:	02 2e       	mov	r0, r18
     d5c:	02 c0       	rjmp	.+4      	; 0xd62 <DIO_voidSetPinValue+0x8e>
     d5e:	88 0f       	add	r24, r24
     d60:	99 1f       	adc	r25, r25
     d62:	0a 94       	dec	r0
     d64:	e2 f7       	brpl	.-8      	; 0xd5e <DIO_voidSetPinValue+0x8a>
     d66:	84 2b       	or	r24, r20
     d68:	8c 93       	st	X, r24
     d6a:	b3 c0       	rjmp	.+358    	; 0xed2 <DIO_voidSetPinValue+0x1fe>
				case DIO_u8_PORTB: SET_BIT(PORTB_Register,u8PinIdCopy); break;
     d6c:	a8 e3       	ldi	r26, 0x38	; 56
     d6e:	b0 e0       	ldi	r27, 0x00	; 0
     d70:	e8 e3       	ldi	r30, 0x38	; 56
     d72:	f0 e0       	ldi	r31, 0x00	; 0
     d74:	80 81       	ld	r24, Z
     d76:	48 2f       	mov	r20, r24
     d78:	8a 81       	ldd	r24, Y+2	; 0x02
     d7a:	28 2f       	mov	r18, r24
     d7c:	30 e0       	ldi	r19, 0x00	; 0
     d7e:	81 e0       	ldi	r24, 0x01	; 1
     d80:	90 e0       	ldi	r25, 0x00	; 0
     d82:	02 2e       	mov	r0, r18
     d84:	02 c0       	rjmp	.+4      	; 0xd8a <DIO_voidSetPinValue+0xb6>
     d86:	88 0f       	add	r24, r24
     d88:	99 1f       	adc	r25, r25
     d8a:	0a 94       	dec	r0
     d8c:	e2 f7       	brpl	.-8      	; 0xd86 <DIO_voidSetPinValue+0xb2>
     d8e:	84 2b       	or	r24, r20
     d90:	8c 93       	st	X, r24
     d92:	9f c0       	rjmp	.+318    	; 0xed2 <DIO_voidSetPinValue+0x1fe>
				case DIO_u8_PORTC: SET_BIT(PORTC_Register,u8PinIdCopy); break;
     d94:	a5 e3       	ldi	r26, 0x35	; 53
     d96:	b0 e0       	ldi	r27, 0x00	; 0
     d98:	e5 e3       	ldi	r30, 0x35	; 53
     d9a:	f0 e0       	ldi	r31, 0x00	; 0
     d9c:	80 81       	ld	r24, Z
     d9e:	48 2f       	mov	r20, r24
     da0:	8a 81       	ldd	r24, Y+2	; 0x02
     da2:	28 2f       	mov	r18, r24
     da4:	30 e0       	ldi	r19, 0x00	; 0
     da6:	81 e0       	ldi	r24, 0x01	; 1
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	02 2e       	mov	r0, r18
     dac:	02 c0       	rjmp	.+4      	; 0xdb2 <DIO_voidSetPinValue+0xde>
     dae:	88 0f       	add	r24, r24
     db0:	99 1f       	adc	r25, r25
     db2:	0a 94       	dec	r0
     db4:	e2 f7       	brpl	.-8      	; 0xdae <DIO_voidSetPinValue+0xda>
     db6:	84 2b       	or	r24, r20
     db8:	8c 93       	st	X, r24
     dba:	8b c0       	rjmp	.+278    	; 0xed2 <DIO_voidSetPinValue+0x1fe>
				case DIO_u8_PORTD: SET_BIT(PORTD_Register,u8PinIdCopy); break;
     dbc:	a2 e3       	ldi	r26, 0x32	; 50
     dbe:	b0 e0       	ldi	r27, 0x00	; 0
     dc0:	e2 e3       	ldi	r30, 0x32	; 50
     dc2:	f0 e0       	ldi	r31, 0x00	; 0
     dc4:	80 81       	ld	r24, Z
     dc6:	48 2f       	mov	r20, r24
     dc8:	8a 81       	ldd	r24, Y+2	; 0x02
     dca:	28 2f       	mov	r18, r24
     dcc:	30 e0       	ldi	r19, 0x00	; 0
     dce:	81 e0       	ldi	r24, 0x01	; 1
     dd0:	90 e0       	ldi	r25, 0x00	; 0
     dd2:	02 2e       	mov	r0, r18
     dd4:	02 c0       	rjmp	.+4      	; 0xdda <DIO_voidSetPinValue+0x106>
     dd6:	88 0f       	add	r24, r24
     dd8:	99 1f       	adc	r25, r25
     dda:	0a 94       	dec	r0
     ddc:	e2 f7       	brpl	.-8      	; 0xdd6 <DIO_voidSetPinValue+0x102>
     dde:	84 2b       	or	r24, r20
     de0:	8c 93       	st	X, r24
     de2:	77 c0       	rjmp	.+238    	; 0xed2 <DIO_voidSetPinValue+0x1fe>
			}
		
		}
		
		else if (u8PinValCopy == DIO_u8_LOW)
     de4:	8b 81       	ldd	r24, Y+3	; 0x03
     de6:	88 23       	and	r24, r24
     de8:	09 f0       	breq	.+2      	; 0xdec <DIO_voidSetPinValue+0x118>
     dea:	73 c0       	rjmp	.+230    	; 0xed2 <DIO_voidSetPinValue+0x1fe>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
     dec:	89 81       	ldd	r24, Y+1	; 0x01
     dee:	28 2f       	mov	r18, r24
     df0:	30 e0       	ldi	r19, 0x00	; 0
     df2:	3d 83       	std	Y+5, r19	; 0x05
     df4:	2c 83       	std	Y+4, r18	; 0x04
     df6:	8c 81       	ldd	r24, Y+4	; 0x04
     df8:	9d 81       	ldd	r25, Y+5	; 0x05
     dfa:	81 30       	cpi	r24, 0x01	; 1
     dfc:	91 05       	cpc	r25, r1
     dfe:	59 f1       	breq	.+86     	; 0xe56 <DIO_voidSetPinValue+0x182>
     e00:	2c 81       	ldd	r18, Y+4	; 0x04
     e02:	3d 81       	ldd	r19, Y+5	; 0x05
     e04:	22 30       	cpi	r18, 0x02	; 2
     e06:	31 05       	cpc	r19, r1
     e08:	2c f4       	brge	.+10     	; 0xe14 <DIO_voidSetPinValue+0x140>
     e0a:	8c 81       	ldd	r24, Y+4	; 0x04
     e0c:	9d 81       	ldd	r25, Y+5	; 0x05
     e0e:	00 97       	sbiw	r24, 0x00	; 0
     e10:	69 f0       	breq	.+26     	; 0xe2c <DIO_voidSetPinValue+0x158>
     e12:	5f c0       	rjmp	.+190    	; 0xed2 <DIO_voidSetPinValue+0x1fe>
     e14:	2c 81       	ldd	r18, Y+4	; 0x04
     e16:	3d 81       	ldd	r19, Y+5	; 0x05
     e18:	22 30       	cpi	r18, 0x02	; 2
     e1a:	31 05       	cpc	r19, r1
     e1c:	89 f1       	breq	.+98     	; 0xe80 <DIO_voidSetPinValue+0x1ac>
     e1e:	8c 81       	ldd	r24, Y+4	; 0x04
     e20:	9d 81       	ldd	r25, Y+5	; 0x05
     e22:	83 30       	cpi	r24, 0x03	; 3
     e24:	91 05       	cpc	r25, r1
     e26:	09 f4       	brne	.+2      	; 0xe2a <DIO_voidSetPinValue+0x156>
     e28:	40 c0       	rjmp	.+128    	; 0xeaa <DIO_voidSetPinValue+0x1d6>
     e2a:	53 c0       	rjmp	.+166    	; 0xed2 <DIO_voidSetPinValue+0x1fe>
			{
				case DIO_u8_PORTA: CLR_BIT(PORTA_Register,u8PinIdCopy); break;
     e2c:	ab e3       	ldi	r26, 0x3B	; 59
     e2e:	b0 e0       	ldi	r27, 0x00	; 0
     e30:	eb e3       	ldi	r30, 0x3B	; 59
     e32:	f0 e0       	ldi	r31, 0x00	; 0
     e34:	80 81       	ld	r24, Z
     e36:	48 2f       	mov	r20, r24
     e38:	8a 81       	ldd	r24, Y+2	; 0x02
     e3a:	28 2f       	mov	r18, r24
     e3c:	30 e0       	ldi	r19, 0x00	; 0
     e3e:	81 e0       	ldi	r24, 0x01	; 1
     e40:	90 e0       	ldi	r25, 0x00	; 0
     e42:	02 2e       	mov	r0, r18
     e44:	02 c0       	rjmp	.+4      	; 0xe4a <DIO_voidSetPinValue+0x176>
     e46:	88 0f       	add	r24, r24
     e48:	99 1f       	adc	r25, r25
     e4a:	0a 94       	dec	r0
     e4c:	e2 f7       	brpl	.-8      	; 0xe46 <DIO_voidSetPinValue+0x172>
     e4e:	80 95       	com	r24
     e50:	84 23       	and	r24, r20
     e52:	8c 93       	st	X, r24
     e54:	3e c0       	rjmp	.+124    	; 0xed2 <DIO_voidSetPinValue+0x1fe>
				case DIO_u8_PORTB: CLR_BIT(PORTB_Register,u8PinIdCopy); break;
     e56:	a8 e3       	ldi	r26, 0x38	; 56
     e58:	b0 e0       	ldi	r27, 0x00	; 0
     e5a:	e8 e3       	ldi	r30, 0x38	; 56
     e5c:	f0 e0       	ldi	r31, 0x00	; 0
     e5e:	80 81       	ld	r24, Z
     e60:	48 2f       	mov	r20, r24
     e62:	8a 81       	ldd	r24, Y+2	; 0x02
     e64:	28 2f       	mov	r18, r24
     e66:	30 e0       	ldi	r19, 0x00	; 0
     e68:	81 e0       	ldi	r24, 0x01	; 1
     e6a:	90 e0       	ldi	r25, 0x00	; 0
     e6c:	02 2e       	mov	r0, r18
     e6e:	02 c0       	rjmp	.+4      	; 0xe74 <DIO_voidSetPinValue+0x1a0>
     e70:	88 0f       	add	r24, r24
     e72:	99 1f       	adc	r25, r25
     e74:	0a 94       	dec	r0
     e76:	e2 f7       	brpl	.-8      	; 0xe70 <DIO_voidSetPinValue+0x19c>
     e78:	80 95       	com	r24
     e7a:	84 23       	and	r24, r20
     e7c:	8c 93       	st	X, r24
     e7e:	29 c0       	rjmp	.+82     	; 0xed2 <DIO_voidSetPinValue+0x1fe>
				case DIO_u8_PORTC: CLR_BIT(PORTC_Register,u8PinIdCopy); break;
     e80:	a5 e3       	ldi	r26, 0x35	; 53
     e82:	b0 e0       	ldi	r27, 0x00	; 0
     e84:	e5 e3       	ldi	r30, 0x35	; 53
     e86:	f0 e0       	ldi	r31, 0x00	; 0
     e88:	80 81       	ld	r24, Z
     e8a:	48 2f       	mov	r20, r24
     e8c:	8a 81       	ldd	r24, Y+2	; 0x02
     e8e:	28 2f       	mov	r18, r24
     e90:	30 e0       	ldi	r19, 0x00	; 0
     e92:	81 e0       	ldi	r24, 0x01	; 1
     e94:	90 e0       	ldi	r25, 0x00	; 0
     e96:	02 2e       	mov	r0, r18
     e98:	02 c0       	rjmp	.+4      	; 0xe9e <DIO_voidSetPinValue+0x1ca>
     e9a:	88 0f       	add	r24, r24
     e9c:	99 1f       	adc	r25, r25
     e9e:	0a 94       	dec	r0
     ea0:	e2 f7       	brpl	.-8      	; 0xe9a <DIO_voidSetPinValue+0x1c6>
     ea2:	80 95       	com	r24
     ea4:	84 23       	and	r24, r20
     ea6:	8c 93       	st	X, r24
     ea8:	14 c0       	rjmp	.+40     	; 0xed2 <DIO_voidSetPinValue+0x1fe>
				case DIO_u8_PORTD: CLR_BIT(PORTD_Register,u8PinIdCopy); break;
     eaa:	a2 e3       	ldi	r26, 0x32	; 50
     eac:	b0 e0       	ldi	r27, 0x00	; 0
     eae:	e2 e3       	ldi	r30, 0x32	; 50
     eb0:	f0 e0       	ldi	r31, 0x00	; 0
     eb2:	80 81       	ld	r24, Z
     eb4:	48 2f       	mov	r20, r24
     eb6:	8a 81       	ldd	r24, Y+2	; 0x02
     eb8:	28 2f       	mov	r18, r24
     eba:	30 e0       	ldi	r19, 0x00	; 0
     ebc:	81 e0       	ldi	r24, 0x01	; 1
     ebe:	90 e0       	ldi	r25, 0x00	; 0
     ec0:	02 2e       	mov	r0, r18
     ec2:	02 c0       	rjmp	.+4      	; 0xec8 <DIO_voidSetPinValue+0x1f4>
     ec4:	88 0f       	add	r24, r24
     ec6:	99 1f       	adc	r25, r25
     ec8:	0a 94       	dec	r0
     eca:	e2 f7       	brpl	.-8      	; 0xec4 <DIO_voidSetPinValue+0x1f0>
     ecc:	80 95       	com	r24
     ece:	84 23       	and	r24, r20
     ed0:	8c 93       	st	X, r24
	
	else
	{
		/* Do nothing, Error in the Pin ID or PORT ID */
	}
}
     ed2:	27 96       	adiw	r28, 0x07	; 7
     ed4:	0f b6       	in	r0, 0x3f	; 63
     ed6:	f8 94       	cli
     ed8:	de bf       	out	0x3e, r29	; 62
     eda:	0f be       	out	0x3f, r0	; 63
     edc:	cd bf       	out	0x3d, r28	; 61
     ede:	cf 91       	pop	r28
     ee0:	df 91       	pop	r29
     ee2:	08 95       	ret

00000ee4 <DIO_u8GetPinValue>:

u8 DIO_u8GetPinValue(u8 u8PortIdCopy, u8 u8PinIdCopy)
{
     ee4:	df 93       	push	r29
     ee6:	cf 93       	push	r28
     ee8:	00 d0       	rcall	.+0      	; 0xeea <DIO_u8GetPinValue+0x6>
     eea:	00 d0       	rcall	.+0      	; 0xeec <DIO_u8GetPinValue+0x8>
     eec:	0f 92       	push	r0
     eee:	cd b7       	in	r28, 0x3d	; 61
     ef0:	de b7       	in	r29, 0x3e	; 62
     ef2:	8a 83       	std	Y+2, r24	; 0x02
     ef4:	6b 83       	std	Y+3, r22	; 0x03
	/* Define Local Variable to get the BIT Value */
	u8 u8ResultLocal;
	/* Make sure that the Port ID and Pin ID are in the valid range */
	if ((u8PortIdCopy <= DIO_u8_PORTD) && (u8PinIdCopy <= DIO_u8_PIN7))
     ef6:	8a 81       	ldd	r24, Y+2	; 0x02
     ef8:	84 30       	cpi	r24, 0x04	; 4
     efa:	08 f0       	brcs	.+2      	; 0xefe <DIO_u8GetPinValue+0x1a>
     efc:	6c c0       	rjmp	.+216    	; 0xfd6 <DIO_u8GetPinValue+0xf2>
     efe:	8b 81       	ldd	r24, Y+3	; 0x03
     f00:	88 30       	cpi	r24, 0x08	; 8
     f02:	08 f0       	brcs	.+2      	; 0xf06 <DIO_u8GetPinValue+0x22>
     f04:	68 c0       	rjmp	.+208    	; 0xfd6 <DIO_u8GetPinValue+0xf2>
	{
		/* Check on the Required PORT Number */
		switch (u8PortIdCopy)
     f06:	8a 81       	ldd	r24, Y+2	; 0x02
     f08:	28 2f       	mov	r18, r24
     f0a:	30 e0       	ldi	r19, 0x00	; 0
     f0c:	3d 83       	std	Y+5, r19	; 0x05
     f0e:	2c 83       	std	Y+4, r18	; 0x04
     f10:	4c 81       	ldd	r20, Y+4	; 0x04
     f12:	5d 81       	ldd	r21, Y+5	; 0x05
     f14:	41 30       	cpi	r20, 0x01	; 1
     f16:	51 05       	cpc	r21, r1
     f18:	41 f1       	breq	.+80     	; 0xf6a <DIO_u8GetPinValue+0x86>
     f1a:	8c 81       	ldd	r24, Y+4	; 0x04
     f1c:	9d 81       	ldd	r25, Y+5	; 0x05
     f1e:	82 30       	cpi	r24, 0x02	; 2
     f20:	91 05       	cpc	r25, r1
     f22:	34 f4       	brge	.+12     	; 0xf30 <DIO_u8GetPinValue+0x4c>
     f24:	2c 81       	ldd	r18, Y+4	; 0x04
     f26:	3d 81       	ldd	r19, Y+5	; 0x05
     f28:	21 15       	cp	r18, r1
     f2a:	31 05       	cpc	r19, r1
     f2c:	61 f0       	breq	.+24     	; 0xf46 <DIO_u8GetPinValue+0x62>
     f2e:	55 c0       	rjmp	.+170    	; 0xfda <DIO_u8GetPinValue+0xf6>
     f30:	4c 81       	ldd	r20, Y+4	; 0x04
     f32:	5d 81       	ldd	r21, Y+5	; 0x05
     f34:	42 30       	cpi	r20, 0x02	; 2
     f36:	51 05       	cpc	r21, r1
     f38:	51 f1       	breq	.+84     	; 0xf8e <DIO_u8GetPinValue+0xaa>
     f3a:	8c 81       	ldd	r24, Y+4	; 0x04
     f3c:	9d 81       	ldd	r25, Y+5	; 0x05
     f3e:	83 30       	cpi	r24, 0x03	; 3
     f40:	91 05       	cpc	r25, r1
     f42:	b9 f1       	breq	.+110    	; 0xfb2 <DIO_u8GetPinValue+0xce>
     f44:	4a c0       	rjmp	.+148    	; 0xfda <DIO_u8GetPinValue+0xf6>
		{
			case DIO_u8_PORTA: u8ResultLocal= GET_BIT(PINA_Register,u8PinIdCopy); break;
     f46:	e9 e3       	ldi	r30, 0x39	; 57
     f48:	f0 e0       	ldi	r31, 0x00	; 0
     f4a:	80 81       	ld	r24, Z
     f4c:	28 2f       	mov	r18, r24
     f4e:	30 e0       	ldi	r19, 0x00	; 0
     f50:	8b 81       	ldd	r24, Y+3	; 0x03
     f52:	88 2f       	mov	r24, r24
     f54:	90 e0       	ldi	r25, 0x00	; 0
     f56:	a9 01       	movw	r20, r18
     f58:	02 c0       	rjmp	.+4      	; 0xf5e <DIO_u8GetPinValue+0x7a>
     f5a:	55 95       	asr	r21
     f5c:	47 95       	ror	r20
     f5e:	8a 95       	dec	r24
     f60:	e2 f7       	brpl	.-8      	; 0xf5a <DIO_u8GetPinValue+0x76>
     f62:	ca 01       	movw	r24, r20
     f64:	81 70       	andi	r24, 0x01	; 1
     f66:	89 83       	std	Y+1, r24	; 0x01
     f68:	38 c0       	rjmp	.+112    	; 0xfda <DIO_u8GetPinValue+0xf6>
			case DIO_u8_PORTB: u8ResultLocal= GET_BIT(PINB_Register,u8PinIdCopy); break;
     f6a:	e6 e3       	ldi	r30, 0x36	; 54
     f6c:	f0 e0       	ldi	r31, 0x00	; 0
     f6e:	80 81       	ld	r24, Z
     f70:	28 2f       	mov	r18, r24
     f72:	30 e0       	ldi	r19, 0x00	; 0
     f74:	8b 81       	ldd	r24, Y+3	; 0x03
     f76:	88 2f       	mov	r24, r24
     f78:	90 e0       	ldi	r25, 0x00	; 0
     f7a:	a9 01       	movw	r20, r18
     f7c:	02 c0       	rjmp	.+4      	; 0xf82 <DIO_u8GetPinValue+0x9e>
     f7e:	55 95       	asr	r21
     f80:	47 95       	ror	r20
     f82:	8a 95       	dec	r24
     f84:	e2 f7       	brpl	.-8      	; 0xf7e <DIO_u8GetPinValue+0x9a>
     f86:	ca 01       	movw	r24, r20
     f88:	81 70       	andi	r24, 0x01	; 1
     f8a:	89 83       	std	Y+1, r24	; 0x01
     f8c:	26 c0       	rjmp	.+76     	; 0xfda <DIO_u8GetPinValue+0xf6>
			case DIO_u8_PORTC: u8ResultLocal= GET_BIT(PINC_Register,u8PinIdCopy); break;
     f8e:	e3 e3       	ldi	r30, 0x33	; 51
     f90:	f0 e0       	ldi	r31, 0x00	; 0
     f92:	80 81       	ld	r24, Z
     f94:	28 2f       	mov	r18, r24
     f96:	30 e0       	ldi	r19, 0x00	; 0
     f98:	8b 81       	ldd	r24, Y+3	; 0x03
     f9a:	88 2f       	mov	r24, r24
     f9c:	90 e0       	ldi	r25, 0x00	; 0
     f9e:	a9 01       	movw	r20, r18
     fa0:	02 c0       	rjmp	.+4      	; 0xfa6 <DIO_u8GetPinValue+0xc2>
     fa2:	55 95       	asr	r21
     fa4:	47 95       	ror	r20
     fa6:	8a 95       	dec	r24
     fa8:	e2 f7       	brpl	.-8      	; 0xfa2 <DIO_u8GetPinValue+0xbe>
     faa:	ca 01       	movw	r24, r20
     fac:	81 70       	andi	r24, 0x01	; 1
     fae:	89 83       	std	Y+1, r24	; 0x01
     fb0:	14 c0       	rjmp	.+40     	; 0xfda <DIO_u8GetPinValue+0xf6>
			case DIO_u8_PORTD: u8ResultLocal= GET_BIT(PIND_Register,u8PinIdCopy); break;
     fb2:	e0 e3       	ldi	r30, 0x30	; 48
     fb4:	f0 e0       	ldi	r31, 0x00	; 0
     fb6:	80 81       	ld	r24, Z
     fb8:	28 2f       	mov	r18, r24
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	8b 81       	ldd	r24, Y+3	; 0x03
     fbe:	88 2f       	mov	r24, r24
     fc0:	90 e0       	ldi	r25, 0x00	; 0
     fc2:	a9 01       	movw	r20, r18
     fc4:	02 c0       	rjmp	.+4      	; 0xfca <DIO_u8GetPinValue+0xe6>
     fc6:	55 95       	asr	r21
     fc8:	47 95       	ror	r20
     fca:	8a 95       	dec	r24
     fcc:	e2 f7       	brpl	.-8      	; 0xfc6 <DIO_u8GetPinValue+0xe2>
     fce:	ca 01       	movw	r24, r20
     fd0:	81 70       	andi	r24, 0x01	; 1
     fd2:	89 83       	std	Y+1, r24	; 0x01
     fd4:	02 c0       	rjmp	.+4      	; 0xfda <DIO_u8GetPinValue+0xf6>
	}
	
	else
	{
		/* return 0xff in case of error in the Pin ID or PORT ID */
		u8ResultLocal = 0xFF;
     fd6:	8f ef       	ldi	r24, 0xFF	; 255
     fd8:	89 83       	std	Y+1, r24	; 0x01
	}
	
	return u8ResultLocal;
     fda:	89 81       	ldd	r24, Y+1	; 0x01
}
     fdc:	0f 90       	pop	r0
     fde:	0f 90       	pop	r0
     fe0:	0f 90       	pop	r0
     fe2:	0f 90       	pop	r0
     fe4:	0f 90       	pop	r0
     fe6:	cf 91       	pop	r28
     fe8:	df 91       	pop	r29
     fea:	08 95       	ret

00000fec <DIO_voidSetPinDirection>:

void DIO_voidSetPinDirection  (u8 u8PortIdCopy, u8 u8PinIdCopy, u8 u8PinDirCopy)
{
     fec:	df 93       	push	r29
     fee:	cf 93       	push	r28
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
     ff4:	27 97       	sbiw	r28, 0x07	; 7
     ff6:	0f b6       	in	r0, 0x3f	; 63
     ff8:	f8 94       	cli
     ffa:	de bf       	out	0x3e, r29	; 62
     ffc:	0f be       	out	0x3f, r0	; 63
     ffe:	cd bf       	out	0x3d, r28	; 61
    1000:	89 83       	std	Y+1, r24	; 0x01
    1002:	6a 83       	std	Y+2, r22	; 0x02
    1004:	4b 83       	std	Y+3, r20	; 0x03
	/* Make sure that the Port ID and Pin ID are in the valid range */
	if ((u8PortIdCopy <= DIO_u8_PORTD) && (u8PinIdCopy <= DIO_u8_PIN7))
    1006:	89 81       	ldd	r24, Y+1	; 0x01
    1008:	84 30       	cpi	r24, 0x04	; 4
    100a:	08 f0       	brcs	.+2      	; 0x100e <DIO_voidSetPinDirection+0x22>
    100c:	ee c0       	rjmp	.+476    	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
    100e:	8a 81       	ldd	r24, Y+2	; 0x02
    1010:	88 30       	cpi	r24, 0x08	; 8
    1012:	08 f0       	brcs	.+2      	; 0x1016 <DIO_voidSetPinDirection+0x2a>
    1014:	ea c0       	rjmp	.+468    	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
	{
		if ( u8PinDirCopy == DIO_u8_OUTPUT )
    1016:	8b 81       	ldd	r24, Y+3	; 0x03
    1018:	81 30       	cpi	r24, 0x01	; 1
    101a:	09 f0       	breq	.+2      	; 0x101e <DIO_voidSetPinDirection+0x32>
    101c:	6f c0       	rjmp	.+222    	; 0x10fc <DIO_voidSetPinDirection+0x110>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
    101e:	89 81       	ldd	r24, Y+1	; 0x01
    1020:	28 2f       	mov	r18, r24
    1022:	30 e0       	ldi	r19, 0x00	; 0
    1024:	3f 83       	std	Y+7, r19	; 0x07
    1026:	2e 83       	std	Y+6, r18	; 0x06
    1028:	8e 81       	ldd	r24, Y+6	; 0x06
    102a:	9f 81       	ldd	r25, Y+7	; 0x07
    102c:	81 30       	cpi	r24, 0x01	; 1
    102e:	91 05       	cpc	r25, r1
    1030:	49 f1       	breq	.+82     	; 0x1084 <DIO_voidSetPinDirection+0x98>
    1032:	2e 81       	ldd	r18, Y+6	; 0x06
    1034:	3f 81       	ldd	r19, Y+7	; 0x07
    1036:	22 30       	cpi	r18, 0x02	; 2
    1038:	31 05       	cpc	r19, r1
    103a:	2c f4       	brge	.+10     	; 0x1046 <DIO_voidSetPinDirection+0x5a>
    103c:	8e 81       	ldd	r24, Y+6	; 0x06
    103e:	9f 81       	ldd	r25, Y+7	; 0x07
    1040:	00 97       	sbiw	r24, 0x00	; 0
    1042:	61 f0       	breq	.+24     	; 0x105c <DIO_voidSetPinDirection+0x70>
    1044:	d2 c0       	rjmp	.+420    	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
    1046:	2e 81       	ldd	r18, Y+6	; 0x06
    1048:	3f 81       	ldd	r19, Y+7	; 0x07
    104a:	22 30       	cpi	r18, 0x02	; 2
    104c:	31 05       	cpc	r19, r1
    104e:	71 f1       	breq	.+92     	; 0x10ac <DIO_voidSetPinDirection+0xc0>
    1050:	8e 81       	ldd	r24, Y+6	; 0x06
    1052:	9f 81       	ldd	r25, Y+7	; 0x07
    1054:	83 30       	cpi	r24, 0x03	; 3
    1056:	91 05       	cpc	r25, r1
    1058:	e9 f1       	breq	.+122    	; 0x10d4 <DIO_voidSetPinDirection+0xe8>
    105a:	c7 c0       	rjmp	.+398    	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
			{
				case DIO_u8_PORTA: SET_BIT(DDRA_Register,u8PinIdCopy); break;
    105c:	aa e3       	ldi	r26, 0x3A	; 58
    105e:	b0 e0       	ldi	r27, 0x00	; 0
    1060:	ea e3       	ldi	r30, 0x3A	; 58
    1062:	f0 e0       	ldi	r31, 0x00	; 0
    1064:	80 81       	ld	r24, Z
    1066:	48 2f       	mov	r20, r24
    1068:	8a 81       	ldd	r24, Y+2	; 0x02
    106a:	28 2f       	mov	r18, r24
    106c:	30 e0       	ldi	r19, 0x00	; 0
    106e:	81 e0       	ldi	r24, 0x01	; 1
    1070:	90 e0       	ldi	r25, 0x00	; 0
    1072:	02 2e       	mov	r0, r18
    1074:	02 c0       	rjmp	.+4      	; 0x107a <DIO_voidSetPinDirection+0x8e>
    1076:	88 0f       	add	r24, r24
    1078:	99 1f       	adc	r25, r25
    107a:	0a 94       	dec	r0
    107c:	e2 f7       	brpl	.-8      	; 0x1076 <DIO_voidSetPinDirection+0x8a>
    107e:	84 2b       	or	r24, r20
    1080:	8c 93       	st	X, r24
    1082:	b3 c0       	rjmp	.+358    	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
				case DIO_u8_PORTB: SET_BIT(DDRB_Register,u8PinIdCopy); break;
    1084:	a7 e3       	ldi	r26, 0x37	; 55
    1086:	b0 e0       	ldi	r27, 0x00	; 0
    1088:	e7 e3       	ldi	r30, 0x37	; 55
    108a:	f0 e0       	ldi	r31, 0x00	; 0
    108c:	80 81       	ld	r24, Z
    108e:	48 2f       	mov	r20, r24
    1090:	8a 81       	ldd	r24, Y+2	; 0x02
    1092:	28 2f       	mov	r18, r24
    1094:	30 e0       	ldi	r19, 0x00	; 0
    1096:	81 e0       	ldi	r24, 0x01	; 1
    1098:	90 e0       	ldi	r25, 0x00	; 0
    109a:	02 2e       	mov	r0, r18
    109c:	02 c0       	rjmp	.+4      	; 0x10a2 <DIO_voidSetPinDirection+0xb6>
    109e:	88 0f       	add	r24, r24
    10a0:	99 1f       	adc	r25, r25
    10a2:	0a 94       	dec	r0
    10a4:	e2 f7       	brpl	.-8      	; 0x109e <DIO_voidSetPinDirection+0xb2>
    10a6:	84 2b       	or	r24, r20
    10a8:	8c 93       	st	X, r24
    10aa:	9f c0       	rjmp	.+318    	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
				case DIO_u8_PORTC: SET_BIT(DDRC_Register,u8PinIdCopy); break;
    10ac:	a4 e3       	ldi	r26, 0x34	; 52
    10ae:	b0 e0       	ldi	r27, 0x00	; 0
    10b0:	e4 e3       	ldi	r30, 0x34	; 52
    10b2:	f0 e0       	ldi	r31, 0x00	; 0
    10b4:	80 81       	ld	r24, Z
    10b6:	48 2f       	mov	r20, r24
    10b8:	8a 81       	ldd	r24, Y+2	; 0x02
    10ba:	28 2f       	mov	r18, r24
    10bc:	30 e0       	ldi	r19, 0x00	; 0
    10be:	81 e0       	ldi	r24, 0x01	; 1
    10c0:	90 e0       	ldi	r25, 0x00	; 0
    10c2:	02 2e       	mov	r0, r18
    10c4:	02 c0       	rjmp	.+4      	; 0x10ca <DIO_voidSetPinDirection+0xde>
    10c6:	88 0f       	add	r24, r24
    10c8:	99 1f       	adc	r25, r25
    10ca:	0a 94       	dec	r0
    10cc:	e2 f7       	brpl	.-8      	; 0x10c6 <DIO_voidSetPinDirection+0xda>
    10ce:	84 2b       	or	r24, r20
    10d0:	8c 93       	st	X, r24
    10d2:	8b c0       	rjmp	.+278    	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
				case DIO_u8_PORTD: SET_BIT(DDRD_Register,u8PinIdCopy); break;
    10d4:	a1 e3       	ldi	r26, 0x31	; 49
    10d6:	b0 e0       	ldi	r27, 0x00	; 0
    10d8:	e1 e3       	ldi	r30, 0x31	; 49
    10da:	f0 e0       	ldi	r31, 0x00	; 0
    10dc:	80 81       	ld	r24, Z
    10de:	48 2f       	mov	r20, r24
    10e0:	8a 81       	ldd	r24, Y+2	; 0x02
    10e2:	28 2f       	mov	r18, r24
    10e4:	30 e0       	ldi	r19, 0x00	; 0
    10e6:	81 e0       	ldi	r24, 0x01	; 1
    10e8:	90 e0       	ldi	r25, 0x00	; 0
    10ea:	02 2e       	mov	r0, r18
    10ec:	02 c0       	rjmp	.+4      	; 0x10f2 <DIO_voidSetPinDirection+0x106>
    10ee:	88 0f       	add	r24, r24
    10f0:	99 1f       	adc	r25, r25
    10f2:	0a 94       	dec	r0
    10f4:	e2 f7       	brpl	.-8      	; 0x10ee <DIO_voidSetPinDirection+0x102>
    10f6:	84 2b       	or	r24, r20
    10f8:	8c 93       	st	X, r24
    10fa:	77 c0       	rjmp	.+238    	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
			}
		}
		
		else if ( u8PinDirCopy == DIO_u8_INPUT )
    10fc:	8b 81       	ldd	r24, Y+3	; 0x03
    10fe:	88 23       	and	r24, r24
    1100:	09 f0       	breq	.+2      	; 0x1104 <DIO_voidSetPinDirection+0x118>
    1102:	73 c0       	rjmp	.+230    	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
    1104:	89 81       	ldd	r24, Y+1	; 0x01
    1106:	28 2f       	mov	r18, r24
    1108:	30 e0       	ldi	r19, 0x00	; 0
    110a:	3d 83       	std	Y+5, r19	; 0x05
    110c:	2c 83       	std	Y+4, r18	; 0x04
    110e:	8c 81       	ldd	r24, Y+4	; 0x04
    1110:	9d 81       	ldd	r25, Y+5	; 0x05
    1112:	81 30       	cpi	r24, 0x01	; 1
    1114:	91 05       	cpc	r25, r1
    1116:	59 f1       	breq	.+86     	; 0x116e <DIO_voidSetPinDirection+0x182>
    1118:	2c 81       	ldd	r18, Y+4	; 0x04
    111a:	3d 81       	ldd	r19, Y+5	; 0x05
    111c:	22 30       	cpi	r18, 0x02	; 2
    111e:	31 05       	cpc	r19, r1
    1120:	2c f4       	brge	.+10     	; 0x112c <DIO_voidSetPinDirection+0x140>
    1122:	8c 81       	ldd	r24, Y+4	; 0x04
    1124:	9d 81       	ldd	r25, Y+5	; 0x05
    1126:	00 97       	sbiw	r24, 0x00	; 0
    1128:	69 f0       	breq	.+26     	; 0x1144 <DIO_voidSetPinDirection+0x158>
    112a:	5f c0       	rjmp	.+190    	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
    112c:	2c 81       	ldd	r18, Y+4	; 0x04
    112e:	3d 81       	ldd	r19, Y+5	; 0x05
    1130:	22 30       	cpi	r18, 0x02	; 2
    1132:	31 05       	cpc	r19, r1
    1134:	89 f1       	breq	.+98     	; 0x1198 <DIO_voidSetPinDirection+0x1ac>
    1136:	8c 81       	ldd	r24, Y+4	; 0x04
    1138:	9d 81       	ldd	r25, Y+5	; 0x05
    113a:	83 30       	cpi	r24, 0x03	; 3
    113c:	91 05       	cpc	r25, r1
    113e:	09 f4       	brne	.+2      	; 0x1142 <DIO_voidSetPinDirection+0x156>
    1140:	40 c0       	rjmp	.+128    	; 0x11c2 <DIO_voidSetPinDirection+0x1d6>
    1142:	53 c0       	rjmp	.+166    	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
			{
				case DIO_u8_PORTA: CLR_BIT(DDRA_Register,u8PinIdCopy); break;
    1144:	aa e3       	ldi	r26, 0x3A	; 58
    1146:	b0 e0       	ldi	r27, 0x00	; 0
    1148:	ea e3       	ldi	r30, 0x3A	; 58
    114a:	f0 e0       	ldi	r31, 0x00	; 0
    114c:	80 81       	ld	r24, Z
    114e:	48 2f       	mov	r20, r24
    1150:	8a 81       	ldd	r24, Y+2	; 0x02
    1152:	28 2f       	mov	r18, r24
    1154:	30 e0       	ldi	r19, 0x00	; 0
    1156:	81 e0       	ldi	r24, 0x01	; 1
    1158:	90 e0       	ldi	r25, 0x00	; 0
    115a:	02 2e       	mov	r0, r18
    115c:	02 c0       	rjmp	.+4      	; 0x1162 <DIO_voidSetPinDirection+0x176>
    115e:	88 0f       	add	r24, r24
    1160:	99 1f       	adc	r25, r25
    1162:	0a 94       	dec	r0
    1164:	e2 f7       	brpl	.-8      	; 0x115e <DIO_voidSetPinDirection+0x172>
    1166:	80 95       	com	r24
    1168:	84 23       	and	r24, r20
    116a:	8c 93       	st	X, r24
    116c:	3e c0       	rjmp	.+124    	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
				case DIO_u8_PORTB: CLR_BIT(DDRB_Register,u8PinIdCopy); break;
    116e:	a7 e3       	ldi	r26, 0x37	; 55
    1170:	b0 e0       	ldi	r27, 0x00	; 0
    1172:	e7 e3       	ldi	r30, 0x37	; 55
    1174:	f0 e0       	ldi	r31, 0x00	; 0
    1176:	80 81       	ld	r24, Z
    1178:	48 2f       	mov	r20, r24
    117a:	8a 81       	ldd	r24, Y+2	; 0x02
    117c:	28 2f       	mov	r18, r24
    117e:	30 e0       	ldi	r19, 0x00	; 0
    1180:	81 e0       	ldi	r24, 0x01	; 1
    1182:	90 e0       	ldi	r25, 0x00	; 0
    1184:	02 2e       	mov	r0, r18
    1186:	02 c0       	rjmp	.+4      	; 0x118c <DIO_voidSetPinDirection+0x1a0>
    1188:	88 0f       	add	r24, r24
    118a:	99 1f       	adc	r25, r25
    118c:	0a 94       	dec	r0
    118e:	e2 f7       	brpl	.-8      	; 0x1188 <DIO_voidSetPinDirection+0x19c>
    1190:	80 95       	com	r24
    1192:	84 23       	and	r24, r20
    1194:	8c 93       	st	X, r24
    1196:	29 c0       	rjmp	.+82     	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
				case DIO_u8_PORTC: CLR_BIT(DDRC_Register,u8PinIdCopy); break;
    1198:	a4 e3       	ldi	r26, 0x34	; 52
    119a:	b0 e0       	ldi	r27, 0x00	; 0
    119c:	e4 e3       	ldi	r30, 0x34	; 52
    119e:	f0 e0       	ldi	r31, 0x00	; 0
    11a0:	80 81       	ld	r24, Z
    11a2:	48 2f       	mov	r20, r24
    11a4:	8a 81       	ldd	r24, Y+2	; 0x02
    11a6:	28 2f       	mov	r18, r24
    11a8:	30 e0       	ldi	r19, 0x00	; 0
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	90 e0       	ldi	r25, 0x00	; 0
    11ae:	02 2e       	mov	r0, r18
    11b0:	02 c0       	rjmp	.+4      	; 0x11b6 <DIO_voidSetPinDirection+0x1ca>
    11b2:	88 0f       	add	r24, r24
    11b4:	99 1f       	adc	r25, r25
    11b6:	0a 94       	dec	r0
    11b8:	e2 f7       	brpl	.-8      	; 0x11b2 <DIO_voidSetPinDirection+0x1c6>
    11ba:	80 95       	com	r24
    11bc:	84 23       	and	r24, r20
    11be:	8c 93       	st	X, r24
    11c0:	14 c0       	rjmp	.+40     	; 0x11ea <DIO_voidSetPinDirection+0x1fe>
				case DIO_u8_PORTD: CLR_BIT(DDRD_Register,u8PinIdCopy); break;
    11c2:	a1 e3       	ldi	r26, 0x31	; 49
    11c4:	b0 e0       	ldi	r27, 0x00	; 0
    11c6:	e1 e3       	ldi	r30, 0x31	; 49
    11c8:	f0 e0       	ldi	r31, 0x00	; 0
    11ca:	80 81       	ld	r24, Z
    11cc:	48 2f       	mov	r20, r24
    11ce:	8a 81       	ldd	r24, Y+2	; 0x02
    11d0:	28 2f       	mov	r18, r24
    11d2:	30 e0       	ldi	r19, 0x00	; 0
    11d4:	81 e0       	ldi	r24, 0x01	; 1
    11d6:	90 e0       	ldi	r25, 0x00	; 0
    11d8:	02 2e       	mov	r0, r18
    11da:	02 c0       	rjmp	.+4      	; 0x11e0 <DIO_voidSetPinDirection+0x1f4>
    11dc:	88 0f       	add	r24, r24
    11de:	99 1f       	adc	r25, r25
    11e0:	0a 94       	dec	r0
    11e2:	e2 f7       	brpl	.-8      	; 0x11dc <DIO_voidSetPinDirection+0x1f0>
    11e4:	80 95       	com	r24
    11e6:	84 23       	and	r24, r20
    11e8:	8c 93       	st	X, r24
	
	else
	{
		/* Do nothing, Error in the Pin ID or PORT ID */
	}
}
    11ea:	27 96       	adiw	r28, 0x07	; 7
    11ec:	0f b6       	in	r0, 0x3f	; 63
    11ee:	f8 94       	cli
    11f0:	de bf       	out	0x3e, r29	; 62
    11f2:	0f be       	out	0x3f, r0	; 63
    11f4:	cd bf       	out	0x3d, r28	; 61
    11f6:	cf 91       	pop	r28
    11f8:	df 91       	pop	r29
    11fa:	08 95       	ret

000011fc <DIO_voidSetPortDirection>:


/* IO Ports */
void DIO_voidSetPortDirection (u8 u8PortId, u8 u8PortDir)
{
    11fc:	df 93       	push	r29
    11fe:	cf 93       	push	r28
    1200:	00 d0       	rcall	.+0      	; 0x1202 <DIO_voidSetPortDirection+0x6>
    1202:	00 d0       	rcall	.+0      	; 0x1204 <DIO_voidSetPortDirection+0x8>
    1204:	cd b7       	in	r28, 0x3d	; 61
    1206:	de b7       	in	r29, 0x3e	; 62
    1208:	89 83       	std	Y+1, r24	; 0x01
    120a:	6a 83       	std	Y+2, r22	; 0x02
	/* Check on the Required PORT Number */
	switch (u8PortId)
    120c:	89 81       	ldd	r24, Y+1	; 0x01
    120e:	28 2f       	mov	r18, r24
    1210:	30 e0       	ldi	r19, 0x00	; 0
    1212:	3c 83       	std	Y+4, r19	; 0x04
    1214:	2b 83       	std	Y+3, r18	; 0x03
    1216:	8b 81       	ldd	r24, Y+3	; 0x03
    1218:	9c 81       	ldd	r25, Y+4	; 0x04
    121a:	81 30       	cpi	r24, 0x01	; 1
    121c:	91 05       	cpc	r25, r1
    121e:	d1 f0       	breq	.+52     	; 0x1254 <DIO_voidSetPortDirection+0x58>
    1220:	2b 81       	ldd	r18, Y+3	; 0x03
    1222:	3c 81       	ldd	r19, Y+4	; 0x04
    1224:	22 30       	cpi	r18, 0x02	; 2
    1226:	31 05       	cpc	r19, r1
    1228:	2c f4       	brge	.+10     	; 0x1234 <DIO_voidSetPortDirection+0x38>
    122a:	8b 81       	ldd	r24, Y+3	; 0x03
    122c:	9c 81       	ldd	r25, Y+4	; 0x04
    122e:	00 97       	sbiw	r24, 0x00	; 0
    1230:	61 f0       	breq	.+24     	; 0x124a <DIO_voidSetPortDirection+0x4e>
    1232:	1e c0       	rjmp	.+60     	; 0x1270 <DIO_voidSetPortDirection+0x74>
    1234:	2b 81       	ldd	r18, Y+3	; 0x03
    1236:	3c 81       	ldd	r19, Y+4	; 0x04
    1238:	22 30       	cpi	r18, 0x02	; 2
    123a:	31 05       	cpc	r19, r1
    123c:	81 f0       	breq	.+32     	; 0x125e <DIO_voidSetPortDirection+0x62>
    123e:	8b 81       	ldd	r24, Y+3	; 0x03
    1240:	9c 81       	ldd	r25, Y+4	; 0x04
    1242:	83 30       	cpi	r24, 0x03	; 3
    1244:	91 05       	cpc	r25, r1
    1246:	81 f0       	breq	.+32     	; 0x1268 <DIO_voidSetPortDirection+0x6c>
    1248:	13 c0       	rjmp	.+38     	; 0x1270 <DIO_voidSetPortDirection+0x74>
	{
		case     DIO_u8_PORTA: DDRA_Register = u8PortDir; break;
    124a:	ea e3       	ldi	r30, 0x3A	; 58
    124c:	f0 e0       	ldi	r31, 0x00	; 0
    124e:	8a 81       	ldd	r24, Y+2	; 0x02
    1250:	80 83       	st	Z, r24
    1252:	0e c0       	rjmp	.+28     	; 0x1270 <DIO_voidSetPortDirection+0x74>
		case     DIO_u8_PORTB: DDRB_Register = u8PortDir; break;
    1254:	e7 e3       	ldi	r30, 0x37	; 55
    1256:	f0 e0       	ldi	r31, 0x00	; 0
    1258:	8a 81       	ldd	r24, Y+2	; 0x02
    125a:	80 83       	st	Z, r24
    125c:	09 c0       	rjmp	.+18     	; 0x1270 <DIO_voidSetPortDirection+0x74>
		case     DIO_u8_PORTC: DDRC_Register = u8PortDir; break;
    125e:	e4 e3       	ldi	r30, 0x34	; 52
    1260:	f0 e0       	ldi	r31, 0x00	; 0
    1262:	8a 81       	ldd	r24, Y+2	; 0x02
    1264:	80 83       	st	Z, r24
    1266:	04 c0       	rjmp	.+8      	; 0x1270 <DIO_voidSetPortDirection+0x74>
		case     DIO_u8_PORTD: DDRD_Register = u8PortDir; break;
    1268:	e1 e3       	ldi	r30, 0x31	; 49
    126a:	f0 e0       	ldi	r31, 0x00	; 0
    126c:	8a 81       	ldd	r24, Y+2	; 0x02
    126e:	80 83       	st	Z, r24
		default: /* Wrong Port ID */       break;
	}
}
    1270:	0f 90       	pop	r0
    1272:	0f 90       	pop	r0
    1274:	0f 90       	pop	r0
    1276:	0f 90       	pop	r0
    1278:	cf 91       	pop	r28
    127a:	df 91       	pop	r29
    127c:	08 95       	ret

0000127e <DIO_voidSetPortValue>:

void DIO_voidSetPortValue     (u8 u8PortId, u8 u8PortVal)
{
    127e:	df 93       	push	r29
    1280:	cf 93       	push	r28
    1282:	00 d0       	rcall	.+0      	; 0x1284 <DIO_voidSetPortValue+0x6>
    1284:	00 d0       	rcall	.+0      	; 0x1286 <DIO_voidSetPortValue+0x8>
    1286:	cd b7       	in	r28, 0x3d	; 61
    1288:	de b7       	in	r29, 0x3e	; 62
    128a:	89 83       	std	Y+1, r24	; 0x01
    128c:	6a 83       	std	Y+2, r22	; 0x02
	/* Check on the Required PORT Number */
	switch (u8PortId)
    128e:	89 81       	ldd	r24, Y+1	; 0x01
    1290:	28 2f       	mov	r18, r24
    1292:	30 e0       	ldi	r19, 0x00	; 0
    1294:	3c 83       	std	Y+4, r19	; 0x04
    1296:	2b 83       	std	Y+3, r18	; 0x03
    1298:	8b 81       	ldd	r24, Y+3	; 0x03
    129a:	9c 81       	ldd	r25, Y+4	; 0x04
    129c:	81 30       	cpi	r24, 0x01	; 1
    129e:	91 05       	cpc	r25, r1
    12a0:	d1 f0       	breq	.+52     	; 0x12d6 <DIO_voidSetPortValue+0x58>
    12a2:	2b 81       	ldd	r18, Y+3	; 0x03
    12a4:	3c 81       	ldd	r19, Y+4	; 0x04
    12a6:	22 30       	cpi	r18, 0x02	; 2
    12a8:	31 05       	cpc	r19, r1
    12aa:	2c f4       	brge	.+10     	; 0x12b6 <DIO_voidSetPortValue+0x38>
    12ac:	8b 81       	ldd	r24, Y+3	; 0x03
    12ae:	9c 81       	ldd	r25, Y+4	; 0x04
    12b0:	00 97       	sbiw	r24, 0x00	; 0
    12b2:	61 f0       	breq	.+24     	; 0x12cc <DIO_voidSetPortValue+0x4e>
    12b4:	1e c0       	rjmp	.+60     	; 0x12f2 <DIO_voidSetPortValue+0x74>
    12b6:	2b 81       	ldd	r18, Y+3	; 0x03
    12b8:	3c 81       	ldd	r19, Y+4	; 0x04
    12ba:	22 30       	cpi	r18, 0x02	; 2
    12bc:	31 05       	cpc	r19, r1
    12be:	81 f0       	breq	.+32     	; 0x12e0 <DIO_voidSetPortValue+0x62>
    12c0:	8b 81       	ldd	r24, Y+3	; 0x03
    12c2:	9c 81       	ldd	r25, Y+4	; 0x04
    12c4:	83 30       	cpi	r24, 0x03	; 3
    12c6:	91 05       	cpc	r25, r1
    12c8:	81 f0       	breq	.+32     	; 0x12ea <DIO_voidSetPortValue+0x6c>
    12ca:	13 c0       	rjmp	.+38     	; 0x12f2 <DIO_voidSetPortValue+0x74>
	{
		case     DIO_u8_PORTA: PORTA_Register = u8PortVal; break;
    12cc:	eb e3       	ldi	r30, 0x3B	; 59
    12ce:	f0 e0       	ldi	r31, 0x00	; 0
    12d0:	8a 81       	ldd	r24, Y+2	; 0x02
    12d2:	80 83       	st	Z, r24
    12d4:	0e c0       	rjmp	.+28     	; 0x12f2 <DIO_voidSetPortValue+0x74>
		case     DIO_u8_PORTB: PORTB_Register = u8PortVal; break;
    12d6:	e8 e3       	ldi	r30, 0x38	; 56
    12d8:	f0 e0       	ldi	r31, 0x00	; 0
    12da:	8a 81       	ldd	r24, Y+2	; 0x02
    12dc:	80 83       	st	Z, r24
    12de:	09 c0       	rjmp	.+18     	; 0x12f2 <DIO_voidSetPortValue+0x74>
		case     DIO_u8_PORTC: PORTC_Register = u8PortVal; break;
    12e0:	e5 e3       	ldi	r30, 0x35	; 53
    12e2:	f0 e0       	ldi	r31, 0x00	; 0
    12e4:	8a 81       	ldd	r24, Y+2	; 0x02
    12e6:	80 83       	st	Z, r24
    12e8:	04 c0       	rjmp	.+8      	; 0x12f2 <DIO_voidSetPortValue+0x74>
		case     DIO_u8_PORTD: PORTD_Register = u8PortVal; break;
    12ea:	e2 e3       	ldi	r30, 0x32	; 50
    12ec:	f0 e0       	ldi	r31, 0x00	; 0
    12ee:	8a 81       	ldd	r24, Y+2	; 0x02
    12f0:	80 83       	st	Z, r24
		default: /* Wrong Port ID */        break;
	}
}
    12f2:	0f 90       	pop	r0
    12f4:	0f 90       	pop	r0
    12f6:	0f 90       	pop	r0
    12f8:	0f 90       	pop	r0
    12fa:	cf 91       	pop	r28
    12fc:	df 91       	pop	r29
    12fe:	08 95       	ret

00001300 <usart_init>:
#include <avr/io.h>
#include "usart_driver.h"
#include "STD_TYPES.h"

void usart_init(unsigned short int baudrate)
{
    1300:	df 93       	push	r29
    1302:	cf 93       	push	r28
    1304:	00 d0       	rcall	.+0      	; 0x1306 <usart_init+0x6>
    1306:	00 d0       	rcall	.+0      	; 0x1308 <usart_init+0x8>
    1308:	cd b7       	in	r28, 0x3d	; 61
    130a:	de b7       	in	r29, 0x3e	; 62
    130c:	9c 83       	std	Y+4, r25	; 0x04
    130e:	8b 83       	std	Y+3, r24	; 0x03
	//Set baud rate
	unsigned short int UBRRVAL=(FCLK_SYSTEM/(baudrate*16UL))-1;
    1310:	8b 81       	ldd	r24, Y+3	; 0x03
    1312:	9c 81       	ldd	r25, Y+4	; 0x04
    1314:	cc 01       	movw	r24, r24
    1316:	a0 e0       	ldi	r26, 0x00	; 0
    1318:	b0 e0       	ldi	r27, 0x00	; 0
    131a:	88 0f       	add	r24, r24
    131c:	99 1f       	adc	r25, r25
    131e:	aa 1f       	adc	r26, r26
    1320:	bb 1f       	adc	r27, r27
    1322:	88 0f       	add	r24, r24
    1324:	99 1f       	adc	r25, r25
    1326:	aa 1f       	adc	r26, r26
    1328:	bb 1f       	adc	r27, r27
    132a:	88 0f       	add	r24, r24
    132c:	99 1f       	adc	r25, r25
    132e:	aa 1f       	adc	r26, r26
    1330:	bb 1f       	adc	r27, r27
    1332:	88 0f       	add	r24, r24
    1334:	99 1f       	adc	r25, r25
    1336:	aa 1f       	adc	r26, r26
    1338:	bb 1f       	adc	r27, r27
    133a:	9c 01       	movw	r18, r24
    133c:	ad 01       	movw	r20, r26
    133e:	80 e0       	ldi	r24, 0x00	; 0
    1340:	92 e1       	ldi	r25, 0x12	; 18
    1342:	aa e7       	ldi	r26, 0x7A	; 122
    1344:	b0 e0       	ldi	r27, 0x00	; 0
    1346:	bc 01       	movw	r22, r24
    1348:	cd 01       	movw	r24, r26
    134a:	0e 94 90 32 	call	0x6520	; 0x6520 <__udivmodsi4>
    134e:	da 01       	movw	r26, r20
    1350:	c9 01       	movw	r24, r18
    1352:	01 97       	sbiw	r24, 0x01	; 1
    1354:	9a 83       	std	Y+2, r25	; 0x02
    1356:	89 83       	std	Y+1, r24	; 0x01
	UBRRL=UBRRVAL; 			//low byte
    1358:	e9 e2       	ldi	r30, 0x29	; 41
    135a:	f0 e0       	ldi	r31, 0x00	; 0
    135c:	89 81       	ldd	r24, Y+1	; 0x01
    135e:	80 83       	st	Z, r24
	UBRRH=(UBRRVAL>>8); 	//high byte
    1360:	e0 e4       	ldi	r30, 0x40	; 64
    1362:	f0 e0       	ldi	r31, 0x00	; 0
    1364:	89 81       	ldd	r24, Y+1	; 0x01
    1366:	9a 81       	ldd	r25, Y+2	; 0x02
    1368:	89 2f       	mov	r24, r25
    136a:	99 27       	eor	r25, r25
    136c:	80 83       	st	Z, r24

	//Set data frame format: asynchronous mode,no parity, 1 stop bit, 8 bit size
	UCSRC=(1<<URSEL)|(0<<UMSEL)|(0<<UPM1)|(0<<UPM0)|(0<<USBS)|(0<<UCSZ2)|(1<<UCSZ1)|(1<<UCSZ0); 
    136e:	e0 e4       	ldi	r30, 0x40	; 64
    1370:	f0 e0       	ldi	r31, 0x00	; 0
    1372:	86 e8       	ldi	r24, 0x86	; 134
    1374:	80 83       	st	Z, r24

	//Enable Transmitter and Receiver
	UCSRB=(1<<RXEN)|(1<<TXEN);
    1376:	ea e2       	ldi	r30, 0x2A	; 42
    1378:	f0 e0       	ldi	r31, 0x00	; 0
    137a:	88 e1       	ldi	r24, 0x18	; 24
    137c:	80 83       	st	Z, r24
}
    137e:	0f 90       	pop	r0
    1380:	0f 90       	pop	r0
    1382:	0f 90       	pop	r0
    1384:	0f 90       	pop	r0
    1386:	cf 91       	pop	r28
    1388:	df 91       	pop	r29
    138a:	08 95       	ret

0000138c <usart_getc>:
unsigned char usart_getc( void )
{
    138c:	df 93       	push	r29
    138e:	cf 93       	push	r28
    1390:	cd b7       	in	r28, 0x3d	; 61
    1392:	de b7       	in	r29, 0x3e	; 62
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<RXC)) );
    1394:	eb e2       	ldi	r30, 0x2B	; 43
    1396:	f0 e0       	ldi	r31, 0x00	; 0
    1398:	80 81       	ld	r24, Z
    139a:	88 23       	and	r24, r24
    139c:	dc f7       	brge	.-10     	; 0x1394 <usart_getc+0x8>
	/* Get and return received data from buffer */
	return UDR;
    139e:	ec e2       	ldi	r30, 0x2C	; 44
    13a0:	f0 e0       	ldi	r31, 0x00	; 0
    13a2:	80 81       	ld	r24, Z
}
    13a4:	cf 91       	pop	r28
    13a6:	df 91       	pop	r29
    13a8:	08 95       	ret

000013aa <usart_getc_NonBlocking>:

ERROR_t usart_getc_NonBlocking(u8 * pData )
{
    13aa:	df 93       	push	r29
    13ac:	cf 93       	push	r28
    13ae:	00 d0       	rcall	.+0      	; 0x13b0 <usart_getc_NonBlocking+0x6>
    13b0:	0f 92       	push	r0
    13b2:	cd b7       	in	r28, 0x3d	; 61
    13b4:	de b7       	in	r29, 0x3e	; 62
    13b6:	9a 83       	std	Y+2, r25	; 0x02
    13b8:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for data to be received */
	if ( (UCSRA & (1<<RXC)) )
    13ba:	eb e2       	ldi	r30, 0x2B	; 43
    13bc:	f0 e0       	ldi	r31, 0x00	; 0
    13be:	80 81       	ld	r24, Z
    13c0:	88 23       	and	r24, r24
    13c2:	44 f4       	brge	.+16     	; 0x13d4 <usart_getc_NonBlocking+0x2a>
	{
		*pData = UDR;
    13c4:	ec e2       	ldi	r30, 0x2C	; 44
    13c6:	f0 e0       	ldi	r31, 0x00	; 0
    13c8:	80 81       	ld	r24, Z
    13ca:	e9 81       	ldd	r30, Y+1	; 0x01
    13cc:	fa 81       	ldd	r31, Y+2	; 0x02
    13ce:	80 83       	st	Z, r24
		return E_OK;
    13d0:	1b 82       	std	Y+3, r1	; 0x03
    13d2:	02 c0       	rjmp	.+4      	; 0x13d8 <usart_getc_NonBlocking+0x2e>
	}
	else
	{
		return PENDING;
    13d4:	82 e0       	ldi	r24, 0x02	; 2
    13d6:	8b 83       	std	Y+3, r24	; 0x03
    13d8:	8b 81       	ldd	r24, Y+3	; 0x03
	}

}
    13da:	0f 90       	pop	r0
    13dc:	0f 90       	pop	r0
    13de:	0f 90       	pop	r0
    13e0:	cf 91       	pop	r28
    13e2:	df 91       	pop	r29
    13e4:	08 95       	ret

000013e6 <usart_putc>:
void usart_putc( unsigned char data )
{
    13e6:	df 93       	push	r29
    13e8:	cf 93       	push	r28
    13ea:	0f 92       	push	r0
    13ec:	cd b7       	in	r28, 0x3d	; 61
    13ee:	de b7       	in	r29, 0x3e	; 62
    13f0:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)));
    13f2:	eb e2       	ldi	r30, 0x2B	; 43
    13f4:	f0 e0       	ldi	r31, 0x00	; 0
    13f6:	80 81       	ld	r24, Z
    13f8:	88 2f       	mov	r24, r24
    13fa:	90 e0       	ldi	r25, 0x00	; 0
    13fc:	80 72       	andi	r24, 0x20	; 32
    13fe:	90 70       	andi	r25, 0x00	; 0
    1400:	00 97       	sbiw	r24, 0x00	; 0
    1402:	b9 f3       	breq	.-18     	; 0x13f2 <usart_putc+0xc>
	/* Put data into buffer, sends the data */
	UDR = data;
    1404:	ec e2       	ldi	r30, 0x2C	; 44
    1406:	f0 e0       	ldi	r31, 0x00	; 0
    1408:	89 81       	ldd	r24, Y+1	; 0x01
    140a:	80 83       	st	Z, r24
}
    140c:	0f 90       	pop	r0
    140e:	cf 91       	pop	r28
    1410:	df 91       	pop	r29
    1412:	08 95       	ret

00001414 <usart_puts>:
void usart_puts( char* str )
{
    1414:	df 93       	push	r29
    1416:	cf 93       	push	r28
    1418:	00 d0       	rcall	.+0      	; 0x141a <usart_puts+0x6>
    141a:	00 d0       	rcall	.+0      	; 0x141c <usart_puts+0x8>
    141c:	cd b7       	in	r28, 0x3d	; 61
    141e:	de b7       	in	r29, 0x3e	; 62
    1420:	9c 83       	std	Y+4, r25	; 0x04
    1422:	8b 83       	std	Y+3, r24	; 0x03
	short int i=0;
    1424:	1a 82       	std	Y+2, r1	; 0x02
    1426:	19 82       	std	Y+1, r1	; 0x01
    1428:	0f c0       	rjmp	.+30     	; 0x1448 <usart_puts+0x34>
	while(str[i])
	{
		usart_putc(str[i]);
    142a:	29 81       	ldd	r18, Y+1	; 0x01
    142c:	3a 81       	ldd	r19, Y+2	; 0x02
    142e:	8b 81       	ldd	r24, Y+3	; 0x03
    1430:	9c 81       	ldd	r25, Y+4	; 0x04
    1432:	fc 01       	movw	r30, r24
    1434:	e2 0f       	add	r30, r18
    1436:	f3 1f       	adc	r31, r19
    1438:	80 81       	ld	r24, Z
    143a:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <usart_putc>
		i++;
    143e:	89 81       	ldd	r24, Y+1	; 0x01
    1440:	9a 81       	ldd	r25, Y+2	; 0x02
    1442:	01 96       	adiw	r24, 0x01	; 1
    1444:	9a 83       	std	Y+2, r25	; 0x02
    1446:	89 83       	std	Y+1, r24	; 0x01
	UDR = data;
}
void usart_puts( char* str )
{
	short int i=0;
	while(str[i])
    1448:	29 81       	ldd	r18, Y+1	; 0x01
    144a:	3a 81       	ldd	r19, Y+2	; 0x02
    144c:	8b 81       	ldd	r24, Y+3	; 0x03
    144e:	9c 81       	ldd	r25, Y+4	; 0x04
    1450:	fc 01       	movw	r30, r24
    1452:	e2 0f       	add	r30, r18
    1454:	f3 1f       	adc	r31, r19
    1456:	80 81       	ld	r24, Z
    1458:	88 23       	and	r24, r24
    145a:	39 f7       	brne	.-50     	; 0x142a <usart_puts+0x16>
	{
		usart_putc(str[i]);
		i++;
	}
}
    145c:	0f 90       	pop	r0
    145e:	0f 90       	pop	r0
    1460:	0f 90       	pop	r0
    1462:	0f 90       	pop	r0
    1464:	cf 91       	pop	r28
    1466:	df 91       	pop	r29
    1468:	08 95       	ret

0000146a <LCD_vidInit>:
/* Description! Apply initialization sequence for LCD module                           */
/* Input      ! Nothing                                                                */
/* Output     ! Nothing                                                                */
/***************************************************************************************/
void LCD_vidInit(void)
{
    146a:	0f 93       	push	r16
    146c:	1f 93       	push	r17
    146e:	df 93       	push	r29
    1470:	cf 93       	push	r28
    1472:	cd b7       	in	r28, 0x3d	; 61
    1474:	de b7       	in	r29, 0x3e	; 62
    1476:	c4 55       	subi	r28, 0x54	; 84
    1478:	d0 40       	sbci	r29, 0x00	; 0
    147a:	0f b6       	in	r0, 0x3f	; 63
    147c:	f8 94       	cli
    147e:	de bf       	out	0x3e, r29	; 62
    1480:	0f be       	out	0x3f, r0	; 63
    1482:	cd bf       	out	0x3d, r28	; 61
	/* Init the Direction for the Control and the data pins as an output */
	DIO_voidSetPortDirection(LCD_DATA_PORT,0xff);
    1484:	82 e0       	ldi	r24, 0x02	; 2
    1486:	6f ef       	ldi	r22, 0xFF	; 255
    1488:	0e 94 fe 08 	call	0x11fc	; 0x11fc <DIO_voidSetPortDirection>
	DIO_voidSetPinDirection(LCD_CONTROL_PORT,LCD_RS_PIN,DIO_u8_OUTPUT);
    148c:	83 e0       	ldi	r24, 0x03	; 3
    148e:	65 e0       	ldi	r22, 0x05	; 5
    1490:	41 e0       	ldi	r20, 0x01	; 1
    1492:	0e 94 f6 07 	call	0xfec	; 0xfec <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_CONTROL_PORT,LCD_RW_PIN,DIO_u8_OUTPUT);
    1496:	83 e0       	ldi	r24, 0x03	; 3
    1498:	66 e0       	ldi	r22, 0x06	; 6
    149a:	41 e0       	ldi	r20, 0x01	; 1
    149c:	0e 94 f6 07 	call	0xfec	; 0xfec <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_CONTROL_PORT,LCD_E_PIN,DIO_u8_OUTPUT);
    14a0:	83 e0       	ldi	r24, 0x03	; 3
    14a2:	67 e0       	ldi	r22, 0x07	; 7
    14a4:	41 e0       	ldi	r20, 0x01	; 1
    14a6:	0e 94 f6 07 	call	0xfec	; 0xfec <DIO_voidSetPinDirection>
    14aa:	fe 01       	movw	r30, r28
    14ac:	ef 5a       	subi	r30, 0xAF	; 175
    14ae:	ff 4f       	sbci	r31, 0xFF	; 255
    14b0:	80 e0       	ldi	r24, 0x00	; 0
    14b2:	90 e0       	ldi	r25, 0x00	; 0
    14b4:	a0 ef       	ldi	r26, 0xF0	; 240
    14b6:	b1 e4       	ldi	r27, 0x41	; 65
    14b8:	80 83       	st	Z, r24
    14ba:	91 83       	std	Z+1, r25	; 0x01
    14bc:	a2 83       	std	Z+2, r26	; 0x02
    14be:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    14c0:	8e 01       	movw	r16, r28
    14c2:	03 5b       	subi	r16, 0xB3	; 179
    14c4:	1f 4f       	sbci	r17, 0xFF	; 255
    14c6:	fe 01       	movw	r30, r28
    14c8:	ef 5a       	subi	r30, 0xAF	; 175
    14ca:	ff 4f       	sbci	r31, 0xFF	; 255
    14cc:	60 81       	ld	r22, Z
    14ce:	71 81       	ldd	r23, Z+1	; 0x01
    14d0:	82 81       	ldd	r24, Z+2	; 0x02
    14d2:	93 81       	ldd	r25, Z+3	; 0x03
    14d4:	20 e0       	ldi	r18, 0x00	; 0
    14d6:	30 e0       	ldi	r19, 0x00	; 0
    14d8:	4a ef       	ldi	r20, 0xFA	; 250
    14da:	54 e4       	ldi	r21, 0x44	; 68
    14dc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    14e0:	dc 01       	movw	r26, r24
    14e2:	cb 01       	movw	r24, r22
    14e4:	f8 01       	movw	r30, r16
    14e6:	80 83       	st	Z, r24
    14e8:	91 83       	std	Z+1, r25	; 0x01
    14ea:	a2 83       	std	Z+2, r26	; 0x02
    14ec:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    14ee:	fe 01       	movw	r30, r28
    14f0:	e3 5b       	subi	r30, 0xB3	; 179
    14f2:	ff 4f       	sbci	r31, 0xFF	; 255
    14f4:	60 81       	ld	r22, Z
    14f6:	71 81       	ldd	r23, Z+1	; 0x01
    14f8:	82 81       	ldd	r24, Z+2	; 0x02
    14fa:	93 81       	ldd	r25, Z+3	; 0x03
    14fc:	20 e0       	ldi	r18, 0x00	; 0
    14fe:	30 e0       	ldi	r19, 0x00	; 0
    1500:	40 e8       	ldi	r20, 0x80	; 128
    1502:	5f e3       	ldi	r21, 0x3F	; 63
    1504:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1508:	88 23       	and	r24, r24
    150a:	44 f4       	brge	.+16     	; 0x151c <LCD_vidInit+0xb2>
		__ticks = 1;
    150c:	fe 01       	movw	r30, r28
    150e:	e5 5b       	subi	r30, 0xB5	; 181
    1510:	ff 4f       	sbci	r31, 0xFF	; 255
    1512:	81 e0       	ldi	r24, 0x01	; 1
    1514:	90 e0       	ldi	r25, 0x00	; 0
    1516:	91 83       	std	Z+1, r25	; 0x01
    1518:	80 83       	st	Z, r24
    151a:	64 c0       	rjmp	.+200    	; 0x15e4 <LCD_vidInit+0x17a>
	else if (__tmp > 65535)
    151c:	fe 01       	movw	r30, r28
    151e:	e3 5b       	subi	r30, 0xB3	; 179
    1520:	ff 4f       	sbci	r31, 0xFF	; 255
    1522:	60 81       	ld	r22, Z
    1524:	71 81       	ldd	r23, Z+1	; 0x01
    1526:	82 81       	ldd	r24, Z+2	; 0x02
    1528:	93 81       	ldd	r25, Z+3	; 0x03
    152a:	20 e0       	ldi	r18, 0x00	; 0
    152c:	3f ef       	ldi	r19, 0xFF	; 255
    152e:	4f e7       	ldi	r20, 0x7F	; 127
    1530:	57 e4       	ldi	r21, 0x47	; 71
    1532:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1536:	18 16       	cp	r1, r24
    1538:	0c f0       	brlt	.+2      	; 0x153c <LCD_vidInit+0xd2>
    153a:	43 c0       	rjmp	.+134    	; 0x15c2 <LCD_vidInit+0x158>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    153c:	fe 01       	movw	r30, r28
    153e:	ef 5a       	subi	r30, 0xAF	; 175
    1540:	ff 4f       	sbci	r31, 0xFF	; 255
    1542:	60 81       	ld	r22, Z
    1544:	71 81       	ldd	r23, Z+1	; 0x01
    1546:	82 81       	ldd	r24, Z+2	; 0x02
    1548:	93 81       	ldd	r25, Z+3	; 0x03
    154a:	20 e0       	ldi	r18, 0x00	; 0
    154c:	30 e0       	ldi	r19, 0x00	; 0
    154e:	40 e2       	ldi	r20, 0x20	; 32
    1550:	51 e4       	ldi	r21, 0x41	; 65
    1552:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1556:	dc 01       	movw	r26, r24
    1558:	cb 01       	movw	r24, r22
    155a:	8e 01       	movw	r16, r28
    155c:	05 5b       	subi	r16, 0xB5	; 181
    155e:	1f 4f       	sbci	r17, 0xFF	; 255
    1560:	bc 01       	movw	r22, r24
    1562:	cd 01       	movw	r24, r26
    1564:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1568:	dc 01       	movw	r26, r24
    156a:	cb 01       	movw	r24, r22
    156c:	f8 01       	movw	r30, r16
    156e:	91 83       	std	Z+1, r25	; 0x01
    1570:	80 83       	st	Z, r24
    1572:	1f c0       	rjmp	.+62     	; 0x15b2 <LCD_vidInit+0x148>
    1574:	fe 01       	movw	r30, r28
    1576:	e7 5b       	subi	r30, 0xB7	; 183
    1578:	ff 4f       	sbci	r31, 0xFF	; 255
    157a:	88 ec       	ldi	r24, 0xC8	; 200
    157c:	90 e0       	ldi	r25, 0x00	; 0
    157e:	91 83       	std	Z+1, r25	; 0x01
    1580:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1582:	fe 01       	movw	r30, r28
    1584:	e7 5b       	subi	r30, 0xB7	; 183
    1586:	ff 4f       	sbci	r31, 0xFF	; 255
    1588:	80 81       	ld	r24, Z
    158a:	91 81       	ldd	r25, Z+1	; 0x01
    158c:	01 97       	sbiw	r24, 0x01	; 1
    158e:	f1 f7       	brne	.-4      	; 0x158c <LCD_vidInit+0x122>
    1590:	fe 01       	movw	r30, r28
    1592:	e7 5b       	subi	r30, 0xB7	; 183
    1594:	ff 4f       	sbci	r31, 0xFF	; 255
    1596:	91 83       	std	Z+1, r25	; 0x01
    1598:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    159a:	de 01       	movw	r26, r28
    159c:	a5 5b       	subi	r26, 0xB5	; 181
    159e:	bf 4f       	sbci	r27, 0xFF	; 255
    15a0:	fe 01       	movw	r30, r28
    15a2:	e5 5b       	subi	r30, 0xB5	; 181
    15a4:	ff 4f       	sbci	r31, 0xFF	; 255
    15a6:	80 81       	ld	r24, Z
    15a8:	91 81       	ldd	r25, Z+1	; 0x01
    15aa:	01 97       	sbiw	r24, 0x01	; 1
    15ac:	11 96       	adiw	r26, 0x01	; 1
    15ae:	9c 93       	st	X, r25
    15b0:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    15b2:	fe 01       	movw	r30, r28
    15b4:	e5 5b       	subi	r30, 0xB5	; 181
    15b6:	ff 4f       	sbci	r31, 0xFF	; 255
    15b8:	80 81       	ld	r24, Z
    15ba:	91 81       	ldd	r25, Z+1	; 0x01
    15bc:	00 97       	sbiw	r24, 0x00	; 0
    15be:	d1 f6       	brne	.-76     	; 0x1574 <LCD_vidInit+0x10a>
    15c0:	27 c0       	rjmp	.+78     	; 0x1610 <LCD_vidInit+0x1a6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    15c2:	8e 01       	movw	r16, r28
    15c4:	05 5b       	subi	r16, 0xB5	; 181
    15c6:	1f 4f       	sbci	r17, 0xFF	; 255
    15c8:	fe 01       	movw	r30, r28
    15ca:	e3 5b       	subi	r30, 0xB3	; 179
    15cc:	ff 4f       	sbci	r31, 0xFF	; 255
    15ce:	60 81       	ld	r22, Z
    15d0:	71 81       	ldd	r23, Z+1	; 0x01
    15d2:	82 81       	ldd	r24, Z+2	; 0x02
    15d4:	93 81       	ldd	r25, Z+3	; 0x03
    15d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    15da:	dc 01       	movw	r26, r24
    15dc:	cb 01       	movw	r24, r22
    15de:	f8 01       	movw	r30, r16
    15e0:	91 83       	std	Z+1, r25	; 0x01
    15e2:	80 83       	st	Z, r24
    15e4:	de 01       	movw	r26, r28
    15e6:	a9 5b       	subi	r26, 0xB9	; 185
    15e8:	bf 4f       	sbci	r27, 0xFF	; 255
    15ea:	fe 01       	movw	r30, r28
    15ec:	e5 5b       	subi	r30, 0xB5	; 181
    15ee:	ff 4f       	sbci	r31, 0xFF	; 255
    15f0:	80 81       	ld	r24, Z
    15f2:	91 81       	ldd	r25, Z+1	; 0x01
    15f4:	8d 93       	st	X+, r24
    15f6:	9c 93       	st	X, r25
    15f8:	fe 01       	movw	r30, r28
    15fa:	e9 5b       	subi	r30, 0xB9	; 185
    15fc:	ff 4f       	sbci	r31, 0xFF	; 255
    15fe:	80 81       	ld	r24, Z
    1600:	91 81       	ldd	r25, Z+1	; 0x01
    1602:	01 97       	sbiw	r24, 0x01	; 1
    1604:	f1 f7       	brne	.-4      	; 0x1602 <LCD_vidInit+0x198>
    1606:	fe 01       	movw	r30, r28
    1608:	e9 5b       	subi	r30, 0xB9	; 185
    160a:	ff 4f       	sbci	r31, 0xFF	; 255
    160c:	91 83       	std	Z+1, r25	; 0x01
    160e:	80 83       	st	Z, r24

	/* Delay 30ms to ensure the initialization of the LCD driver */
	_delay_ms(30);

	/* Return Home  */
	LCD_vidSendCommand(lcd_Home);
    1610:	82 e0       	ldi	r24, 0x02	; 2
    1612:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_vidSendCommand>
    1616:	fe 01       	movw	r30, r28
    1618:	ed 5b       	subi	r30, 0xBD	; 189
    161a:	ff 4f       	sbci	r31, 0xFF	; 255
    161c:	80 e0       	ldi	r24, 0x00	; 0
    161e:	90 e0       	ldi	r25, 0x00	; 0
    1620:	a0 e7       	ldi	r26, 0x70	; 112
    1622:	b1 e4       	ldi	r27, 0x41	; 65
    1624:	80 83       	st	Z, r24
    1626:	91 83       	std	Z+1, r25	; 0x01
    1628:	a2 83       	std	Z+2, r26	; 0x02
    162a:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    162c:	8e 01       	movw	r16, r28
    162e:	01 5c       	subi	r16, 0xC1	; 193
    1630:	1f 4f       	sbci	r17, 0xFF	; 255
    1632:	fe 01       	movw	r30, r28
    1634:	ed 5b       	subi	r30, 0xBD	; 189
    1636:	ff 4f       	sbci	r31, 0xFF	; 255
    1638:	60 81       	ld	r22, Z
    163a:	71 81       	ldd	r23, Z+1	; 0x01
    163c:	82 81       	ldd	r24, Z+2	; 0x02
    163e:	93 81       	ldd	r25, Z+3	; 0x03
    1640:	20 e0       	ldi	r18, 0x00	; 0
    1642:	30 e0       	ldi	r19, 0x00	; 0
    1644:	4a ef       	ldi	r20, 0xFA	; 250
    1646:	54 e4       	ldi	r21, 0x44	; 68
    1648:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    164c:	dc 01       	movw	r26, r24
    164e:	cb 01       	movw	r24, r22
    1650:	f8 01       	movw	r30, r16
    1652:	80 83       	st	Z, r24
    1654:	91 83       	std	Z+1, r25	; 0x01
    1656:	a2 83       	std	Z+2, r26	; 0x02
    1658:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    165a:	fe 01       	movw	r30, r28
    165c:	ff 96       	adiw	r30, 0x3f	; 63
    165e:	60 81       	ld	r22, Z
    1660:	71 81       	ldd	r23, Z+1	; 0x01
    1662:	82 81       	ldd	r24, Z+2	; 0x02
    1664:	93 81       	ldd	r25, Z+3	; 0x03
    1666:	20 e0       	ldi	r18, 0x00	; 0
    1668:	30 e0       	ldi	r19, 0x00	; 0
    166a:	40 e8       	ldi	r20, 0x80	; 128
    166c:	5f e3       	ldi	r21, 0x3F	; 63
    166e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1672:	88 23       	and	r24, r24
    1674:	2c f4       	brge	.+10     	; 0x1680 <LCD_vidInit+0x216>
		__ticks = 1;
    1676:	81 e0       	ldi	r24, 0x01	; 1
    1678:	90 e0       	ldi	r25, 0x00	; 0
    167a:	9e af       	std	Y+62, r25	; 0x3e
    167c:	8d af       	std	Y+61, r24	; 0x3d
    167e:	46 c0       	rjmp	.+140    	; 0x170c <LCD_vidInit+0x2a2>
	else if (__tmp > 65535)
    1680:	fe 01       	movw	r30, r28
    1682:	ff 96       	adiw	r30, 0x3f	; 63
    1684:	60 81       	ld	r22, Z
    1686:	71 81       	ldd	r23, Z+1	; 0x01
    1688:	82 81       	ldd	r24, Z+2	; 0x02
    168a:	93 81       	ldd	r25, Z+3	; 0x03
    168c:	20 e0       	ldi	r18, 0x00	; 0
    168e:	3f ef       	ldi	r19, 0xFF	; 255
    1690:	4f e7       	ldi	r20, 0x7F	; 127
    1692:	57 e4       	ldi	r21, 0x47	; 71
    1694:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1698:	18 16       	cp	r1, r24
    169a:	64 f5       	brge	.+88     	; 0x16f4 <LCD_vidInit+0x28a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    169c:	fe 01       	movw	r30, r28
    169e:	ed 5b       	subi	r30, 0xBD	; 189
    16a0:	ff 4f       	sbci	r31, 0xFF	; 255
    16a2:	60 81       	ld	r22, Z
    16a4:	71 81       	ldd	r23, Z+1	; 0x01
    16a6:	82 81       	ldd	r24, Z+2	; 0x02
    16a8:	93 81       	ldd	r25, Z+3	; 0x03
    16aa:	20 e0       	ldi	r18, 0x00	; 0
    16ac:	30 e0       	ldi	r19, 0x00	; 0
    16ae:	40 e2       	ldi	r20, 0x20	; 32
    16b0:	51 e4       	ldi	r21, 0x41	; 65
    16b2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    16b6:	dc 01       	movw	r26, r24
    16b8:	cb 01       	movw	r24, r22
    16ba:	bc 01       	movw	r22, r24
    16bc:	cd 01       	movw	r24, r26
    16be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16c2:	dc 01       	movw	r26, r24
    16c4:	cb 01       	movw	r24, r22
    16c6:	9e af       	std	Y+62, r25	; 0x3e
    16c8:	8d af       	std	Y+61, r24	; 0x3d
    16ca:	0f c0       	rjmp	.+30     	; 0x16ea <LCD_vidInit+0x280>
    16cc:	88 ec       	ldi	r24, 0xC8	; 200
    16ce:	90 e0       	ldi	r25, 0x00	; 0
    16d0:	9c af       	std	Y+60, r25	; 0x3c
    16d2:	8b af       	std	Y+59, r24	; 0x3b
    16d4:	8b ad       	ldd	r24, Y+59	; 0x3b
    16d6:	9c ad       	ldd	r25, Y+60	; 0x3c
    16d8:	01 97       	sbiw	r24, 0x01	; 1
    16da:	f1 f7       	brne	.-4      	; 0x16d8 <LCD_vidInit+0x26e>
    16dc:	9c af       	std	Y+60, r25	; 0x3c
    16de:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    16e0:	8d ad       	ldd	r24, Y+61	; 0x3d
    16e2:	9e ad       	ldd	r25, Y+62	; 0x3e
    16e4:	01 97       	sbiw	r24, 0x01	; 1
    16e6:	9e af       	std	Y+62, r25	; 0x3e
    16e8:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16ea:	8d ad       	ldd	r24, Y+61	; 0x3d
    16ec:	9e ad       	ldd	r25, Y+62	; 0x3e
    16ee:	00 97       	sbiw	r24, 0x00	; 0
    16f0:	69 f7       	brne	.-38     	; 0x16cc <LCD_vidInit+0x262>
    16f2:	16 c0       	rjmp	.+44     	; 0x1720 <LCD_vidInit+0x2b6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    16f4:	fe 01       	movw	r30, r28
    16f6:	ff 96       	adiw	r30, 0x3f	; 63
    16f8:	60 81       	ld	r22, Z
    16fa:	71 81       	ldd	r23, Z+1	; 0x01
    16fc:	82 81       	ldd	r24, Z+2	; 0x02
    16fe:	93 81       	ldd	r25, Z+3	; 0x03
    1700:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1704:	dc 01       	movw	r26, r24
    1706:	cb 01       	movw	r24, r22
    1708:	9e af       	std	Y+62, r25	; 0x3e
    170a:	8d af       	std	Y+61, r24	; 0x3d
    170c:	8d ad       	ldd	r24, Y+61	; 0x3d
    170e:	9e ad       	ldd	r25, Y+62	; 0x3e
    1710:	9a af       	std	Y+58, r25	; 0x3a
    1712:	89 af       	std	Y+57, r24	; 0x39
    1714:	89 ad       	ldd	r24, Y+57	; 0x39
    1716:	9a ad       	ldd	r25, Y+58	; 0x3a
    1718:	01 97       	sbiw	r24, 0x01	; 1
    171a:	f1 f7       	brne	.-4      	; 0x1718 <LCD_vidInit+0x2ae>
    171c:	9a af       	std	Y+58, r25	; 0x3a
    171e:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(15);

	/* Function Set  */
	LCD_vidSendCommand(lcd_FunctionSet8bit);
    1720:	88 e3       	ldi	r24, 0x38	; 56
    1722:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_vidSendCommand>
    1726:	80 e0       	ldi	r24, 0x00	; 0
    1728:	90 e0       	ldi	r25, 0x00	; 0
    172a:	a0 e8       	ldi	r26, 0x80	; 128
    172c:	bf e3       	ldi	r27, 0x3F	; 63
    172e:	8d ab       	std	Y+53, r24	; 0x35
    1730:	9e ab       	std	Y+54, r25	; 0x36
    1732:	af ab       	std	Y+55, r26	; 0x37
    1734:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1736:	6d a9       	ldd	r22, Y+53	; 0x35
    1738:	7e a9       	ldd	r23, Y+54	; 0x36
    173a:	8f a9       	ldd	r24, Y+55	; 0x37
    173c:	98 ad       	ldd	r25, Y+56	; 0x38
    173e:	20 e0       	ldi	r18, 0x00	; 0
    1740:	30 e0       	ldi	r19, 0x00	; 0
    1742:	4a ef       	ldi	r20, 0xFA	; 250
    1744:	54 e4       	ldi	r21, 0x44	; 68
    1746:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    174a:	dc 01       	movw	r26, r24
    174c:	cb 01       	movw	r24, r22
    174e:	89 ab       	std	Y+49, r24	; 0x31
    1750:	9a ab       	std	Y+50, r25	; 0x32
    1752:	ab ab       	std	Y+51, r26	; 0x33
    1754:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1756:	69 a9       	ldd	r22, Y+49	; 0x31
    1758:	7a a9       	ldd	r23, Y+50	; 0x32
    175a:	8b a9       	ldd	r24, Y+51	; 0x33
    175c:	9c a9       	ldd	r25, Y+52	; 0x34
    175e:	20 e0       	ldi	r18, 0x00	; 0
    1760:	30 e0       	ldi	r19, 0x00	; 0
    1762:	40 e8       	ldi	r20, 0x80	; 128
    1764:	5f e3       	ldi	r21, 0x3F	; 63
    1766:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    176a:	88 23       	and	r24, r24
    176c:	2c f4       	brge	.+10     	; 0x1778 <LCD_vidInit+0x30e>
		__ticks = 1;
    176e:	81 e0       	ldi	r24, 0x01	; 1
    1770:	90 e0       	ldi	r25, 0x00	; 0
    1772:	98 ab       	std	Y+48, r25	; 0x30
    1774:	8f a7       	std	Y+47, r24	; 0x2f
    1776:	3f c0       	rjmp	.+126    	; 0x17f6 <LCD_vidInit+0x38c>
	else if (__tmp > 65535)
    1778:	69 a9       	ldd	r22, Y+49	; 0x31
    177a:	7a a9       	ldd	r23, Y+50	; 0x32
    177c:	8b a9       	ldd	r24, Y+51	; 0x33
    177e:	9c a9       	ldd	r25, Y+52	; 0x34
    1780:	20 e0       	ldi	r18, 0x00	; 0
    1782:	3f ef       	ldi	r19, 0xFF	; 255
    1784:	4f e7       	ldi	r20, 0x7F	; 127
    1786:	57 e4       	ldi	r21, 0x47	; 71
    1788:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    178c:	18 16       	cp	r1, r24
    178e:	4c f5       	brge	.+82     	; 0x17e2 <LCD_vidInit+0x378>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1790:	6d a9       	ldd	r22, Y+53	; 0x35
    1792:	7e a9       	ldd	r23, Y+54	; 0x36
    1794:	8f a9       	ldd	r24, Y+55	; 0x37
    1796:	98 ad       	ldd	r25, Y+56	; 0x38
    1798:	20 e0       	ldi	r18, 0x00	; 0
    179a:	30 e0       	ldi	r19, 0x00	; 0
    179c:	40 e2       	ldi	r20, 0x20	; 32
    179e:	51 e4       	ldi	r21, 0x41	; 65
    17a0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17a4:	dc 01       	movw	r26, r24
    17a6:	cb 01       	movw	r24, r22
    17a8:	bc 01       	movw	r22, r24
    17aa:	cd 01       	movw	r24, r26
    17ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    17b0:	dc 01       	movw	r26, r24
    17b2:	cb 01       	movw	r24, r22
    17b4:	98 ab       	std	Y+48, r25	; 0x30
    17b6:	8f a7       	std	Y+47, r24	; 0x2f
    17b8:	0f c0       	rjmp	.+30     	; 0x17d8 <LCD_vidInit+0x36e>
    17ba:	88 ec       	ldi	r24, 0xC8	; 200
    17bc:	90 e0       	ldi	r25, 0x00	; 0
    17be:	9e a7       	std	Y+46, r25	; 0x2e
    17c0:	8d a7       	std	Y+45, r24	; 0x2d
    17c2:	8d a5       	ldd	r24, Y+45	; 0x2d
    17c4:	9e a5       	ldd	r25, Y+46	; 0x2e
    17c6:	01 97       	sbiw	r24, 0x01	; 1
    17c8:	f1 f7       	brne	.-4      	; 0x17c6 <LCD_vidInit+0x35c>
    17ca:	9e a7       	std	Y+46, r25	; 0x2e
    17cc:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    17ce:	8f a5       	ldd	r24, Y+47	; 0x2f
    17d0:	98 a9       	ldd	r25, Y+48	; 0x30
    17d2:	01 97       	sbiw	r24, 0x01	; 1
    17d4:	98 ab       	std	Y+48, r25	; 0x30
    17d6:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    17d8:	8f a5       	ldd	r24, Y+47	; 0x2f
    17da:	98 a9       	ldd	r25, Y+48	; 0x30
    17dc:	00 97       	sbiw	r24, 0x00	; 0
    17de:	69 f7       	brne	.-38     	; 0x17ba <LCD_vidInit+0x350>
    17e0:	14 c0       	rjmp	.+40     	; 0x180a <LCD_vidInit+0x3a0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    17e2:	69 a9       	ldd	r22, Y+49	; 0x31
    17e4:	7a a9       	ldd	r23, Y+50	; 0x32
    17e6:	8b a9       	ldd	r24, Y+51	; 0x33
    17e8:	9c a9       	ldd	r25, Y+52	; 0x34
    17ea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    17ee:	dc 01       	movw	r26, r24
    17f0:	cb 01       	movw	r24, r22
    17f2:	98 ab       	std	Y+48, r25	; 0x30
    17f4:	8f a7       	std	Y+47, r24	; 0x2f
    17f6:	8f a5       	ldd	r24, Y+47	; 0x2f
    17f8:	98 a9       	ldd	r25, Y+48	; 0x30
    17fa:	9c a7       	std	Y+44, r25	; 0x2c
    17fc:	8b a7       	std	Y+43, r24	; 0x2b
    17fe:	8b a5       	ldd	r24, Y+43	; 0x2b
    1800:	9c a5       	ldd	r25, Y+44	; 0x2c
    1802:	01 97       	sbiw	r24, 0x01	; 1
    1804:	f1 f7       	brne	.-4      	; 0x1802 <LCD_vidInit+0x398>
    1806:	9c a7       	std	Y+44, r25	; 0x2c
    1808:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1);



	/* Display ON OFF Control */
	LCD_vidSendCommand(lcd_DisplayOn);
    180a:	8c e0       	ldi	r24, 0x0C	; 12
    180c:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_vidSendCommand>
    1810:	80 e0       	ldi	r24, 0x00	; 0
    1812:	90 e0       	ldi	r25, 0x00	; 0
    1814:	a0 e8       	ldi	r26, 0x80	; 128
    1816:	bf e3       	ldi	r27, 0x3F	; 63
    1818:	8f a3       	std	Y+39, r24	; 0x27
    181a:	98 a7       	std	Y+40, r25	; 0x28
    181c:	a9 a7       	std	Y+41, r26	; 0x29
    181e:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1820:	6f a1       	ldd	r22, Y+39	; 0x27
    1822:	78 a5       	ldd	r23, Y+40	; 0x28
    1824:	89 a5       	ldd	r24, Y+41	; 0x29
    1826:	9a a5       	ldd	r25, Y+42	; 0x2a
    1828:	20 e0       	ldi	r18, 0x00	; 0
    182a:	30 e0       	ldi	r19, 0x00	; 0
    182c:	4a ef       	ldi	r20, 0xFA	; 250
    182e:	54 e4       	ldi	r21, 0x44	; 68
    1830:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1834:	dc 01       	movw	r26, r24
    1836:	cb 01       	movw	r24, r22
    1838:	8b a3       	std	Y+35, r24	; 0x23
    183a:	9c a3       	std	Y+36, r25	; 0x24
    183c:	ad a3       	std	Y+37, r26	; 0x25
    183e:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1840:	6b a1       	ldd	r22, Y+35	; 0x23
    1842:	7c a1       	ldd	r23, Y+36	; 0x24
    1844:	8d a1       	ldd	r24, Y+37	; 0x25
    1846:	9e a1       	ldd	r25, Y+38	; 0x26
    1848:	20 e0       	ldi	r18, 0x00	; 0
    184a:	30 e0       	ldi	r19, 0x00	; 0
    184c:	40 e8       	ldi	r20, 0x80	; 128
    184e:	5f e3       	ldi	r21, 0x3F	; 63
    1850:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1854:	88 23       	and	r24, r24
    1856:	2c f4       	brge	.+10     	; 0x1862 <LCD_vidInit+0x3f8>
		__ticks = 1;
    1858:	81 e0       	ldi	r24, 0x01	; 1
    185a:	90 e0       	ldi	r25, 0x00	; 0
    185c:	9a a3       	std	Y+34, r25	; 0x22
    185e:	89 a3       	std	Y+33, r24	; 0x21
    1860:	3f c0       	rjmp	.+126    	; 0x18e0 <LCD_vidInit+0x476>
	else if (__tmp > 65535)
    1862:	6b a1       	ldd	r22, Y+35	; 0x23
    1864:	7c a1       	ldd	r23, Y+36	; 0x24
    1866:	8d a1       	ldd	r24, Y+37	; 0x25
    1868:	9e a1       	ldd	r25, Y+38	; 0x26
    186a:	20 e0       	ldi	r18, 0x00	; 0
    186c:	3f ef       	ldi	r19, 0xFF	; 255
    186e:	4f e7       	ldi	r20, 0x7F	; 127
    1870:	57 e4       	ldi	r21, 0x47	; 71
    1872:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1876:	18 16       	cp	r1, r24
    1878:	4c f5       	brge	.+82     	; 0x18cc <LCD_vidInit+0x462>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    187a:	6f a1       	ldd	r22, Y+39	; 0x27
    187c:	78 a5       	ldd	r23, Y+40	; 0x28
    187e:	89 a5       	ldd	r24, Y+41	; 0x29
    1880:	9a a5       	ldd	r25, Y+42	; 0x2a
    1882:	20 e0       	ldi	r18, 0x00	; 0
    1884:	30 e0       	ldi	r19, 0x00	; 0
    1886:	40 e2       	ldi	r20, 0x20	; 32
    1888:	51 e4       	ldi	r21, 0x41	; 65
    188a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    188e:	dc 01       	movw	r26, r24
    1890:	cb 01       	movw	r24, r22
    1892:	bc 01       	movw	r22, r24
    1894:	cd 01       	movw	r24, r26
    1896:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    189a:	dc 01       	movw	r26, r24
    189c:	cb 01       	movw	r24, r22
    189e:	9a a3       	std	Y+34, r25	; 0x22
    18a0:	89 a3       	std	Y+33, r24	; 0x21
    18a2:	0f c0       	rjmp	.+30     	; 0x18c2 <LCD_vidInit+0x458>
    18a4:	88 ec       	ldi	r24, 0xC8	; 200
    18a6:	90 e0       	ldi	r25, 0x00	; 0
    18a8:	98 a3       	std	Y+32, r25	; 0x20
    18aa:	8f 8f       	std	Y+31, r24	; 0x1f
    18ac:	8f 8d       	ldd	r24, Y+31	; 0x1f
    18ae:	98 a1       	ldd	r25, Y+32	; 0x20
    18b0:	01 97       	sbiw	r24, 0x01	; 1
    18b2:	f1 f7       	brne	.-4      	; 0x18b0 <LCD_vidInit+0x446>
    18b4:	98 a3       	std	Y+32, r25	; 0x20
    18b6:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18b8:	89 a1       	ldd	r24, Y+33	; 0x21
    18ba:	9a a1       	ldd	r25, Y+34	; 0x22
    18bc:	01 97       	sbiw	r24, 0x01	; 1
    18be:	9a a3       	std	Y+34, r25	; 0x22
    18c0:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18c2:	89 a1       	ldd	r24, Y+33	; 0x21
    18c4:	9a a1       	ldd	r25, Y+34	; 0x22
    18c6:	00 97       	sbiw	r24, 0x00	; 0
    18c8:	69 f7       	brne	.-38     	; 0x18a4 <LCD_vidInit+0x43a>
    18ca:	14 c0       	rjmp	.+40     	; 0x18f4 <LCD_vidInit+0x48a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18cc:	6b a1       	ldd	r22, Y+35	; 0x23
    18ce:	7c a1       	ldd	r23, Y+36	; 0x24
    18d0:	8d a1       	ldd	r24, Y+37	; 0x25
    18d2:	9e a1       	ldd	r25, Y+38	; 0x26
    18d4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18d8:	dc 01       	movw	r26, r24
    18da:	cb 01       	movw	r24, r22
    18dc:	9a a3       	std	Y+34, r25	; 0x22
    18de:	89 a3       	std	Y+33, r24	; 0x21
    18e0:	89 a1       	ldd	r24, Y+33	; 0x21
    18e2:	9a a1       	ldd	r25, Y+34	; 0x22
    18e4:	9e 8f       	std	Y+30, r25	; 0x1e
    18e6:	8d 8f       	std	Y+29, r24	; 0x1d
    18e8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    18ea:	9e 8d       	ldd	r25, Y+30	; 0x1e
    18ec:	01 97       	sbiw	r24, 0x01	; 1
    18ee:	f1 f7       	brne	.-4      	; 0x18ec <LCD_vidInit+0x482>
    18f0:	9e 8f       	std	Y+30, r25	; 0x1e
    18f2:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);

	/* Clear Display */
	LCD_vidSendCommand(lcd_Clear);
    18f4:	81 e0       	ldi	r24, 0x01	; 1
    18f6:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_vidSendCommand>
    18fa:	80 e0       	ldi	r24, 0x00	; 0
    18fc:	90 e0       	ldi	r25, 0x00	; 0
    18fe:	a0 e7       	ldi	r26, 0x70	; 112
    1900:	b1 e4       	ldi	r27, 0x41	; 65
    1902:	89 8f       	std	Y+25, r24	; 0x19
    1904:	9a 8f       	std	Y+26, r25	; 0x1a
    1906:	ab 8f       	std	Y+27, r26	; 0x1b
    1908:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    190a:	69 8d       	ldd	r22, Y+25	; 0x19
    190c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    190e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1910:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1912:	20 e0       	ldi	r18, 0x00	; 0
    1914:	30 e0       	ldi	r19, 0x00	; 0
    1916:	4a ef       	ldi	r20, 0xFA	; 250
    1918:	54 e4       	ldi	r21, 0x44	; 68
    191a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    191e:	dc 01       	movw	r26, r24
    1920:	cb 01       	movw	r24, r22
    1922:	8d 8b       	std	Y+21, r24	; 0x15
    1924:	9e 8b       	std	Y+22, r25	; 0x16
    1926:	af 8b       	std	Y+23, r26	; 0x17
    1928:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    192a:	6d 89       	ldd	r22, Y+21	; 0x15
    192c:	7e 89       	ldd	r23, Y+22	; 0x16
    192e:	8f 89       	ldd	r24, Y+23	; 0x17
    1930:	98 8d       	ldd	r25, Y+24	; 0x18
    1932:	20 e0       	ldi	r18, 0x00	; 0
    1934:	30 e0       	ldi	r19, 0x00	; 0
    1936:	40 e8       	ldi	r20, 0x80	; 128
    1938:	5f e3       	ldi	r21, 0x3F	; 63
    193a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    193e:	88 23       	and	r24, r24
    1940:	2c f4       	brge	.+10     	; 0x194c <LCD_vidInit+0x4e2>
		__ticks = 1;
    1942:	81 e0       	ldi	r24, 0x01	; 1
    1944:	90 e0       	ldi	r25, 0x00	; 0
    1946:	9c 8b       	std	Y+20, r25	; 0x14
    1948:	8b 8b       	std	Y+19, r24	; 0x13
    194a:	3f c0       	rjmp	.+126    	; 0x19ca <LCD_vidInit+0x560>
	else if (__tmp > 65535)
    194c:	6d 89       	ldd	r22, Y+21	; 0x15
    194e:	7e 89       	ldd	r23, Y+22	; 0x16
    1950:	8f 89       	ldd	r24, Y+23	; 0x17
    1952:	98 8d       	ldd	r25, Y+24	; 0x18
    1954:	20 e0       	ldi	r18, 0x00	; 0
    1956:	3f ef       	ldi	r19, 0xFF	; 255
    1958:	4f e7       	ldi	r20, 0x7F	; 127
    195a:	57 e4       	ldi	r21, 0x47	; 71
    195c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1960:	18 16       	cp	r1, r24
    1962:	4c f5       	brge	.+82     	; 0x19b6 <LCD_vidInit+0x54c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1964:	69 8d       	ldd	r22, Y+25	; 0x19
    1966:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1968:	8b 8d       	ldd	r24, Y+27	; 0x1b
    196a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    196c:	20 e0       	ldi	r18, 0x00	; 0
    196e:	30 e0       	ldi	r19, 0x00	; 0
    1970:	40 e2       	ldi	r20, 0x20	; 32
    1972:	51 e4       	ldi	r21, 0x41	; 65
    1974:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1978:	dc 01       	movw	r26, r24
    197a:	cb 01       	movw	r24, r22
    197c:	bc 01       	movw	r22, r24
    197e:	cd 01       	movw	r24, r26
    1980:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1984:	dc 01       	movw	r26, r24
    1986:	cb 01       	movw	r24, r22
    1988:	9c 8b       	std	Y+20, r25	; 0x14
    198a:	8b 8b       	std	Y+19, r24	; 0x13
    198c:	0f c0       	rjmp	.+30     	; 0x19ac <LCD_vidInit+0x542>
    198e:	88 ec       	ldi	r24, 0xC8	; 200
    1990:	90 e0       	ldi	r25, 0x00	; 0
    1992:	9a 8b       	std	Y+18, r25	; 0x12
    1994:	89 8b       	std	Y+17, r24	; 0x11
    1996:	89 89       	ldd	r24, Y+17	; 0x11
    1998:	9a 89       	ldd	r25, Y+18	; 0x12
    199a:	01 97       	sbiw	r24, 0x01	; 1
    199c:	f1 f7       	brne	.-4      	; 0x199a <LCD_vidInit+0x530>
    199e:	9a 8b       	std	Y+18, r25	; 0x12
    19a0:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19a2:	8b 89       	ldd	r24, Y+19	; 0x13
    19a4:	9c 89       	ldd	r25, Y+20	; 0x14
    19a6:	01 97       	sbiw	r24, 0x01	; 1
    19a8:	9c 8b       	std	Y+20, r25	; 0x14
    19aa:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19ac:	8b 89       	ldd	r24, Y+19	; 0x13
    19ae:	9c 89       	ldd	r25, Y+20	; 0x14
    19b0:	00 97       	sbiw	r24, 0x00	; 0
    19b2:	69 f7       	brne	.-38     	; 0x198e <LCD_vidInit+0x524>
    19b4:	14 c0       	rjmp	.+40     	; 0x19de <LCD_vidInit+0x574>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    19b6:	6d 89       	ldd	r22, Y+21	; 0x15
    19b8:	7e 89       	ldd	r23, Y+22	; 0x16
    19ba:	8f 89       	ldd	r24, Y+23	; 0x17
    19bc:	98 8d       	ldd	r25, Y+24	; 0x18
    19be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19c2:	dc 01       	movw	r26, r24
    19c4:	cb 01       	movw	r24, r22
    19c6:	9c 8b       	std	Y+20, r25	; 0x14
    19c8:	8b 8b       	std	Y+19, r24	; 0x13
    19ca:	8b 89       	ldd	r24, Y+19	; 0x13
    19cc:	9c 89       	ldd	r25, Y+20	; 0x14
    19ce:	98 8b       	std	Y+16, r25	; 0x10
    19d0:	8f 87       	std	Y+15, r24	; 0x0f
    19d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    19d4:	98 89       	ldd	r25, Y+16	; 0x10
    19d6:	01 97       	sbiw	r24, 0x01	; 1
    19d8:	f1 f7       	brne	.-4      	; 0x19d6 <LCD_vidInit+0x56c>
    19da:	98 8b       	std	Y+16, r25	; 0x10
    19dc:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(15);

	/* Entry Mode Set  */
	LCD_vidSendCommand(lcd_EntryMode);
    19de:	86 e0       	ldi	r24, 0x06	; 6
    19e0:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_vidSendCommand>
    19e4:	80 e0       	ldi	r24, 0x00	; 0
    19e6:	90 e0       	ldi	r25, 0x00	; 0
    19e8:	a0 e0       	ldi	r26, 0x00	; 0
    19ea:	b0 e4       	ldi	r27, 0x40	; 64
    19ec:	8b 87       	std	Y+11, r24	; 0x0b
    19ee:	9c 87       	std	Y+12, r25	; 0x0c
    19f0:	ad 87       	std	Y+13, r26	; 0x0d
    19f2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    19f4:	6b 85       	ldd	r22, Y+11	; 0x0b
    19f6:	7c 85       	ldd	r23, Y+12	; 0x0c
    19f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    19fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    19fc:	20 e0       	ldi	r18, 0x00	; 0
    19fe:	30 e0       	ldi	r19, 0x00	; 0
    1a00:	4a ef       	ldi	r20, 0xFA	; 250
    1a02:	54 e4       	ldi	r21, 0x44	; 68
    1a04:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a08:	dc 01       	movw	r26, r24
    1a0a:	cb 01       	movw	r24, r22
    1a0c:	8f 83       	std	Y+7, r24	; 0x07
    1a0e:	98 87       	std	Y+8, r25	; 0x08
    1a10:	a9 87       	std	Y+9, r26	; 0x09
    1a12:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1a14:	6f 81       	ldd	r22, Y+7	; 0x07
    1a16:	78 85       	ldd	r23, Y+8	; 0x08
    1a18:	89 85       	ldd	r24, Y+9	; 0x09
    1a1a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a1c:	20 e0       	ldi	r18, 0x00	; 0
    1a1e:	30 e0       	ldi	r19, 0x00	; 0
    1a20:	40 e8       	ldi	r20, 0x80	; 128
    1a22:	5f e3       	ldi	r21, 0x3F	; 63
    1a24:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1a28:	88 23       	and	r24, r24
    1a2a:	2c f4       	brge	.+10     	; 0x1a36 <LCD_vidInit+0x5cc>
		__ticks = 1;
    1a2c:	81 e0       	ldi	r24, 0x01	; 1
    1a2e:	90 e0       	ldi	r25, 0x00	; 0
    1a30:	9e 83       	std	Y+6, r25	; 0x06
    1a32:	8d 83       	std	Y+5, r24	; 0x05
    1a34:	3f c0       	rjmp	.+126    	; 0x1ab4 <LCD_vidInit+0x64a>
	else if (__tmp > 65535)
    1a36:	6f 81       	ldd	r22, Y+7	; 0x07
    1a38:	78 85       	ldd	r23, Y+8	; 0x08
    1a3a:	89 85       	ldd	r24, Y+9	; 0x09
    1a3c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a3e:	20 e0       	ldi	r18, 0x00	; 0
    1a40:	3f ef       	ldi	r19, 0xFF	; 255
    1a42:	4f e7       	ldi	r20, 0x7F	; 127
    1a44:	57 e4       	ldi	r21, 0x47	; 71
    1a46:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1a4a:	18 16       	cp	r1, r24
    1a4c:	4c f5       	brge	.+82     	; 0x1aa0 <LCD_vidInit+0x636>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a4e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a50:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a52:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a54:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a56:	20 e0       	ldi	r18, 0x00	; 0
    1a58:	30 e0       	ldi	r19, 0x00	; 0
    1a5a:	40 e2       	ldi	r20, 0x20	; 32
    1a5c:	51 e4       	ldi	r21, 0x41	; 65
    1a5e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a62:	dc 01       	movw	r26, r24
    1a64:	cb 01       	movw	r24, r22
    1a66:	bc 01       	movw	r22, r24
    1a68:	cd 01       	movw	r24, r26
    1a6a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a6e:	dc 01       	movw	r26, r24
    1a70:	cb 01       	movw	r24, r22
    1a72:	9e 83       	std	Y+6, r25	; 0x06
    1a74:	8d 83       	std	Y+5, r24	; 0x05
    1a76:	0f c0       	rjmp	.+30     	; 0x1a96 <LCD_vidInit+0x62c>
    1a78:	88 ec       	ldi	r24, 0xC8	; 200
    1a7a:	90 e0       	ldi	r25, 0x00	; 0
    1a7c:	9c 83       	std	Y+4, r25	; 0x04
    1a7e:	8b 83       	std	Y+3, r24	; 0x03
    1a80:	8b 81       	ldd	r24, Y+3	; 0x03
    1a82:	9c 81       	ldd	r25, Y+4	; 0x04
    1a84:	01 97       	sbiw	r24, 0x01	; 1
    1a86:	f1 f7       	brne	.-4      	; 0x1a84 <LCD_vidInit+0x61a>
    1a88:	9c 83       	std	Y+4, r25	; 0x04
    1a8a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a8c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a8e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a90:	01 97       	sbiw	r24, 0x01	; 1
    1a92:	9e 83       	std	Y+6, r25	; 0x06
    1a94:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a96:	8d 81       	ldd	r24, Y+5	; 0x05
    1a98:	9e 81       	ldd	r25, Y+6	; 0x06
    1a9a:	00 97       	sbiw	r24, 0x00	; 0
    1a9c:	69 f7       	brne	.-38     	; 0x1a78 <LCD_vidInit+0x60e>
    1a9e:	14 c0       	rjmp	.+40     	; 0x1ac8 <LCD_vidInit+0x65e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1aa0:	6f 81       	ldd	r22, Y+7	; 0x07
    1aa2:	78 85       	ldd	r23, Y+8	; 0x08
    1aa4:	89 85       	ldd	r24, Y+9	; 0x09
    1aa6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1aa8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1aac:	dc 01       	movw	r26, r24
    1aae:	cb 01       	movw	r24, r22
    1ab0:	9e 83       	std	Y+6, r25	; 0x06
    1ab2:	8d 83       	std	Y+5, r24	; 0x05
    1ab4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ab6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ab8:	9a 83       	std	Y+2, r25	; 0x02
    1aba:	89 83       	std	Y+1, r24	; 0x01
    1abc:	89 81       	ldd	r24, Y+1	; 0x01
    1abe:	9a 81       	ldd	r25, Y+2	; 0x02
    1ac0:	01 97       	sbiw	r24, 0x01	; 1
    1ac2:	f1 f7       	brne	.-4      	; 0x1ac0 <LCD_vidInit+0x656>
    1ac4:	9a 83       	std	Y+2, r25	; 0x02
    1ac6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);

}
    1ac8:	cc 5a       	subi	r28, 0xAC	; 172
    1aca:	df 4f       	sbci	r29, 0xFF	; 255
    1acc:	0f b6       	in	r0, 0x3f	; 63
    1ace:	f8 94       	cli
    1ad0:	de bf       	out	0x3e, r29	; 62
    1ad2:	0f be       	out	0x3f, r0	; 63
    1ad4:	cd bf       	out	0x3d, r28	; 61
    1ad6:	cf 91       	pop	r28
    1ad8:	df 91       	pop	r29
    1ada:	1f 91       	pop	r17
    1adc:	0f 91       	pop	r16
    1ade:	08 95       	ret

00001ae0 <LCD_vidSendCommand>:
/* Description! Interface to send the configuration commands to the LCD Driver         */
/* Input      ! Command number                                                         */
/* Output     ! Nothing                                                                */
/***************************************************************************************/
void LCD_vidSendCommand(u8 u8CmdCpy)
{
    1ae0:	df 93       	push	r29
    1ae2:	cf 93       	push	r28
    1ae4:	cd b7       	in	r28, 0x3d	; 61
    1ae6:	de b7       	in	r29, 0x3e	; 62
    1ae8:	6d 97       	sbiw	r28, 0x1d	; 29
    1aea:	0f b6       	in	r0, 0x3f	; 63
    1aec:	f8 94       	cli
    1aee:	de bf       	out	0x3e, r29	; 62
    1af0:	0f be       	out	0x3f, r0	; 63
    1af2:	cd bf       	out	0x3d, r28	; 61
    1af4:	8d 8f       	std	Y+29, r24	; 0x1d

	/* Set RS to LOW */
	DIO_voidSetPinValue(LCD_CONTROL_PORT, LCD_RS_PIN, DIO_u8_LOW);
    1af6:	83 e0       	ldi	r24, 0x03	; 3
    1af8:	65 e0       	ldi	r22, 0x05	; 5
    1afa:	40 e0       	ldi	r20, 0x00	; 0
    1afc:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <DIO_voidSetPinValue>

	/* Set R/W to LOW */
	DIO_voidSetPinValue(LCD_CONTROL_PORT, LCD_RW_PIN, DIO_u8_LOW);
    1b00:	83 e0       	ldi	r24, 0x03	; 3
    1b02:	66 e0       	ldi	r22, 0x06	; 6
    1b04:	40 e0       	ldi	r20, 0x00	; 0
    1b06:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <DIO_voidSetPinValue>

	/* Set E to HIGH  */
	DIO_voidSetPinValue(LCD_CONTROL_PORT, LCD_E_PIN, DIO_u8_HIGH);
    1b0a:	83 e0       	ldi	r24, 0x03	; 3
    1b0c:	67 e0       	ldi	r22, 0x07	; 7
    1b0e:	41 e0       	ldi	r20, 0x01	; 1
    1b10:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <DIO_voidSetPinValue>

	/* Load Command on Data bus */
	DIO_voidSetPortValue(LCD_DATA_PORT, u8CmdCpy);
    1b14:	82 e0       	ldi	r24, 0x02	; 2
    1b16:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1b18:	0e 94 3f 09 	call	0x127e	; 0x127e <DIO_voidSetPortValue>

	/* Set E to LOW */
	DIO_voidSetPinValue(LCD_CONTROL_PORT, LCD_E_PIN, DIO_u8_LOW);
    1b1c:	83 e0       	ldi	r24, 0x03	; 3
    1b1e:	67 e0       	ldi	r22, 0x07	; 7
    1b20:	40 e0       	ldi	r20, 0x00	; 0
    1b22:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <DIO_voidSetPinValue>
    1b26:	80 e0       	ldi	r24, 0x00	; 0
    1b28:	90 e0       	ldi	r25, 0x00	; 0
    1b2a:	a0 e8       	ldi	r26, 0x80	; 128
    1b2c:	bf e3       	ldi	r27, 0x3F	; 63
    1b2e:	89 8f       	std	Y+25, r24	; 0x19
    1b30:	9a 8f       	std	Y+26, r25	; 0x1a
    1b32:	ab 8f       	std	Y+27, r26	; 0x1b
    1b34:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1b36:	69 8d       	ldd	r22, Y+25	; 0x19
    1b38:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1b3a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1b3c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1b3e:	20 e0       	ldi	r18, 0x00	; 0
    1b40:	30 e0       	ldi	r19, 0x00	; 0
    1b42:	4a ef       	ldi	r20, 0xFA	; 250
    1b44:	54 e4       	ldi	r21, 0x44	; 68
    1b46:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b4a:	dc 01       	movw	r26, r24
    1b4c:	cb 01       	movw	r24, r22
    1b4e:	8d 8b       	std	Y+21, r24	; 0x15
    1b50:	9e 8b       	std	Y+22, r25	; 0x16
    1b52:	af 8b       	std	Y+23, r26	; 0x17
    1b54:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1b56:	6d 89       	ldd	r22, Y+21	; 0x15
    1b58:	7e 89       	ldd	r23, Y+22	; 0x16
    1b5a:	8f 89       	ldd	r24, Y+23	; 0x17
    1b5c:	98 8d       	ldd	r25, Y+24	; 0x18
    1b5e:	20 e0       	ldi	r18, 0x00	; 0
    1b60:	30 e0       	ldi	r19, 0x00	; 0
    1b62:	40 e8       	ldi	r20, 0x80	; 128
    1b64:	5f e3       	ldi	r21, 0x3F	; 63
    1b66:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1b6a:	88 23       	and	r24, r24
    1b6c:	2c f4       	brge	.+10     	; 0x1b78 <LCD_vidSendCommand+0x98>
		__ticks = 1;
    1b6e:	81 e0       	ldi	r24, 0x01	; 1
    1b70:	90 e0       	ldi	r25, 0x00	; 0
    1b72:	9c 8b       	std	Y+20, r25	; 0x14
    1b74:	8b 8b       	std	Y+19, r24	; 0x13
    1b76:	3f c0       	rjmp	.+126    	; 0x1bf6 <LCD_vidSendCommand+0x116>
	else if (__tmp > 65535)
    1b78:	6d 89       	ldd	r22, Y+21	; 0x15
    1b7a:	7e 89       	ldd	r23, Y+22	; 0x16
    1b7c:	8f 89       	ldd	r24, Y+23	; 0x17
    1b7e:	98 8d       	ldd	r25, Y+24	; 0x18
    1b80:	20 e0       	ldi	r18, 0x00	; 0
    1b82:	3f ef       	ldi	r19, 0xFF	; 255
    1b84:	4f e7       	ldi	r20, 0x7F	; 127
    1b86:	57 e4       	ldi	r21, 0x47	; 71
    1b88:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1b8c:	18 16       	cp	r1, r24
    1b8e:	4c f5       	brge	.+82     	; 0x1be2 <LCD_vidSendCommand+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b90:	69 8d       	ldd	r22, Y+25	; 0x19
    1b92:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1b94:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1b96:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1b98:	20 e0       	ldi	r18, 0x00	; 0
    1b9a:	30 e0       	ldi	r19, 0x00	; 0
    1b9c:	40 e2       	ldi	r20, 0x20	; 32
    1b9e:	51 e4       	ldi	r21, 0x41	; 65
    1ba0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ba4:	dc 01       	movw	r26, r24
    1ba6:	cb 01       	movw	r24, r22
    1ba8:	bc 01       	movw	r22, r24
    1baa:	cd 01       	movw	r24, r26
    1bac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bb0:	dc 01       	movw	r26, r24
    1bb2:	cb 01       	movw	r24, r22
    1bb4:	9c 8b       	std	Y+20, r25	; 0x14
    1bb6:	8b 8b       	std	Y+19, r24	; 0x13
    1bb8:	0f c0       	rjmp	.+30     	; 0x1bd8 <LCD_vidSendCommand+0xf8>
    1bba:	88 ec       	ldi	r24, 0xC8	; 200
    1bbc:	90 e0       	ldi	r25, 0x00	; 0
    1bbe:	9a 8b       	std	Y+18, r25	; 0x12
    1bc0:	89 8b       	std	Y+17, r24	; 0x11
    1bc2:	89 89       	ldd	r24, Y+17	; 0x11
    1bc4:	9a 89       	ldd	r25, Y+18	; 0x12
    1bc6:	01 97       	sbiw	r24, 0x01	; 1
    1bc8:	f1 f7       	brne	.-4      	; 0x1bc6 <LCD_vidSendCommand+0xe6>
    1bca:	9a 8b       	std	Y+18, r25	; 0x12
    1bcc:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1bce:	8b 89       	ldd	r24, Y+19	; 0x13
    1bd0:	9c 89       	ldd	r25, Y+20	; 0x14
    1bd2:	01 97       	sbiw	r24, 0x01	; 1
    1bd4:	9c 8b       	std	Y+20, r25	; 0x14
    1bd6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1bd8:	8b 89       	ldd	r24, Y+19	; 0x13
    1bda:	9c 89       	ldd	r25, Y+20	; 0x14
    1bdc:	00 97       	sbiw	r24, 0x00	; 0
    1bde:	69 f7       	brne	.-38     	; 0x1bba <LCD_vidSendCommand+0xda>
    1be0:	14 c0       	rjmp	.+40     	; 0x1c0a <LCD_vidSendCommand+0x12a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1be2:	6d 89       	ldd	r22, Y+21	; 0x15
    1be4:	7e 89       	ldd	r23, Y+22	; 0x16
    1be6:	8f 89       	ldd	r24, Y+23	; 0x17
    1be8:	98 8d       	ldd	r25, Y+24	; 0x18
    1bea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bee:	dc 01       	movw	r26, r24
    1bf0:	cb 01       	movw	r24, r22
    1bf2:	9c 8b       	std	Y+20, r25	; 0x14
    1bf4:	8b 8b       	std	Y+19, r24	; 0x13
    1bf6:	8b 89       	ldd	r24, Y+19	; 0x13
    1bf8:	9c 89       	ldd	r25, Y+20	; 0x14
    1bfa:	98 8b       	std	Y+16, r25	; 0x10
    1bfc:	8f 87       	std	Y+15, r24	; 0x0f
    1bfe:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c00:	98 89       	ldd	r25, Y+16	; 0x10
    1c02:	01 97       	sbiw	r24, 0x01	; 1
    1c04:	f1 f7       	brne	.-4      	; 0x1c02 <LCD_vidSendCommand+0x122>
    1c06:	98 8b       	std	Y+16, r25	; 0x10
    1c08:	8f 87       	std	Y+15, r24	; 0x0f

	/* Wait for E to settle */
	_delay_ms(1);

	/* Set E to HIGH */
	DIO_voidSetPinValue(LCD_CONTROL_PORT, LCD_E_PIN, DIO_u8_HIGH);
    1c0a:	83 e0       	ldi	r24, 0x03	; 3
    1c0c:	67 e0       	ldi	r22, 0x07	; 7
    1c0e:	41 e0       	ldi	r20, 0x01	; 1
    1c10:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <DIO_voidSetPinValue>
    1c14:	80 e0       	ldi	r24, 0x00	; 0
    1c16:	90 e0       	ldi	r25, 0x00	; 0
    1c18:	a0 e8       	ldi	r26, 0x80	; 128
    1c1a:	bf e3       	ldi	r27, 0x3F	; 63
    1c1c:	8b 87       	std	Y+11, r24	; 0x0b
    1c1e:	9c 87       	std	Y+12, r25	; 0x0c
    1c20:	ad 87       	std	Y+13, r26	; 0x0d
    1c22:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c24:	6b 85       	ldd	r22, Y+11	; 0x0b
    1c26:	7c 85       	ldd	r23, Y+12	; 0x0c
    1c28:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c2a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c2c:	20 e0       	ldi	r18, 0x00	; 0
    1c2e:	30 e0       	ldi	r19, 0x00	; 0
    1c30:	4a ef       	ldi	r20, 0xFA	; 250
    1c32:	54 e4       	ldi	r21, 0x44	; 68
    1c34:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c38:	dc 01       	movw	r26, r24
    1c3a:	cb 01       	movw	r24, r22
    1c3c:	8f 83       	std	Y+7, r24	; 0x07
    1c3e:	98 87       	std	Y+8, r25	; 0x08
    1c40:	a9 87       	std	Y+9, r26	; 0x09
    1c42:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1c44:	6f 81       	ldd	r22, Y+7	; 0x07
    1c46:	78 85       	ldd	r23, Y+8	; 0x08
    1c48:	89 85       	ldd	r24, Y+9	; 0x09
    1c4a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c4c:	20 e0       	ldi	r18, 0x00	; 0
    1c4e:	30 e0       	ldi	r19, 0x00	; 0
    1c50:	40 e8       	ldi	r20, 0x80	; 128
    1c52:	5f e3       	ldi	r21, 0x3F	; 63
    1c54:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1c58:	88 23       	and	r24, r24
    1c5a:	2c f4       	brge	.+10     	; 0x1c66 <LCD_vidSendCommand+0x186>
		__ticks = 1;
    1c5c:	81 e0       	ldi	r24, 0x01	; 1
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	9e 83       	std	Y+6, r25	; 0x06
    1c62:	8d 83       	std	Y+5, r24	; 0x05
    1c64:	3f c0       	rjmp	.+126    	; 0x1ce4 <LCD_vidSendCommand+0x204>
	else if (__tmp > 65535)
    1c66:	6f 81       	ldd	r22, Y+7	; 0x07
    1c68:	78 85       	ldd	r23, Y+8	; 0x08
    1c6a:	89 85       	ldd	r24, Y+9	; 0x09
    1c6c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c6e:	20 e0       	ldi	r18, 0x00	; 0
    1c70:	3f ef       	ldi	r19, 0xFF	; 255
    1c72:	4f e7       	ldi	r20, 0x7F	; 127
    1c74:	57 e4       	ldi	r21, 0x47	; 71
    1c76:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1c7a:	18 16       	cp	r1, r24
    1c7c:	4c f5       	brge	.+82     	; 0x1cd0 <LCD_vidSendCommand+0x1f0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c7e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1c80:	7c 85       	ldd	r23, Y+12	; 0x0c
    1c82:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c84:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c86:	20 e0       	ldi	r18, 0x00	; 0
    1c88:	30 e0       	ldi	r19, 0x00	; 0
    1c8a:	40 e2       	ldi	r20, 0x20	; 32
    1c8c:	51 e4       	ldi	r21, 0x41	; 65
    1c8e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c92:	dc 01       	movw	r26, r24
    1c94:	cb 01       	movw	r24, r22
    1c96:	bc 01       	movw	r22, r24
    1c98:	cd 01       	movw	r24, r26
    1c9a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c9e:	dc 01       	movw	r26, r24
    1ca0:	cb 01       	movw	r24, r22
    1ca2:	9e 83       	std	Y+6, r25	; 0x06
    1ca4:	8d 83       	std	Y+5, r24	; 0x05
    1ca6:	0f c0       	rjmp	.+30     	; 0x1cc6 <LCD_vidSendCommand+0x1e6>
    1ca8:	88 ec       	ldi	r24, 0xC8	; 200
    1caa:	90 e0       	ldi	r25, 0x00	; 0
    1cac:	9c 83       	std	Y+4, r25	; 0x04
    1cae:	8b 83       	std	Y+3, r24	; 0x03
    1cb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb2:	9c 81       	ldd	r25, Y+4	; 0x04
    1cb4:	01 97       	sbiw	r24, 0x01	; 1
    1cb6:	f1 f7       	brne	.-4      	; 0x1cb4 <LCD_vidSendCommand+0x1d4>
    1cb8:	9c 83       	std	Y+4, r25	; 0x04
    1cba:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1cbc:	8d 81       	ldd	r24, Y+5	; 0x05
    1cbe:	9e 81       	ldd	r25, Y+6	; 0x06
    1cc0:	01 97       	sbiw	r24, 0x01	; 1
    1cc2:	9e 83       	std	Y+6, r25	; 0x06
    1cc4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1cc6:	8d 81       	ldd	r24, Y+5	; 0x05
    1cc8:	9e 81       	ldd	r25, Y+6	; 0x06
    1cca:	00 97       	sbiw	r24, 0x00	; 0
    1ccc:	69 f7       	brne	.-38     	; 0x1ca8 <LCD_vidSendCommand+0x1c8>
    1cce:	14 c0       	rjmp	.+40     	; 0x1cf8 <LCD_vidSendCommand+0x218>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1cd0:	6f 81       	ldd	r22, Y+7	; 0x07
    1cd2:	78 85       	ldd	r23, Y+8	; 0x08
    1cd4:	89 85       	ldd	r24, Y+9	; 0x09
    1cd6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cd8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cdc:	dc 01       	movw	r26, r24
    1cde:	cb 01       	movw	r24, r22
    1ce0:	9e 83       	std	Y+6, r25	; 0x06
    1ce2:	8d 83       	std	Y+5, r24	; 0x05
    1ce4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ce6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ce8:	9a 83       	std	Y+2, r25	; 0x02
    1cea:	89 83       	std	Y+1, r24	; 0x01
    1cec:	89 81       	ldd	r24, Y+1	; 0x01
    1cee:	9a 81       	ldd	r25, Y+2	; 0x02
    1cf0:	01 97       	sbiw	r24, 0x01	; 1
    1cf2:	f1 f7       	brne	.-4      	; 0x1cf0 <LCD_vidSendCommand+0x210>
    1cf4:	9a 83       	std	Y+2, r25	; 0x02
    1cf6:	89 83       	std	Y+1, r24	; 0x01

	/* Delay for 1ms to let the LCD execute command */
	_delay_ms(1);

}
    1cf8:	6d 96       	adiw	r28, 0x1d	; 29
    1cfa:	0f b6       	in	r0, 0x3f	; 63
    1cfc:	f8 94       	cli
    1cfe:	de bf       	out	0x3e, r29	; 62
    1d00:	0f be       	out	0x3f, r0	; 63
    1d02:	cd bf       	out	0x3d, r28	; 61
    1d04:	cf 91       	pop	r28
    1d06:	df 91       	pop	r29
    1d08:	08 95       	ret

00001d0a <LCD_vidWriteCharctr>:
/* Description! Interface to write character on LCD screen                             */
/* Input      ! Data to send                                                           */
/* Output     ! Nothing                                                                */
/***************************************************************************************/
void LCD_vidWriteCharctr(u8 u8DataCpy)
{
    1d0a:	df 93       	push	r29
    1d0c:	cf 93       	push	r28
    1d0e:	cd b7       	in	r28, 0x3d	; 61
    1d10:	de b7       	in	r29, 0x3e	; 62
    1d12:	6d 97       	sbiw	r28, 0x1d	; 29
    1d14:	0f b6       	in	r0, 0x3f	; 63
    1d16:	f8 94       	cli
    1d18:	de bf       	out	0x3e, r29	; 62
    1d1a:	0f be       	out	0x3f, r0	; 63
    1d1c:	cd bf       	out	0x3d, r28	; 61
    1d1e:	8d 8f       	std	Y+29, r24	; 0x1d
	/* Set RS to High */
	DIO_voidSetPinValue(LCD_CONTROL_PORT, LCD_RS_PIN, DIO_u8_HIGH);
    1d20:	83 e0       	ldi	r24, 0x03	; 3
    1d22:	65 e0       	ldi	r22, 0x05	; 5
    1d24:	41 e0       	ldi	r20, 0x01	; 1
    1d26:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <DIO_voidSetPinValue>

	/* Set R/W to LOW */
	DIO_voidSetPinValue(LCD_CONTROL_PORT, LCD_RW_PIN, DIO_u8_LOW);
    1d2a:	83 e0       	ldi	r24, 0x03	; 3
    1d2c:	66 e0       	ldi	r22, 0x06	; 6
    1d2e:	40 e0       	ldi	r20, 0x00	; 0
    1d30:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <DIO_voidSetPinValue>

	/* Set E to HIGH  */
	DIO_voidSetPinValue(LCD_CONTROL_PORT, LCD_E_PIN, DIO_u8_HIGH);
    1d34:	83 e0       	ldi	r24, 0x03	; 3
    1d36:	67 e0       	ldi	r22, 0x07	; 7
    1d38:	41 e0       	ldi	r20, 0x01	; 1
    1d3a:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <DIO_voidSetPinValue>

	/* Load Command on Data bus */
	DIO_voidSetPortValue(LCD_DATA_PORT, u8DataCpy);
    1d3e:	82 e0       	ldi	r24, 0x02	; 2
    1d40:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1d42:	0e 94 3f 09 	call	0x127e	; 0x127e <DIO_voidSetPortValue>

	/* Set E to LOW */
	DIO_voidSetPinValue(LCD_CONTROL_PORT, LCD_E_PIN, DIO_u8_LOW);
    1d46:	83 e0       	ldi	r24, 0x03	; 3
    1d48:	67 e0       	ldi	r22, 0x07	; 7
    1d4a:	40 e0       	ldi	r20, 0x00	; 0
    1d4c:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <DIO_voidSetPinValue>
    1d50:	80 e0       	ldi	r24, 0x00	; 0
    1d52:	90 e0       	ldi	r25, 0x00	; 0
    1d54:	a0 e8       	ldi	r26, 0x80	; 128
    1d56:	bf e3       	ldi	r27, 0x3F	; 63
    1d58:	89 8f       	std	Y+25, r24	; 0x19
    1d5a:	9a 8f       	std	Y+26, r25	; 0x1a
    1d5c:	ab 8f       	std	Y+27, r26	; 0x1b
    1d5e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d60:	69 8d       	ldd	r22, Y+25	; 0x19
    1d62:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1d64:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d66:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1d68:	20 e0       	ldi	r18, 0x00	; 0
    1d6a:	30 e0       	ldi	r19, 0x00	; 0
    1d6c:	4a ef       	ldi	r20, 0xFA	; 250
    1d6e:	54 e4       	ldi	r21, 0x44	; 68
    1d70:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d74:	dc 01       	movw	r26, r24
    1d76:	cb 01       	movw	r24, r22
    1d78:	8d 8b       	std	Y+21, r24	; 0x15
    1d7a:	9e 8b       	std	Y+22, r25	; 0x16
    1d7c:	af 8b       	std	Y+23, r26	; 0x17
    1d7e:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1d80:	6d 89       	ldd	r22, Y+21	; 0x15
    1d82:	7e 89       	ldd	r23, Y+22	; 0x16
    1d84:	8f 89       	ldd	r24, Y+23	; 0x17
    1d86:	98 8d       	ldd	r25, Y+24	; 0x18
    1d88:	20 e0       	ldi	r18, 0x00	; 0
    1d8a:	30 e0       	ldi	r19, 0x00	; 0
    1d8c:	40 e8       	ldi	r20, 0x80	; 128
    1d8e:	5f e3       	ldi	r21, 0x3F	; 63
    1d90:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1d94:	88 23       	and	r24, r24
    1d96:	2c f4       	brge	.+10     	; 0x1da2 <LCD_vidWriteCharctr+0x98>
		__ticks = 1;
    1d98:	81 e0       	ldi	r24, 0x01	; 1
    1d9a:	90 e0       	ldi	r25, 0x00	; 0
    1d9c:	9c 8b       	std	Y+20, r25	; 0x14
    1d9e:	8b 8b       	std	Y+19, r24	; 0x13
    1da0:	3f c0       	rjmp	.+126    	; 0x1e20 <LCD_vidWriteCharctr+0x116>
	else if (__tmp > 65535)
    1da2:	6d 89       	ldd	r22, Y+21	; 0x15
    1da4:	7e 89       	ldd	r23, Y+22	; 0x16
    1da6:	8f 89       	ldd	r24, Y+23	; 0x17
    1da8:	98 8d       	ldd	r25, Y+24	; 0x18
    1daa:	20 e0       	ldi	r18, 0x00	; 0
    1dac:	3f ef       	ldi	r19, 0xFF	; 255
    1dae:	4f e7       	ldi	r20, 0x7F	; 127
    1db0:	57 e4       	ldi	r21, 0x47	; 71
    1db2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1db6:	18 16       	cp	r1, r24
    1db8:	4c f5       	brge	.+82     	; 0x1e0c <LCD_vidWriteCharctr+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1dba:	69 8d       	ldd	r22, Y+25	; 0x19
    1dbc:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1dbe:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1dc0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1dc2:	20 e0       	ldi	r18, 0x00	; 0
    1dc4:	30 e0       	ldi	r19, 0x00	; 0
    1dc6:	40 e2       	ldi	r20, 0x20	; 32
    1dc8:	51 e4       	ldi	r21, 0x41	; 65
    1dca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1dce:	dc 01       	movw	r26, r24
    1dd0:	cb 01       	movw	r24, r22
    1dd2:	bc 01       	movw	r22, r24
    1dd4:	cd 01       	movw	r24, r26
    1dd6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1dda:	dc 01       	movw	r26, r24
    1ddc:	cb 01       	movw	r24, r22
    1dde:	9c 8b       	std	Y+20, r25	; 0x14
    1de0:	8b 8b       	std	Y+19, r24	; 0x13
    1de2:	0f c0       	rjmp	.+30     	; 0x1e02 <LCD_vidWriteCharctr+0xf8>
    1de4:	88 ec       	ldi	r24, 0xC8	; 200
    1de6:	90 e0       	ldi	r25, 0x00	; 0
    1de8:	9a 8b       	std	Y+18, r25	; 0x12
    1dea:	89 8b       	std	Y+17, r24	; 0x11
    1dec:	89 89       	ldd	r24, Y+17	; 0x11
    1dee:	9a 89       	ldd	r25, Y+18	; 0x12
    1df0:	01 97       	sbiw	r24, 0x01	; 1
    1df2:	f1 f7       	brne	.-4      	; 0x1df0 <LCD_vidWriteCharctr+0xe6>
    1df4:	9a 8b       	std	Y+18, r25	; 0x12
    1df6:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1df8:	8b 89       	ldd	r24, Y+19	; 0x13
    1dfa:	9c 89       	ldd	r25, Y+20	; 0x14
    1dfc:	01 97       	sbiw	r24, 0x01	; 1
    1dfe:	9c 8b       	std	Y+20, r25	; 0x14
    1e00:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e02:	8b 89       	ldd	r24, Y+19	; 0x13
    1e04:	9c 89       	ldd	r25, Y+20	; 0x14
    1e06:	00 97       	sbiw	r24, 0x00	; 0
    1e08:	69 f7       	brne	.-38     	; 0x1de4 <LCD_vidWriteCharctr+0xda>
    1e0a:	14 c0       	rjmp	.+40     	; 0x1e34 <LCD_vidWriteCharctr+0x12a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e0c:	6d 89       	ldd	r22, Y+21	; 0x15
    1e0e:	7e 89       	ldd	r23, Y+22	; 0x16
    1e10:	8f 89       	ldd	r24, Y+23	; 0x17
    1e12:	98 8d       	ldd	r25, Y+24	; 0x18
    1e14:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e18:	dc 01       	movw	r26, r24
    1e1a:	cb 01       	movw	r24, r22
    1e1c:	9c 8b       	std	Y+20, r25	; 0x14
    1e1e:	8b 8b       	std	Y+19, r24	; 0x13
    1e20:	8b 89       	ldd	r24, Y+19	; 0x13
    1e22:	9c 89       	ldd	r25, Y+20	; 0x14
    1e24:	98 8b       	std	Y+16, r25	; 0x10
    1e26:	8f 87       	std	Y+15, r24	; 0x0f
    1e28:	8f 85       	ldd	r24, Y+15	; 0x0f
    1e2a:	98 89       	ldd	r25, Y+16	; 0x10
    1e2c:	01 97       	sbiw	r24, 0x01	; 1
    1e2e:	f1 f7       	brne	.-4      	; 0x1e2c <LCD_vidWriteCharctr+0x122>
    1e30:	98 8b       	std	Y+16, r25	; 0x10
    1e32:	8f 87       	std	Y+15, r24	; 0x0f

	/* Wait for E to settle */
	_delay_ms(1);

	/* Set E to HIGH */
	DIO_voidSetPinValue(LCD_CONTROL_PORT, LCD_E_PIN, DIO_u8_HIGH);
    1e34:	83 e0       	ldi	r24, 0x03	; 3
    1e36:	67 e0       	ldi	r22, 0x07	; 7
    1e38:	41 e0       	ldi	r20, 0x01	; 1
    1e3a:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <DIO_voidSetPinValue>
    1e3e:	80 e0       	ldi	r24, 0x00	; 0
    1e40:	90 e0       	ldi	r25, 0x00	; 0
    1e42:	a0 e8       	ldi	r26, 0x80	; 128
    1e44:	bf e3       	ldi	r27, 0x3F	; 63
    1e46:	8b 87       	std	Y+11, r24	; 0x0b
    1e48:	9c 87       	std	Y+12, r25	; 0x0c
    1e4a:	ad 87       	std	Y+13, r26	; 0x0d
    1e4c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1e4e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1e50:	7c 85       	ldd	r23, Y+12	; 0x0c
    1e52:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e54:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e56:	20 e0       	ldi	r18, 0x00	; 0
    1e58:	30 e0       	ldi	r19, 0x00	; 0
    1e5a:	4a ef       	ldi	r20, 0xFA	; 250
    1e5c:	54 e4       	ldi	r21, 0x44	; 68
    1e5e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e62:	dc 01       	movw	r26, r24
    1e64:	cb 01       	movw	r24, r22
    1e66:	8f 83       	std	Y+7, r24	; 0x07
    1e68:	98 87       	std	Y+8, r25	; 0x08
    1e6a:	a9 87       	std	Y+9, r26	; 0x09
    1e6c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1e6e:	6f 81       	ldd	r22, Y+7	; 0x07
    1e70:	78 85       	ldd	r23, Y+8	; 0x08
    1e72:	89 85       	ldd	r24, Y+9	; 0x09
    1e74:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e76:	20 e0       	ldi	r18, 0x00	; 0
    1e78:	30 e0       	ldi	r19, 0x00	; 0
    1e7a:	40 e8       	ldi	r20, 0x80	; 128
    1e7c:	5f e3       	ldi	r21, 0x3F	; 63
    1e7e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1e82:	88 23       	and	r24, r24
    1e84:	2c f4       	brge	.+10     	; 0x1e90 <LCD_vidWriteCharctr+0x186>
		__ticks = 1;
    1e86:	81 e0       	ldi	r24, 0x01	; 1
    1e88:	90 e0       	ldi	r25, 0x00	; 0
    1e8a:	9e 83       	std	Y+6, r25	; 0x06
    1e8c:	8d 83       	std	Y+5, r24	; 0x05
    1e8e:	3f c0       	rjmp	.+126    	; 0x1f0e <LCD_vidWriteCharctr+0x204>
	else if (__tmp > 65535)
    1e90:	6f 81       	ldd	r22, Y+7	; 0x07
    1e92:	78 85       	ldd	r23, Y+8	; 0x08
    1e94:	89 85       	ldd	r24, Y+9	; 0x09
    1e96:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e98:	20 e0       	ldi	r18, 0x00	; 0
    1e9a:	3f ef       	ldi	r19, 0xFF	; 255
    1e9c:	4f e7       	ldi	r20, 0x7F	; 127
    1e9e:	57 e4       	ldi	r21, 0x47	; 71
    1ea0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1ea4:	18 16       	cp	r1, r24
    1ea6:	4c f5       	brge	.+82     	; 0x1efa <LCD_vidWriteCharctr+0x1f0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1ea8:	6b 85       	ldd	r22, Y+11	; 0x0b
    1eaa:	7c 85       	ldd	r23, Y+12	; 0x0c
    1eac:	8d 85       	ldd	r24, Y+13	; 0x0d
    1eae:	9e 85       	ldd	r25, Y+14	; 0x0e
    1eb0:	20 e0       	ldi	r18, 0x00	; 0
    1eb2:	30 e0       	ldi	r19, 0x00	; 0
    1eb4:	40 e2       	ldi	r20, 0x20	; 32
    1eb6:	51 e4       	ldi	r21, 0x41	; 65
    1eb8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ebc:	dc 01       	movw	r26, r24
    1ebe:	cb 01       	movw	r24, r22
    1ec0:	bc 01       	movw	r22, r24
    1ec2:	cd 01       	movw	r24, r26
    1ec4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ec8:	dc 01       	movw	r26, r24
    1eca:	cb 01       	movw	r24, r22
    1ecc:	9e 83       	std	Y+6, r25	; 0x06
    1ece:	8d 83       	std	Y+5, r24	; 0x05
    1ed0:	0f c0       	rjmp	.+30     	; 0x1ef0 <LCD_vidWriteCharctr+0x1e6>
    1ed2:	88 ec       	ldi	r24, 0xC8	; 200
    1ed4:	90 e0       	ldi	r25, 0x00	; 0
    1ed6:	9c 83       	std	Y+4, r25	; 0x04
    1ed8:	8b 83       	std	Y+3, r24	; 0x03
    1eda:	8b 81       	ldd	r24, Y+3	; 0x03
    1edc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ede:	01 97       	sbiw	r24, 0x01	; 1
    1ee0:	f1 f7       	brne	.-4      	; 0x1ede <LCD_vidWriteCharctr+0x1d4>
    1ee2:	9c 83       	std	Y+4, r25	; 0x04
    1ee4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ee6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ee8:	9e 81       	ldd	r25, Y+6	; 0x06
    1eea:	01 97       	sbiw	r24, 0x01	; 1
    1eec:	9e 83       	std	Y+6, r25	; 0x06
    1eee:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ef0:	8d 81       	ldd	r24, Y+5	; 0x05
    1ef2:	9e 81       	ldd	r25, Y+6	; 0x06
    1ef4:	00 97       	sbiw	r24, 0x00	; 0
    1ef6:	69 f7       	brne	.-38     	; 0x1ed2 <LCD_vidWriteCharctr+0x1c8>
    1ef8:	14 c0       	rjmp	.+40     	; 0x1f22 <LCD_vidWriteCharctr+0x218>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1efa:	6f 81       	ldd	r22, Y+7	; 0x07
    1efc:	78 85       	ldd	r23, Y+8	; 0x08
    1efe:	89 85       	ldd	r24, Y+9	; 0x09
    1f00:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f02:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f06:	dc 01       	movw	r26, r24
    1f08:	cb 01       	movw	r24, r22
    1f0a:	9e 83       	std	Y+6, r25	; 0x06
    1f0c:	8d 83       	std	Y+5, r24	; 0x05
    1f0e:	8d 81       	ldd	r24, Y+5	; 0x05
    1f10:	9e 81       	ldd	r25, Y+6	; 0x06
    1f12:	9a 83       	std	Y+2, r25	; 0x02
    1f14:	89 83       	std	Y+1, r24	; 0x01
    1f16:	89 81       	ldd	r24, Y+1	; 0x01
    1f18:	9a 81       	ldd	r25, Y+2	; 0x02
    1f1a:	01 97       	sbiw	r24, 0x01	; 1
    1f1c:	f1 f7       	brne	.-4      	; 0x1f1a <LCD_vidWriteCharctr+0x210>
    1f1e:	9a 83       	std	Y+2, r25	; 0x02
    1f20:	89 83       	std	Y+1, r24	; 0x01

	/* Delay to let the LCD Display the character */
	_delay_ms(1);

}
    1f22:	6d 96       	adiw	r28, 0x1d	; 29
    1f24:	0f b6       	in	r0, 0x3f	; 63
    1f26:	f8 94       	cli
    1f28:	de bf       	out	0x3e, r29	; 62
    1f2a:	0f be       	out	0x3f, r0	; 63
    1f2c:	cd bf       	out	0x3d, r28	; 61
    1f2e:	cf 91       	pop	r28
    1f30:	df 91       	pop	r29
    1f32:	08 95       	ret

00001f34 <LCD_vidWriteString>:
/* Description! Interface to write string on LCD screen                                */
/* Input      ! Pointer to the string                                                  */
/* Output     ! Nothing                                                                */
/***************************************************************************************/
void LCD_vidWriteString (u8* pu8StringCpy)
{
    1f34:	df 93       	push	r29
    1f36:	cf 93       	push	r28
    1f38:	cd b7       	in	r28, 0x3d	; 61
    1f3a:	de b7       	in	r29, 0x3e	; 62
    1f3c:	61 97       	sbiw	r28, 0x11	; 17
    1f3e:	0f b6       	in	r0, 0x3f	; 63
    1f40:	f8 94       	cli
    1f42:	de bf       	out	0x3e, r29	; 62
    1f44:	0f be       	out	0x3f, r0	; 63
    1f46:	cd bf       	out	0x3d, r28	; 61
    1f48:	99 8b       	std	Y+17, r25	; 0x11
    1f4a:	88 8b       	std	Y+16, r24	; 0x10

	//	/* Local loop index */
	//	u8 u8Index = 0;
	u8 iteration=0;
    1f4c:	1f 86       	std	Y+15, r1	; 0x0f
	//	while (pu8StringCpy[u8Index] != '\0')
	for (iteration=0; pu8StringCpy[iteration]!= '\0' ; iteration++)
    1f4e:	1f 86       	std	Y+15, r1	; 0x0f
    1f50:	80 c0       	rjmp	.+256    	; 0x2052 <LCD_vidWriteString+0x11e>
	{

		/* Write Character on LCD */
		LCD_vidWriteCharctr(pu8StringCpy[iteration]);
    1f52:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f54:	28 2f       	mov	r18, r24
    1f56:	30 e0       	ldi	r19, 0x00	; 0
    1f58:	88 89       	ldd	r24, Y+16	; 0x10
    1f5a:	99 89       	ldd	r25, Y+17	; 0x11
    1f5c:	fc 01       	movw	r30, r24
    1f5e:	e2 0f       	add	r30, r18
    1f60:	f3 1f       	adc	r31, r19
    1f62:	80 81       	ld	r24, Z
    1f64:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <LCD_vidWriteCharctr>
    1f68:	80 e0       	ldi	r24, 0x00	; 0
    1f6a:	90 e0       	ldi	r25, 0x00	; 0
    1f6c:	a0 e0       	ldi	r26, 0x00	; 0
    1f6e:	b0 e4       	ldi	r27, 0x40	; 64
    1f70:	8b 87       	std	Y+11, r24	; 0x0b
    1f72:	9c 87       	std	Y+12, r25	; 0x0c
    1f74:	ad 87       	std	Y+13, r26	; 0x0d
    1f76:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1f78:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f7a:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f7c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f7e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f80:	20 e0       	ldi	r18, 0x00	; 0
    1f82:	30 e0       	ldi	r19, 0x00	; 0
    1f84:	4a ef       	ldi	r20, 0xFA	; 250
    1f86:	54 e4       	ldi	r21, 0x44	; 68
    1f88:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f8c:	dc 01       	movw	r26, r24
    1f8e:	cb 01       	movw	r24, r22
    1f90:	8f 83       	std	Y+7, r24	; 0x07
    1f92:	98 87       	std	Y+8, r25	; 0x08
    1f94:	a9 87       	std	Y+9, r26	; 0x09
    1f96:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1f98:	6f 81       	ldd	r22, Y+7	; 0x07
    1f9a:	78 85       	ldd	r23, Y+8	; 0x08
    1f9c:	89 85       	ldd	r24, Y+9	; 0x09
    1f9e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fa0:	20 e0       	ldi	r18, 0x00	; 0
    1fa2:	30 e0       	ldi	r19, 0x00	; 0
    1fa4:	40 e8       	ldi	r20, 0x80	; 128
    1fa6:	5f e3       	ldi	r21, 0x3F	; 63
    1fa8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1fac:	88 23       	and	r24, r24
    1fae:	2c f4       	brge	.+10     	; 0x1fba <LCD_vidWriteString+0x86>
		__ticks = 1;
    1fb0:	81 e0       	ldi	r24, 0x01	; 1
    1fb2:	90 e0       	ldi	r25, 0x00	; 0
    1fb4:	9e 83       	std	Y+6, r25	; 0x06
    1fb6:	8d 83       	std	Y+5, r24	; 0x05
    1fb8:	3f c0       	rjmp	.+126    	; 0x2038 <LCD_vidWriteString+0x104>
	else if (__tmp > 65535)
    1fba:	6f 81       	ldd	r22, Y+7	; 0x07
    1fbc:	78 85       	ldd	r23, Y+8	; 0x08
    1fbe:	89 85       	ldd	r24, Y+9	; 0x09
    1fc0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fc2:	20 e0       	ldi	r18, 0x00	; 0
    1fc4:	3f ef       	ldi	r19, 0xFF	; 255
    1fc6:	4f e7       	ldi	r20, 0x7F	; 127
    1fc8:	57 e4       	ldi	r21, 0x47	; 71
    1fca:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1fce:	18 16       	cp	r1, r24
    1fd0:	4c f5       	brge	.+82     	; 0x2024 <LCD_vidWriteString+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1fd2:	6b 85       	ldd	r22, Y+11	; 0x0b
    1fd4:	7c 85       	ldd	r23, Y+12	; 0x0c
    1fd6:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fd8:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fda:	20 e0       	ldi	r18, 0x00	; 0
    1fdc:	30 e0       	ldi	r19, 0x00	; 0
    1fde:	40 e2       	ldi	r20, 0x20	; 32
    1fe0:	51 e4       	ldi	r21, 0x41	; 65
    1fe2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1fe6:	dc 01       	movw	r26, r24
    1fe8:	cb 01       	movw	r24, r22
    1fea:	bc 01       	movw	r22, r24
    1fec:	cd 01       	movw	r24, r26
    1fee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ff2:	dc 01       	movw	r26, r24
    1ff4:	cb 01       	movw	r24, r22
    1ff6:	9e 83       	std	Y+6, r25	; 0x06
    1ff8:	8d 83       	std	Y+5, r24	; 0x05
    1ffa:	0f c0       	rjmp	.+30     	; 0x201a <LCD_vidWriteString+0xe6>
    1ffc:	88 ec       	ldi	r24, 0xC8	; 200
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	9c 83       	std	Y+4, r25	; 0x04
    2002:	8b 83       	std	Y+3, r24	; 0x03
    2004:	8b 81       	ldd	r24, Y+3	; 0x03
    2006:	9c 81       	ldd	r25, Y+4	; 0x04
    2008:	01 97       	sbiw	r24, 0x01	; 1
    200a:	f1 f7       	brne	.-4      	; 0x2008 <LCD_vidWriteString+0xd4>
    200c:	9c 83       	std	Y+4, r25	; 0x04
    200e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2010:	8d 81       	ldd	r24, Y+5	; 0x05
    2012:	9e 81       	ldd	r25, Y+6	; 0x06
    2014:	01 97       	sbiw	r24, 0x01	; 1
    2016:	9e 83       	std	Y+6, r25	; 0x06
    2018:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    201a:	8d 81       	ldd	r24, Y+5	; 0x05
    201c:	9e 81       	ldd	r25, Y+6	; 0x06
    201e:	00 97       	sbiw	r24, 0x00	; 0
    2020:	69 f7       	brne	.-38     	; 0x1ffc <LCD_vidWriteString+0xc8>
    2022:	14 c0       	rjmp	.+40     	; 0x204c <LCD_vidWriteString+0x118>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2024:	6f 81       	ldd	r22, Y+7	; 0x07
    2026:	78 85       	ldd	r23, Y+8	; 0x08
    2028:	89 85       	ldd	r24, Y+9	; 0x09
    202a:	9a 85       	ldd	r25, Y+10	; 0x0a
    202c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2030:	dc 01       	movw	r26, r24
    2032:	cb 01       	movw	r24, r22
    2034:	9e 83       	std	Y+6, r25	; 0x06
    2036:	8d 83       	std	Y+5, r24	; 0x05
    2038:	8d 81       	ldd	r24, Y+5	; 0x05
    203a:	9e 81       	ldd	r25, Y+6	; 0x06
    203c:	9a 83       	std	Y+2, r25	; 0x02
    203e:	89 83       	std	Y+1, r24	; 0x01
    2040:	89 81       	ldd	r24, Y+1	; 0x01
    2042:	9a 81       	ldd	r25, Y+2	; 0x02
    2044:	01 97       	sbiw	r24, 0x01	; 1
    2046:	f1 f7       	brne	.-4      	; 0x2044 <LCD_vidWriteString+0x110>
    2048:	9a 83       	std	Y+2, r25	; 0x02
    204a:	89 83       	std	Y+1, r24	; 0x01

	//	/* Local loop index */
	//	u8 u8Index = 0;
	u8 iteration=0;
	//	while (pu8StringCpy[u8Index] != '\0')
	for (iteration=0; pu8StringCpy[iteration]!= '\0' ; iteration++)
    204c:	8f 85       	ldd	r24, Y+15	; 0x0f
    204e:	8f 5f       	subi	r24, 0xFF	; 255
    2050:	8f 87       	std	Y+15, r24	; 0x0f
    2052:	8f 85       	ldd	r24, Y+15	; 0x0f
    2054:	28 2f       	mov	r18, r24
    2056:	30 e0       	ldi	r19, 0x00	; 0
    2058:	88 89       	ldd	r24, Y+16	; 0x10
    205a:	99 89       	ldd	r25, Y+17	; 0x11
    205c:	fc 01       	movw	r30, r24
    205e:	e2 0f       	add	r30, r18
    2060:	f3 1f       	adc	r31, r19
    2062:	80 81       	ld	r24, Z
    2064:	88 23       	and	r24, r24
    2066:	09 f0       	breq	.+2      	; 0x206a <LCD_vidWriteString+0x136>
    2068:	74 cf       	rjmp	.-280    	; 0x1f52 <LCD_vidWriteString+0x1e>

		/* Delay to let the LCD show the character */
		_delay_ms(2);
	}

}
    206a:	61 96       	adiw	r28, 0x11	; 17
    206c:	0f b6       	in	r0, 0x3f	; 63
    206e:	f8 94       	cli
    2070:	de bf       	out	0x3e, r29	; 62
    2072:	0f be       	out	0x3f, r0	; 63
    2074:	cd bf       	out	0x3d, r28	; 61
    2076:	cf 91       	pop	r28
    2078:	df 91       	pop	r29
    207a:	08 95       	ret

0000207c <LCD_vidGotoxy>:
/* Description! Interface to start the writing process at certain digit in the LCD     */
/* Input      ! Y = Row position , X = Column position                                 */
/* Output     ! Nothing                                                                */
/***************************************************************************************/
void LCD_vidGotoxy (u8 Y,u8 X)
{
    207c:	df 93       	push	r29
    207e:	cf 93       	push	r28
    2080:	00 d0       	rcall	.+0      	; 0x2082 <LCD_vidGotoxy+0x6>
    2082:	00 d0       	rcall	.+0      	; 0x2084 <LCD_vidGotoxy+0x8>
    2084:	cd b7       	in	r28, 0x3d	; 61
    2086:	de b7       	in	r29, 0x3e	; 62
    2088:	89 83       	std	Y+1, r24	; 0x01
    208a:	6a 83       	std	Y+2, r22	; 0x02
	if (X>0 && X<=16)
    208c:	8a 81       	ldd	r24, Y+2	; 0x02
    208e:	88 23       	and	r24, r24
    2090:	e1 f0       	breq	.+56     	; 0x20ca <LCD_vidGotoxy+0x4e>
    2092:	8a 81       	ldd	r24, Y+2	; 0x02
    2094:	81 31       	cpi	r24, 0x11	; 17
    2096:	c8 f4       	brcc	.+50     	; 0x20ca <LCD_vidGotoxy+0x4e>
	{
		switch(Y)
    2098:	89 81       	ldd	r24, Y+1	; 0x01
    209a:	28 2f       	mov	r18, r24
    209c:	30 e0       	ldi	r19, 0x00	; 0
    209e:	3c 83       	std	Y+4, r19	; 0x04
    20a0:	2b 83       	std	Y+3, r18	; 0x03
    20a2:	8b 81       	ldd	r24, Y+3	; 0x03
    20a4:	9c 81       	ldd	r25, Y+4	; 0x04
    20a6:	81 30       	cpi	r24, 0x01	; 1
    20a8:	91 05       	cpc	r25, r1
    20aa:	31 f0       	breq	.+12     	; 0x20b8 <LCD_vidGotoxy+0x3c>
    20ac:	2b 81       	ldd	r18, Y+3	; 0x03
    20ae:	3c 81       	ldd	r19, Y+4	; 0x04
    20b0:	22 30       	cpi	r18, 0x02	; 2
    20b2:	31 05       	cpc	r19, r1
    20b4:	31 f0       	breq	.+12     	; 0x20c2 <LCD_vidGotoxy+0x46>
    20b6:	09 c0       	rjmp	.+18     	; 0x20ca <LCD_vidGotoxy+0x4e>
		{
		case 1:
			LCD_vidSendCommand(0x80+X-1);
    20b8:	8a 81       	ldd	r24, Y+2	; 0x02
    20ba:	81 58       	subi	r24, 0x81	; 129
    20bc:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_vidSendCommand>
    20c0:	04 c0       	rjmp	.+8      	; 0x20ca <LCD_vidGotoxy+0x4e>
			break;
		case 2:
			LCD_vidSendCommand(0xC0+X-1);
    20c2:	8a 81       	ldd	r24, Y+2	; 0x02
    20c4:	81 54       	subi	r24, 0x41	; 65
    20c6:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_vidSendCommand>
			break;
		default:
			break;
		}
	}
}
    20ca:	0f 90       	pop	r0
    20cc:	0f 90       	pop	r0
    20ce:	0f 90       	pop	r0
    20d0:	0f 90       	pop	r0
    20d2:	cf 91       	pop	r28
    20d4:	df 91       	pop	r29
    20d6:	08 95       	ret

000020d8 <LCD_vidWriteExtraChar>:
/* Description! Interface to write extra characters saved in the CGRAM                 */
/* Input      ! Y = Row position , X = Column position                                 */
/* Output     ! Nothing                                                                */
/***************************************************************************************/
void LCD_vidWriteExtraChar (u8 Y,u8 X)
{
    20d8:	df 93       	push	r29
    20da:	cf 93       	push	r28
    20dc:	cd b7       	in	r28, 0x3d	; 61
    20de:	de b7       	in	r29, 0x3e	; 62
    20e0:	62 97       	sbiw	r28, 0x12	; 18
    20e2:	0f b6       	in	r0, 0x3f	; 63
    20e4:	f8 94       	cli
    20e6:	de bf       	out	0x3e, r29	; 62
    20e8:	0f be       	out	0x3f, r0	; 63
    20ea:	cd bf       	out	0x3d, r28	; 61
    20ec:	89 8b       	std	Y+17, r24	; 0x11
    20ee:	6a 8b       	std	Y+18, r22	; 0x12
	u8 iteration1,iteration2;

	/*DDRAM-->CGRAM*/
	LCD_vidSendCommand(64);
    20f0:	80 e4       	ldi	r24, 0x40	; 64
    20f2:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_vidSendCommand>
	for(iteration1=0 ; iteration1<64 ; iteration1++)
    20f6:	18 8a       	std	Y+16, r1	; 0x10
    20f8:	0c c0       	rjmp	.+24     	; 0x2112 <LCD_vidWriteExtraChar+0x3a>
	{
		LCD_vidWriteCharctr(ExtraChar[iteration1]);
    20fa:	88 89       	ldd	r24, Y+16	; 0x10
    20fc:	88 2f       	mov	r24, r24
    20fe:	90 e0       	ldi	r25, 0x00	; 0
    2100:	fc 01       	movw	r30, r24
    2102:	ef 59       	subi	r30, 0x9F	; 159
    2104:	fe 4f       	sbci	r31, 0xFE	; 254
    2106:	80 81       	ld	r24, Z
    2108:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <LCD_vidWriteCharctr>
{
	u8 iteration1,iteration2;

	/*DDRAM-->CGRAM*/
	LCD_vidSendCommand(64);
	for(iteration1=0 ; iteration1<64 ; iteration1++)
    210c:	88 89       	ldd	r24, Y+16	; 0x10
    210e:	8f 5f       	subi	r24, 0xFF	; 255
    2110:	88 8b       	std	Y+16, r24	; 0x10
    2112:	88 89       	ldd	r24, Y+16	; 0x10
    2114:	80 34       	cpi	r24, 0x40	; 64
    2116:	88 f3       	brcs	.-30     	; 0x20fa <LCD_vidWriteExtraChar+0x22>
	{
		LCD_vidWriteCharctr(ExtraChar[iteration1]);
	}
	/*CGRAM-->DDRAM*/
	LCD_vidSendCommand(128);
    2118:	80 e8       	ldi	r24, 0x80	; 128
    211a:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_vidSendCommand>
	LCD_vidGotoxy(Y,X);
    211e:	89 89       	ldd	r24, Y+17	; 0x11
    2120:	6a 89       	ldd	r22, Y+18	; 0x12
    2122:	0e 94 3e 10 	call	0x207c	; 0x207c <LCD_vidGotoxy>
	/*First eight character which saved at CGRAM*/
	for (iteration2=0; iteration2<=7 ; iteration2++)
    2126:	1f 86       	std	Y+15, r1	; 0x0f
    2128:	78 c0       	rjmp	.+240    	; 0x221a <LCD_vidWriteExtraChar+0x142>
	{
		/* Write bytes of DDRAM */
		LCD_vidWriteCharctr(iteration2);
    212a:	8f 85       	ldd	r24, Y+15	; 0x0f
    212c:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <LCD_vidWriteCharctr>
    2130:	80 e0       	ldi	r24, 0x00	; 0
    2132:	90 e0       	ldi	r25, 0x00	; 0
    2134:	a0 ea       	ldi	r26, 0xA0	; 160
    2136:	b0 e4       	ldi	r27, 0x40	; 64
    2138:	8b 87       	std	Y+11, r24	; 0x0b
    213a:	9c 87       	std	Y+12, r25	; 0x0c
    213c:	ad 87       	std	Y+13, r26	; 0x0d
    213e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2140:	6b 85       	ldd	r22, Y+11	; 0x0b
    2142:	7c 85       	ldd	r23, Y+12	; 0x0c
    2144:	8d 85       	ldd	r24, Y+13	; 0x0d
    2146:	9e 85       	ldd	r25, Y+14	; 0x0e
    2148:	20 e0       	ldi	r18, 0x00	; 0
    214a:	30 e0       	ldi	r19, 0x00	; 0
    214c:	4a ef       	ldi	r20, 0xFA	; 250
    214e:	54 e4       	ldi	r21, 0x44	; 68
    2150:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2154:	dc 01       	movw	r26, r24
    2156:	cb 01       	movw	r24, r22
    2158:	8f 83       	std	Y+7, r24	; 0x07
    215a:	98 87       	std	Y+8, r25	; 0x08
    215c:	a9 87       	std	Y+9, r26	; 0x09
    215e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2160:	6f 81       	ldd	r22, Y+7	; 0x07
    2162:	78 85       	ldd	r23, Y+8	; 0x08
    2164:	89 85       	ldd	r24, Y+9	; 0x09
    2166:	9a 85       	ldd	r25, Y+10	; 0x0a
    2168:	20 e0       	ldi	r18, 0x00	; 0
    216a:	30 e0       	ldi	r19, 0x00	; 0
    216c:	40 e8       	ldi	r20, 0x80	; 128
    216e:	5f e3       	ldi	r21, 0x3F	; 63
    2170:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2174:	88 23       	and	r24, r24
    2176:	2c f4       	brge	.+10     	; 0x2182 <LCD_vidWriteExtraChar+0xaa>
		__ticks = 1;
    2178:	81 e0       	ldi	r24, 0x01	; 1
    217a:	90 e0       	ldi	r25, 0x00	; 0
    217c:	9e 83       	std	Y+6, r25	; 0x06
    217e:	8d 83       	std	Y+5, r24	; 0x05
    2180:	3f c0       	rjmp	.+126    	; 0x2200 <LCD_vidWriteExtraChar+0x128>
	else if (__tmp > 65535)
    2182:	6f 81       	ldd	r22, Y+7	; 0x07
    2184:	78 85       	ldd	r23, Y+8	; 0x08
    2186:	89 85       	ldd	r24, Y+9	; 0x09
    2188:	9a 85       	ldd	r25, Y+10	; 0x0a
    218a:	20 e0       	ldi	r18, 0x00	; 0
    218c:	3f ef       	ldi	r19, 0xFF	; 255
    218e:	4f e7       	ldi	r20, 0x7F	; 127
    2190:	57 e4       	ldi	r21, 0x47	; 71
    2192:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2196:	18 16       	cp	r1, r24
    2198:	4c f5       	brge	.+82     	; 0x21ec <LCD_vidWriteExtraChar+0x114>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    219a:	6b 85       	ldd	r22, Y+11	; 0x0b
    219c:	7c 85       	ldd	r23, Y+12	; 0x0c
    219e:	8d 85       	ldd	r24, Y+13	; 0x0d
    21a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    21a2:	20 e0       	ldi	r18, 0x00	; 0
    21a4:	30 e0       	ldi	r19, 0x00	; 0
    21a6:	40 e2       	ldi	r20, 0x20	; 32
    21a8:	51 e4       	ldi	r21, 0x41	; 65
    21aa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21ae:	dc 01       	movw	r26, r24
    21b0:	cb 01       	movw	r24, r22
    21b2:	bc 01       	movw	r22, r24
    21b4:	cd 01       	movw	r24, r26
    21b6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21ba:	dc 01       	movw	r26, r24
    21bc:	cb 01       	movw	r24, r22
    21be:	9e 83       	std	Y+6, r25	; 0x06
    21c0:	8d 83       	std	Y+5, r24	; 0x05
    21c2:	0f c0       	rjmp	.+30     	; 0x21e2 <LCD_vidWriteExtraChar+0x10a>
    21c4:	88 ec       	ldi	r24, 0xC8	; 200
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	9c 83       	std	Y+4, r25	; 0x04
    21ca:	8b 83       	std	Y+3, r24	; 0x03
    21cc:	8b 81       	ldd	r24, Y+3	; 0x03
    21ce:	9c 81       	ldd	r25, Y+4	; 0x04
    21d0:	01 97       	sbiw	r24, 0x01	; 1
    21d2:	f1 f7       	brne	.-4      	; 0x21d0 <LCD_vidWriteExtraChar+0xf8>
    21d4:	9c 83       	std	Y+4, r25	; 0x04
    21d6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    21d8:	8d 81       	ldd	r24, Y+5	; 0x05
    21da:	9e 81       	ldd	r25, Y+6	; 0x06
    21dc:	01 97       	sbiw	r24, 0x01	; 1
    21de:	9e 83       	std	Y+6, r25	; 0x06
    21e0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    21e2:	8d 81       	ldd	r24, Y+5	; 0x05
    21e4:	9e 81       	ldd	r25, Y+6	; 0x06
    21e6:	00 97       	sbiw	r24, 0x00	; 0
    21e8:	69 f7       	brne	.-38     	; 0x21c4 <LCD_vidWriteExtraChar+0xec>
    21ea:	14 c0       	rjmp	.+40     	; 0x2214 <LCD_vidWriteExtraChar+0x13c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    21ec:	6f 81       	ldd	r22, Y+7	; 0x07
    21ee:	78 85       	ldd	r23, Y+8	; 0x08
    21f0:	89 85       	ldd	r24, Y+9	; 0x09
    21f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    21f4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21f8:	dc 01       	movw	r26, r24
    21fa:	cb 01       	movw	r24, r22
    21fc:	9e 83       	std	Y+6, r25	; 0x06
    21fe:	8d 83       	std	Y+5, r24	; 0x05
    2200:	8d 81       	ldd	r24, Y+5	; 0x05
    2202:	9e 81       	ldd	r25, Y+6	; 0x06
    2204:	9a 83       	std	Y+2, r25	; 0x02
    2206:	89 83       	std	Y+1, r24	; 0x01
    2208:	89 81       	ldd	r24, Y+1	; 0x01
    220a:	9a 81       	ldd	r25, Y+2	; 0x02
    220c:	01 97       	sbiw	r24, 0x01	; 1
    220e:	f1 f7       	brne	.-4      	; 0x220c <LCD_vidWriteExtraChar+0x134>
    2210:	9a 83       	std	Y+2, r25	; 0x02
    2212:	89 83       	std	Y+1, r24	; 0x01
	}
	/*CGRAM-->DDRAM*/
	LCD_vidSendCommand(128);
	LCD_vidGotoxy(Y,X);
	/*First eight character which saved at CGRAM*/
	for (iteration2=0; iteration2<=7 ; iteration2++)
    2214:	8f 85       	ldd	r24, Y+15	; 0x0f
    2216:	8f 5f       	subi	r24, 0xFF	; 255
    2218:	8f 87       	std	Y+15, r24	; 0x0f
    221a:	8f 85       	ldd	r24, Y+15	; 0x0f
    221c:	88 30       	cpi	r24, 0x08	; 8
    221e:	08 f4       	brcc	.+2      	; 0x2222 <LCD_vidWriteExtraChar+0x14a>
    2220:	84 cf       	rjmp	.-248    	; 0x212a <LCD_vidWriteExtraChar+0x52>
		/* Write bytes of DDRAM */
		LCD_vidWriteCharctr(iteration2);

		_delay_ms(5);
	}
}
    2222:	62 96       	adiw	r28, 0x12	; 18
    2224:	0f b6       	in	r0, 0x3f	; 63
    2226:	f8 94       	cli
    2228:	de bf       	out	0x3e, r29	; 62
    222a:	0f be       	out	0x3f, r0	; 63
    222c:	cd bf       	out	0x3d, r28	; 61
    222e:	cf 91       	pop	r28
    2230:	df 91       	pop	r29
    2232:	08 95       	ret

00002234 <LCD_vidWriteNumber>:
void LCD_vidWriteNumber(u16 Copy_u16Number)
{
    2234:	df 93       	push	r29
    2236:	cf 93       	push	r28
    2238:	cd b7       	in	r28, 0x3d	; 61
    223a:	de b7       	in	r29, 0x3e	; 62
    223c:	27 97       	sbiw	r28, 0x07	; 7
    223e:	0f b6       	in	r0, 0x3f	; 63
    2240:	f8 94       	cli
    2242:	de bf       	out	0x3e, r29	; 62
    2244:	0f be       	out	0x3f, r0	; 63
    2246:	cd bf       	out	0x3d, r28	; 61
    2248:	9f 83       	std	Y+7, r25	; 0x07
    224a:	8e 83       	std	Y+6, r24	; 0x06
	u8 Counter=0,Digits=0,Current;
    224c:	1d 82       	std	Y+5, r1	; 0x05
    224e:	1c 82       	std	Y+4, r1	; 0x04
	u16 CopyNumber=Copy_u16Number;
    2250:	8e 81       	ldd	r24, Y+6	; 0x06
    2252:	9f 81       	ldd	r25, Y+7	; 0x07
    2254:	9a 83       	std	Y+2, r25	; 0x02
    2256:	89 83       	std	Y+1, r24	; 0x01
    2258:	0d c0       	rjmp	.+26     	; 0x2274 <LCD_vidWriteNumber+0x40>
	while(CopyNumber)
	{
		CopyNumber/=10;
    225a:	89 81       	ldd	r24, Y+1	; 0x01
    225c:	9a 81       	ldd	r25, Y+2	; 0x02
    225e:	2a e0       	ldi	r18, 0x0A	; 10
    2260:	30 e0       	ldi	r19, 0x00	; 0
    2262:	b9 01       	movw	r22, r18
    2264:	0e 94 7c 32 	call	0x64f8	; 0x64f8 <__udivmodhi4>
    2268:	cb 01       	movw	r24, r22
    226a:	9a 83       	std	Y+2, r25	; 0x02
    226c:	89 83       	std	Y+1, r24	; 0x01
		Digits++;
    226e:	8c 81       	ldd	r24, Y+4	; 0x04
    2270:	8f 5f       	subi	r24, 0xFF	; 255
    2272:	8c 83       	std	Y+4, r24	; 0x04
}
void LCD_vidWriteNumber(u16 Copy_u16Number)
{
	u8 Counter=0,Digits=0,Current;
	u16 CopyNumber=Copy_u16Number;
	while(CopyNumber)
    2274:	89 81       	ldd	r24, Y+1	; 0x01
    2276:	9a 81       	ldd	r25, Y+2	; 0x02
    2278:	00 97       	sbiw	r24, 0x00	; 0
    227a:	79 f7       	brne	.-34     	; 0x225a <LCD_vidWriteNumber+0x26>
	{
		CopyNumber/=10;
		Digits++;
	}
	CopyNumber=Copy_u16Number;
    227c:	8e 81       	ldd	r24, Y+6	; 0x06
    227e:	9f 81       	ldd	r25, Y+7	; 0x07
    2280:	9a 83       	std	Y+2, r25	; 0x02
    2282:	89 83       	std	Y+1, r24	; 0x01
	for(Counter=0;Counter<Digits;Counter++)
    2284:	1d 82       	std	Y+5, r1	; 0x05
    2286:	2d c0       	rjmp	.+90     	; 0x22e2 <LCD_vidWriteNumber+0xae>
	{
		Current=CopyNumber/(Private_GetPower(10,Digits-1-Counter));
    2288:	9c 81       	ldd	r25, Y+4	; 0x04
    228a:	8d 81       	ldd	r24, Y+5	; 0x05
    228c:	29 2f       	mov	r18, r25
    228e:	28 1b       	sub	r18, r24
    2290:	82 2f       	mov	r24, r18
    2292:	98 2f       	mov	r25, r24
    2294:	91 50       	subi	r25, 0x01	; 1
    2296:	8a e0       	ldi	r24, 0x0A	; 10
    2298:	69 2f       	mov	r22, r25
    229a:	0e 94 7e 11 	call	0x22fc	; 0x22fc <Private_GetPower>
    229e:	9c 01       	movw	r18, r24
    22a0:	89 81       	ldd	r24, Y+1	; 0x01
    22a2:	9a 81       	ldd	r25, Y+2	; 0x02
    22a4:	b9 01       	movw	r22, r18
    22a6:	0e 94 7c 32 	call	0x64f8	; 0x64f8 <__udivmodhi4>
    22aa:	cb 01       	movw	r24, r22
    22ac:	8b 83       	std	Y+3, r24	; 0x03
		LCD_vidWriteCharctr(Current+'0');
    22ae:	8b 81       	ldd	r24, Y+3	; 0x03
    22b0:	80 5d       	subi	r24, 0xD0	; 208
    22b2:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <LCD_vidWriteCharctr>
		CopyNumber%=(Private_GetPower(10,Digits-1-Counter));
    22b6:	9c 81       	ldd	r25, Y+4	; 0x04
    22b8:	8d 81       	ldd	r24, Y+5	; 0x05
    22ba:	29 2f       	mov	r18, r25
    22bc:	28 1b       	sub	r18, r24
    22be:	82 2f       	mov	r24, r18
    22c0:	98 2f       	mov	r25, r24
    22c2:	91 50       	subi	r25, 0x01	; 1
    22c4:	8a e0       	ldi	r24, 0x0A	; 10
    22c6:	69 2f       	mov	r22, r25
    22c8:	0e 94 7e 11 	call	0x22fc	; 0x22fc <Private_GetPower>
    22cc:	9c 01       	movw	r18, r24
    22ce:	89 81       	ldd	r24, Y+1	; 0x01
    22d0:	9a 81       	ldd	r25, Y+2	; 0x02
    22d2:	b9 01       	movw	r22, r18
    22d4:	0e 94 7c 32 	call	0x64f8	; 0x64f8 <__udivmodhi4>
    22d8:	9a 83       	std	Y+2, r25	; 0x02
    22da:	89 83       	std	Y+1, r24	; 0x01
	{
		CopyNumber/=10;
		Digits++;
	}
	CopyNumber=Copy_u16Number;
	for(Counter=0;Counter<Digits;Counter++)
    22dc:	8d 81       	ldd	r24, Y+5	; 0x05
    22de:	8f 5f       	subi	r24, 0xFF	; 255
    22e0:	8d 83       	std	Y+5, r24	; 0x05
    22e2:	9d 81       	ldd	r25, Y+5	; 0x05
    22e4:	8c 81       	ldd	r24, Y+4	; 0x04
    22e6:	98 17       	cp	r25, r24
    22e8:	78 f2       	brcs	.-98     	; 0x2288 <LCD_vidWriteNumber+0x54>
		Current=CopyNumber/(Private_GetPower(10,Digits-1-Counter));
		LCD_vidWriteCharctr(Current+'0');
		CopyNumber%=(Private_GetPower(10,Digits-1-Counter));
	}

}
    22ea:	27 96       	adiw	r28, 0x07	; 7
    22ec:	0f b6       	in	r0, 0x3f	; 63
    22ee:	f8 94       	cli
    22f0:	de bf       	out	0x3e, r29	; 62
    22f2:	0f be       	out	0x3f, r0	; 63
    22f4:	cd bf       	out	0x3d, r28	; 61
    22f6:	cf 91       	pop	r28
    22f8:	df 91       	pop	r29
    22fa:	08 95       	ret

000022fc <Private_GetPower>:
static u16 Private_GetPower(u8 Num1, u8 Num2)
{
    22fc:	df 93       	push	r29
    22fe:	cf 93       	push	r28
    2300:	00 d0       	rcall	.+0      	; 0x2302 <Private_GetPower+0x6>
    2302:	00 d0       	rcall	.+0      	; 0x2304 <Private_GetPower+0x8>
    2304:	0f 92       	push	r0
    2306:	cd b7       	in	r28, 0x3d	; 61
    2308:	de b7       	in	r29, 0x3e	; 62
    230a:	8c 83       	std	Y+4, r24	; 0x04
    230c:	6d 83       	std	Y+5, r22	; 0x05
	u16 Result=1;
    230e:	81 e0       	ldi	r24, 0x01	; 1
    2310:	90 e0       	ldi	r25, 0x00	; 0
    2312:	9b 83       	std	Y+3, r25	; 0x03
    2314:	8a 83       	std	Y+2, r24	; 0x02
	u8 Counter=0;
    2316:	19 82       	std	Y+1, r1	; 0x01
	for(Counter=0;Counter<Num2;Counter++)
    2318:	19 82       	std	Y+1, r1	; 0x01
    231a:	12 c0       	rjmp	.+36     	; 0x2340 <Private_GetPower+0x44>
	{
		Result*=Num1;
    231c:	8c 81       	ldd	r24, Y+4	; 0x04
    231e:	28 2f       	mov	r18, r24
    2320:	30 e0       	ldi	r19, 0x00	; 0
    2322:	8a 81       	ldd	r24, Y+2	; 0x02
    2324:	9b 81       	ldd	r25, Y+3	; 0x03
    2326:	ac 01       	movw	r20, r24
    2328:	42 9f       	mul	r20, r18
    232a:	c0 01       	movw	r24, r0
    232c:	43 9f       	mul	r20, r19
    232e:	90 0d       	add	r25, r0
    2330:	52 9f       	mul	r21, r18
    2332:	90 0d       	add	r25, r0
    2334:	11 24       	eor	r1, r1
    2336:	9b 83       	std	Y+3, r25	; 0x03
    2338:	8a 83       	std	Y+2, r24	; 0x02
}
static u16 Private_GetPower(u8 Num1, u8 Num2)
{
	u16 Result=1;
	u8 Counter=0;
	for(Counter=0;Counter<Num2;Counter++)
    233a:	89 81       	ldd	r24, Y+1	; 0x01
    233c:	8f 5f       	subi	r24, 0xFF	; 255
    233e:	89 83       	std	Y+1, r24	; 0x01
    2340:	99 81       	ldd	r25, Y+1	; 0x01
    2342:	8d 81       	ldd	r24, Y+5	; 0x05
    2344:	98 17       	cp	r25, r24
    2346:	50 f3       	brcs	.-44     	; 0x231c <Private_GetPower+0x20>
	{
		Result*=Num1;
	}
	return Result;
    2348:	8a 81       	ldd	r24, Y+2	; 0x02
    234a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    234c:	0f 90       	pop	r0
    234e:	0f 90       	pop	r0
    2350:	0f 90       	pop	r0
    2352:	0f 90       	pop	r0
    2354:	0f 90       	pop	r0
    2356:	cf 91       	pop	r28
    2358:	df 91       	pop	r29
    235a:	08 95       	ret

0000235c <main>:
	u8 AS;
} TAS;


int main(void)
{
    235c:	af 92       	push	r10
    235e:	bf 92       	push	r11
    2360:	cf 92       	push	r12
    2362:	df 92       	push	r13
    2364:	ef 92       	push	r14
    2366:	ff 92       	push	r15
    2368:	0f 93       	push	r16
    236a:	df 93       	push	r29
    236c:	cf 93       	push	r28
    236e:	cd b7       	in	r28, 0x3d	; 61
    2370:	de b7       	in	r29, 0x3e	; 62

	System_Init();
    2372:	0e 94 85 14 	call	0x290a	; 0x290a <System_Init>

	/* OS Object Creation */
	egEvents = xEventGroupCreate();
    2376:	0e 94 50 19 	call	0x32a0	; 0x32a0 <xEventGroupCreate>
    237a:	90 93 a3 01 	sts	0x01A3, r25
    237e:	80 93 a2 01 	sts	0x01A2, r24
	bsCheck = xSemaphoreCreateBinary();
    2382:	81 e0       	ldi	r24, 0x01	; 1
    2384:	60 e0       	ldi	r22, 0x00	; 0
    2386:	43 e0       	ldi	r20, 0x03	; 3
    2388:	0e 94 6e 22 	call	0x44dc	; 0x44dc <xQueueGenericCreate>
    238c:	90 93 05 07 	sts	0x0705, r25
    2390:	80 93 04 07 	sts	0x0704, r24


#if 1
	LCD_vidWriteString("System Started");
    2394:	80 e6       	ldi	r24, 0x60	; 96
    2396:	90 e0       	ldi	r25, 0x00	; 0
    2398:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	/* Creating the tasks*/
	xTaskCreate(T_Display, 	NULL, 150, NULL, 1, NULL);
    239c:	85 e2       	ldi	r24, 0x25	; 37
    239e:	94 e1       	ldi	r25, 0x14	; 20
    23a0:	60 e0       	ldi	r22, 0x00	; 0
    23a2:	70 e0       	ldi	r23, 0x00	; 0
    23a4:	46 e9       	ldi	r20, 0x96	; 150
    23a6:	50 e0       	ldi	r21, 0x00	; 0
    23a8:	20 e0       	ldi	r18, 0x00	; 0
    23aa:	30 e0       	ldi	r19, 0x00	; 0
    23ac:	01 e0       	ldi	r16, 0x01	; 1
    23ae:	ee 24       	eor	r14, r14
    23b0:	ff 24       	eor	r15, r15
    23b2:	cc 24       	eor	r12, r12
    23b4:	dd 24       	eor	r13, r13
    23b6:	aa 24       	eor	r10, r10
    23b8:	bb 24       	eor	r11, r11
    23ba:	0e 94 94 29 	call	0x5328	; 0x5328 <xTaskGenericCreate>
	xTaskCreate(T_CTemp, 	NULL, 150, NULL, 2, NULL);
    23be:	8c ec       	ldi	r24, 0xCC	; 204
    23c0:	93 e1       	ldi	r25, 0x13	; 19
    23c2:	60 e0       	ldi	r22, 0x00	; 0
    23c4:	70 e0       	ldi	r23, 0x00	; 0
    23c6:	46 e9       	ldi	r20, 0x96	; 150
    23c8:	50 e0       	ldi	r21, 0x00	; 0
    23ca:	20 e0       	ldi	r18, 0x00	; 0
    23cc:	30 e0       	ldi	r19, 0x00	; 0
    23ce:	02 e0       	ldi	r16, 0x02	; 2
    23d0:	ee 24       	eor	r14, r14
    23d2:	ff 24       	eor	r15, r15
    23d4:	cc 24       	eor	r12, r12
    23d6:	dd 24       	eor	r13, r13
    23d8:	aa 24       	eor	r10, r10
    23da:	bb 24       	eor	r11, r11
    23dc:	0e 94 94 29 	call	0x5328	; 0x5328 <xTaskGenericCreate>
	xTaskCreate(T_Terminal, NULL, 150, NULL, 3, NULL);
    23e0:	8d ed       	ldi	r24, 0xDD	; 221
    23e2:	92 e1       	ldi	r25, 0x12	; 18
    23e4:	60 e0       	ldi	r22, 0x00	; 0
    23e6:	70 e0       	ldi	r23, 0x00	; 0
    23e8:	46 e9       	ldi	r20, 0x96	; 150
    23ea:	50 e0       	ldi	r21, 0x00	; 0
    23ec:	20 e0       	ldi	r18, 0x00	; 0
    23ee:	30 e0       	ldi	r19, 0x00	; 0
    23f0:	03 e0       	ldi	r16, 0x03	; 3
    23f2:	ee 24       	eor	r14, r14
    23f4:	ff 24       	eor	r15, r15
    23f6:	cc 24       	eor	r12, r12
    23f8:	dd 24       	eor	r13, r13
    23fa:	aa 24       	eor	r10, r10
    23fc:	bb 24       	eor	r11, r11
    23fe:	0e 94 94 29 	call	0x5328	; 0x5328 <xTaskGenericCreate>
	xTaskCreate(T_SysCheck, NULL, 150, NULL, 4, NULL);
    2402:	89 e6       	ldi	r24, 0x69	; 105
    2404:	92 e1       	ldi	r25, 0x12	; 18
    2406:	60 e0       	ldi	r22, 0x00	; 0
    2408:	70 e0       	ldi	r23, 0x00	; 0
    240a:	46 e9       	ldi	r20, 0x96	; 150
    240c:	50 e0       	ldi	r21, 0x00	; 0
    240e:	20 e0       	ldi	r18, 0x00	; 0
    2410:	30 e0       	ldi	r19, 0x00	; 0
    2412:	04 e0       	ldi	r16, 0x04	; 4
    2414:	ee 24       	eor	r14, r14
    2416:	ff 24       	eor	r15, r15
    2418:	cc 24       	eor	r12, r12
    241a:	dd 24       	eor	r13, r13
    241c:	aa 24       	eor	r10, r10
    241e:	bb 24       	eor	r11, r11
    2420:	0e 94 94 29 	call	0x5328	; 0x5328 <xTaskGenericCreate>
	xTaskCreate(T_Alarm,	NULL, 100, NULL, 5, NULL);
    2424:	81 e3       	ldi	r24, 0x31	; 49
    2426:	92 e1       	ldi	r25, 0x12	; 18
    2428:	60 e0       	ldi	r22, 0x00	; 0
    242a:	70 e0       	ldi	r23, 0x00	; 0
    242c:	44 e6       	ldi	r20, 0x64	; 100
    242e:	50 e0       	ldi	r21, 0x00	; 0
    2430:	20 e0       	ldi	r18, 0x00	; 0
    2432:	30 e0       	ldi	r19, 0x00	; 0
    2434:	05 e0       	ldi	r16, 0x05	; 5
    2436:	ee 24       	eor	r14, r14
    2438:	ff 24       	eor	r15, r15
    243a:	cc 24       	eor	r12, r12
    243c:	dd 24       	eor	r13, r13
    243e:	aa 24       	eor	r10, r10
    2440:	bb 24       	eor	r11, r11
    2442:	0e 94 94 29 	call	0x5328	; 0x5328 <xTaskGenericCreate>

	vTaskStartScheduler();
    2446:	0e 94 0f 2b 	call	0x561e	; 0x561e <vTaskStartScheduler>
    244a:	80 e0       	ldi	r24, 0x00	; 0
    244c:	90 e0       	ldi	r25, 0x00	; 0

#endif

}
    244e:	cf 91       	pop	r28
    2450:	df 91       	pop	r29
    2452:	0f 91       	pop	r16
    2454:	ff 90       	pop	r15
    2456:	ef 90       	pop	r14
    2458:	df 90       	pop	r13
    245a:	cf 90       	pop	r12
    245c:	bf 90       	pop	r11
    245e:	af 90       	pop	r10
    2460:	08 95       	ret

00002462 <T_Alarm>:


void T_Alarm(void* pvParam)
{
    2462:	0f 93       	push	r16
    2464:	1f 93       	push	r17
    2466:	df 93       	push	r29
    2468:	cf 93       	push	r28
    246a:	00 d0       	rcall	.+0      	; 0x246c <T_Alarm+0xa>
    246c:	cd b7       	in	r28, 0x3d	; 61
    246e:	de b7       	in	r29, 0x3e	; 62
    2470:	9a 83       	std	Y+2, r25	; 0x02
    2472:	89 83       	std	Y+1, r24	; 0x01
	usart_puts("T_Alarm started ...\r\n");
    2474:	8f e6       	ldi	r24, 0x6F	; 111
    2476:	90 e0       	ldi	r25, 0x00	; 0
    2478:	0e 94 0a 0a 	call	0x1414	; 0x1414 <usart_puts>
	while(1)
	{
		//usart_puts("Running T_Alarm\r\n");

		/* Waiting the event to Start the alarm */
		ebBits = xEventGroupWaitBits(egEvents, E_Alarm, 0, 0, portMAX_DELAY);
    247c:	80 91 a2 01 	lds	r24, 0x01A2
    2480:	90 91 a3 01 	lds	r25, 0x01A3
    2484:	61 e0       	ldi	r22, 0x01	; 1
    2486:	70 e0       	ldi	r23, 0x00	; 0
    2488:	40 e0       	ldi	r20, 0x00	; 0
    248a:	20 e0       	ldi	r18, 0x00	; 0
    248c:	0f ef       	ldi	r16, 0xFF	; 255
    248e:	1f ef       	ldi	r17, 0xFF	; 255
    2490:	0e 94 26 1a 	call	0x344c	; 0x344c <xEventGroupWaitBits>
    2494:	90 93 03 07 	sts	0x0703, r25
    2498:	80 93 02 07 	sts	0x0702, r24
		if( (ebBits&E_Alarm) == E_Alarm )	/* if exit waiting because of event */
    249c:	80 91 02 07 	lds	r24, 0x0702
    24a0:	90 91 03 07 	lds	r25, 0x0703
    24a4:	81 70       	andi	r24, 0x01	; 1
    24a6:	90 70       	andi	r25, 0x00	; 0
    24a8:	88 23       	and	r24, r24
    24aa:	41 f3       	breq	.-48     	; 0x247c <T_Alarm+0x1a>
		{
			//usart_puts("E_Alarm received...\r\n");
			DIO_voidSetPinValue(DIO_u8_PORTD, DIO_u8_PIN2, DIO_u8_HIGH );
    24ac:	83 e0       	ldi	r24, 0x03	; 3
    24ae:	62 e0       	ldi	r22, 0x02	; 2
    24b0:	41 e0       	ldi	r20, 0x01	; 1
    24b2:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <DIO_voidSetPinValue>
			vTaskDelay(500);
    24b6:	84 ef       	ldi	r24, 0xF4	; 244
    24b8:	91 e0       	ldi	r25, 0x01	; 1
    24ba:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <vTaskDelay>
			DIO_voidSetPinValue(DIO_u8_PORTD, DIO_u8_PIN2, DIO_u8_LOW );
    24be:	83 e0       	ldi	r24, 0x03	; 3
    24c0:	62 e0       	ldi	r22, 0x02	; 2
    24c2:	40 e0       	ldi	r20, 0x00	; 0
    24c4:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <DIO_voidSetPinValue>
			vTaskDelay(500);
    24c8:	84 ef       	ldi	r24, 0xF4	; 244
    24ca:	91 e0       	ldi	r25, 0x01	; 1
    24cc:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <vTaskDelay>
    24d0:	d5 cf       	rjmp	.-86     	; 0x247c <T_Alarm+0x1a>

000024d2 <T_SysCheck>:
		}
	}
}

void T_SysCheck(void* pvParam)
{
    24d2:	df 93       	push	r29
    24d4:	cf 93       	push	r28
    24d6:	00 d0       	rcall	.+0      	; 0x24d8 <T_SysCheck+0x6>
    24d8:	cd b7       	in	r28, 0x3d	; 61
    24da:	de b7       	in	r29, 0x3e	; 62
    24dc:	9a 83       	std	Y+2, r25	; 0x02
    24de:	89 83       	std	Y+1, r24	; 0x01
	usart_puts("T_SysCheck started...\r\n");
    24e0:	85 e8       	ldi	r24, 0x85	; 133
    24e2:	90 e0       	ldi	r25, 0x00	; 0
    24e4:	0e 94 0a 0a 	call	0x1414	; 0x1414 <usart_puts>

	/* initial trigger to T_Display Task */
	xEventGroupSetBits(egEvents, E_MainScreen); /* for T_Display Task */
    24e8:	80 91 a2 01 	lds	r24, 0x01A2
    24ec:	90 91 a3 01 	lds	r25, 0x01A3
    24f0:	62 e0       	ldi	r22, 0x02	; 2
    24f2:	70 e0       	ldi	r23, 0x00	; 0
    24f4:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
	{

		//usart_puts("Running T_SysCheck \r\n");

		/* Waiting Sem. from T_CTemp or T_terminal */
		if(xSemaphoreTake(bsCheck, portMAX_DELAY))
    24f8:	80 91 04 07 	lds	r24, 0x0704
    24fc:	90 91 05 07 	lds	r25, 0x0705
    2500:	60 e0       	ldi	r22, 0x00	; 0
    2502:	70 e0       	ldi	r23, 0x00	; 0
    2504:	4f ef       	ldi	r20, 0xFF	; 255
    2506:	5f ef       	ldi	r21, 0xFF	; 255
    2508:	20 e0       	ldi	r18, 0x00	; 0
    250a:	0e 94 47 24 	call	0x488e	; 0x488e <xQueueGenericReceive>
    250e:	88 23       	and	r24, r24
    2510:	99 f3       	breq	.-26     	; 0x24f8 <T_SysCheck+0x26>
		{
			//usart_puts("xSemaphoreTake \r\n");
			if( TAS.SystemState == MainState && TAS.CTemp >= TAS.TTemp && TAS.AS == ENABLED)
    2512:	80 91 0b 07 	lds	r24, 0x070B
    2516:	88 23       	and	r24, r24
    2518:	f1 f4       	brne	.+60     	; 0x2556 <T_SysCheck+0x84>
    251a:	90 91 0c 07 	lds	r25, 0x070C
    251e:	80 91 0d 07 	lds	r24, 0x070D
    2522:	98 17       	cp	r25, r24
    2524:	c0 f0       	brcs	.+48     	; 0x2556 <T_SysCheck+0x84>
    2526:	80 91 0e 07 	lds	r24, 0x070E
    252a:	81 30       	cpi	r24, 0x01	; 1
    252c:	a1 f4       	brne	.+40     	; 0x2556 <T_SysCheck+0x84>
			{
			/* if we are in main screen AND if temp is bigger than threshold AND Alarming enabled*/
				//usart_puts("condition1 \r\n");
				TAS.SystemState = AlarmState;	/* to display the alarm screen when T_Display is called*/
    252e:	82 e0       	ldi	r24, 0x02	; 2
    2530:	80 93 0b 07 	sts	0x070B, r24
				xEventGroupSetBits(egEvents, E_Alarm); /* trigger the T_Alarm Task */
    2534:	80 91 a2 01 	lds	r24, 0x01A2
    2538:	90 91 a3 01 	lds	r25, 0x01A3
    253c:	61 e0       	ldi	r22, 0x01	; 1
    253e:	70 e0       	ldi	r23, 0x00	; 0
    2540:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
				xEventGroupSetBits(egEvents, E_AlarmScreen); /* for T_Display Task */
    2544:	80 91 a2 01 	lds	r24, 0x01A2
    2548:	90 91 a3 01 	lds	r25, 0x01A3
    254c:	68 e0       	ldi	r22, 0x08	; 8
    254e:	70 e0       	ldi	r23, 0x00	; 0
    2550:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
    2554:	d1 cf       	rjmp	.-94     	; 0x24f8 <T_SysCheck+0x26>
			}
			else if( TAS.SystemState == AlarmState &&
    2556:	80 91 0b 07 	lds	r24, 0x070B
    255a:	82 30       	cpi	r24, 0x02	; 2
    255c:	29 f5       	brne	.+74     	; 0x25a8 <T_SysCheck+0xd6>
    255e:	90 91 0c 07 	lds	r25, 0x070C
    2562:	80 91 0d 07 	lds	r24, 0x070D
    2566:	98 17       	cp	r25, r24
    2568:	20 f0       	brcs	.+8      	; 0x2572 <T_SysCheck+0xa0>
    256a:	80 91 0e 07 	lds	r24, 0x070E
    256e:	88 23       	and	r24, r24
    2570:	d9 f4       	brne	.+54     	; 0x25a8 <T_SysCheck+0xd6>
					 (TAS.CTemp < TAS.TTemp || TAS.AS == DISABLED) )
			{			/* if we are in alarm screen AND ( temp is below  threshold or Alarming disabled*/
				//usart_puts("condition2 \r\n");
				TAS.SystemState = MainState;	/* to display the main screen when T_Display is called*/
    2572:	10 92 0b 07 	sts	0x070B, r1
				xEventGroupClearBits(egEvents, E_Alarm); /* disable the Alarm */
    2576:	80 91 a2 01 	lds	r24, 0x01A2
    257a:	90 91 a3 01 	lds	r25, 0x01A3
    257e:	61 e0       	ldi	r22, 0x01	; 1
    2580:	70 e0       	ldi	r23, 0x00	; 0
    2582:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <xEventGroupClearBits>

				/* for T_Display Task */
				xEventGroupSetBits(egEvents, E_MainScreen 	| E_CTempUpdated);
    2586:	80 91 a2 01 	lds	r24, 0x01A2
    258a:	90 91 a3 01 	lds	r25, 0x01A3
    258e:	62 e1       	ldi	r22, 0x12	; 18
    2590:	70 e0       	ldi	r23, 0x00	; 0
    2592:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
				xEventGroupSetBits(egEvents, E_TTempUpdated | E_ASUpdated);
    2596:	80 91 a2 01 	lds	r24, 0x01A2
    259a:	90 91 a3 01 	lds	r25, 0x01A3
    259e:	60 e6       	ldi	r22, 0x60	; 96
    25a0:	70 e0       	ldi	r23, 0x00	; 0
    25a2:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
    25a6:	a8 cf       	rjmp	.-176    	; 0x24f8 <T_SysCheck+0x26>

			}
			else
			{	/* the cpu is  not supposed to reach this condition, but it just to make sure */
				//usart_puts("condition else \r\n");
				xEventGroupClearBits(egEvents, E_Alarm); /* disable the Alarm */
    25a8:	80 91 a2 01 	lds	r24, 0x01A2
    25ac:	90 91 a3 01 	lds	r25, 0x01A3
    25b0:	61 e0       	ldi	r22, 0x01	; 1
    25b2:	70 e0       	ldi	r23, 0x00	; 0
    25b4:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <xEventGroupClearBits>
    25b8:	9f cf       	rjmp	.-194    	; 0x24f8 <T_SysCheck+0x26>

000025ba <T_Terminal>:
	u8 strTTemp[4];
	u8 i;
}g_temp_TTemp;

void T_Terminal(void* pvParam)
{
    25ba:	df 93       	push	r29
    25bc:	cf 93       	push	r28
    25be:	cd b7       	in	r28, 0x3d	; 61
    25c0:	de b7       	in	r29, 0x3e	; 62
    25c2:	28 97       	sbiw	r28, 0x08	; 8
    25c4:	0f b6       	in	r0, 0x3f	; 63
    25c6:	f8 94       	cli
    25c8:	de bf       	out	0x3e, r29	; 62
    25ca:	0f be       	out	0x3f, r0	; 63
    25cc:	cd bf       	out	0x3d, r28	; 61
    25ce:	98 87       	std	Y+8, r25	; 0x08
    25d0:	8f 83       	std	Y+7, r24	; 0x07
	usart_puts("T_Terminal started ...\r\n");
    25d2:	8d e9       	ldi	r24, 0x9D	; 157
    25d4:	90 e0       	ldi	r25, 0x00	; 0
    25d6:	0e 94 0a 0a 	call	0x1414	; 0x1414 <usart_puts>
	u8 data;
	u8 strTTemp[4];
	memset(strTTemp, 0, 3);
    25da:	ce 01       	movw	r24, r28
    25dc:	03 96       	adiw	r24, 0x03	; 3
    25de:	60 e0       	ldi	r22, 0x00	; 0
    25e0:	70 e0       	ldi	r23, 0x00	; 0
    25e2:	43 e0       	ldi	r20, 0x03	; 3
    25e4:	50 e0       	ldi	r21, 0x00	; 0
    25e6:	0e 94 2b 33 	call	0x6656	; 0x6656 <memset>
	u8 i = 0;
    25ea:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		//usart_puts("Running T_Terminal\r\n");

		if(E_OK == usart_getc_NonBlocking(&data))	/* New data exist */
    25ec:	ce 01       	movw	r24, r28
    25ee:	02 96       	adiw	r24, 0x02	; 2
    25f0:	0e 94 d5 09 	call	0x13aa	; 0x13aa <usart_getc_NonBlocking>
    25f4:	88 23       	and	r24, r24
    25f6:	09 f0       	breq	.+2      	; 0x25fa <T_Terminal+0x40>
    25f8:	ca c0       	rjmp	.+404    	; 0x278e <T_Terminal+0x1d4>
		{
			if(TAS.SystemState == MainState)
    25fa:	80 91 0b 07 	lds	r24, 0x070B
    25fe:	88 23       	and	r24, r24
    2600:	89 f5       	brne	.+98     	; 0x2664 <T_Terminal+0xaa>
			{
				/* if( MainState is the current)*/
				if(data == 'C')
    2602:	8a 81       	ldd	r24, Y+2	; 0x02
    2604:	83 34       	cpi	r24, 0x43	; 67
    2606:	61 f4       	brne	.+24     	; 0x2620 <T_Terminal+0x66>
				{
					TAS.SystemState = ConfigState;
    2608:	81 e0       	ldi	r24, 0x01	; 1
    260a:	80 93 0b 07 	sts	0x070B, r24
					xEventGroupSetBits(egEvents, E_ConfigScreen);
    260e:	80 91 a2 01 	lds	r24, 0x01A2
    2612:	90 91 a3 01 	lds	r25, 0x01A3
    2616:	64 e0       	ldi	r22, 0x04	; 4
    2618:	70 e0       	ldi	r23, 0x00	; 0
    261a:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
    261e:	b7 c0       	rjmp	.+366    	; 0x278e <T_Terminal+0x1d4>
				}
				else if(data == 'T')
    2620:	8a 81       	ldd	r24, Y+2	; 0x02
    2622:	84 35       	cpi	r24, 0x54	; 84
    2624:	09 f0       	breq	.+2      	; 0x2628 <T_Terminal+0x6e>
    2626:	b3 c0       	rjmp	.+358    	; 0x278e <T_Terminal+0x1d4>
				{
					/*************************************/
					/* Toggle the AlarmState (between on Enabled and disabled)*/
					TAS.AS ^= 1;
    2628:	90 91 0e 07 	lds	r25, 0x070E
    262c:	81 e0       	ldi	r24, 0x01	; 1
    262e:	89 27       	eor	r24, r25
    2630:	80 93 0e 07 	sts	0x070E, r24
					//usart_puts("\r\nTAS.AS = "); /* DEBUG */
					//usart_putc(TAS.AS + 48); /* DEBUG */
					//usart_puts("\r\n"); /* DEBUG */
					vTaskDelay(200); /* DEBUG */
    2634:	88 ec       	ldi	r24, 0xC8	; 200
    2636:	90 e0       	ldi	r25, 0x00	; 0
    2638:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <vTaskDelay>
					xEventGroupSetBits(egEvents, E_ASUpdated);	/* to trigger display task and  update the Alarm state*/
    263c:	80 91 a2 01 	lds	r24, 0x01A2
    2640:	90 91 a3 01 	lds	r25, 0x01A3
    2644:	60 e4       	ldi	r22, 0x40	; 64
    2646:	70 e0       	ldi	r23, 0x00	; 0
    2648:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
					xSemaphoreGive(bsCheck);	/* to trigger T_SysCheck task to update the T_Alarm task state */
    264c:	80 91 04 07 	lds	r24, 0x0704
    2650:	90 91 05 07 	lds	r25, 0x0705
    2654:	60 e0       	ldi	r22, 0x00	; 0
    2656:	70 e0       	ldi	r23, 0x00	; 0
    2658:	40 e0       	ldi	r20, 0x00	; 0
    265a:	50 e0       	ldi	r21, 0x00	; 0
    265c:	20 e0       	ldi	r18, 0x00	; 0
    265e:	0e 94 39 23 	call	0x4672	; 0x4672 <xQueueGenericSend>
    2662:	95 c0       	rjmp	.+298    	; 0x278e <T_Terminal+0x1d4>
				}
			}	/*end if( MainState is the current)*/

			else if(TAS.SystemState == ConfigState)
    2664:	80 91 0b 07 	lds	r24, 0x070B
    2668:	81 30       	cpi	r24, 0x01	; 1
    266a:	09 f0       	breq	.+2      	; 0x266e <T_Terminal+0xb4>
    266c:	74 c0       	rjmp	.+232    	; 0x2756 <T_Terminal+0x19c>
			{/* if( ConfigState is the current)*/
				if( data >= '0' && data <= '9')
    266e:	8a 81       	ldd	r24, Y+2	; 0x02
    2670:	80 33       	cpi	r24, 0x30	; 48
    2672:	98 f1       	brcs	.+102    	; 0x26da <T_Terminal+0x120>
    2674:	8a 81       	ldd	r24, Y+2	; 0x02
    2676:	8a 33       	cpi	r24, 0x3A	; 58
    2678:	80 f5       	brcc	.+96     	; 0x26da <T_Terminal+0x120>
				{
					/* if the data is a digit */
					strTTemp[i] = data;
    267a:	89 81       	ldd	r24, Y+1	; 0x01
    267c:	28 2f       	mov	r18, r24
    267e:	30 e0       	ldi	r19, 0x00	; 0
    2680:	4a 81       	ldd	r20, Y+2	; 0x02
    2682:	ce 01       	movw	r24, r28
    2684:	03 96       	adiw	r24, 0x03	; 3
    2686:	fc 01       	movw	r30, r24
    2688:	e2 0f       	add	r30, r18
    268a:	f3 1f       	adc	r31, r19
    268c:	40 83       	st	Z, r20
					i++;
    268e:	89 81       	ldd	r24, Y+1	; 0x01
    2690:	8f 5f       	subi	r24, 0xFF	; 255
    2692:	89 83       	std	Y+1, r24	; 0x01

					/* make data ready for display task, just a copy */
					memset( g_temp_TTemp.strTTemp, strTTemp, 3);
    2694:	9e 01       	movw	r18, r28
    2696:	2d 5f       	subi	r18, 0xFD	; 253
    2698:	3f 4f       	sbci	r19, 0xFF	; 255
    269a:	86 e0       	ldi	r24, 0x06	; 6
    269c:	97 e0       	ldi	r25, 0x07	; 7
    269e:	b9 01       	movw	r22, r18
    26a0:	43 e0       	ldi	r20, 0x03	; 3
    26a2:	50 e0       	ldi	r21, 0x00	; 0
    26a4:	0e 94 2b 33 	call	0x6656	; 0x6656 <memset>
					g_temp_TTemp.i = i;
    26a8:	89 81       	ldd	r24, Y+1	; 0x01
    26aa:	80 93 0a 07 	sts	0x070A, r24

					xEventGroupSetBits(egEvents, E_TConfigUpdated);	/* to trigger the Display task*/
    26ae:	80 91 a2 01 	lds	r24, 0x01A2
    26b2:	90 91 a3 01 	lds	r25, 0x01A3
    26b6:	60 e8       	ldi	r22, 0x80	; 128
    26b8:	70 e0       	ldi	r23, 0x00	; 0
    26ba:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>

					if(i > 2)
    26be:	89 81       	ldd	r24, Y+1	; 0x01
    26c0:	83 30       	cpi	r24, 0x03	; 3
    26c2:	08 f4       	brcc	.+2      	; 0x26c6 <T_Terminal+0x10c>
    26c4:	64 c0       	rjmp	.+200    	; 0x278e <T_Terminal+0x1d4>
					{
						/* if the last stored data is the third digit*/
						i = 0;
    26c6:	19 82       	std	Y+1, r1	; 0x01
						xEventGroupSetBits(egEvents, E_TTempUpdated);	/* to trigger the Display task*/
    26c8:	80 91 a2 01 	lds	r24, 0x01A2
    26cc:	90 91 a3 01 	lds	r25, 0x01A3
    26d0:	60 e2       	ldi	r22, 0x20	; 32
    26d2:	70 e0       	ldi	r23, 0x00	; 0
    26d4:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
    26d8:	5a c0       	rjmp	.+180    	; 0x278e <T_Terminal+0x1d4>
					}
				}/* end if the data is a digit */
				else if(data == 'O')
    26da:	8a 81       	ldd	r24, Y+2	; 0x02
    26dc:	8f 34       	cpi	r24, 0x4F	; 79
    26de:	29 f5       	brne	.+74     	; 0x272a <T_Terminal+0x170>
				{/* if data is O (OK) */
					TAS.TTemp = atoi(strTTemp);	/* Set the global threshold with local from terminal*/
    26e0:	ce 01       	movw	r24, r28
    26e2:	03 96       	adiw	r24, 0x03	; 3
    26e4:	0e 94 04 33 	call	0x6608	; 0x6608 <atoi>
    26e8:	80 93 0d 07 	sts	0x070D, r24
					TAS.SystemState = MainState; /* we done configure hence done with congigure screen*/
    26ec:	10 92 0b 07 	sts	0x070B, r1
					xSemaphoreGive(bsCheck); /* to trigger T_SysCheck to update the alarm state based on new threshold from terminal*/
    26f0:	80 91 04 07 	lds	r24, 0x0704
    26f4:	90 91 05 07 	lds	r25, 0x0705
    26f8:	60 e0       	ldi	r22, 0x00	; 0
    26fa:	70 e0       	ldi	r23, 0x00	; 0
    26fc:	40 e0       	ldi	r20, 0x00	; 0
    26fe:	50 e0       	ldi	r21, 0x00	; 0
    2700:	20 e0       	ldi	r18, 0x00	; 0
    2702:	0e 94 39 23 	call	0x4672	; 0x4672 <xQueueGenericSend>

					/* For display task */
					xEventGroupSetBits(egEvents, E_MainScreen 	| E_CTempUpdated);
    2706:	80 91 a2 01 	lds	r24, 0x01A2
    270a:	90 91 a3 01 	lds	r25, 0x01A3
    270e:	62 e1       	ldi	r22, 0x12	; 18
    2710:	70 e0       	ldi	r23, 0x00	; 0
    2712:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
					xEventGroupSetBits(egEvents, E_TTempUpdated | E_ASUpdated);
    2716:	80 91 a2 01 	lds	r24, 0x01A2
    271a:	90 91 a3 01 	lds	r25, 0x01A3
    271e:	60 e6       	ldi	r22, 0x60	; 96
    2720:	70 e0       	ldi	r23, 0x00	; 0
    2722:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>

					i = 0;	/* when OK, we finished storing digit hence clear index for next time */
    2726:	19 82       	std	Y+1, r1	; 0x01
    2728:	32 c0       	rjmp	.+100    	; 0x278e <T_Terminal+0x1d4>
				}/* end if data is O (OK) */
				else if(data == 'C')
    272a:	8a 81       	ldd	r24, Y+2	; 0x02
    272c:	83 34       	cpi	r24, 0x43	; 67
    272e:	79 f5       	brne	.+94     	; 0x278e <T_Terminal+0x1d4>
				{/* if data is C (Cancel) */
					TAS.SystemState = MainState; /* we done configure hence done with congigure screen*/
    2730:	10 92 0b 07 	sts	0x070B, r1
					/* For display task */
					xEventGroupSetBits(egEvents, E_MainScreen 	| E_CTempUpdated);
    2734:	80 91 a2 01 	lds	r24, 0x01A2
    2738:	90 91 a3 01 	lds	r25, 0x01A3
    273c:	62 e1       	ldi	r22, 0x12	; 18
    273e:	70 e0       	ldi	r23, 0x00	; 0
    2740:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
					xEventGroupSetBits(egEvents, E_TTempUpdated | E_ASUpdated);
    2744:	80 91 a2 01 	lds	r24, 0x01A2
    2748:	90 91 a3 01 	lds	r25, 0x01A3
    274c:	60 e6       	ldi	r22, 0x60	; 96
    274e:	70 e0       	ldi	r23, 0x00	; 0
    2750:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
    2754:	1c c0       	rjmp	.+56     	; 0x278e <T_Terminal+0x1d4>
				}/* end if data is C (Cancel) */

			}/*end if( ConfigState is the current)*/
			else if(TAS.SystemState == AlarmState)
    2756:	80 91 0b 07 	lds	r24, 0x070B
    275a:	82 30       	cpi	r24, 0x02	; 2
    275c:	c1 f4       	brne	.+48     	; 0x278e <T_Terminal+0x1d4>
			{/* if( AlarmState is the current)*/
				if(data == 'S')
    275e:	8a 81       	ldd	r24, Y+2	; 0x02
    2760:	83 35       	cpi	r24, 0x53	; 83
    2762:	a9 f4       	brne	.+42     	; 0x278e <T_Terminal+0x1d4>
				{
					TAS.AS = DISABLED;	/* disable AlarmState to disable the Alarm */
    2764:	10 92 0e 07 	sts	0x070E, r1
					xSemaphoreGive(bsCheck); 	/* to trigger T_SysCheck to update T_Alarm */
    2768:	80 91 04 07 	lds	r24, 0x0704
    276c:	90 91 05 07 	lds	r25, 0x0705
    2770:	60 e0       	ldi	r22, 0x00	; 0
    2772:	70 e0       	ldi	r23, 0x00	; 0
    2774:	40 e0       	ldi	r20, 0x00	; 0
    2776:	50 e0       	ldi	r21, 0x00	; 0
    2778:	20 e0       	ldi	r18, 0x00	; 0
    277a:	0e 94 39 23 	call	0x4672	; 0x4672 <xQueueGenericSend>
					xEventGroupSetBits(egEvents, E_MainScreen);	/* to trigger the Display task*/
    277e:	80 91 a2 01 	lds	r24, 0x01A2
    2782:	90 91 a3 01 	lds	r25, 0x01A3
    2786:	62 e0       	ldi	r22, 0x02	; 2
    2788:	70 e0       	ldi	r23, 0x00	; 0
    278a:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
		else
		{
			/* if No new data exist */
			/* exit */
		}
		vTaskDelay(50);  /* Task periodicity is 50ms */
    278e:	82 e3       	ldi	r24, 0x32	; 50
    2790:	90 e0       	ldi	r25, 0x00	; 0
    2792:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <vTaskDelay>
    2796:	2a cf       	rjmp	.-428    	; 0x25ec <T_Terminal+0x32>

00002798 <T_CTemp>:
	return E_OK;
}
#endif

void T_CTemp(void* pvParam)
{
    2798:	df 93       	push	r29
    279a:	cf 93       	push	r28
    279c:	00 d0       	rcall	.+0      	; 0x279e <T_CTemp+0x6>
    279e:	00 d0       	rcall	.+0      	; 0x27a0 <T_CTemp+0x8>
    27a0:	0f 92       	push	r0
    27a2:	cd b7       	in	r28, 0x3d	; 61
    27a4:	de b7       	in	r29, 0x3e	; 62
    27a6:	9d 83       	std	Y+5, r25	; 0x05
    27a8:	8c 83       	std	Y+4, r24	; 0x04
	usart_puts("T_CTemp started ...\r\n");
    27aa:	86 eb       	ldi	r24, 0xB6	; 182
    27ac:	90 e0       	ldi	r25, 0x00	; 0
    27ae:	0e 94 0a 0a 	call	0x1414	; 0x1414 <usart_puts>
	u16 ADCData = 0; /* 0V >> 5V*/	/* 0C >> 50C */
    27b2:	1b 82       	std	Y+3, r1	; 0x03
    27b4:	1a 82       	std	Y+2, r1	; 0x02
	u8 NewTemp = ADCData * 10 ;	/* Fake Temp */
    27b6:	8a 81       	ldd	r24, Y+2	; 0x02
    27b8:	9b 81       	ldd	r25, Y+3	; 0x03
    27ba:	9c 01       	movw	r18, r24
    27bc:	22 0f       	add	r18, r18
    27be:	33 1f       	adc	r19, r19
    27c0:	c9 01       	movw	r24, r18
    27c2:	88 0f       	add	r24, r24
    27c4:	99 1f       	adc	r25, r25
    27c6:	88 0f       	add	r24, r24
    27c8:	99 1f       	adc	r25, r25
    27ca:	82 0f       	add	r24, r18
    27cc:	93 1f       	adc	r25, r19
    27ce:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{

		//if(E_OK == ADC_u16GetDigitalValue_NonBlocking(0, &ADCData))	/*if reaady, read from channel zero to ADCData */
		//if(E_OK == ADC_u16GetDigitalValue_NonBlockingFAKE(0, &ADCData))	/* FAKE */
		ADCData = ADC_u16GetDigitalValue(0);
    27d0:	80 e0       	ldi	r24, 0x00	; 0
    27d2:	0e 94 db 05 	call	0xbb6	; 0xbb6 <ADC_u16GetDigitalValue>
    27d6:	9b 83       	std	Y+3, r25	; 0x03
    27d8:	8a 83       	std	Y+2, r24	; 0x02
		ADCData = (ADCData*50) / 1024;
    27da:	2a 81       	ldd	r18, Y+2	; 0x02
    27dc:	3b 81       	ldd	r19, Y+3	; 0x03
    27de:	82 e3       	ldi	r24, 0x32	; 50
    27e0:	90 e0       	ldi	r25, 0x00	; 0
    27e2:	ac 01       	movw	r20, r24
    27e4:	24 9f       	mul	r18, r20
    27e6:	c0 01       	movw	r24, r0
    27e8:	25 9f       	mul	r18, r21
    27ea:	90 0d       	add	r25, r0
    27ec:	34 9f       	mul	r19, r20
    27ee:	90 0d       	add	r25, r0
    27f0:	11 24       	eor	r1, r1
    27f2:	89 2f       	mov	r24, r25
    27f4:	99 27       	eor	r25, r25
    27f6:	86 95       	lsr	r24
    27f8:	86 95       	lsr	r24
    27fa:	9b 83       	std	Y+3, r25	; 0x03
    27fc:	8a 83       	std	Y+2, r24	; 0x02

#if 1

			//usart_puts("Running T_CTemp\r\n");

			NewTemp = ADCData  ;	/* (Fake Temp) */
    27fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2800:	89 83       	std	Y+1, r24	; 0x01
			//usart_putc(ADCData + 48);
			//usart_puts("\r\n");



			if( NewTemp != TAS.CTemp )	/* if the new readed temp is not the already stored in the system*/
    2802:	90 91 0c 07 	lds	r25, 0x070C
    2806:	89 81       	ldd	r24, Y+1	; 0x01
    2808:	98 17       	cp	r25, r24
    280a:	d1 f0       	breq	.+52     	; 0x2840 <T_CTemp+0xa8>
			{
				TAS.CTemp = NewTemp;
    280c:	89 81       	ldd	r24, Y+1	; 0x01
    280e:	80 93 0c 07 	sts	0x070C, r24
				xSemaphoreGive(bsCheck); /* to trigger T_SysCheck to update T_Alarm based on new Temp*/
    2812:	80 91 04 07 	lds	r24, 0x0704
    2816:	90 91 05 07 	lds	r25, 0x0705
    281a:	60 e0       	ldi	r22, 0x00	; 0
    281c:	70 e0       	ldi	r23, 0x00	; 0
    281e:	40 e0       	ldi	r20, 0x00	; 0
    2820:	50 e0       	ldi	r21, 0x00	; 0
    2822:	20 e0       	ldi	r18, 0x00	; 0
    2824:	0e 94 39 23 	call	0x4672	; 0x4672 <xQueueGenericSend>
				if(TAS.SystemState == MainState)
    2828:	80 91 0b 07 	lds	r24, 0x070B
    282c:	88 23       	and	r24, r24
    282e:	41 f4       	brne	.+16     	; 0x2840 <T_CTemp+0xa8>
				{/* if the current state is Main*/
					xEventGroupSetBits(egEvents, E_TTempUpdated);	/* to update display */
    2830:	80 91 a2 01 	lds	r24, 0x01A2
    2834:	90 91 a3 01 	lds	r25, 0x01A3
    2838:	60 e2       	ldi	r22, 0x20	; 32
    283a:	70 e0       	ldi	r23, 0x00	; 0
    283c:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
			}
#endif

		}

		vTaskDelay(200);  	/* Task periodicity is 100ms */
    2840:	88 ec       	ldi	r24, 0xC8	; 200
    2842:	90 e0       	ldi	r25, 0x00	; 0
    2844:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <vTaskDelay>
    2848:	c3 cf       	rjmp	.-122    	; 0x27d0 <T_CTemp+0x38>

0000284a <T_Display>:
static void	Private_UpdateAS(void);
static void	Private_UpdateTTempConfig(void);


void T_Display(void* pvParam)
{
    284a:	0f 93       	push	r16
    284c:	1f 93       	push	r17
    284e:	df 93       	push	r29
    2850:	cf 93       	push	r28
    2852:	00 d0       	rcall	.+0      	; 0x2854 <T_Display+0xa>
    2854:	cd b7       	in	r28, 0x3d	; 61
    2856:	de b7       	in	r29, 0x3e	; 62
    2858:	9a 83       	std	Y+2, r25	; 0x02
    285a:	89 83       	std	Y+1, r24	; 0x01
	usart_puts("T_Display started ...\r\n");
    285c:	8c ec       	ldi	r24, 0xCC	; 204
    285e:	90 e0       	ldi	r25, 0x00	; 0
    2860:	0e 94 0a 0a 	call	0x1414	; 0x1414 <usart_puts>

	while(1)
	{
		//usart_puts("Running T_Display\r\n");
		ebBits = xEventGroupWaitBits(egEvents, E_MainScreen | E_ConfigScreen |
    2864:	80 91 a2 01 	lds	r24, 0x01A2
    2868:	90 91 a3 01 	lds	r25, 0x01A3
    286c:	6e ef       	ldi	r22, 0xFE	; 254
    286e:	70 e0       	ldi	r23, 0x00	; 0
    2870:	41 e0       	ldi	r20, 0x01	; 1
    2872:	20 e0       	ldi	r18, 0x00	; 0
    2874:	0f ef       	ldi	r16, 0xFF	; 255
    2876:	1f ef       	ldi	r17, 0xFF	; 255
    2878:	0e 94 26 1a 	call	0x344c	; 0x344c <xEventGroupWaitBits>
    287c:	90 93 03 07 	sts	0x0703, r25
    2880:	80 93 02 07 	sts	0x0702, r24
									  0,
									  portMAX_DELAY);

		//usart_puts("\r\n exit Waiting event \r\n");

		if( (ebBits&E_MainScreen) == E_MainScreen )
    2884:	80 91 02 07 	lds	r24, 0x0702
    2888:	90 91 03 07 	lds	r25, 0x0703
    288c:	82 70       	andi	r24, 0x02	; 2
    288e:	90 70       	andi	r25, 0x00	; 0
    2890:	00 97       	sbiw	r24, 0x00	; 0
    2892:	19 f0       	breq	.+6      	; 0x289a <T_Display+0x50>
		{
			Private_DisplayMainScreen();
    2894:	0e 94 a7 14 	call	0x294e	; 0x294e <Private_DisplayMainScreen>
    2898:	e5 cf       	rjmp	.-54     	; 0x2864 <T_Display+0x1a>
		}
		else if( (ebBits&E_ConfigScreen) == E_ConfigScreen )
    289a:	80 91 02 07 	lds	r24, 0x0702
    289e:	90 91 03 07 	lds	r25, 0x0703
    28a2:	84 70       	andi	r24, 0x04	; 4
    28a4:	90 70       	andi	r25, 0x00	; 0
    28a6:	00 97       	sbiw	r24, 0x00	; 0
    28a8:	19 f0       	breq	.+6      	; 0x28b0 <T_Display+0x66>
		{
			Private_DisplayConfigScreen();
    28aa:	0e 94 e4 14 	call	0x29c8	; 0x29c8 <Private_DisplayConfigScreen>
    28ae:	da cf       	rjmp	.-76     	; 0x2864 <T_Display+0x1a>
		}
		else if( (ebBits&E_AlarmScreen) == E_AlarmScreen )
    28b0:	80 91 02 07 	lds	r24, 0x0702
    28b4:	90 91 03 07 	lds	r25, 0x0703
    28b8:	88 70       	andi	r24, 0x08	; 8
    28ba:	90 70       	andi	r25, 0x00	; 0
    28bc:	00 97       	sbiw	r24, 0x00	; 0
    28be:	19 f0       	breq	.+6      	; 0x28c6 <T_Display+0x7c>
		{
			Private_DisplayAlarmScreen();
    28c0:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <Private_DisplayAlarmScreen>
    28c4:	cf cf       	rjmp	.-98     	; 0x2864 <T_Display+0x1a>
		}
		else if( (ebBits&E_CTempUpdated) == E_CTempUpdated )
    28c6:	80 91 02 07 	lds	r24, 0x0702
    28ca:	90 91 03 07 	lds	r25, 0x0703
    28ce:	80 71       	andi	r24, 0x10	; 16
    28d0:	90 70       	andi	r25, 0x00	; 0
    28d2:	00 97       	sbiw	r24, 0x00	; 0
    28d4:	19 f0       	breq	.+6      	; 0x28dc <T_Display+0x92>
		{
			Private_UpdateCTemp();
    28d6:	0e 94 10 15 	call	0x2a20	; 0x2a20 <Private_UpdateCTemp>
    28da:	c4 cf       	rjmp	.-120    	; 0x2864 <T_Display+0x1a>
		}
		else if( (ebBits&E_TTempUpdated) == E_TTempUpdated )
    28dc:	80 91 02 07 	lds	r24, 0x0702
    28e0:	90 91 03 07 	lds	r25, 0x0703
    28e4:	80 72       	andi	r24, 0x20	; 32
    28e6:	90 70       	andi	r25, 0x00	; 0
    28e8:	00 97       	sbiw	r24, 0x00	; 0
    28ea:	19 f0       	breq	.+6      	; 0x28f2 <T_Display+0xa8>
		{
			Private_UpdateTTemp();
    28ec:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <Private_UpdateTTemp>
    28f0:	b9 cf       	rjmp	.-142    	; 0x2864 <T_Display+0x1a>
		}
		else if( (ebBits&E_ASUpdated) == E_ASUpdated )
    28f2:	80 91 02 07 	lds	r24, 0x0702
    28f6:	90 91 03 07 	lds	r25, 0x0703
    28fa:	80 74       	andi	r24, 0x40	; 64
    28fc:	90 70       	andi	r25, 0x00	; 0
    28fe:	00 97       	sbiw	r24, 0x00	; 0
    2900:	09 f4       	brne	.+2      	; 0x2904 <T_Display+0xba>
    2902:	b0 cf       	rjmp	.-160    	; 0x2864 <T_Display+0x1a>
		{
			Private_UpdateAS();
    2904:	0e 94 5e 15 	call	0x2abc	; 0x2abc <Private_UpdateAS>
    2908:	ad cf       	rjmp	.-166    	; 0x2864 <T_Display+0x1a>

0000290a <System_Init>:

	}
}

void System_Init(void)
{
    290a:	df 93       	push	r29
    290c:	cf 93       	push	r28
    290e:	cd b7       	in	r28, 0x3d	; 61
    2910:	de b7       	in	r29, 0x3e	; 62

	/*initial system parameters*/
	TAS.SystemState = MainState;
    2912:	10 92 0b 07 	sts	0x070B, r1
	TAS.AS = ENABLED;
    2916:	81 e0       	ldi	r24, 0x01	; 1
    2918:	80 93 0e 07 	sts	0x070E, r24
	TAS.CTemp = 0;
    291c:	10 92 0c 07 	sts	0x070C, r1
	TAS.TTemp = 30;
    2920:	8e e1       	ldi	r24, 0x1E	; 30
    2922:	80 93 0d 07 	sts	0x070D, r24

	/* lcd init */
	LCD_vidInit();
    2926:	0e 94 35 0a 	call	0x146a	; 0x146a <LCD_vidInit>

	/* ADC init */
	ADC_voidInit();
    292a:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADC_voidInit>

	/**/
	DIO_voidSetPinDirection(DIO_u8_PORTD, DIO_u8_PIN2, DIO_u8_OUTPUT);
    292e:	83 e0       	ldi	r24, 0x03	; 3
    2930:	62 e0       	ldi	r22, 0x02	; 2
    2932:	41 e0       	ldi	r20, 0x01	; 1
    2934:	0e 94 f6 07 	call	0xfec	; 0xfec <DIO_voidSetPinDirection>


	/* uart init*/
	usart_init(9600);
    2938:	80 e8       	ldi	r24, 0x80	; 128
    293a:	95 e2       	ldi	r25, 0x25	; 37
    293c:	0e 94 80 09 	call	0x1300	; 0x1300 <usart_init>
	usart_puts("System started\r\n");
    2940:	84 ee       	ldi	r24, 0xE4	; 228
    2942:	90 e0       	ldi	r25, 0x00	; 0
    2944:	0e 94 0a 0a 	call	0x1414	; 0x1414 <usart_puts>

}
    2948:	cf 91       	pop	r28
    294a:	df 91       	pop	r29
    294c:	08 95       	ret

0000294e <Private_DisplayMainScreen>:



/* private to T_Display task */
static void	Private_DisplayMainScreen(void)
{
    294e:	df 93       	push	r29
    2950:	cf 93       	push	r28
    2952:	cd b7       	in	r28, 0x3d	; 61
    2954:	de b7       	in	r29, 0x3e	; 62
	LCD_vidSendCommand(lcd_Clear);
    2956:	81 e0       	ldi	r24, 0x01	; 1
    2958:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_vidSendCommand>
	LCD_vidWriteString("C:");
    295c:	85 ef       	ldi	r24, 0xF5	; 245
    295e:	90 e0       	ldi	r25, 0x00	; 0
    2960:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	LCD_vidWriteNumber(TAS.CTemp);
    2964:	80 91 0c 07 	lds	r24, 0x070C
    2968:	88 2f       	mov	r24, r24
    296a:	90 e0       	ldi	r25, 0x00	; 0
    296c:	0e 94 1a 11 	call	0x2234	; 0x2234 <LCD_vidWriteNumber>
	LCD_vidWriteString("  ");
    2970:	88 ef       	ldi	r24, 0xF8	; 248
    2972:	90 e0       	ldi	r25, 0x00	; 0
    2974:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	LCD_vidWriteString("T:");
    2978:	8b ef       	ldi	r24, 0xFB	; 251
    297a:	90 e0       	ldi	r25, 0x00	; 0
    297c:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	LCD_vidWriteNumber(TAS.TTemp);
    2980:	80 91 0d 07 	lds	r24, 0x070D
    2984:	88 2f       	mov	r24, r24
    2986:	90 e0       	ldi	r25, 0x00	; 0
    2988:	0e 94 1a 11 	call	0x2234	; 0x2234 <LCD_vidWriteNumber>
	LCD_vidWriteString("  ");
    298c:	88 ef       	ldi	r24, 0xF8	; 248
    298e:	90 e0       	ldi	r25, 0x00	; 0
    2990:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	LCD_vidWriteString("AS:");
    2994:	8e ef       	ldi	r24, 0xFE	; 254
    2996:	90 e0       	ldi	r25, 0x00	; 0
    2998:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	if(TAS.AS) /* 1 >> enabled */
    299c:	80 91 0e 07 	lds	r24, 0x070E
    29a0:	88 23       	and	r24, r24
    29a2:	21 f0       	breq	.+8      	; 0x29ac <Private_DisplayMainScreen+0x5e>
	{
		LCD_vidWriteCharctr('E');
    29a4:	85 e4       	ldi	r24, 0x45	; 69
    29a6:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <LCD_vidWriteCharctr>
    29aa:	03 c0       	rjmp	.+6      	; 0x29b2 <Private_DisplayMainScreen+0x64>
	}
	else
	{
		LCD_vidWriteCharctr('D');
    29ac:	84 e4       	ldi	r24, 0x44	; 68
    29ae:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <LCD_vidWriteCharctr>
	}
	LCD_vidGotoxy(2,4);
    29b2:	82 e0       	ldi	r24, 0x02	; 2
    29b4:	64 e0       	ldi	r22, 0x04	; 4
    29b6:	0e 94 3e 10 	call	0x207c	; 0x207c <LCD_vidGotoxy>
	LCD_vidWriteString("TC:C   AST:T");
    29ba:	82 e0       	ldi	r24, 0x02	; 2
    29bc:	91 e0       	ldi	r25, 0x01	; 1
    29be:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>

}
    29c2:	cf 91       	pop	r28
    29c4:	df 91       	pop	r29
    29c6:	08 95       	ret

000029c8 <Private_DisplayConfigScreen>:
static void	Private_DisplayConfigScreen(void)
{
    29c8:	df 93       	push	r29
    29ca:	cf 93       	push	r28
    29cc:	cd b7       	in	r28, 0x3d	; 61
    29ce:	de b7       	in	r29, 0x3e	; 62
	LCD_vidSendCommand(lcd_Clear);
    29d0:	81 e0       	ldi	r24, 0x01	; 1
    29d2:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_vidSendCommand>
	LCD_vidWriteString("    T:");
    29d6:	8f e0       	ldi	r24, 0x0F	; 15
    29d8:	91 e0       	ldi	r25, 0x01	; 1
    29da:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	LCD_vidGotoxy(2,2);
    29de:	82 e0       	ldi	r24, 0x02	; 2
    29e0:	62 e0       	ldi	r22, 0x02	; 2
    29e2:	0e 94 3e 10 	call	0x207c	; 0x207c <LCD_vidGotoxy>
	LCD_vidWriteString("OK:O    Canc:C");
    29e6:	86 e1       	ldi	r24, 0x16	; 22
    29e8:	91 e0       	ldi	r25, 0x01	; 1
    29ea:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>

}
    29ee:	cf 91       	pop	r28
    29f0:	df 91       	pop	r29
    29f2:	08 95       	ret

000029f4 <Private_DisplayAlarmScreen>:
static void	Private_DisplayAlarmScreen(void)
{
    29f4:	df 93       	push	r29
    29f6:	cf 93       	push	r28
    29f8:	cd b7       	in	r28, 0x3d	; 61
    29fa:	de b7       	in	r29, 0x3e	; 62
	LCD_vidSendCommand(lcd_Clear);
    29fc:	81 e0       	ldi	r24, 0x01	; 1
    29fe:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_vidSendCommand>
	LCD_vidWriteString("ALARMING!!");
    2a02:	85 e2       	ldi	r24, 0x25	; 37
    2a04:	91 e0       	ldi	r25, 0x01	; 1
    2a06:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	LCD_vidGotoxy(2,4);
    2a0a:	82 e0       	ldi	r24, 0x02	; 2
    2a0c:	64 e0       	ldi	r22, 0x04	; 4
    2a0e:	0e 94 3e 10 	call	0x207c	; 0x207c <LCD_vidGotoxy>
	LCD_vidWriteString("STOP:S");
    2a12:	80 e3       	ldi	r24, 0x30	; 48
    2a14:	91 e0       	ldi	r25, 0x01	; 1
    2a16:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
}
    2a1a:	cf 91       	pop	r28
    2a1c:	df 91       	pop	r29
    2a1e:	08 95       	ret

00002a20 <Private_UpdateCTemp>:
static void	Private_UpdateCTemp(void)
{
    2a20:	df 93       	push	r29
    2a22:	cf 93       	push	r28
    2a24:	cd b7       	in	r28, 0x3d	; 61
    2a26:	de b7       	in	r29, 0x3e	; 62
	LCD_vidGotoxy(1,1);
    2a28:	81 e0       	ldi	r24, 0x01	; 1
    2a2a:	61 e0       	ldi	r22, 0x01	; 1
    2a2c:	0e 94 3e 10 	call	0x207c	; 0x207c <LCD_vidGotoxy>
	LCD_vidWriteString("C:");
    2a30:	85 ef       	ldi	r24, 0xF5	; 245
    2a32:	90 e0       	ldi	r25, 0x00	; 0
    2a34:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	LCD_vidWriteNumber(TAS.CTemp);
    2a38:	80 91 0c 07 	lds	r24, 0x070C
    2a3c:	88 2f       	mov	r24, r24
    2a3e:	90 e0       	ldi	r25, 0x00	; 0
    2a40:	0e 94 1a 11 	call	0x2234	; 0x2234 <LCD_vidWriteNumber>
	LCD_vidWriteString("xx");
    2a44:	87 e3       	ldi	r24, 0x37	; 55
    2a46:	91 e0       	ldi	r25, 0x01	; 1
    2a48:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	LCD_vidWriteString("T:");
    2a4c:	8b ef       	ldi	r24, 0xFB	; 251
    2a4e:	90 e0       	ldi	r25, 0x00	; 0
    2a50:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	LCD_vidWriteNumber(TAS.TTemp);
    2a54:	80 91 0d 07 	lds	r24, 0x070D
    2a58:	88 2f       	mov	r24, r24
    2a5a:	90 e0       	ldi	r25, 0x00	; 0
    2a5c:	0e 94 1a 11 	call	0x2234	; 0x2234 <LCD_vidWriteNumber>
	LCD_vidWriteString("xx");
    2a60:	87 e3       	ldi	r24, 0x37	; 55
    2a62:	91 e0       	ldi	r25, 0x01	; 1
    2a64:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
}
    2a68:	cf 91       	pop	r28
    2a6a:	df 91       	pop	r29
    2a6c:	08 95       	ret

00002a6e <Private_UpdateTTemp>:
static void	Private_UpdateTTemp(void)
{
    2a6e:	df 93       	push	r29
    2a70:	cf 93       	push	r28
    2a72:	cd b7       	in	r28, 0x3d	; 61
    2a74:	de b7       	in	r29, 0x3e	; 62
	LCD_vidGotoxy(1,1);
    2a76:	81 e0       	ldi	r24, 0x01	; 1
    2a78:	61 e0       	ldi	r22, 0x01	; 1
    2a7a:	0e 94 3e 10 	call	0x207c	; 0x207c <LCD_vidGotoxy>
	LCD_vidWriteString("C:");
    2a7e:	85 ef       	ldi	r24, 0xF5	; 245
    2a80:	90 e0       	ldi	r25, 0x00	; 0
    2a82:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	LCD_vidWriteNumber(TAS.CTemp);
    2a86:	80 91 0c 07 	lds	r24, 0x070C
    2a8a:	88 2f       	mov	r24, r24
    2a8c:	90 e0       	ldi	r25, 0x00	; 0
    2a8e:	0e 94 1a 11 	call	0x2234	; 0x2234 <LCD_vidWriteNumber>
	LCD_vidWriteString("xx");
    2a92:	87 e3       	ldi	r24, 0x37	; 55
    2a94:	91 e0       	ldi	r25, 0x01	; 1
    2a96:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	LCD_vidWriteString("T:");
    2a9a:	8b ef       	ldi	r24, 0xFB	; 251
    2a9c:	90 e0       	ldi	r25, 0x00	; 0
    2a9e:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
	LCD_vidWriteNumber(TAS.TTemp);
    2aa2:	80 91 0d 07 	lds	r24, 0x070D
    2aa6:	88 2f       	mov	r24, r24
    2aa8:	90 e0       	ldi	r25, 0x00	; 0
    2aaa:	0e 94 1a 11 	call	0x2234	; 0x2234 <LCD_vidWriteNumber>
	LCD_vidWriteString("xx");
    2aae:	87 e3       	ldi	r24, 0x37	; 55
    2ab0:	91 e0       	ldi	r25, 0x01	; 1
    2ab2:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <LCD_vidWriteString>
}
    2ab6:	cf 91       	pop	r28
    2ab8:	df 91       	pop	r29
    2aba:	08 95       	ret

00002abc <Private_UpdateAS>:
static void	Private_UpdateAS(void)
{
    2abc:	df 93       	push	r29
    2abe:	cf 93       	push	r28
    2ac0:	cd b7       	in	r28, 0x3d	; 61
    2ac2:	de b7       	in	r29, 0x3e	; 62
	LCD_vidGotoxy(1,16);
    2ac4:	81 e0       	ldi	r24, 0x01	; 1
    2ac6:	60 e1       	ldi	r22, 0x10	; 16
    2ac8:	0e 94 3e 10 	call	0x207c	; 0x207c <LCD_vidGotoxy>
	if(TAS.AS) /* 1 >> enabled */
    2acc:	80 91 0e 07 	lds	r24, 0x070E
    2ad0:	88 23       	and	r24, r24
    2ad2:	21 f0       	breq	.+8      	; 0x2adc <Private_UpdateAS+0x20>
	{
		LCD_vidWriteCharctr('E');
    2ad4:	85 e4       	ldi	r24, 0x45	; 69
    2ad6:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <LCD_vidWriteCharctr>
    2ada:	03 c0       	rjmp	.+6      	; 0x2ae2 <Private_UpdateAS+0x26>
	}
	else
	{
		LCD_vidWriteCharctr('D');
    2adc:	84 e4       	ldi	r24, 0x44	; 68
    2ade:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <LCD_vidWriteCharctr>
	}
}
    2ae2:	cf 91       	pop	r28
    2ae4:	df 91       	pop	r29
    2ae6:	08 95       	ret

00002ae8 <Private_UpdateTTempConfig>:


static void	Private_UpdateTTempConfig(void)
{
    2ae8:	df 93       	push	r29
    2aea:	cf 93       	push	r28
    2aec:	cd b7       	in	r28, 0x3d	; 61
    2aee:	de b7       	in	r29, 0x3e	; 62
	LCD_vidGotoxy(1, 8 + g_temp_TTemp.i);
    2af0:	80 91 0a 07 	lds	r24, 0x070A
    2af4:	98 2f       	mov	r25, r24
    2af6:	98 5f       	subi	r25, 0xF8	; 248
    2af8:	81 e0       	ldi	r24, 0x01	; 1
    2afa:	69 2f       	mov	r22, r25
    2afc:	0e 94 3e 10 	call	0x207c	; 0x207c <LCD_vidGotoxy>

	//usart_puts("\r\ng_temp_TTemp.strTTemp = ");
	//usart_putc(g_temp_TTemp.strTTemp[g_temp_TTemp.i] + 48);
	//usart_puts("\r\n");

	LCD_vidWriteCharctr( g_temp_TTemp.strTTemp[g_temp_TTemp.i] + 48 );
    2b00:	80 91 0a 07 	lds	r24, 0x070A
    2b04:	88 2f       	mov	r24, r24
    2b06:	90 e0       	ldi	r25, 0x00	; 0
    2b08:	fc 01       	movw	r30, r24
    2b0a:	ea 5f       	subi	r30, 0xFA	; 250
    2b0c:	f8 4f       	sbci	r31, 0xF8	; 248
    2b0e:	80 81       	ld	r24, Z
    2b10:	80 5d       	subi	r24, 0xD0	; 208
    2b12:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <LCD_vidWriteCharctr>
}
    2b16:	cf 91       	pop	r28
    2b18:	df 91       	pop	r29
    2b1a:	08 95       	ret

00002b1c <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    2b1c:	af 92       	push	r10
    2b1e:	bf 92       	push	r11
    2b20:	cf 92       	push	r12
    2b22:	df 92       	push	r13
    2b24:	ef 92       	push	r14
    2b26:	ff 92       	push	r15
    2b28:	0f 93       	push	r16
    2b2a:	df 93       	push	r29
    2b2c:	cf 93       	push	r28
    2b2e:	0f 92       	push	r0
    2b30:	cd b7       	in	r28, 0x3d	; 61
    2b32:	de b7       	in	r29, 0x3e	; 62
    2b34:	89 83       	std	Y+1, r24	; 0x01
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    2b36:	8a e0       	ldi	r24, 0x0A	; 10
    2b38:	62 e0       	ldi	r22, 0x02	; 2
    2b3a:	40 e0       	ldi	r20, 0x00	; 0
    2b3c:	0e 94 6e 22 	call	0x44dc	; 0x44dc <xQueueGenericCreate>
    2b40:	90 93 a7 01 	sts	0x01A7, r25
    2b44:	80 93 a6 01 	sts	0x01A6, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    2b48:	82 e1       	ldi	r24, 0x12	; 18
    2b4a:	96 e1       	ldi	r25, 0x16	; 22
    2b4c:	2a e3       	ldi	r18, 0x3A	; 58
    2b4e:	31 e0       	ldi	r19, 0x01	; 1
    2b50:	e6 ea       	ldi	r30, 0xA6	; 166
    2b52:	f1 e0       	ldi	r31, 0x01	; 1
    2b54:	b9 01       	movw	r22, r18
    2b56:	45 e5       	ldi	r20, 0x55	; 85
    2b58:	50 e0       	ldi	r21, 0x00	; 0
    2b5a:	9f 01       	movw	r18, r30
    2b5c:	09 81       	ldd	r16, Y+1	; 0x01
    2b5e:	ee 24       	eor	r14, r14
    2b60:	ff 24       	eor	r15, r15
    2b62:	cc 24       	eor	r12, r12
    2b64:	dd 24       	eor	r13, r13
    2b66:	aa 24       	eor	r10, r10
    2b68:	bb 24       	eor	r11, r11
    2b6a:	0e 94 94 29 	call	0x5328	; 0x5328 <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    2b6e:	85 ed       	ldi	r24, 0xD5	; 213
    2b70:	95 e1       	ldi	r25, 0x15	; 21
    2b72:	22 e4       	ldi	r18, 0x42	; 66
    2b74:	31 e0       	ldi	r19, 0x01	; 1
    2b76:	e6 ea       	ldi	r30, 0xA6	; 166
    2b78:	f1 e0       	ldi	r31, 0x01	; 1
    2b7a:	b9 01       	movw	r22, r18
    2b7c:	45 e5       	ldi	r20, 0x55	; 85
    2b7e:	50 e0       	ldi	r21, 0x00	; 0
    2b80:	9f 01       	movw	r18, r30
    2b82:	09 81       	ldd	r16, Y+1	; 0x01
    2b84:	ee 24       	eor	r14, r14
    2b86:	ff 24       	eor	r15, r15
    2b88:	cc 24       	eor	r12, r12
    2b8a:	dd 24       	eor	r13, r13
    2b8c:	aa 24       	eor	r10, r10
    2b8e:	bb 24       	eor	r11, r11
    2b90:	0e 94 94 29 	call	0x5328	; 0x5328 <xTaskGenericCreate>
}
    2b94:	0f 90       	pop	r0
    2b96:	cf 91       	pop	r28
    2b98:	df 91       	pop	r29
    2b9a:	0f 91       	pop	r16
    2b9c:	ff 90       	pop	r15
    2b9e:	ef 90       	pop	r14
    2ba0:	df 90       	pop	r13
    2ba2:	cf 90       	pop	r12
    2ba4:	bf 90       	pop	r11
    2ba6:	af 90       	pop	r10
    2ba8:	08 95       	ret

00002baa <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    2baa:	df 93       	push	r29
    2bac:	cf 93       	push	r28
    2bae:	00 d0       	rcall	.+0      	; 0x2bb0 <vPolledQueueProducer+0x6>
    2bb0:	00 d0       	rcall	.+0      	; 0x2bb2 <vPolledQueueProducer+0x8>
    2bb2:	00 d0       	rcall	.+0      	; 0x2bb4 <vPolledQueueProducer+0xa>
    2bb4:	cd b7       	in	r28, 0x3d	; 61
    2bb6:	de b7       	in	r29, 0x3e	; 62
    2bb8:	9e 83       	std	Y+6, r25	; 0x06
    2bba:	8d 83       	std	Y+5, r24	; 0x05
uint16_t usValue = ( uint16_t ) 0;
    2bbc:	1c 82       	std	Y+4, r1	; 0x04
    2bbe:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xError = pdFALSE, xLoop;
    2bc0:	1a 82       	std	Y+2, r1	; 0x02

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    2bc2:	19 82       	std	Y+1, r1	; 0x01
    2bc4:	27 c0       	rjmp	.+78     	; 0x2c14 <vPolledQueueProducer+0x6a>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    2bc6:	ed 81       	ldd	r30, Y+5	; 0x05
    2bc8:	fe 81       	ldd	r31, Y+6	; 0x06
    2bca:	80 81       	ld	r24, Z
    2bcc:	91 81       	ldd	r25, Z+1	; 0x01
    2bce:	9e 01       	movw	r18, r28
    2bd0:	2d 5f       	subi	r18, 0xFD	; 253
    2bd2:	3f 4f       	sbci	r19, 0xFF	; 255
    2bd4:	b9 01       	movw	r22, r18
    2bd6:	40 e0       	ldi	r20, 0x00	; 0
    2bd8:	50 e0       	ldi	r21, 0x00	; 0
    2bda:	20 e0       	ldi	r18, 0x00	; 0
    2bdc:	0e 94 39 23 	call	0x4672	; 0x4672 <xQueueGenericSend>
    2be0:	81 30       	cpi	r24, 0x01	; 1
    2be2:	19 f0       	breq	.+6      	; 0x2bea <vPolledQueueProducer+0x40>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
    2be4:	81 e0       	ldi	r24, 0x01	; 1
    2be6:	8a 83       	std	Y+2, r24	; 0x02
    2be8:	12 c0       	rjmp	.+36     	; 0x2c0e <vPolledQueueProducer+0x64>
			}
			else
			{
				if( xError == pdFALSE )
    2bea:	8a 81       	ldd	r24, Y+2	; 0x02
    2bec:	88 23       	and	r24, r24
    2bee:	51 f4       	brne	.+20     	; 0x2c04 <vPolledQueueProducer+0x5a>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    2bf0:	0f b6       	in	r0, 0x3f	; 63
    2bf2:	f8 94       	cli
    2bf4:	0f 92       	push	r0
						xPollingProducerCount++;
    2bf6:	80 91 a5 01 	lds	r24, 0x01A5
    2bfa:	8f 5f       	subi	r24, 0xFF	; 255
    2bfc:	80 93 a5 01 	sts	0x01A5, r24
					portEXIT_CRITICAL();
    2c00:	0f 90       	pop	r0
    2c02:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    2c04:	8b 81       	ldd	r24, Y+3	; 0x03
    2c06:	9c 81       	ldd	r25, Y+4	; 0x04
    2c08:	01 96       	adiw	r24, 0x01	; 1
    2c0a:	9c 83       	std	Y+4, r25	; 0x04
    2c0c:	8b 83       	std	Y+3, r24	; 0x03
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    2c0e:	89 81       	ldd	r24, Y+1	; 0x01
    2c10:	8f 5f       	subi	r24, 0xFF	; 255
    2c12:	89 83       	std	Y+1, r24	; 0x01
    2c14:	89 81       	ldd	r24, Y+1	; 0x01
    2c16:	83 30       	cpi	r24, 0x03	; 3
    2c18:	b4 f2       	brlt	.-84     	; 0x2bc6 <vPolledQueueProducer+0x1c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    2c1a:	88 ec       	ldi	r24, 0xC8	; 200
    2c1c:	90 e0       	ldi	r25, 0x00	; 0
    2c1e:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <vTaskDelay>
    2c22:	cf cf       	rjmp	.-98     	; 0x2bc2 <vPolledQueueProducer+0x18>

00002c24 <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    2c24:	df 93       	push	r29
    2c26:	cf 93       	push	r28
    2c28:	cd b7       	in	r28, 0x3d	; 61
    2c2a:	de b7       	in	r29, 0x3e	; 62
    2c2c:	27 97       	sbiw	r28, 0x07	; 7
    2c2e:	0f b6       	in	r0, 0x3f	; 63
    2c30:	f8 94       	cli
    2c32:	de bf       	out	0x3e, r29	; 62
    2c34:	0f be       	out	0x3f, r0	; 63
    2c36:	cd bf       	out	0x3d, r28	; 61
    2c38:	9f 83       	std	Y+7, r25	; 0x07
    2c3a:	8e 83       	std	Y+6, r24	; 0x06
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
    2c3c:	1b 82       	std	Y+3, r1	; 0x03
    2c3e:	1a 82       	std	Y+2, r1	; 0x02
BaseType_t xError = pdFALSE;
    2c40:	19 82       	std	Y+1, r1	; 0x01
    2c42:	2f c0       	rjmp	.+94     	; 0x2ca2 <vPolledQueueConsumer+0x7e>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    2c44:	ee 81       	ldd	r30, Y+6	; 0x06
    2c46:	ff 81       	ldd	r31, Y+7	; 0x07
    2c48:	80 81       	ld	r24, Z
    2c4a:	91 81       	ldd	r25, Z+1	; 0x01
    2c4c:	9e 01       	movw	r18, r28
    2c4e:	2c 5f       	subi	r18, 0xFC	; 252
    2c50:	3f 4f       	sbci	r19, 0xFF	; 255
    2c52:	b9 01       	movw	r22, r18
    2c54:	40 e0       	ldi	r20, 0x00	; 0
    2c56:	50 e0       	ldi	r21, 0x00	; 0
    2c58:	20 e0       	ldi	r18, 0x00	; 0
    2c5a:	0e 94 47 24 	call	0x488e	; 0x488e <xQueueGenericReceive>
    2c5e:	81 30       	cpi	r24, 0x01	; 1
    2c60:	01 f5       	brne	.+64     	; 0x2ca2 <vPolledQueueConsumer+0x7e>
			{
				if( usData != usExpectedValue )
    2c62:	2c 81       	ldd	r18, Y+4	; 0x04
    2c64:	3d 81       	ldd	r19, Y+5	; 0x05
    2c66:	8a 81       	ldd	r24, Y+2	; 0x02
    2c68:	9b 81       	ldd	r25, Y+3	; 0x03
    2c6a:	28 17       	cp	r18, r24
    2c6c:	39 07       	cpc	r19, r25
    2c6e:	39 f0       	breq	.+14     	; 0x2c7e <vPolledQueueConsumer+0x5a>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
    2c70:	81 e0       	ldi	r24, 0x01	; 1
    2c72:	89 83       	std	Y+1, r24	; 0x01

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
    2c74:	8c 81       	ldd	r24, Y+4	; 0x04
    2c76:	9d 81       	ldd	r25, Y+5	; 0x05
    2c78:	9b 83       	std	Y+3, r25	; 0x03
    2c7a:	8a 83       	std	Y+2, r24	; 0x02
    2c7c:	0d c0       	rjmp	.+26     	; 0x2c98 <vPolledQueueConsumer+0x74>
				}
				else
				{
					if( xError == pdFALSE )
    2c7e:	89 81       	ldd	r24, Y+1	; 0x01
    2c80:	88 23       	and	r24, r24
    2c82:	51 f4       	brne	.+20     	; 0x2c98 <vPolledQueueConsumer+0x74>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    2c84:	0f b6       	in	r0, 0x3f	; 63
    2c86:	f8 94       	cli
    2c88:	0f 92       	push	r0
							xPollingConsumerCount++;
    2c8a:	80 91 a4 01 	lds	r24, 0x01A4
    2c8e:	8f 5f       	subi	r24, 0xFF	; 255
    2c90:	80 93 a4 01 	sts	0x01A4, r24
						portEXIT_CRITICAL();
    2c94:	0f 90       	pop	r0
    2c96:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    2c98:	8a 81       	ldd	r24, Y+2	; 0x02
    2c9a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c9c:	01 96       	adiw	r24, 0x01	; 1
    2c9e:	9b 83       	std	Y+3, r25	; 0x03
    2ca0:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    2ca2:	ee 81       	ldd	r30, Y+6	; 0x06
    2ca4:	ff 81       	ldd	r31, Y+7	; 0x07
    2ca6:	80 81       	ld	r24, Z
    2ca8:	91 81       	ldd	r25, Z+1	; 0x01
    2caa:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <uxQueueMessagesWaiting>
    2cae:	88 23       	and	r24, r24
    2cb0:	49 f6       	brne	.-110    	; 0x2c44 <vPolledQueueConsumer+0x20>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    2cb2:	84 eb       	ldi	r24, 0xB4	; 180
    2cb4:	90 e0       	ldi	r25, 0x00	; 0
    2cb6:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <vTaskDelay>
    2cba:	f3 cf       	rjmp	.-26     	; 0x2ca2 <vPolledQueueConsumer+0x7e>

00002cbc <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
    2cbc:	df 93       	push	r29
    2cbe:	cf 93       	push	r28
    2cc0:	0f 92       	push	r0
    2cc2:	cd b7       	in	r28, 0x3d	; 61
    2cc4:	de b7       	in	r29, 0x3e	; 62

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    2cc6:	80 91 a4 01 	lds	r24, 0x01A4
    2cca:	88 23       	and	r24, r24
    2ccc:	21 f0       	breq	.+8      	; 0x2cd6 <xArePollingQueuesStillRunning+0x1a>
    2cce:	80 91 a5 01 	lds	r24, 0x01A5
    2cd2:	88 23       	and	r24, r24
    2cd4:	11 f4       	brne	.+4      	; 0x2cda <xArePollingQueuesStillRunning+0x1e>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
    2cd6:	19 82       	std	Y+1, r1	; 0x01
    2cd8:	02 c0       	rjmp	.+4      	; 0x2cde <xArePollingQueuesStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
    2cda:	81 e0       	ldi	r24, 0x01	; 1
    2cdc:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    2cde:	10 92 a4 01 	sts	0x01A4, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    2ce2:	10 92 a5 01 	sts	0x01A5, r1

	return xReturn;
    2ce6:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ce8:	0f 90       	pop	r0
    2cea:	cf 91       	pop	r28
    2cec:	df 91       	pop	r29
    2cee:	08 95       	ret

00002cf0 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    2cf0:	df 93       	push	r29
    2cf2:	cf 93       	push	r28
    2cf4:	cd b7       	in	r28, 0x3d	; 61
    2cf6:	de b7       	in	r29, 0x3e	; 62
    2cf8:	27 97       	sbiw	r28, 0x07	; 7
    2cfa:	0f b6       	in	r0, 0x3f	; 63
    2cfc:	f8 94       	cli
    2cfe:	de bf       	out	0x3e, r29	; 62
    2d00:	0f be       	out	0x3f, r0	; 63
    2d02:	cd bf       	out	0x3d, r28	; 61
    2d04:	9d 83       	std	Y+5, r25	; 0x05
    2d06:	8c 83       	std	Y+4, r24	; 0x04
    2d08:	6e 83       	std	Y+6, r22	; 0x06
    2d0a:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    2d0c:	8a e1       	ldi	r24, 0x1A	; 26
    2d0e:	90 e0       	ldi	r25, 0x00	; 0
    2d10:	0e 94 90 1c 	call	0x3920	; 0x3920 <pvPortMalloc>
    2d14:	9a 83       	std	Y+2, r25	; 0x02
    2d16:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    2d18:	89 81       	ldd	r24, Y+1	; 0x01
    2d1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d1c:	00 97       	sbiw	r24, 0x00	; 0
    2d1e:	09 f4       	brne	.+2      	; 0x2d22 <xCoRoutineCreate+0x32>
    2d20:	6f c0       	rjmp	.+222    	; 0x2e00 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2d22:	80 91 a8 01 	lds	r24, 0x01A8
    2d26:	90 91 a9 01 	lds	r25, 0x01A9
    2d2a:	00 97       	sbiw	r24, 0x00	; 0
    2d2c:	41 f4       	brne	.+16     	; 0x2d3e <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2d2e:	89 81       	ldd	r24, Y+1	; 0x01
    2d30:	9a 81       	ldd	r25, Y+2	; 0x02
    2d32:	90 93 a9 01 	sts	0x01A9, r25
    2d36:	80 93 a8 01 	sts	0x01A8, r24
			prvInitialiseCoRoutineLists();
    2d3a:	0e 94 df 18 	call	0x31be	; 0x31be <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2d3e:	8e 81       	ldd	r24, Y+6	; 0x06
    2d40:	82 30       	cpi	r24, 0x02	; 2
    2d42:	10 f0       	brcs	.+4      	; 0x2d48 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    2d44:	81 e0       	ldi	r24, 0x01	; 1
    2d46:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2d48:	e9 81       	ldd	r30, Y+1	; 0x01
    2d4a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d4c:	11 8e       	std	Z+25, r1	; 0x19
    2d4e:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2d50:	e9 81       	ldd	r30, Y+1	; 0x01
    2d52:	fa 81       	ldd	r31, Y+2	; 0x02
    2d54:	8e 81       	ldd	r24, Y+6	; 0x06
    2d56:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2d58:	e9 81       	ldd	r30, Y+1	; 0x01
    2d5a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d5c:	8f 81       	ldd	r24, Y+7	; 0x07
    2d5e:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2d60:	e9 81       	ldd	r30, Y+1	; 0x01
    2d62:	fa 81       	ldd	r31, Y+2	; 0x02
    2d64:	8c 81       	ldd	r24, Y+4	; 0x04
    2d66:	9d 81       	ldd	r25, Y+5	; 0x05
    2d68:	91 83       	std	Z+1, r25	; 0x01
    2d6a:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2d6c:	89 81       	ldd	r24, Y+1	; 0x01
    2d6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d70:	02 96       	adiw	r24, 0x02	; 2
    2d72:	0e 94 08 1e 	call	0x3c10	; 0x3c10 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2d76:	89 81       	ldd	r24, Y+1	; 0x01
    2d78:	9a 81       	ldd	r25, Y+2	; 0x02
    2d7a:	0c 96       	adiw	r24, 0x0c	; 12
    2d7c:	0e 94 08 1e 	call	0x3c10	; 0x3c10 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2d80:	e9 81       	ldd	r30, Y+1	; 0x01
    2d82:	fa 81       	ldd	r31, Y+2	; 0x02
    2d84:	89 81       	ldd	r24, Y+1	; 0x01
    2d86:	9a 81       	ldd	r25, Y+2	; 0x02
    2d88:	91 87       	std	Z+9, r25	; 0x09
    2d8a:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2d8c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d8e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d90:	89 81       	ldd	r24, Y+1	; 0x01
    2d92:	9a 81       	ldd	r25, Y+2	; 0x02
    2d94:	93 8b       	std	Z+19, r25	; 0x13
    2d96:	82 8b       	std	Z+18, r24	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2d98:	8e 81       	ldd	r24, Y+6	; 0x06
    2d9a:	28 2f       	mov	r18, r24
    2d9c:	30 e0       	ldi	r19, 0x00	; 0
    2d9e:	82 e0       	ldi	r24, 0x02	; 2
    2da0:	90 e0       	ldi	r25, 0x00	; 0
    2da2:	82 1b       	sub	r24, r18
    2da4:	93 0b       	sbc	r25, r19
    2da6:	e9 81       	ldd	r30, Y+1	; 0x01
    2da8:	fa 81       	ldd	r31, Y+2	; 0x02
    2daa:	95 87       	std	Z+13, r25	; 0x0d
    2dac:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2dae:	e9 81       	ldd	r30, Y+1	; 0x01
    2db0:	fa 81       	ldd	r31, Y+2	; 0x02
    2db2:	96 89       	ldd	r25, Z+22	; 0x16
    2db4:	80 91 aa 01 	lds	r24, 0x01AA
    2db8:	89 17       	cp	r24, r25
    2dba:	28 f4       	brcc	.+10     	; 0x2dc6 <xCoRoutineCreate+0xd6>
    2dbc:	e9 81       	ldd	r30, Y+1	; 0x01
    2dbe:	fa 81       	ldd	r31, Y+2	; 0x02
    2dc0:	86 89       	ldd	r24, Z+22	; 0x16
    2dc2:	80 93 aa 01 	sts	0x01AA, r24
    2dc6:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dca:	86 89       	ldd	r24, Z+22	; 0x16
    2dcc:	28 2f       	mov	r18, r24
    2dce:	30 e0       	ldi	r19, 0x00	; 0
    2dd0:	c9 01       	movw	r24, r18
    2dd2:	88 0f       	add	r24, r24
    2dd4:	99 1f       	adc	r25, r25
    2dd6:	88 0f       	add	r24, r24
    2dd8:	99 1f       	adc	r25, r25
    2dda:	88 0f       	add	r24, r24
    2ddc:	99 1f       	adc	r25, r25
    2dde:	82 0f       	add	r24, r18
    2de0:	93 1f       	adc	r25, r19
    2de2:	ac 01       	movw	r20, r24
    2de4:	4f 54       	subi	r20, 0x4F	; 79
    2de6:	5e 4f       	sbci	r21, 0xFE	; 254
    2de8:	89 81       	ldd	r24, Y+1	; 0x01
    2dea:	9a 81       	ldd	r25, Y+2	; 0x02
    2dec:	9c 01       	movw	r18, r24
    2dee:	2e 5f       	subi	r18, 0xFE	; 254
    2df0:	3f 4f       	sbci	r19, 0xFF	; 255
    2df2:	ca 01       	movw	r24, r20
    2df4:	b9 01       	movw	r22, r18
    2df6:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>

		xReturn = pdPASS;
    2dfa:	81 e0       	ldi	r24, 0x01	; 1
    2dfc:	8b 83       	std	Y+3, r24	; 0x03
    2dfe:	02 c0       	rjmp	.+4      	; 0x2e04 <xCoRoutineCreate+0x114>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2e00:	8f ef       	ldi	r24, 0xFF	; 255
    2e02:	8b 83       	std	Y+3, r24	; 0x03
	}

	return xReturn;
    2e04:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2e06:	27 96       	adiw	r28, 0x07	; 7
    2e08:	0f b6       	in	r0, 0x3f	; 63
    2e0a:	f8 94       	cli
    2e0c:	de bf       	out	0x3e, r29	; 62
    2e0e:	0f be       	out	0x3f, r0	; 63
    2e10:	cd bf       	out	0x3d, r28	; 61
    2e12:	cf 91       	pop	r28
    2e14:	df 91       	pop	r29
    2e16:	08 95       	ret

00002e18 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    2e18:	df 93       	push	r29
    2e1a:	cf 93       	push	r28
    2e1c:	00 d0       	rcall	.+0      	; 0x2e1e <vCoRoutineAddToDelayedList+0x6>
    2e1e:	00 d0       	rcall	.+0      	; 0x2e20 <vCoRoutineAddToDelayedList+0x8>
    2e20:	00 d0       	rcall	.+0      	; 0x2e22 <vCoRoutineAddToDelayedList+0xa>
    2e22:	cd b7       	in	r28, 0x3d	; 61
    2e24:	de b7       	in	r29, 0x3e	; 62
    2e26:	9c 83       	std	Y+4, r25	; 0x04
    2e28:	8b 83       	std	Y+3, r24	; 0x03
    2e2a:	7e 83       	std	Y+6, r23	; 0x06
    2e2c:	6d 83       	std	Y+5, r22	; 0x05
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2e2e:	20 91 ab 01 	lds	r18, 0x01AB
    2e32:	30 91 ac 01 	lds	r19, 0x01AC
    2e36:	8b 81       	ldd	r24, Y+3	; 0x03
    2e38:	9c 81       	ldd	r25, Y+4	; 0x04
    2e3a:	82 0f       	add	r24, r18
    2e3c:	93 1f       	adc	r25, r19
    2e3e:	9a 83       	std	Y+2, r25	; 0x02
    2e40:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2e42:	80 91 a8 01 	lds	r24, 0x01A8
    2e46:	90 91 a9 01 	lds	r25, 0x01A9
    2e4a:	02 96       	adiw	r24, 0x02	; 2
    2e4c:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2e50:	e0 91 a8 01 	lds	r30, 0x01A8
    2e54:	f0 91 a9 01 	lds	r31, 0x01A9
    2e58:	89 81       	ldd	r24, Y+1	; 0x01
    2e5a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e5c:	93 83       	std	Z+3, r25	; 0x03
    2e5e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2e60:	20 91 ab 01 	lds	r18, 0x01AB
    2e64:	30 91 ac 01 	lds	r19, 0x01AC
    2e68:	89 81       	ldd	r24, Y+1	; 0x01
    2e6a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e6c:	82 17       	cp	r24, r18
    2e6e:	93 07       	cpc	r25, r19
    2e70:	70 f4       	brcc	.+28     	; 0x2e8e <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2e72:	80 91 d7 01 	lds	r24, 0x01D7
    2e76:	90 91 d8 01 	lds	r25, 0x01D8
    2e7a:	20 91 a8 01 	lds	r18, 0x01A8
    2e7e:	30 91 a9 01 	lds	r19, 0x01A9
    2e82:	2e 5f       	subi	r18, 0xFE	; 254
    2e84:	3f 4f       	sbci	r19, 0xFF	; 255
    2e86:	b9 01       	movw	r22, r18
    2e88:	0e 94 5c 1e 	call	0x3cb8	; 0x3cb8 <vListInsert>
    2e8c:	0d c0       	rjmp	.+26     	; 0x2ea8 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2e8e:	80 91 d5 01 	lds	r24, 0x01D5
    2e92:	90 91 d6 01 	lds	r25, 0x01D6
    2e96:	20 91 a8 01 	lds	r18, 0x01A8
    2e9a:	30 91 a9 01 	lds	r19, 0x01A9
    2e9e:	2e 5f       	subi	r18, 0xFE	; 254
    2ea0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ea2:	b9 01       	movw	r22, r18
    2ea4:	0e 94 5c 1e 	call	0x3cb8	; 0x3cb8 <vListInsert>
	}

	if( pxEventList )
    2ea8:	8d 81       	ldd	r24, Y+5	; 0x05
    2eaa:	9e 81       	ldd	r25, Y+6	; 0x06
    2eac:	00 97       	sbiw	r24, 0x00	; 0
    2eae:	61 f0       	breq	.+24     	; 0x2ec8 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2eb0:	80 91 a8 01 	lds	r24, 0x01A8
    2eb4:	90 91 a9 01 	lds	r25, 0x01A9
    2eb8:	9c 01       	movw	r18, r24
    2eba:	24 5f       	subi	r18, 0xF4	; 244
    2ebc:	3f 4f       	sbci	r19, 0xFF	; 255
    2ebe:	8d 81       	ldd	r24, Y+5	; 0x05
    2ec0:	9e 81       	ldd	r25, Y+6	; 0x06
    2ec2:	b9 01       	movw	r22, r18
    2ec4:	0e 94 5c 1e 	call	0x3cb8	; 0x3cb8 <vListInsert>
	}
}
    2ec8:	26 96       	adiw	r28, 0x06	; 6
    2eca:	0f b6       	in	r0, 0x3f	; 63
    2ecc:	f8 94       	cli
    2ece:	de bf       	out	0x3e, r29	; 62
    2ed0:	0f be       	out	0x3f, r0	; 63
    2ed2:	cd bf       	out	0x3d, r28	; 61
    2ed4:	cf 91       	pop	r28
    2ed6:	df 91       	pop	r29
    2ed8:	08 95       	ret

00002eda <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    2eda:	df 93       	push	r29
    2edc:	cf 93       	push	r28
    2ede:	00 d0       	rcall	.+0      	; 0x2ee0 <prvCheckPendingReadyList+0x6>
    2ee0:	cd b7       	in	r28, 0x3d	; 61
    2ee2:	de b7       	in	r29, 0x3e	; 62
    2ee4:	3a c0       	rjmp	.+116    	; 0x2f5a <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2ee6:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    2ee8:	e0 91 de 01 	lds	r30, 0x01DE
    2eec:	f0 91 df 01 	lds	r31, 0x01DF
    2ef0:	86 81       	ldd	r24, Z+6	; 0x06
    2ef2:	97 81       	ldd	r25, Z+7	; 0x07
    2ef4:	9a 83       	std	Y+2, r25	; 0x02
    2ef6:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2ef8:	89 81       	ldd	r24, Y+1	; 0x01
    2efa:	9a 81       	ldd	r25, Y+2	; 0x02
    2efc:	0c 96       	adiw	r24, 0x0c	; 12
    2efe:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2f02:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2f04:	89 81       	ldd	r24, Y+1	; 0x01
    2f06:	9a 81       	ldd	r25, Y+2	; 0x02
    2f08:	02 96       	adiw	r24, 0x02	; 2
    2f0a:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2f0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f10:	fa 81       	ldd	r31, Y+2	; 0x02
    2f12:	96 89       	ldd	r25, Z+22	; 0x16
    2f14:	80 91 aa 01 	lds	r24, 0x01AA
    2f18:	89 17       	cp	r24, r25
    2f1a:	28 f4       	brcc	.+10     	; 0x2f26 <prvCheckPendingReadyList+0x4c>
    2f1c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f1e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f20:	86 89       	ldd	r24, Z+22	; 0x16
    2f22:	80 93 aa 01 	sts	0x01AA, r24
    2f26:	e9 81       	ldd	r30, Y+1	; 0x01
    2f28:	fa 81       	ldd	r31, Y+2	; 0x02
    2f2a:	86 89       	ldd	r24, Z+22	; 0x16
    2f2c:	28 2f       	mov	r18, r24
    2f2e:	30 e0       	ldi	r19, 0x00	; 0
    2f30:	c9 01       	movw	r24, r18
    2f32:	88 0f       	add	r24, r24
    2f34:	99 1f       	adc	r25, r25
    2f36:	88 0f       	add	r24, r24
    2f38:	99 1f       	adc	r25, r25
    2f3a:	88 0f       	add	r24, r24
    2f3c:	99 1f       	adc	r25, r25
    2f3e:	82 0f       	add	r24, r18
    2f40:	93 1f       	adc	r25, r19
    2f42:	ac 01       	movw	r20, r24
    2f44:	4f 54       	subi	r20, 0x4F	; 79
    2f46:	5e 4f       	sbci	r21, 0xFE	; 254
    2f48:	89 81       	ldd	r24, Y+1	; 0x01
    2f4a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f4c:	9c 01       	movw	r18, r24
    2f4e:	2e 5f       	subi	r18, 0xFE	; 254
    2f50:	3f 4f       	sbci	r19, 0xFF	; 255
    2f52:	ca 01       	movw	r24, r20
    2f54:	b9 01       	movw	r22, r18
    2f56:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2f5a:	80 91 d9 01 	lds	r24, 0x01D9
    2f5e:	88 23       	and	r24, r24
    2f60:	09 f0       	breq	.+2      	; 0x2f64 <prvCheckPendingReadyList+0x8a>
    2f62:	c1 cf       	rjmp	.-126    	; 0x2ee6 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
    2f64:	0f 90       	pop	r0
    2f66:	0f 90       	pop	r0
    2f68:	cf 91       	pop	r28
    2f6a:	df 91       	pop	r29
    2f6c:	08 95       	ret

00002f6e <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2f6e:	df 93       	push	r29
    2f70:	cf 93       	push	r28
    2f72:	00 d0       	rcall	.+0      	; 0x2f74 <prvCheckDelayedList+0x6>
    2f74:	00 d0       	rcall	.+0      	; 0x2f76 <prvCheckDelayedList+0x8>
    2f76:	cd b7       	in	r28, 0x3d	; 61
    2f78:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2f7a:	0e 94 e8 2b 	call	0x57d0	; 0x57d0 <xTaskGetTickCount>
    2f7e:	20 91 ad 01 	lds	r18, 0x01AD
    2f82:	30 91 ae 01 	lds	r19, 0x01AE
    2f86:	82 1b       	sub	r24, r18
    2f88:	93 0b       	sbc	r25, r19
    2f8a:	90 93 b0 01 	sts	0x01B0, r25
    2f8e:	80 93 af 01 	sts	0x01AF, r24
    2f92:	85 c0       	rjmp	.+266    	; 0x309e <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2f94:	80 91 ab 01 	lds	r24, 0x01AB
    2f98:	90 91 ac 01 	lds	r25, 0x01AC
    2f9c:	01 96       	adiw	r24, 0x01	; 1
    2f9e:	90 93 ac 01 	sts	0x01AC, r25
    2fa2:	80 93 ab 01 	sts	0x01AB, r24
		xPassedTicks--;
    2fa6:	80 91 af 01 	lds	r24, 0x01AF
    2faa:	90 91 b0 01 	lds	r25, 0x01B0
    2fae:	01 97       	sbiw	r24, 0x01	; 1
    2fb0:	90 93 b0 01 	sts	0x01B0, r25
    2fb4:	80 93 af 01 	sts	0x01AF, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2fb8:	80 91 ab 01 	lds	r24, 0x01AB
    2fbc:	90 91 ac 01 	lds	r25, 0x01AC
    2fc0:	00 97       	sbiw	r24, 0x00	; 0
    2fc2:	09 f0       	breq	.+2      	; 0x2fc6 <prvCheckDelayedList+0x58>
    2fc4:	64 c0       	rjmp	.+200    	; 0x308e <prvCheckDelayedList+0x120>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2fc6:	80 91 d5 01 	lds	r24, 0x01D5
    2fca:	90 91 d6 01 	lds	r25, 0x01D6
    2fce:	9a 83       	std	Y+2, r25	; 0x02
    2fd0:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2fd2:	80 91 d7 01 	lds	r24, 0x01D7
    2fd6:	90 91 d8 01 	lds	r25, 0x01D8
    2fda:	90 93 d6 01 	sts	0x01D6, r25
    2fde:	80 93 d5 01 	sts	0x01D5, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2fe2:	89 81       	ldd	r24, Y+1	; 0x01
    2fe4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fe6:	90 93 d8 01 	sts	0x01D8, r25
    2fea:	80 93 d7 01 	sts	0x01D7, r24
    2fee:	4f c0       	rjmp	.+158    	; 0x308e <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2ff0:	e0 91 d5 01 	lds	r30, 0x01D5
    2ff4:	f0 91 d6 01 	lds	r31, 0x01D6
    2ff8:	05 80       	ldd	r0, Z+5	; 0x05
    2ffa:	f6 81       	ldd	r31, Z+6	; 0x06
    2ffc:	e0 2d       	mov	r30, r0
    2ffe:	86 81       	ldd	r24, Z+6	; 0x06
    3000:	97 81       	ldd	r25, Z+7	; 0x07
    3002:	9c 83       	std	Y+4, r25	; 0x04
    3004:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    3006:	eb 81       	ldd	r30, Y+3	; 0x03
    3008:	fc 81       	ldd	r31, Y+4	; 0x04
    300a:	22 81       	ldd	r18, Z+2	; 0x02
    300c:	33 81       	ldd	r19, Z+3	; 0x03
    300e:	80 91 ab 01 	lds	r24, 0x01AB
    3012:	90 91 ac 01 	lds	r25, 0x01AC
    3016:	82 17       	cp	r24, r18
    3018:	93 07       	cpc	r25, r19
    301a:	08 f4       	brcc	.+2      	; 0x301e <prvCheckDelayedList+0xb0>
    301c:	40 c0       	rjmp	.+128    	; 0x309e <prvCheckDelayedList+0x130>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    301e:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    3020:	8b 81       	ldd	r24, Y+3	; 0x03
    3022:	9c 81       	ldd	r25, Y+4	; 0x04
    3024:	02 96       	adiw	r24, 0x02	; 2
    3026:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    302a:	eb 81       	ldd	r30, Y+3	; 0x03
    302c:	fc 81       	ldd	r31, Y+4	; 0x04
    302e:	84 89       	ldd	r24, Z+20	; 0x14
    3030:	95 89       	ldd	r25, Z+21	; 0x15
    3032:	00 97       	sbiw	r24, 0x00	; 0
    3034:	29 f0       	breq	.+10     	; 0x3040 <prvCheckDelayedList+0xd2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    3036:	8b 81       	ldd	r24, Y+3	; 0x03
    3038:	9c 81       	ldd	r25, Y+4	; 0x04
    303a:	0c 96       	adiw	r24, 0x0c	; 12
    303c:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    3040:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    3042:	eb 81       	ldd	r30, Y+3	; 0x03
    3044:	fc 81       	ldd	r31, Y+4	; 0x04
    3046:	96 89       	ldd	r25, Z+22	; 0x16
    3048:	80 91 aa 01 	lds	r24, 0x01AA
    304c:	89 17       	cp	r24, r25
    304e:	28 f4       	brcc	.+10     	; 0x305a <prvCheckDelayedList+0xec>
    3050:	eb 81       	ldd	r30, Y+3	; 0x03
    3052:	fc 81       	ldd	r31, Y+4	; 0x04
    3054:	86 89       	ldd	r24, Z+22	; 0x16
    3056:	80 93 aa 01 	sts	0x01AA, r24
    305a:	eb 81       	ldd	r30, Y+3	; 0x03
    305c:	fc 81       	ldd	r31, Y+4	; 0x04
    305e:	86 89       	ldd	r24, Z+22	; 0x16
    3060:	28 2f       	mov	r18, r24
    3062:	30 e0       	ldi	r19, 0x00	; 0
    3064:	c9 01       	movw	r24, r18
    3066:	88 0f       	add	r24, r24
    3068:	99 1f       	adc	r25, r25
    306a:	88 0f       	add	r24, r24
    306c:	99 1f       	adc	r25, r25
    306e:	88 0f       	add	r24, r24
    3070:	99 1f       	adc	r25, r25
    3072:	82 0f       	add	r24, r18
    3074:	93 1f       	adc	r25, r19
    3076:	ac 01       	movw	r20, r24
    3078:	4f 54       	subi	r20, 0x4F	; 79
    307a:	5e 4f       	sbci	r21, 0xFE	; 254
    307c:	8b 81       	ldd	r24, Y+3	; 0x03
    307e:	9c 81       	ldd	r25, Y+4	; 0x04
    3080:	9c 01       	movw	r18, r24
    3082:	2e 5f       	subi	r18, 0xFE	; 254
    3084:	3f 4f       	sbci	r19, 0xFF	; 255
    3086:	ca 01       	movw	r24, r20
    3088:	b9 01       	movw	r22, r18
    308a:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    308e:	e0 91 d5 01 	lds	r30, 0x01D5
    3092:	f0 91 d6 01 	lds	r31, 0x01D6
    3096:	80 81       	ld	r24, Z
    3098:	88 23       	and	r24, r24
    309a:	09 f0       	breq	.+2      	; 0x309e <prvCheckDelayedList+0x130>
    309c:	a9 cf       	rjmp	.-174    	; 0x2ff0 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    309e:	80 91 af 01 	lds	r24, 0x01AF
    30a2:	90 91 b0 01 	lds	r25, 0x01B0
    30a6:	00 97       	sbiw	r24, 0x00	; 0
    30a8:	09 f0       	breq	.+2      	; 0x30ac <prvCheckDelayedList+0x13e>
    30aa:	74 cf       	rjmp	.-280    	; 0x2f94 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    30ac:	80 91 ab 01 	lds	r24, 0x01AB
    30b0:	90 91 ac 01 	lds	r25, 0x01AC
    30b4:	90 93 ae 01 	sts	0x01AE, r25
    30b8:	80 93 ad 01 	sts	0x01AD, r24
}
    30bc:	0f 90       	pop	r0
    30be:	0f 90       	pop	r0
    30c0:	0f 90       	pop	r0
    30c2:	0f 90       	pop	r0
    30c4:	cf 91       	pop	r28
    30c6:	df 91       	pop	r29
    30c8:	08 95       	ret

000030ca <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    30ca:	df 93       	push	r29
    30cc:	cf 93       	push	r28
    30ce:	00 d0       	rcall	.+0      	; 0x30d0 <vCoRoutineSchedule+0x6>
    30d0:	cd b7       	in	r28, 0x3d	; 61
    30d2:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    30d4:	0e 94 6d 17 	call	0x2eda	; 0x2eda <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    30d8:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <prvCheckDelayedList>
    30dc:	0a c0       	rjmp	.+20     	; 0x30f2 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    30de:	80 91 aa 01 	lds	r24, 0x01AA
    30e2:	88 23       	and	r24, r24
    30e4:	09 f4       	brne	.+2      	; 0x30e8 <vCoRoutineSchedule+0x1e>
    30e6:	66 c0       	rjmp	.+204    	; 0x31b4 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    30e8:	80 91 aa 01 	lds	r24, 0x01AA
    30ec:	81 50       	subi	r24, 0x01	; 1
    30ee:	80 93 aa 01 	sts	0x01AA, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    30f2:	80 91 aa 01 	lds	r24, 0x01AA
    30f6:	28 2f       	mov	r18, r24
    30f8:	30 e0       	ldi	r19, 0x00	; 0
    30fa:	c9 01       	movw	r24, r18
    30fc:	88 0f       	add	r24, r24
    30fe:	99 1f       	adc	r25, r25
    3100:	88 0f       	add	r24, r24
    3102:	99 1f       	adc	r25, r25
    3104:	88 0f       	add	r24, r24
    3106:	99 1f       	adc	r25, r25
    3108:	82 0f       	add	r24, r18
    310a:	93 1f       	adc	r25, r19
    310c:	fc 01       	movw	r30, r24
    310e:	ef 54       	subi	r30, 0x4F	; 79
    3110:	fe 4f       	sbci	r31, 0xFE	; 254
    3112:	80 81       	ld	r24, Z
    3114:	88 23       	and	r24, r24
    3116:	19 f3       	breq	.-58     	; 0x30de <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    3118:	80 91 aa 01 	lds	r24, 0x01AA
    311c:	28 2f       	mov	r18, r24
    311e:	30 e0       	ldi	r19, 0x00	; 0
    3120:	c9 01       	movw	r24, r18
    3122:	88 0f       	add	r24, r24
    3124:	99 1f       	adc	r25, r25
    3126:	88 0f       	add	r24, r24
    3128:	99 1f       	adc	r25, r25
    312a:	88 0f       	add	r24, r24
    312c:	99 1f       	adc	r25, r25
    312e:	82 0f       	add	r24, r18
    3130:	93 1f       	adc	r25, r19
    3132:	8f 54       	subi	r24, 0x4F	; 79
    3134:	9e 4f       	sbci	r25, 0xFE	; 254
    3136:	9a 83       	std	Y+2, r25	; 0x02
    3138:	89 83       	std	Y+1, r24	; 0x01
    313a:	e9 81       	ldd	r30, Y+1	; 0x01
    313c:	fa 81       	ldd	r31, Y+2	; 0x02
    313e:	01 80       	ldd	r0, Z+1	; 0x01
    3140:	f2 81       	ldd	r31, Z+2	; 0x02
    3142:	e0 2d       	mov	r30, r0
    3144:	82 81       	ldd	r24, Z+2	; 0x02
    3146:	93 81       	ldd	r25, Z+3	; 0x03
    3148:	e9 81       	ldd	r30, Y+1	; 0x01
    314a:	fa 81       	ldd	r31, Y+2	; 0x02
    314c:	92 83       	std	Z+2, r25	; 0x02
    314e:	81 83       	std	Z+1, r24	; 0x01
    3150:	e9 81       	ldd	r30, Y+1	; 0x01
    3152:	fa 81       	ldd	r31, Y+2	; 0x02
    3154:	21 81       	ldd	r18, Z+1	; 0x01
    3156:	32 81       	ldd	r19, Z+2	; 0x02
    3158:	89 81       	ldd	r24, Y+1	; 0x01
    315a:	9a 81       	ldd	r25, Y+2	; 0x02
    315c:	03 96       	adiw	r24, 0x03	; 3
    315e:	28 17       	cp	r18, r24
    3160:	39 07       	cpc	r19, r25
    3162:	59 f4       	brne	.+22     	; 0x317a <vCoRoutineSchedule+0xb0>
    3164:	e9 81       	ldd	r30, Y+1	; 0x01
    3166:	fa 81       	ldd	r31, Y+2	; 0x02
    3168:	01 80       	ldd	r0, Z+1	; 0x01
    316a:	f2 81       	ldd	r31, Z+2	; 0x02
    316c:	e0 2d       	mov	r30, r0
    316e:	82 81       	ldd	r24, Z+2	; 0x02
    3170:	93 81       	ldd	r25, Z+3	; 0x03
    3172:	e9 81       	ldd	r30, Y+1	; 0x01
    3174:	fa 81       	ldd	r31, Y+2	; 0x02
    3176:	92 83       	std	Z+2, r25	; 0x02
    3178:	81 83       	std	Z+1, r24	; 0x01
    317a:	e9 81       	ldd	r30, Y+1	; 0x01
    317c:	fa 81       	ldd	r31, Y+2	; 0x02
    317e:	01 80       	ldd	r0, Z+1	; 0x01
    3180:	f2 81       	ldd	r31, Z+2	; 0x02
    3182:	e0 2d       	mov	r30, r0
    3184:	86 81       	ldd	r24, Z+6	; 0x06
    3186:	97 81       	ldd	r25, Z+7	; 0x07
    3188:	90 93 a9 01 	sts	0x01A9, r25
    318c:	80 93 a8 01 	sts	0x01A8, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    3190:	e0 91 a8 01 	lds	r30, 0x01A8
    3194:	f0 91 a9 01 	lds	r31, 0x01A9
    3198:	40 81       	ld	r20, Z
    319a:	51 81       	ldd	r21, Z+1	; 0x01
    319c:	80 91 a8 01 	lds	r24, 0x01A8
    31a0:	90 91 a9 01 	lds	r25, 0x01A9
    31a4:	e0 91 a8 01 	lds	r30, 0x01A8
    31a8:	f0 91 a9 01 	lds	r31, 0x01A9
    31ac:	27 89       	ldd	r18, Z+23	; 0x17
    31ae:	62 2f       	mov	r22, r18
    31b0:	fa 01       	movw	r30, r20
    31b2:	09 95       	icall

	return;
}
    31b4:	0f 90       	pop	r0
    31b6:	0f 90       	pop	r0
    31b8:	cf 91       	pop	r28
    31ba:	df 91       	pop	r29
    31bc:	08 95       	ret

000031be <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    31be:	df 93       	push	r29
    31c0:	cf 93       	push	r28
    31c2:	0f 92       	push	r0
    31c4:	cd b7       	in	r28, 0x3d	; 61
    31c6:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    31c8:	19 82       	std	Y+1, r1	; 0x01
    31ca:	13 c0       	rjmp	.+38     	; 0x31f2 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    31cc:	89 81       	ldd	r24, Y+1	; 0x01
    31ce:	28 2f       	mov	r18, r24
    31d0:	30 e0       	ldi	r19, 0x00	; 0
    31d2:	c9 01       	movw	r24, r18
    31d4:	88 0f       	add	r24, r24
    31d6:	99 1f       	adc	r25, r25
    31d8:	88 0f       	add	r24, r24
    31da:	99 1f       	adc	r25, r25
    31dc:	88 0f       	add	r24, r24
    31de:	99 1f       	adc	r25, r25
    31e0:	82 0f       	add	r24, r18
    31e2:	93 1f       	adc	r25, r19
    31e4:	8f 54       	subi	r24, 0x4F	; 79
    31e6:	9e 4f       	sbci	r25, 0xFE	; 254
    31e8:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    31ec:	89 81       	ldd	r24, Y+1	; 0x01
    31ee:	8f 5f       	subi	r24, 0xFF	; 255
    31f0:	89 83       	std	Y+1, r24	; 0x01
    31f2:	89 81       	ldd	r24, Y+1	; 0x01
    31f4:	82 30       	cpi	r24, 0x02	; 2
    31f6:	50 f3       	brcs	.-44     	; 0x31cc <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    31f8:	83 ec       	ldi	r24, 0xC3	; 195
    31fa:	91 e0       	ldi	r25, 0x01	; 1
    31fc:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    3200:	8c ec       	ldi	r24, 0xCC	; 204
    3202:	91 e0       	ldi	r25, 0x01	; 1
    3204:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    3208:	89 ed       	ldi	r24, 0xD9	; 217
    320a:	91 e0       	ldi	r25, 0x01	; 1
    320c:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    3210:	83 ec       	ldi	r24, 0xC3	; 195
    3212:	91 e0       	ldi	r25, 0x01	; 1
    3214:	90 93 d6 01 	sts	0x01D6, r25
    3218:	80 93 d5 01 	sts	0x01D5, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    321c:	8c ec       	ldi	r24, 0xCC	; 204
    321e:	91 e0       	ldi	r25, 0x01	; 1
    3220:	90 93 d8 01 	sts	0x01D8, r25
    3224:	80 93 d7 01 	sts	0x01D7, r24
}
    3228:	0f 90       	pop	r0
    322a:	cf 91       	pop	r28
    322c:	df 91       	pop	r29
    322e:	08 95       	ret

00003230 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    3230:	df 93       	push	r29
    3232:	cf 93       	push	r28
    3234:	00 d0       	rcall	.+0      	; 0x3236 <xCoRoutineRemoveFromEventList+0x6>
    3236:	00 d0       	rcall	.+0      	; 0x3238 <xCoRoutineRemoveFromEventList+0x8>
    3238:	0f 92       	push	r0
    323a:	cd b7       	in	r28, 0x3d	; 61
    323c:	de b7       	in	r29, 0x3e	; 62
    323e:	9d 83       	std	Y+5, r25	; 0x05
    3240:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3242:	ec 81       	ldd	r30, Y+4	; 0x04
    3244:	fd 81       	ldd	r31, Y+5	; 0x05
    3246:	05 80       	ldd	r0, Z+5	; 0x05
    3248:	f6 81       	ldd	r31, Z+6	; 0x06
    324a:	e0 2d       	mov	r30, r0
    324c:	86 81       	ldd	r24, Z+6	; 0x06
    324e:	97 81       	ldd	r25, Z+7	; 0x07
    3250:	9b 83       	std	Y+3, r25	; 0x03
    3252:	8a 83       	std	Y+2, r24	; 0x02
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    3254:	8a 81       	ldd	r24, Y+2	; 0x02
    3256:	9b 81       	ldd	r25, Y+3	; 0x03
    3258:	0c 96       	adiw	r24, 0x0c	; 12
    325a:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    325e:	8a 81       	ldd	r24, Y+2	; 0x02
    3260:	9b 81       	ldd	r25, Y+3	; 0x03
    3262:	9c 01       	movw	r18, r24
    3264:	24 5f       	subi	r18, 0xF4	; 244
    3266:	3f 4f       	sbci	r19, 0xFF	; 255
    3268:	89 ed       	ldi	r24, 0xD9	; 217
    326a:	91 e0       	ldi	r25, 0x01	; 1
    326c:	b9 01       	movw	r22, r18
    326e:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    3272:	ea 81       	ldd	r30, Y+2	; 0x02
    3274:	fb 81       	ldd	r31, Y+3	; 0x03
    3276:	96 89       	ldd	r25, Z+22	; 0x16
    3278:	e0 91 a8 01 	lds	r30, 0x01A8
    327c:	f0 91 a9 01 	lds	r31, 0x01A9
    3280:	86 89       	ldd	r24, Z+22	; 0x16
    3282:	98 17       	cp	r25, r24
    3284:	18 f0       	brcs	.+6      	; 0x328c <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    3286:	81 e0       	ldi	r24, 0x01	; 1
    3288:	89 83       	std	Y+1, r24	; 0x01
    328a:	01 c0       	rjmp	.+2      	; 0x328e <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    328c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    328e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3290:	0f 90       	pop	r0
    3292:	0f 90       	pop	r0
    3294:	0f 90       	pop	r0
    3296:	0f 90       	pop	r0
    3298:	0f 90       	pop	r0
    329a:	cf 91       	pop	r28
    329c:	df 91       	pop	r29
    329e:	08 95       	ret

000032a0 <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    32a0:	df 93       	push	r29
    32a2:	cf 93       	push	r28
    32a4:	00 d0       	rcall	.+0      	; 0x32a6 <xEventGroupCreate+0x6>
    32a6:	cd b7       	in	r28, 0x3d	; 61
    32a8:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
    32aa:	8b e0       	ldi	r24, 0x0B	; 11
    32ac:	90 e0       	ldi	r25, 0x00	; 0
    32ae:	0e 94 90 1c 	call	0x3920	; 0x3920 <pvPortMalloc>
    32b2:	9a 83       	std	Y+2, r25	; 0x02
    32b4:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
    32b6:	89 81       	ldd	r24, Y+1	; 0x01
    32b8:	9a 81       	ldd	r25, Y+2	; 0x02
    32ba:	00 97       	sbiw	r24, 0x00	; 0
    32bc:	49 f0       	breq	.+18     	; 0x32d0 <xEventGroupCreate+0x30>
	{
		pxEventBits->uxEventBits = 0;
    32be:	e9 81       	ldd	r30, Y+1	; 0x01
    32c0:	fa 81       	ldd	r31, Y+2	; 0x02
    32c2:	11 82       	std	Z+1, r1	; 0x01
    32c4:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    32c6:	89 81       	ldd	r24, Y+1	; 0x01
    32c8:	9a 81       	ldd	r25, Y+2	; 0x02
    32ca:	02 96       	adiw	r24, 0x02	; 2
    32cc:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
    32d0:	89 81       	ldd	r24, Y+1	; 0x01
    32d2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    32d4:	0f 90       	pop	r0
    32d6:	0f 90       	pop	r0
    32d8:	cf 91       	pop	r28
    32da:	df 91       	pop	r29
    32dc:	08 95       	ret

000032de <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    32de:	df 93       	push	r29
    32e0:	cf 93       	push	r28
    32e2:	cd b7       	in	r28, 0x3d	; 61
    32e4:	de b7       	in	r29, 0x3e	; 62
    32e6:	60 97       	sbiw	r28, 0x10	; 16
    32e8:	0f b6       	in	r0, 0x3f	; 63
    32ea:	f8 94       	cli
    32ec:	de bf       	out	0x3e, r29	; 62
    32ee:	0f be       	out	0x3f, r0	; 63
    32f0:	cd bf       	out	0x3d, r28	; 61
    32f2:	9a 87       	std	Y+10, r25	; 0x0a
    32f4:	89 87       	std	Y+9, r24	; 0x09
    32f6:	7c 87       	std	Y+12, r23	; 0x0c
    32f8:	6b 87       	std	Y+11, r22	; 0x0b
    32fa:	5e 87       	std	Y+14, r21	; 0x0e
    32fc:	4d 87       	std	Y+13, r20	; 0x0d
    32fe:	38 8b       	std	Y+16, r19	; 0x10
    3300:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    3302:	89 85       	ldd	r24, Y+9	; 0x09
    3304:	9a 85       	ldd	r25, Y+10	; 0x0a
    3306:	9c 83       	std	Y+4, r25	; 0x04
    3308:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    330a:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    330c:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    3310:	eb 81       	ldd	r30, Y+3	; 0x03
    3312:	fc 81       	ldd	r31, Y+4	; 0x04
    3314:	80 81       	ld	r24, Z
    3316:	91 81       	ldd	r25, Z+1	; 0x01
    3318:	98 87       	std	Y+8, r25	; 0x08
    331a:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    331c:	89 85       	ldd	r24, Y+9	; 0x09
    331e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3320:	2b 85       	ldd	r18, Y+11	; 0x0b
    3322:	3c 85       	ldd	r19, Y+12	; 0x0c
    3324:	b9 01       	movw	r22, r18
    3326:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    332a:	2f 81       	ldd	r18, Y+7	; 0x07
    332c:	38 85       	ldd	r19, Y+8	; 0x08
    332e:	8b 85       	ldd	r24, Y+11	; 0x0b
    3330:	9c 85       	ldd	r25, Y+12	; 0x0c
    3332:	28 2b       	or	r18, r24
    3334:	39 2b       	or	r19, r25
    3336:	8d 85       	ldd	r24, Y+13	; 0x0d
    3338:	9e 85       	ldd	r25, Y+14	; 0x0e
    333a:	28 23       	and	r18, r24
    333c:	39 23       	and	r19, r25
    333e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3340:	9e 85       	ldd	r25, Y+14	; 0x0e
    3342:	28 17       	cp	r18, r24
    3344:	39 07       	cpc	r19, r25
    3346:	c9 f4       	brne	.+50     	; 0x337a <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    3348:	2f 81       	ldd	r18, Y+7	; 0x07
    334a:	38 85       	ldd	r19, Y+8	; 0x08
    334c:	8b 85       	ldd	r24, Y+11	; 0x0b
    334e:	9c 85       	ldd	r25, Y+12	; 0x0c
    3350:	82 2b       	or	r24, r18
    3352:	93 2b       	or	r25, r19
    3354:	9e 83       	std	Y+6, r25	; 0x06
    3356:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    3358:	eb 81       	ldd	r30, Y+3	; 0x03
    335a:	fc 81       	ldd	r31, Y+4	; 0x04
    335c:	20 81       	ld	r18, Z
    335e:	31 81       	ldd	r19, Z+1	; 0x01
    3360:	8d 85       	ldd	r24, Y+13	; 0x0d
    3362:	9e 85       	ldd	r25, Y+14	; 0x0e
    3364:	80 95       	com	r24
    3366:	90 95       	com	r25
    3368:	82 23       	and	r24, r18
    336a:	93 23       	and	r25, r19
    336c:	eb 81       	ldd	r30, Y+3	; 0x03
    336e:	fc 81       	ldd	r31, Y+4	; 0x04
    3370:	91 83       	std	Z+1, r25	; 0x01
    3372:	80 83       	st	Z, r24

			xTicksToWait = 0;
    3374:	18 8a       	std	Y+16, r1	; 0x10
    3376:	1f 86       	std	Y+15, r1	; 0x0f
    3378:	1c c0       	rjmp	.+56     	; 0x33b2 <xEventGroupSync+0xd4>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    337a:	8f 85       	ldd	r24, Y+15	; 0x0f
    337c:	98 89       	ldd	r25, Y+16	; 0x10
    337e:	00 97       	sbiw	r24, 0x00	; 0
    3380:	91 f0       	breq	.+36     	; 0x33a6 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    3382:	8b 81       	ldd	r24, Y+3	; 0x03
    3384:	9c 81       	ldd	r25, Y+4	; 0x04
    3386:	bc 01       	movw	r22, r24
    3388:	6e 5f       	subi	r22, 0xFE	; 254
    338a:	7f 4f       	sbci	r23, 0xFF	; 255
    338c:	8d 85       	ldd	r24, Y+13	; 0x0d
    338e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3390:	9c 01       	movw	r18, r24
    3392:	35 60       	ori	r19, 0x05	; 5
    3394:	4f 85       	ldd	r20, Y+15	; 0x0f
    3396:	58 89       	ldd	r21, Y+16	; 0x10
    3398:	cb 01       	movw	r24, r22
    339a:	b9 01       	movw	r22, r18
    339c:	0e 94 a2 2d 	call	0x5b44	; 0x5b44 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    33a0:	1e 82       	std	Y+6, r1	; 0x06
    33a2:	1d 82       	std	Y+5, r1	; 0x05
    33a4:	06 c0       	rjmp	.+12     	; 0x33b2 <xEventGroupSync+0xd4>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    33a6:	eb 81       	ldd	r30, Y+3	; 0x03
    33a8:	fc 81       	ldd	r31, Y+4	; 0x04
    33aa:	80 81       	ld	r24, Z
    33ac:	91 81       	ldd	r25, Z+1	; 0x01
    33ae:	9e 83       	std	Y+6, r25	; 0x06
    33b0:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    33b2:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>
    33b6:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    33b8:	8f 85       	ldd	r24, Y+15	; 0x0f
    33ba:	98 89       	ldd	r25, Y+16	; 0x10
    33bc:	00 97       	sbiw	r24, 0x00	; 0
    33be:	09 f4       	brne	.+2      	; 0x33c2 <xEventGroupSync+0xe4>
    33c0:	3a c0       	rjmp	.+116    	; 0x3436 <xEventGroupSync+0x158>
	{
		if( xAlreadyYielded == pdFALSE )
    33c2:	8a 81       	ldd	r24, Y+2	; 0x02
    33c4:	88 23       	and	r24, r24
    33c6:	11 f4       	brne	.+4      	; 0x33cc <xEventGroupSync+0xee>
		{
			portYIELD_WITHIN_API();
    33c8:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    33cc:	0e 94 1e 32 	call	0x643c	; 0x643c <uxTaskResetEventItemValue>
    33d0:	9e 83       	std	Y+6, r25	; 0x06
    33d2:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    33d4:	8d 81       	ldd	r24, Y+5	; 0x05
    33d6:	9e 81       	ldd	r25, Y+6	; 0x06
    33d8:	80 70       	andi	r24, 0x00	; 0
    33da:	92 70       	andi	r25, 0x02	; 2
    33dc:	00 97       	sbiw	r24, 0x00	; 0
    33de:	31 f5       	brne	.+76     	; 0x342c <xEventGroupSync+0x14e>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    33e0:	0f b6       	in	r0, 0x3f	; 63
    33e2:	f8 94       	cli
    33e4:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    33e6:	eb 81       	ldd	r30, Y+3	; 0x03
    33e8:	fc 81       	ldd	r31, Y+4	; 0x04
    33ea:	80 81       	ld	r24, Z
    33ec:	91 81       	ldd	r25, Z+1	; 0x01
    33ee:	9e 83       	std	Y+6, r25	; 0x06
    33f0:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    33f2:	2d 81       	ldd	r18, Y+5	; 0x05
    33f4:	3e 81       	ldd	r19, Y+6	; 0x06
    33f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    33f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    33fa:	28 23       	and	r18, r24
    33fc:	39 23       	and	r19, r25
    33fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    3400:	9e 85       	ldd	r25, Y+14	; 0x0e
    3402:	28 17       	cp	r18, r24
    3404:	39 07       	cpc	r19, r25
    3406:	71 f4       	brne	.+28     	; 0x3424 <xEventGroupSync+0x146>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    3408:	eb 81       	ldd	r30, Y+3	; 0x03
    340a:	fc 81       	ldd	r31, Y+4	; 0x04
    340c:	20 81       	ld	r18, Z
    340e:	31 81       	ldd	r19, Z+1	; 0x01
    3410:	8d 85       	ldd	r24, Y+13	; 0x0d
    3412:	9e 85       	ldd	r25, Y+14	; 0x0e
    3414:	80 95       	com	r24
    3416:	90 95       	com	r25
    3418:	82 23       	and	r24, r18
    341a:	93 23       	and	r25, r19
    341c:	eb 81       	ldd	r30, Y+3	; 0x03
    341e:	fc 81       	ldd	r31, Y+4	; 0x04
    3420:	91 83       	std	Z+1, r25	; 0x01
    3422:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3424:	0f 90       	pop	r0
    3426:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    3428:	81 e0       	ldi	r24, 0x01	; 1
    342a:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    342c:	8d 81       	ldd	r24, Y+5	; 0x05
    342e:	9e 81       	ldd	r25, Y+6	; 0x06
    3430:	90 70       	andi	r25, 0x00	; 0
    3432:	9e 83       	std	Y+6, r25	; 0x06
    3434:	8d 83       	std	Y+5, r24	; 0x05
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    3436:	8d 81       	ldd	r24, Y+5	; 0x05
    3438:	9e 81       	ldd	r25, Y+6	; 0x06
}
    343a:	60 96       	adiw	r28, 0x10	; 16
    343c:	0f b6       	in	r0, 0x3f	; 63
    343e:	f8 94       	cli
    3440:	de bf       	out	0x3e, r29	; 62
    3442:	0f be       	out	0x3f, r0	; 63
    3444:	cd bf       	out	0x3d, r28	; 61
    3446:	cf 91       	pop	r28
    3448:	df 91       	pop	r29
    344a:	08 95       	ret

0000344c <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    344c:	0f 93       	push	r16
    344e:	1f 93       	push	r17
    3450:	df 93       	push	r29
    3452:	cf 93       	push	r28
    3454:	cd b7       	in	r28, 0x3d	; 61
    3456:	de b7       	in	r29, 0x3e	; 62
    3458:	63 97       	sbiw	r28, 0x13	; 19
    345a:	0f b6       	in	r0, 0x3f	; 63
    345c:	f8 94       	cli
    345e:	de bf       	out	0x3e, r29	; 62
    3460:	0f be       	out	0x3f, r0	; 63
    3462:	cd bf       	out	0x3d, r28	; 61
    3464:	9d 87       	std	Y+13, r25	; 0x0d
    3466:	8c 87       	std	Y+12, r24	; 0x0c
    3468:	7f 87       	std	Y+15, r23	; 0x0f
    346a:	6e 87       	std	Y+14, r22	; 0x0e
    346c:	48 8b       	std	Y+16, r20	; 0x10
    346e:	29 8b       	std	Y+17, r18	; 0x11
    3470:	1b 8b       	std	Y+19, r17	; 0x13
    3472:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    3474:	8c 85       	ldd	r24, Y+12	; 0x0c
    3476:	9d 85       	ldd	r25, Y+13	; 0x0d
    3478:	9b 87       	std	Y+11, r25	; 0x0b
    347a:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    347c:	1f 82       	std	Y+7, r1	; 0x07
    347e:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    3480:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    3482:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    3486:	ea 85       	ldd	r30, Y+10	; 0x0a
    3488:	fb 85       	ldd	r31, Y+11	; 0x0b
    348a:	80 81       	ld	r24, Z
    348c:	91 81       	ldd	r25, Z+1	; 0x01
    348e:	9a 83       	std	Y+2, r25	; 0x02
    3490:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    3492:	89 81       	ldd	r24, Y+1	; 0x01
    3494:	9a 81       	ldd	r25, Y+2	; 0x02
    3496:	2e 85       	ldd	r18, Y+14	; 0x0e
    3498:	3f 85       	ldd	r19, Y+15	; 0x0f
    349a:	b9 01       	movw	r22, r18
    349c:	49 89       	ldd	r20, Y+17	; 0x11
    349e:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <prvTestWaitCondition>
    34a2:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    34a4:	8d 81       	ldd	r24, Y+5	; 0x05
    34a6:	88 23       	and	r24, r24
    34a8:	c1 f0       	breq	.+48     	; 0x34da <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    34aa:	89 81       	ldd	r24, Y+1	; 0x01
    34ac:	9a 81       	ldd	r25, Y+2	; 0x02
    34ae:	99 87       	std	Y+9, r25	; 0x09
    34b0:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    34b2:	1b 8a       	std	Y+19, r1	; 0x13
    34b4:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    34b6:	88 89       	ldd	r24, Y+16	; 0x10
    34b8:	88 23       	and	r24, r24
    34ba:	d9 f1       	breq	.+118    	; 0x3532 <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    34bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    34be:	fb 85       	ldd	r31, Y+11	; 0x0b
    34c0:	20 81       	ld	r18, Z
    34c2:	31 81       	ldd	r19, Z+1	; 0x01
    34c4:	8e 85       	ldd	r24, Y+14	; 0x0e
    34c6:	9f 85       	ldd	r25, Y+15	; 0x0f
    34c8:	80 95       	com	r24
    34ca:	90 95       	com	r25
    34cc:	82 23       	and	r24, r18
    34ce:	93 23       	and	r25, r19
    34d0:	ea 85       	ldd	r30, Y+10	; 0x0a
    34d2:	fb 85       	ldd	r31, Y+11	; 0x0b
    34d4:	91 83       	std	Z+1, r25	; 0x01
    34d6:	80 83       	st	Z, r24
    34d8:	2c c0       	rjmp	.+88     	; 0x3532 <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    34da:	8a 89       	ldd	r24, Y+18	; 0x12
    34dc:	9b 89       	ldd	r25, Y+19	; 0x13
    34de:	00 97       	sbiw	r24, 0x00	; 0
    34e0:	29 f4       	brne	.+10     	; 0x34ec <xEventGroupWaitBits+0xa0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    34e2:	89 81       	ldd	r24, Y+1	; 0x01
    34e4:	9a 81       	ldd	r25, Y+2	; 0x02
    34e6:	99 87       	std	Y+9, r25	; 0x09
    34e8:	88 87       	std	Y+8, r24	; 0x08
    34ea:	23 c0       	rjmp	.+70     	; 0x3532 <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    34ec:	88 89       	ldd	r24, Y+16	; 0x10
    34ee:	88 23       	and	r24, r24
    34f0:	29 f0       	breq	.+10     	; 0x34fc <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    34f2:	8e 81       	ldd	r24, Y+6	; 0x06
    34f4:	9f 81       	ldd	r25, Y+7	; 0x07
    34f6:	91 60       	ori	r25, 0x01	; 1
    34f8:	9f 83       	std	Y+7, r25	; 0x07
    34fa:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    34fc:	89 89       	ldd	r24, Y+17	; 0x11
    34fe:	88 23       	and	r24, r24
    3500:	29 f0       	breq	.+10     	; 0x350c <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    3502:	8e 81       	ldd	r24, Y+6	; 0x06
    3504:	9f 81       	ldd	r25, Y+7	; 0x07
    3506:	94 60       	ori	r25, 0x04	; 4
    3508:	9f 83       	std	Y+7, r25	; 0x07
    350a:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    350c:	8a 85       	ldd	r24, Y+10	; 0x0a
    350e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3510:	bc 01       	movw	r22, r24
    3512:	6e 5f       	subi	r22, 0xFE	; 254
    3514:	7f 4f       	sbci	r23, 0xFF	; 255
    3516:	2e 85       	ldd	r18, Y+14	; 0x0e
    3518:	3f 85       	ldd	r19, Y+15	; 0x0f
    351a:	8e 81       	ldd	r24, Y+6	; 0x06
    351c:	9f 81       	ldd	r25, Y+7	; 0x07
    351e:	28 2b       	or	r18, r24
    3520:	39 2b       	or	r19, r25
    3522:	4a 89       	ldd	r20, Y+18	; 0x12
    3524:	5b 89       	ldd	r21, Y+19	; 0x13
    3526:	cb 01       	movw	r24, r22
    3528:	b9 01       	movw	r22, r18
    352a:	0e 94 a2 2d 	call	0x5b44	; 0x5b44 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    352e:	19 86       	std	Y+9, r1	; 0x09
    3530:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    3532:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>
    3536:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    3538:	8a 89       	ldd	r24, Y+18	; 0x12
    353a:	9b 89       	ldd	r25, Y+19	; 0x13
    353c:	00 97       	sbiw	r24, 0x00	; 0
    353e:	09 f4       	brne	.+2      	; 0x3542 <xEventGroupWaitBits+0xf6>
    3540:	3b c0       	rjmp	.+118    	; 0x35b8 <xEventGroupWaitBits+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
    3542:	8c 81       	ldd	r24, Y+4	; 0x04
    3544:	88 23       	and	r24, r24
    3546:	11 f4       	brne	.+4      	; 0x354c <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
    3548:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    354c:	0e 94 1e 32 	call	0x643c	; 0x643c <uxTaskResetEventItemValue>
    3550:	99 87       	std	Y+9, r25	; 0x09
    3552:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    3554:	88 85       	ldd	r24, Y+8	; 0x08
    3556:	99 85       	ldd	r25, Y+9	; 0x09
    3558:	80 70       	andi	r24, 0x00	; 0
    355a:	92 70       	andi	r25, 0x02	; 2
    355c:	00 97       	sbiw	r24, 0x00	; 0
    355e:	39 f5       	brne	.+78     	; 0x35ae <xEventGroupWaitBits+0x162>
		{
			taskENTER_CRITICAL();
    3560:	0f b6       	in	r0, 0x3f	; 63
    3562:	f8 94       	cli
    3564:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    3566:	ea 85       	ldd	r30, Y+10	; 0x0a
    3568:	fb 85       	ldd	r31, Y+11	; 0x0b
    356a:	80 81       	ld	r24, Z
    356c:	91 81       	ldd	r25, Z+1	; 0x01
    356e:	99 87       	std	Y+9, r25	; 0x09
    3570:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    3572:	88 85       	ldd	r24, Y+8	; 0x08
    3574:	99 85       	ldd	r25, Y+9	; 0x09
    3576:	2e 85       	ldd	r18, Y+14	; 0x0e
    3578:	3f 85       	ldd	r19, Y+15	; 0x0f
    357a:	b9 01       	movw	r22, r18
    357c:	49 89       	ldd	r20, Y+17	; 0x11
    357e:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <prvTestWaitCondition>
    3582:	88 23       	and	r24, r24
    3584:	89 f0       	breq	.+34     	; 0x35a8 <xEventGroupWaitBits+0x15c>
				{
					if( xClearOnExit != pdFALSE )
    3586:	88 89       	ldd	r24, Y+16	; 0x10
    3588:	88 23       	and	r24, r24
    358a:	71 f0       	breq	.+28     	; 0x35a8 <xEventGroupWaitBits+0x15c>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    358c:	ea 85       	ldd	r30, Y+10	; 0x0a
    358e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3590:	20 81       	ld	r18, Z
    3592:	31 81       	ldd	r19, Z+1	; 0x01
    3594:	8e 85       	ldd	r24, Y+14	; 0x0e
    3596:	9f 85       	ldd	r25, Y+15	; 0x0f
    3598:	80 95       	com	r24
    359a:	90 95       	com	r25
    359c:	82 23       	and	r24, r18
    359e:	93 23       	and	r25, r19
    35a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    35a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    35a4:	91 83       	std	Z+1, r25	; 0x01
    35a6:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    35a8:	0f 90       	pop	r0
    35aa:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    35ac:	1b 82       	std	Y+3, r1	; 0x03
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    35ae:	88 85       	ldd	r24, Y+8	; 0x08
    35b0:	99 85       	ldd	r25, Y+9	; 0x09
    35b2:	90 70       	andi	r25, 0x00	; 0
    35b4:	99 87       	std	Y+9, r25	; 0x09
    35b6:	88 87       	std	Y+8, r24	; 0x08
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    35b8:	88 85       	ldd	r24, Y+8	; 0x08
    35ba:	99 85       	ldd	r25, Y+9	; 0x09
}
    35bc:	63 96       	adiw	r28, 0x13	; 19
    35be:	0f b6       	in	r0, 0x3f	; 63
    35c0:	f8 94       	cli
    35c2:	de bf       	out	0x3e, r29	; 62
    35c4:	0f be       	out	0x3f, r0	; 63
    35c6:	cd bf       	out	0x3d, r28	; 61
    35c8:	cf 91       	pop	r28
    35ca:	df 91       	pop	r29
    35cc:	1f 91       	pop	r17
    35ce:	0f 91       	pop	r16
    35d0:	08 95       	ret

000035d2 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    35d2:	df 93       	push	r29
    35d4:	cf 93       	push	r28
    35d6:	cd b7       	in	r28, 0x3d	; 61
    35d8:	de b7       	in	r29, 0x3e	; 62
    35da:	28 97       	sbiw	r28, 0x08	; 8
    35dc:	0f b6       	in	r0, 0x3f	; 63
    35de:	f8 94       	cli
    35e0:	de bf       	out	0x3e, r29	; 62
    35e2:	0f be       	out	0x3f, r0	; 63
    35e4:	cd bf       	out	0x3d, r28	; 61
    35e6:	9e 83       	std	Y+6, r25	; 0x06
    35e8:	8d 83       	std	Y+5, r24	; 0x05
    35ea:	78 87       	std	Y+8, r23	; 0x08
    35ec:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    35ee:	8d 81       	ldd	r24, Y+5	; 0x05
    35f0:	9e 81       	ldd	r25, Y+6	; 0x06
    35f2:	9c 83       	std	Y+4, r25	; 0x04
    35f4:	8b 83       	std	Y+3, r24	; 0x03

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    35f6:	0f b6       	in	r0, 0x3f	; 63
    35f8:	f8 94       	cli
    35fa:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    35fc:	eb 81       	ldd	r30, Y+3	; 0x03
    35fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3600:	80 81       	ld	r24, Z
    3602:	91 81       	ldd	r25, Z+1	; 0x01
    3604:	9a 83       	std	Y+2, r25	; 0x02
    3606:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    3608:	eb 81       	ldd	r30, Y+3	; 0x03
    360a:	fc 81       	ldd	r31, Y+4	; 0x04
    360c:	20 81       	ld	r18, Z
    360e:	31 81       	ldd	r19, Z+1	; 0x01
    3610:	8f 81       	ldd	r24, Y+7	; 0x07
    3612:	98 85       	ldd	r25, Y+8	; 0x08
    3614:	80 95       	com	r24
    3616:	90 95       	com	r25
    3618:	82 23       	and	r24, r18
    361a:	93 23       	and	r25, r19
    361c:	eb 81       	ldd	r30, Y+3	; 0x03
    361e:	fc 81       	ldd	r31, Y+4	; 0x04
    3620:	91 83       	std	Z+1, r25	; 0x01
    3622:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    3624:	0f 90       	pop	r0
    3626:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3628:	89 81       	ldd	r24, Y+1	; 0x01
    362a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    362c:	28 96       	adiw	r28, 0x08	; 8
    362e:	0f b6       	in	r0, 0x3f	; 63
    3630:	f8 94       	cli
    3632:	de bf       	out	0x3e, r29	; 62
    3634:	0f be       	out	0x3f, r0	; 63
    3636:	cd bf       	out	0x3d, r28	; 61
    3638:	cf 91       	pop	r28
    363a:	df 91       	pop	r29
    363c:	08 95       	ret

0000363e <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    363e:	df 93       	push	r29
    3640:	cf 93       	push	r28
    3642:	cd b7       	in	r28, 0x3d	; 61
    3644:	de b7       	in	r29, 0x3e	; 62
    3646:	27 97       	sbiw	r28, 0x07	; 7
    3648:	0f b6       	in	r0, 0x3f	; 63
    364a:	f8 94       	cli
    364c:	de bf       	out	0x3e, r29	; 62
    364e:	0f be       	out	0x3f, r0	; 63
    3650:	cd bf       	out	0x3d, r28	; 61
    3652:	9f 83       	std	Y+7, r25	; 0x07
    3654:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    3656:	8e 81       	ldd	r24, Y+6	; 0x06
    3658:	9f 81       	ldd	r25, Y+7	; 0x07
    365a:	9c 83       	std	Y+4, r25	; 0x04
    365c:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    365e:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    3660:	eb 81       	ldd	r30, Y+3	; 0x03
    3662:	fc 81       	ldd	r31, Y+4	; 0x04
    3664:	80 81       	ld	r24, Z
    3666:	91 81       	ldd	r25, Z+1	; 0x01
    3668:	9a 83       	std	Y+2, r25	; 0x02
    366a:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    366c:	89 81       	ldd	r24, Y+1	; 0x01
    366e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3670:	27 96       	adiw	r28, 0x07	; 7
    3672:	0f b6       	in	r0, 0x3f	; 63
    3674:	f8 94       	cli
    3676:	de bf       	out	0x3e, r29	; 62
    3678:	0f be       	out	0x3f, r0	; 63
    367a:	cd bf       	out	0x3d, r28	; 61
    367c:	cf 91       	pop	r28
    367e:	df 91       	pop	r29
    3680:	08 95       	ret

00003682 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    3682:	df 93       	push	r29
    3684:	cf 93       	push	r28
    3686:	cd b7       	in	r28, 0x3d	; 61
    3688:	de b7       	in	r29, 0x3e	; 62
    368a:	65 97       	sbiw	r28, 0x15	; 21
    368c:	0f b6       	in	r0, 0x3f	; 63
    368e:	f8 94       	cli
    3690:	de bf       	out	0x3e, r29	; 62
    3692:	0f be       	out	0x3f, r0	; 63
    3694:	cd bf       	out	0x3d, r28	; 61
    3696:	9b 8b       	std	Y+19, r25	; 0x13
    3698:	8a 8b       	std	Y+18, r24	; 0x12
    369a:	7d 8b       	std	Y+21, r23	; 0x15
    369c:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    369e:	19 86       	std	Y+9, r1	; 0x09
    36a0:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    36a2:	8a 89       	ldd	r24, Y+18	; 0x12
    36a4:	9b 89       	ldd	r25, Y+19	; 0x13
    36a6:	9b 83       	std	Y+3, r25	; 0x03
    36a8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    36aa:	19 82       	std	Y+1, r1	; 0x01

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    36ac:	8a 81       	ldd	r24, Y+2	; 0x02
    36ae:	9b 81       	ldd	r25, Y+3	; 0x03
    36b0:	02 96       	adiw	r24, 0x02	; 2
    36b2:	9b 87       	std	Y+11, r25	; 0x0b
    36b4:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    36b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    36b8:	9b 85       	ldd	r25, Y+11	; 0x0b
    36ba:	03 96       	adiw	r24, 0x03	; 3
    36bc:	9d 87       	std	Y+13, r25	; 0x0d
    36be:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    36c0:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    36c4:	ea 85       	ldd	r30, Y+10	; 0x0a
    36c6:	fb 85       	ldd	r31, Y+11	; 0x0b
    36c8:	85 81       	ldd	r24, Z+5	; 0x05
    36ca:	96 81       	ldd	r25, Z+6	; 0x06
    36cc:	99 8b       	std	Y+17, r25	; 0x11
    36ce:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    36d0:	ea 81       	ldd	r30, Y+2	; 0x02
    36d2:	fb 81       	ldd	r31, Y+3	; 0x03
    36d4:	20 81       	ld	r18, Z
    36d6:	31 81       	ldd	r19, Z+1	; 0x01
    36d8:	8c 89       	ldd	r24, Y+20	; 0x14
    36da:	9d 89       	ldd	r25, Y+21	; 0x15
    36dc:	82 2b       	or	r24, r18
    36de:	93 2b       	or	r25, r19
    36e0:	ea 81       	ldd	r30, Y+2	; 0x02
    36e2:	fb 81       	ldd	r31, Y+3	; 0x03
    36e4:	91 83       	std	Z+1, r25	; 0x01
    36e6:	80 83       	st	Z, r24
    36e8:	59 c0       	rjmp	.+178    	; 0x379c <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    36ea:	e8 89       	ldd	r30, Y+16	; 0x10
    36ec:	f9 89       	ldd	r31, Y+17	; 0x11
    36ee:	82 81       	ldd	r24, Z+2	; 0x02
    36f0:	93 81       	ldd	r25, Z+3	; 0x03
    36f2:	9f 87       	std	Y+15, r25	; 0x0f
    36f4:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    36f6:	e8 89       	ldd	r30, Y+16	; 0x10
    36f8:	f9 89       	ldd	r31, Y+17	; 0x11
    36fa:	80 81       	ld	r24, Z
    36fc:	91 81       	ldd	r25, Z+1	; 0x01
    36fe:	9f 83       	std	Y+7, r25	; 0x07
    3700:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    3702:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    3704:	8e 81       	ldd	r24, Y+6	; 0x06
    3706:	9f 81       	ldd	r25, Y+7	; 0x07
    3708:	80 70       	andi	r24, 0x00	; 0
    370a:	9d 83       	std	Y+5, r25	; 0x05
    370c:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    370e:	8e 81       	ldd	r24, Y+6	; 0x06
    3710:	9f 81       	ldd	r25, Y+7	; 0x07
    3712:	90 70       	andi	r25, 0x00	; 0
    3714:	9f 83       	std	Y+7, r25	; 0x07
    3716:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    3718:	8c 81       	ldd	r24, Y+4	; 0x04
    371a:	9d 81       	ldd	r25, Y+5	; 0x05
    371c:	80 70       	andi	r24, 0x00	; 0
    371e:	94 70       	andi	r25, 0x04	; 4
    3720:	00 97       	sbiw	r24, 0x00	; 0
    3722:	69 f4       	brne	.+26     	; 0x373e <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    3724:	ea 81       	ldd	r30, Y+2	; 0x02
    3726:	fb 81       	ldd	r31, Y+3	; 0x03
    3728:	20 81       	ld	r18, Z
    372a:	31 81       	ldd	r19, Z+1	; 0x01
    372c:	8e 81       	ldd	r24, Y+6	; 0x06
    372e:	9f 81       	ldd	r25, Y+7	; 0x07
    3730:	82 23       	and	r24, r18
    3732:	93 23       	and	r25, r19
    3734:	00 97       	sbiw	r24, 0x00	; 0
    3736:	91 f0       	breq	.+36     	; 0x375c <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    3738:	81 e0       	ldi	r24, 0x01	; 1
    373a:	89 83       	std	Y+1, r24	; 0x01
    373c:	0f c0       	rjmp	.+30     	; 0x375c <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    373e:	ea 81       	ldd	r30, Y+2	; 0x02
    3740:	fb 81       	ldd	r31, Y+3	; 0x03
    3742:	20 81       	ld	r18, Z
    3744:	31 81       	ldd	r19, Z+1	; 0x01
    3746:	8e 81       	ldd	r24, Y+6	; 0x06
    3748:	9f 81       	ldd	r25, Y+7	; 0x07
    374a:	28 23       	and	r18, r24
    374c:	39 23       	and	r19, r25
    374e:	8e 81       	ldd	r24, Y+6	; 0x06
    3750:	9f 81       	ldd	r25, Y+7	; 0x07
    3752:	28 17       	cp	r18, r24
    3754:	39 07       	cpc	r19, r25
    3756:	11 f4       	brne	.+4      	; 0x375c <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    3758:	81 e0       	ldi	r24, 0x01	; 1
    375a:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    375c:	89 81       	ldd	r24, Y+1	; 0x01
    375e:	88 23       	and	r24, r24
    3760:	c9 f0       	breq	.+50     	; 0x3794 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    3762:	8c 81       	ldd	r24, Y+4	; 0x04
    3764:	9d 81       	ldd	r25, Y+5	; 0x05
    3766:	80 70       	andi	r24, 0x00	; 0
    3768:	91 70       	andi	r25, 0x01	; 1
    376a:	00 97       	sbiw	r24, 0x00	; 0
    376c:	41 f0       	breq	.+16     	; 0x377e <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    376e:	88 85       	ldd	r24, Y+8	; 0x08
    3770:	99 85       	ldd	r25, Y+9	; 0x09
    3772:	2e 81       	ldd	r18, Y+6	; 0x06
    3774:	3f 81       	ldd	r19, Y+7	; 0x07
    3776:	82 2b       	or	r24, r18
    3778:	93 2b       	or	r25, r19
    377a:	99 87       	std	Y+9, r25	; 0x09
    377c:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    377e:	ea 81       	ldd	r30, Y+2	; 0x02
    3780:	fb 81       	ldd	r31, Y+3	; 0x03
    3782:	80 81       	ld	r24, Z
    3784:	91 81       	ldd	r25, Z+1	; 0x01
    3786:	9c 01       	movw	r18, r24
    3788:	32 60       	ori	r19, 0x02	; 2
    378a:	88 89       	ldd	r24, Y+16	; 0x10
    378c:	99 89       	ldd	r25, Y+17	; 0x11
    378e:	b9 01       	movw	r22, r18
    3790:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    3794:	8e 85       	ldd	r24, Y+14	; 0x0e
    3796:	9f 85       	ldd	r25, Y+15	; 0x0f
    3798:	99 8b       	std	Y+17, r25	; 0x11
    379a:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    379c:	28 89       	ldd	r18, Y+16	; 0x10
    379e:	39 89       	ldd	r19, Y+17	; 0x11
    37a0:	8c 85       	ldd	r24, Y+12	; 0x0c
    37a2:	9d 85       	ldd	r25, Y+13	; 0x0d
    37a4:	28 17       	cp	r18, r24
    37a6:	39 07       	cpc	r19, r25
    37a8:	09 f0       	breq	.+2      	; 0x37ac <xEventGroupSetBits+0x12a>
    37aa:	9f cf       	rjmp	.-194    	; 0x36ea <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    37ac:	ea 81       	ldd	r30, Y+2	; 0x02
    37ae:	fb 81       	ldd	r31, Y+3	; 0x03
    37b0:	20 81       	ld	r18, Z
    37b2:	31 81       	ldd	r19, Z+1	; 0x01
    37b4:	88 85       	ldd	r24, Y+8	; 0x08
    37b6:	99 85       	ldd	r25, Y+9	; 0x09
    37b8:	80 95       	com	r24
    37ba:	90 95       	com	r25
    37bc:	82 23       	and	r24, r18
    37be:	93 23       	and	r25, r19
    37c0:	ea 81       	ldd	r30, Y+2	; 0x02
    37c2:	fb 81       	ldd	r31, Y+3	; 0x03
    37c4:	91 83       	std	Z+1, r25	; 0x01
    37c6:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    37c8:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    37cc:	ea 81       	ldd	r30, Y+2	; 0x02
    37ce:	fb 81       	ldd	r31, Y+3	; 0x03
    37d0:	80 81       	ld	r24, Z
    37d2:	91 81       	ldd	r25, Z+1	; 0x01
}
    37d4:	65 96       	adiw	r28, 0x15	; 21
    37d6:	0f b6       	in	r0, 0x3f	; 63
    37d8:	f8 94       	cli
    37da:	de bf       	out	0x3e, r29	; 62
    37dc:	0f be       	out	0x3f, r0	; 63
    37de:	cd bf       	out	0x3d, r28	; 61
    37e0:	cf 91       	pop	r28
    37e2:	df 91       	pop	r29
    37e4:	08 95       	ret

000037e6 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    37e6:	df 93       	push	r29
    37e8:	cf 93       	push	r28
    37ea:	00 d0       	rcall	.+0      	; 0x37ec <vEventGroupDelete+0x6>
    37ec:	00 d0       	rcall	.+0      	; 0x37ee <vEventGroupDelete+0x8>
    37ee:	00 d0       	rcall	.+0      	; 0x37f0 <vEventGroupDelete+0xa>
    37f0:	cd b7       	in	r28, 0x3d	; 61
    37f2:	de b7       	in	r29, 0x3e	; 62
    37f4:	9e 83       	std	Y+6, r25	; 0x06
    37f6:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    37f8:	8d 81       	ldd	r24, Y+5	; 0x05
    37fa:	9e 81       	ldd	r25, Y+6	; 0x06
    37fc:	9c 83       	std	Y+4, r25	; 0x04
    37fe:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    3800:	8b 81       	ldd	r24, Y+3	; 0x03
    3802:	9c 81       	ldd	r25, Y+4	; 0x04
    3804:	02 96       	adiw	r24, 0x02	; 2
    3806:	9a 83       	std	Y+2, r25	; 0x02
    3808:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    380a:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
    380e:	08 c0       	rjmp	.+16     	; 0x3820 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    3810:	e9 81       	ldd	r30, Y+1	; 0x01
    3812:	fa 81       	ldd	r31, Y+2	; 0x02
    3814:	85 81       	ldd	r24, Z+5	; 0x05
    3816:	96 81       	ldd	r25, Z+6	; 0x06
    3818:	60 e0       	ldi	r22, 0x00	; 0
    381a:	72 e0       	ldi	r23, 0x02	; 2
    381c:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    3820:	e9 81       	ldd	r30, Y+1	; 0x01
    3822:	fa 81       	ldd	r31, Y+2	; 0x02
    3824:	80 81       	ld	r24, Z
    3826:	88 23       	and	r24, r24
    3828:	99 f7       	brne	.-26     	; 0x3810 <vEventGroupDelete+0x2a>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    382a:	8b 81       	ldd	r24, Y+3	; 0x03
    382c:	9c 81       	ldd	r25, Y+4	; 0x04
    382e:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <vPortFree>
	}
	( void ) xTaskResumeAll();
    3832:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>
}
    3836:	26 96       	adiw	r28, 0x06	; 6
    3838:	0f b6       	in	r0, 0x3f	; 63
    383a:	f8 94       	cli
    383c:	de bf       	out	0x3e, r29	; 62
    383e:	0f be       	out	0x3f, r0	; 63
    3840:	cd bf       	out	0x3d, r28	; 61
    3842:	cf 91       	pop	r28
    3844:	df 91       	pop	r29
    3846:	08 95       	ret

00003848 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    3848:	df 93       	push	r29
    384a:	cf 93       	push	r28
    384c:	00 d0       	rcall	.+0      	; 0x384e <vEventGroupSetBitsCallback+0x6>
    384e:	00 d0       	rcall	.+0      	; 0x3850 <vEventGroupSetBitsCallback+0x8>
    3850:	00 d0       	rcall	.+0      	; 0x3852 <vEventGroupSetBitsCallback+0xa>
    3852:	cd b7       	in	r28, 0x3d	; 61
    3854:	de b7       	in	r29, 0x3e	; 62
    3856:	9a 83       	std	Y+2, r25	; 0x02
    3858:	89 83       	std	Y+1, r24	; 0x01
    385a:	4b 83       	std	Y+3, r20	; 0x03
    385c:	5c 83       	std	Y+4, r21	; 0x04
    385e:	6d 83       	std	Y+5, r22	; 0x05
    3860:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    3862:	2b 81       	ldd	r18, Y+3	; 0x03
    3864:	3c 81       	ldd	r19, Y+4	; 0x04
    3866:	89 81       	ldd	r24, Y+1	; 0x01
    3868:	9a 81       	ldd	r25, Y+2	; 0x02
    386a:	b9 01       	movw	r22, r18
    386c:	0e 94 41 1b 	call	0x3682	; 0x3682 <xEventGroupSetBits>
}
    3870:	26 96       	adiw	r28, 0x06	; 6
    3872:	0f b6       	in	r0, 0x3f	; 63
    3874:	f8 94       	cli
    3876:	de bf       	out	0x3e, r29	; 62
    3878:	0f be       	out	0x3f, r0	; 63
    387a:	cd bf       	out	0x3d, r28	; 61
    387c:	cf 91       	pop	r28
    387e:	df 91       	pop	r29
    3880:	08 95       	ret

00003882 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    3882:	df 93       	push	r29
    3884:	cf 93       	push	r28
    3886:	00 d0       	rcall	.+0      	; 0x3888 <vEventGroupClearBitsCallback+0x6>
    3888:	00 d0       	rcall	.+0      	; 0x388a <vEventGroupClearBitsCallback+0x8>
    388a:	00 d0       	rcall	.+0      	; 0x388c <vEventGroupClearBitsCallback+0xa>
    388c:	cd b7       	in	r28, 0x3d	; 61
    388e:	de b7       	in	r29, 0x3e	; 62
    3890:	9a 83       	std	Y+2, r25	; 0x02
    3892:	89 83       	std	Y+1, r24	; 0x01
    3894:	4b 83       	std	Y+3, r20	; 0x03
    3896:	5c 83       	std	Y+4, r21	; 0x04
    3898:	6d 83       	std	Y+5, r22	; 0x05
    389a:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    389c:	2b 81       	ldd	r18, Y+3	; 0x03
    389e:	3c 81       	ldd	r19, Y+4	; 0x04
    38a0:	89 81       	ldd	r24, Y+1	; 0x01
    38a2:	9a 81       	ldd	r25, Y+2	; 0x02
    38a4:	b9 01       	movw	r22, r18
    38a6:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <xEventGroupClearBits>
}
    38aa:	26 96       	adiw	r28, 0x06	; 6
    38ac:	0f b6       	in	r0, 0x3f	; 63
    38ae:	f8 94       	cli
    38b0:	de bf       	out	0x3e, r29	; 62
    38b2:	0f be       	out	0x3f, r0	; 63
    38b4:	cd bf       	out	0x3d, r28	; 61
    38b6:	cf 91       	pop	r28
    38b8:	df 91       	pop	r29
    38ba:	08 95       	ret

000038bc <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    38bc:	df 93       	push	r29
    38be:	cf 93       	push	r28
    38c0:	00 d0       	rcall	.+0      	; 0x38c2 <prvTestWaitCondition+0x6>
    38c2:	00 d0       	rcall	.+0      	; 0x38c4 <prvTestWaitCondition+0x8>
    38c4:	00 d0       	rcall	.+0      	; 0x38c6 <prvTestWaitCondition+0xa>
    38c6:	cd b7       	in	r28, 0x3d	; 61
    38c8:	de b7       	in	r29, 0x3e	; 62
    38ca:	9b 83       	std	Y+3, r25	; 0x03
    38cc:	8a 83       	std	Y+2, r24	; 0x02
    38ce:	7d 83       	std	Y+5, r23	; 0x05
    38d0:	6c 83       	std	Y+4, r22	; 0x04
    38d2:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    38d4:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    38d6:	8e 81       	ldd	r24, Y+6	; 0x06
    38d8:	88 23       	and	r24, r24
    38da:	59 f4       	brne	.+22     	; 0x38f2 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    38dc:	8a 81       	ldd	r24, Y+2	; 0x02
    38de:	9b 81       	ldd	r25, Y+3	; 0x03
    38e0:	2c 81       	ldd	r18, Y+4	; 0x04
    38e2:	3d 81       	ldd	r19, Y+5	; 0x05
    38e4:	82 23       	and	r24, r18
    38e6:	93 23       	and	r25, r19
    38e8:	00 97       	sbiw	r24, 0x00	; 0
    38ea:	81 f0       	breq	.+32     	; 0x390c <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    38ec:	81 e0       	ldi	r24, 0x01	; 1
    38ee:	89 83       	std	Y+1, r24	; 0x01
    38f0:	0d c0       	rjmp	.+26     	; 0x390c <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    38f2:	2a 81       	ldd	r18, Y+2	; 0x02
    38f4:	3b 81       	ldd	r19, Y+3	; 0x03
    38f6:	8c 81       	ldd	r24, Y+4	; 0x04
    38f8:	9d 81       	ldd	r25, Y+5	; 0x05
    38fa:	28 23       	and	r18, r24
    38fc:	39 23       	and	r19, r25
    38fe:	8c 81       	ldd	r24, Y+4	; 0x04
    3900:	9d 81       	ldd	r25, Y+5	; 0x05
    3902:	28 17       	cp	r18, r24
    3904:	39 07       	cpc	r19, r25
    3906:	11 f4       	brne	.+4      	; 0x390c <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    3908:	81 e0       	ldi	r24, 0x01	; 1
    390a:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    390c:	89 81       	ldd	r24, Y+1	; 0x01
}
    390e:	26 96       	adiw	r28, 0x06	; 6
    3910:	0f b6       	in	r0, 0x3f	; 63
    3912:	f8 94       	cli
    3914:	de bf       	out	0x3e, r29	; 62
    3916:	0f be       	out	0x3f, r0	; 63
    3918:	cd bf       	out	0x3d, r28	; 61
    391a:	cf 91       	pop	r28
    391c:	df 91       	pop	r29
    391e:	08 95       	ret

00003920 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3920:	df 93       	push	r29
    3922:	cf 93       	push	r28
    3924:	00 d0       	rcall	.+0      	; 0x3926 <pvPortMalloc+0x6>
    3926:	00 d0       	rcall	.+0      	; 0x3928 <pvPortMalloc+0x8>
    3928:	cd b7       	in	r28, 0x3d	; 61
    392a:	de b7       	in	r29, 0x3e	; 62
    392c:	9c 83       	std	Y+4, r25	; 0x04
    392e:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    3930:	1a 82       	std	Y+2, r1	; 0x02
    3932:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    3934:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    3938:	80 91 e4 01 	lds	r24, 0x01E4
    393c:	90 91 e5 01 	lds	r25, 0x01E5
    3940:	00 97       	sbiw	r24, 0x00	; 0
    3942:	31 f4       	brne	.+12     	; 0x3950 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    3944:	87 ee       	ldi	r24, 0xE7	; 231
    3946:	91 e0       	ldi	r25, 0x01	; 1
    3948:	90 93 e5 01 	sts	0x01E5, r25
    394c:	80 93 e4 01 	sts	0x01E4, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    3950:	80 91 e2 01 	lds	r24, 0x01E2
    3954:	90 91 e3 01 	lds	r25, 0x01E3
    3958:	2b 81       	ldd	r18, Y+3	; 0x03
    395a:	3c 81       	ldd	r19, Y+4	; 0x04
    395c:	82 0f       	add	r24, r18
    395e:	93 1f       	adc	r25, r19
    3960:	24 e0       	ldi	r18, 0x04	; 4
    3962:	8f 3a       	cpi	r24, 0xAF	; 175
    3964:	92 07       	cpc	r25, r18
    3966:	38 f5       	brcc	.+78     	; 0x39b6 <pvPortMalloc+0x96>
    3968:	20 91 e2 01 	lds	r18, 0x01E2
    396c:	30 91 e3 01 	lds	r19, 0x01E3
    3970:	8b 81       	ldd	r24, Y+3	; 0x03
    3972:	9c 81       	ldd	r25, Y+4	; 0x04
    3974:	28 0f       	add	r18, r24
    3976:	39 1f       	adc	r19, r25
    3978:	80 91 e2 01 	lds	r24, 0x01E2
    397c:	90 91 e3 01 	lds	r25, 0x01E3
    3980:	82 17       	cp	r24, r18
    3982:	93 07       	cpc	r25, r19
    3984:	c0 f4       	brcc	.+48     	; 0x39b6 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    3986:	20 91 e4 01 	lds	r18, 0x01E4
    398a:	30 91 e5 01 	lds	r19, 0x01E5
    398e:	80 91 e2 01 	lds	r24, 0x01E2
    3992:	90 91 e3 01 	lds	r25, 0x01E3
    3996:	82 0f       	add	r24, r18
    3998:	93 1f       	adc	r25, r19
    399a:	9a 83       	std	Y+2, r25	; 0x02
    399c:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    399e:	20 91 e2 01 	lds	r18, 0x01E2
    39a2:	30 91 e3 01 	lds	r19, 0x01E3
    39a6:	8b 81       	ldd	r24, Y+3	; 0x03
    39a8:	9c 81       	ldd	r25, Y+4	; 0x04
    39aa:	82 0f       	add	r24, r18
    39ac:	93 1f       	adc	r25, r19
    39ae:	90 93 e3 01 	sts	0x01E3, r25
    39b2:	80 93 e2 01 	sts	0x01E2, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    39b6:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    39ba:	89 81       	ldd	r24, Y+1	; 0x01
    39bc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    39be:	0f 90       	pop	r0
    39c0:	0f 90       	pop	r0
    39c2:	0f 90       	pop	r0
    39c4:	0f 90       	pop	r0
    39c6:	cf 91       	pop	r28
    39c8:	df 91       	pop	r29
    39ca:	08 95       	ret

000039cc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    39cc:	df 93       	push	r29
    39ce:	cf 93       	push	r28
    39d0:	00 d0       	rcall	.+0      	; 0x39d2 <vPortFree+0x6>
    39d2:	cd b7       	in	r28, 0x3d	; 61
    39d4:	de b7       	in	r29, 0x3e	; 62
    39d6:	9a 83       	std	Y+2, r25	; 0x02
    39d8:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    39da:	0f 90       	pop	r0
    39dc:	0f 90       	pop	r0
    39de:	cf 91       	pop	r28
    39e0:	df 91       	pop	r29
    39e2:	08 95       	ret

000039e4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    39e4:	df 93       	push	r29
    39e6:	cf 93       	push	r28
    39e8:	cd b7       	in	r28, 0x3d	; 61
    39ea:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    39ec:	10 92 e3 01 	sts	0x01E3, r1
    39f0:	10 92 e2 01 	sts	0x01E2, r1
}
    39f4:	cf 91       	pop	r28
    39f6:	df 91       	pop	r29
    39f8:	08 95       	ret

000039fa <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    39fa:	df 93       	push	r29
    39fc:	cf 93       	push	r28
    39fe:	cd b7       	in	r28, 0x3d	; 61
    3a00:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    3a02:	20 91 e2 01 	lds	r18, 0x01E2
    3a06:	30 91 e3 01 	lds	r19, 0x01E3
    3a0a:	8f ea       	ldi	r24, 0xAF	; 175
    3a0c:	94 e0       	ldi	r25, 0x04	; 4
    3a0e:	82 1b       	sub	r24, r18
    3a10:	93 0b       	sbc	r25, r19
}
    3a12:	cf 91       	pop	r28
    3a14:	df 91       	pop	r29
    3a16:	08 95       	ret

00003a18 <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    3a18:	af 92       	push	r10
    3a1a:	bf 92       	push	r11
    3a1c:	cf 92       	push	r12
    3a1e:	df 92       	push	r13
    3a20:	ef 92       	push	r14
    3a22:	ff 92       	push	r15
    3a24:	0f 93       	push	r16
    3a26:	df 93       	push	r29
    3a28:	cf 93       	push	r28
    3a2a:	00 d0       	rcall	.+0      	; 0x3a2c <vStartIntegerMathTasks+0x14>
    3a2c:	0f 92       	push	r0
    3a2e:	cd b7       	in	r28, 0x3d	; 61
    3a30:	de b7       	in	r29, 0x3e	; 62
    3a32:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3a34:	1a 82       	std	Y+2, r1	; 0x02
    3a36:	19 82       	std	Y+1, r1	; 0x01
    3a38:	1b c0       	rjmp	.+54     	; 0x3a70 <vStartIntegerMathTasks+0x58>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    3a3a:	89 81       	ldd	r24, Y+1	; 0x01
    3a3c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a3e:	fc 01       	movw	r30, r24
    3a40:	ea 56       	subi	r30, 0x6A	; 106
    3a42:	f9 4f       	sbci	r31, 0xF9	; 249
    3a44:	8a e4       	ldi	r24, 0x4A	; 74
    3a46:	9d e1       	ldi	r25, 0x1D	; 29
    3a48:	2a e4       	ldi	r18, 0x4A	; 74
    3a4a:	31 e0       	ldi	r19, 0x01	; 1
    3a4c:	b9 01       	movw	r22, r18
    3a4e:	45 e5       	ldi	r20, 0x55	; 85
    3a50:	50 e0       	ldi	r21, 0x00	; 0
    3a52:	9f 01       	movw	r18, r30
    3a54:	0b 81       	ldd	r16, Y+3	; 0x03
    3a56:	ee 24       	eor	r14, r14
    3a58:	ff 24       	eor	r15, r15
    3a5a:	cc 24       	eor	r12, r12
    3a5c:	dd 24       	eor	r13, r13
    3a5e:	aa 24       	eor	r10, r10
    3a60:	bb 24       	eor	r11, r11
    3a62:	0e 94 94 29 	call	0x5328	; 0x5328 <xTaskGenericCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3a66:	89 81       	ldd	r24, Y+1	; 0x01
    3a68:	9a 81       	ldd	r25, Y+2	; 0x02
    3a6a:	01 96       	adiw	r24, 0x01	; 1
    3a6c:	9a 83       	std	Y+2, r25	; 0x02
    3a6e:	89 83       	std	Y+1, r24	; 0x01
    3a70:	89 81       	ldd	r24, Y+1	; 0x01
    3a72:	9a 81       	ldd	r25, Y+2	; 0x02
    3a74:	18 16       	cp	r1, r24
    3a76:	19 06       	cpc	r1, r25
    3a78:	04 f7       	brge	.-64     	; 0x3a3a <vStartIntegerMathTasks+0x22>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
    3a7a:	0f 90       	pop	r0
    3a7c:	0f 90       	pop	r0
    3a7e:	0f 90       	pop	r0
    3a80:	cf 91       	pop	r28
    3a82:	df 91       	pop	r29
    3a84:	0f 91       	pop	r16
    3a86:	ff 90       	pop	r15
    3a88:	ef 90       	pop	r14
    3a8a:	df 90       	pop	r13
    3a8c:	cf 90       	pop	r12
    3a8e:	bf 90       	pop	r11
    3a90:	af 90       	pop	r10
    3a92:	08 95       	ret

00003a94 <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    3a94:	df 93       	push	r29
    3a96:	cf 93       	push	r28
    3a98:	cd b7       	in	r28, 0x3d	; 61
    3a9a:	de b7       	in	r29, 0x3e	; 62
    3a9c:	2a 97       	sbiw	r28, 0x0a	; 10
    3a9e:	0f b6       	in	r0, 0x3f	; 63
    3aa0:	f8 94       	cli
    3aa2:	de bf       	out	0x3e, r29	; 62
    3aa4:	0f be       	out	0x3f, r0	; 63
    3aa6:	cd bf       	out	0x3d, r28	; 61
    3aa8:	9a 87       	std	Y+10, r25	; 0x0a
    3aaa:	89 87       	std	Y+9, r24	; 0x09
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    3aac:	1c 82       	std	Y+4, r1	; 0x04
    3aae:	1b 82       	std	Y+3, r1	; 0x03
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    3ab0:	89 85       	ldd	r24, Y+9	; 0x09
    3ab2:	9a 85       	ldd	r25, Y+10	; 0x0a
    3ab4:	9a 83       	std	Y+2, r25	; 0x02
    3ab6:	89 83       	std	Y+1, r24	; 0x01
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    3ab8:	8b e7       	ldi	r24, 0x7B	; 123
    3aba:	90 e0       	ldi	r25, 0x00	; 0
    3abc:	a0 e0       	ldi	r26, 0x00	; 0
    3abe:	b0 e0       	ldi	r27, 0x00	; 0
    3ac0:	8d 83       	std	Y+5, r24	; 0x05
    3ac2:	9e 83       	std	Y+6, r25	; 0x06
    3ac4:	af 83       	std	Y+7, r26	; 0x07
    3ac6:	b8 87       	std	Y+8, r27	; 0x08
		lValue += intgCONST2;
    3ac8:	8d 81       	ldd	r24, Y+5	; 0x05
    3aca:	9e 81       	ldd	r25, Y+6	; 0x06
    3acc:	af 81       	ldd	r26, Y+7	; 0x07
    3ace:	b8 85       	ldd	r27, Y+8	; 0x08
    3ad0:	89 5b       	subi	r24, 0xB9	; 185
    3ad2:	9b 46       	sbci	r25, 0x6B	; 107
    3ad4:	ac 4f       	sbci	r26, 0xFC	; 252
    3ad6:	bf 4f       	sbci	r27, 0xFF	; 255
    3ad8:	8d 83       	std	Y+5, r24	; 0x05
    3ada:	9e 83       	std	Y+6, r25	; 0x06
    3adc:	af 83       	std	Y+7, r26	; 0x07
    3ade:	b8 87       	std	Y+8, r27	; 0x08
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    3ae0:	8d 81       	ldd	r24, Y+5	; 0x05
    3ae2:	9e 81       	ldd	r25, Y+6	; 0x06
    3ae4:	af 81       	ldd	r26, Y+7	; 0x07
    3ae6:	b8 85       	ldd	r27, Y+8	; 0x08
    3ae8:	2d ef       	ldi	r18, 0xFD	; 253
    3aea:	3f ef       	ldi	r19, 0xFF	; 255
    3aec:	4f ef       	ldi	r20, 0xFF	; 255
    3aee:	5f ef       	ldi	r21, 0xFF	; 255
    3af0:	bc 01       	movw	r22, r24
    3af2:	cd 01       	movw	r24, r26
    3af4:	0e 94 5d 32 	call	0x64ba	; 0x64ba <__mulsi3>
    3af8:	dc 01       	movw	r26, r24
    3afa:	cb 01       	movw	r24, r22
    3afc:	8d 83       	std	Y+5, r24	; 0x05
    3afe:	9e 83       	std	Y+6, r25	; 0x06
    3b00:	af 83       	std	Y+7, r26	; 0x07
    3b02:	b8 87       	std	Y+8, r27	; 0x08
		lValue /= intgCONST4;
    3b04:	8d 81       	ldd	r24, Y+5	; 0x05
    3b06:	9e 81       	ldd	r25, Y+6	; 0x06
    3b08:	af 81       	ldd	r26, Y+7	; 0x07
    3b0a:	b8 85       	ldd	r27, Y+8	; 0x08
    3b0c:	27 e0       	ldi	r18, 0x07	; 7
    3b0e:	30 e0       	ldi	r19, 0x00	; 0
    3b10:	40 e0       	ldi	r20, 0x00	; 0
    3b12:	50 e0       	ldi	r21, 0x00	; 0
    3b14:	bc 01       	movw	r22, r24
    3b16:	cd 01       	movw	r24, r26
    3b18:	0e 94 b2 32 	call	0x6564	; 0x6564 <__divmodsi4>
    3b1c:	da 01       	movw	r26, r20
    3b1e:	c9 01       	movw	r24, r18
    3b20:	8d 83       	std	Y+5, r24	; 0x05
    3b22:	9e 83       	std	Y+6, r25	; 0x06
    3b24:	af 83       	std	Y+7, r26	; 0x07
    3b26:	b8 87       	std	Y+8, r27	; 0x08

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    3b28:	8d 81       	ldd	r24, Y+5	; 0x05
    3b2a:	9e 81       	ldd	r25, Y+6	; 0x06
    3b2c:	af 81       	ldd	r26, Y+7	; 0x07
    3b2e:	b8 85       	ldd	r27, Y+8	; 0x08
    3b30:	8b 31       	cpi	r24, 0x1B	; 27
    3b32:	27 e7       	ldi	r18, 0x77	; 119
    3b34:	92 07       	cpc	r25, r18
    3b36:	2e ef       	ldi	r18, 0xFE	; 254
    3b38:	a2 07       	cpc	r26, r18
    3b3a:	2f ef       	ldi	r18, 0xFF	; 255
    3b3c:	b2 07       	cpc	r27, r18
    3b3e:	21 f0       	breq	.+8      	; 0x3b48 <vCompeteingIntMathTask+0xb4>
		{
			sError = pdTRUE;
    3b40:	81 e0       	ldi	r24, 0x01	; 1
    3b42:	90 e0       	ldi	r25, 0x00	; 0
    3b44:	9c 83       	std	Y+4, r25	; 0x04
    3b46:	8b 83       	std	Y+3, r24	; 0x03
		}

		if( sError == pdFALSE )
    3b48:	8b 81       	ldd	r24, Y+3	; 0x03
    3b4a:	9c 81       	ldd	r25, Y+4	; 0x04
    3b4c:	00 97       	sbiw	r24, 0x00	; 0
    3b4e:	09 f0       	breq	.+2      	; 0x3b52 <vCompeteingIntMathTask+0xbe>
    3b50:	b3 cf       	rjmp	.-154    	; 0x3ab8 <vCompeteingIntMathTask+0x24>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    3b52:	0f b6       	in	r0, 0x3f	; 63
    3b54:	f8 94       	cli
    3b56:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    3b58:	e9 81       	ldd	r30, Y+1	; 0x01
    3b5a:	fa 81       	ldd	r31, Y+2	; 0x02
    3b5c:	81 e0       	ldi	r24, 0x01	; 1
    3b5e:	80 83       	st	Z, r24
			portEXIT_CRITICAL();
    3b60:	0f 90       	pop	r0
    3b62:	0f be       	out	0x3f, r0	; 63
    3b64:	a9 cf       	rjmp	.-174    	; 0x3ab8 <vCompeteingIntMathTask+0x24>

00003b66 <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
    3b66:	df 93       	push	r29
    3b68:	cf 93       	push	r28
    3b6a:	00 d0       	rcall	.+0      	; 0x3b6c <xAreIntegerMathsTaskStillRunning+0x6>
    3b6c:	0f 92       	push	r0
    3b6e:	cd b7       	in	r28, 0x3d	; 61
    3b70:	de b7       	in	r29, 0x3e	; 62
BaseType_t xReturn = pdTRUE;
    3b72:	81 e0       	ldi	r24, 0x01	; 1
    3b74:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3b76:	1a 82       	std	Y+2, r1	; 0x02
    3b78:	19 82       	std	Y+1, r1	; 0x01
    3b7a:	14 c0       	rjmp	.+40     	; 0x3ba4 <xAreIntegerMathsTaskStillRunning+0x3e>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    3b7c:	89 81       	ldd	r24, Y+1	; 0x01
    3b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    3b80:	fc 01       	movw	r30, r24
    3b82:	ea 56       	subi	r30, 0x6A	; 106
    3b84:	f9 4f       	sbci	r31, 0xF9	; 249
    3b86:	80 81       	ld	r24, Z
    3b88:	88 23       	and	r24, r24
    3b8a:	09 f4       	brne	.+2      	; 0x3b8e <xAreIntegerMathsTaskStillRunning+0x28>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    3b8c:	1b 82       	std	Y+3, r1	; 0x03
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    3b8e:	89 81       	ldd	r24, Y+1	; 0x01
    3b90:	9a 81       	ldd	r25, Y+2	; 0x02
    3b92:	fc 01       	movw	r30, r24
    3b94:	ea 56       	subi	r30, 0x6A	; 106
    3b96:	f9 4f       	sbci	r31, 0xF9	; 249
    3b98:	10 82       	st	Z, r1
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3b9a:	89 81       	ldd	r24, Y+1	; 0x01
    3b9c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b9e:	01 96       	adiw	r24, 0x01	; 1
    3ba0:	9a 83       	std	Y+2, r25	; 0x02
    3ba2:	89 83       	std	Y+1, r24	; 0x01
    3ba4:	89 81       	ldd	r24, Y+1	; 0x01
    3ba6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ba8:	18 16       	cp	r1, r24
    3baa:	19 06       	cpc	r1, r25
    3bac:	3c f7       	brge	.-50     	; 0x3b7c <xAreIntegerMathsTaskStillRunning+0x16>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    3bae:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3bb0:	0f 90       	pop	r0
    3bb2:	0f 90       	pop	r0
    3bb4:	0f 90       	pop	r0
    3bb6:	cf 91       	pop	r28
    3bb8:	df 91       	pop	r29
    3bba:	08 95       	ret

00003bbc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3bbc:	df 93       	push	r29
    3bbe:	cf 93       	push	r28
    3bc0:	00 d0       	rcall	.+0      	; 0x3bc2 <vListInitialise+0x6>
    3bc2:	cd b7       	in	r28, 0x3d	; 61
    3bc4:	de b7       	in	r29, 0x3e	; 62
    3bc6:	9a 83       	std	Y+2, r25	; 0x02
    3bc8:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3bca:	89 81       	ldd	r24, Y+1	; 0x01
    3bcc:	9a 81       	ldd	r25, Y+2	; 0x02
    3bce:	03 96       	adiw	r24, 0x03	; 3
    3bd0:	e9 81       	ldd	r30, Y+1	; 0x01
    3bd2:	fa 81       	ldd	r31, Y+2	; 0x02
    3bd4:	92 83       	std	Z+2, r25	; 0x02
    3bd6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    3bd8:	e9 81       	ldd	r30, Y+1	; 0x01
    3bda:	fa 81       	ldd	r31, Y+2	; 0x02
    3bdc:	8f ef       	ldi	r24, 0xFF	; 255
    3bde:	9f ef       	ldi	r25, 0xFF	; 255
    3be0:	94 83       	std	Z+4, r25	; 0x04
    3be2:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3be4:	89 81       	ldd	r24, Y+1	; 0x01
    3be6:	9a 81       	ldd	r25, Y+2	; 0x02
    3be8:	03 96       	adiw	r24, 0x03	; 3
    3bea:	e9 81       	ldd	r30, Y+1	; 0x01
    3bec:	fa 81       	ldd	r31, Y+2	; 0x02
    3bee:	96 83       	std	Z+6, r25	; 0x06
    3bf0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3bf2:	89 81       	ldd	r24, Y+1	; 0x01
    3bf4:	9a 81       	ldd	r25, Y+2	; 0x02
    3bf6:	03 96       	adiw	r24, 0x03	; 3
    3bf8:	e9 81       	ldd	r30, Y+1	; 0x01
    3bfa:	fa 81       	ldd	r31, Y+2	; 0x02
    3bfc:	90 87       	std	Z+8, r25	; 0x08
    3bfe:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    3c00:	e9 81       	ldd	r30, Y+1	; 0x01
    3c02:	fa 81       	ldd	r31, Y+2	; 0x02
    3c04:	10 82       	st	Z, r1
}
    3c06:	0f 90       	pop	r0
    3c08:	0f 90       	pop	r0
    3c0a:	cf 91       	pop	r28
    3c0c:	df 91       	pop	r29
    3c0e:	08 95       	ret

00003c10 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    3c10:	df 93       	push	r29
    3c12:	cf 93       	push	r28
    3c14:	00 d0       	rcall	.+0      	; 0x3c16 <vListInitialiseItem+0x6>
    3c16:	cd b7       	in	r28, 0x3d	; 61
    3c18:	de b7       	in	r29, 0x3e	; 62
    3c1a:	9a 83       	std	Y+2, r25	; 0x02
    3c1c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    3c1e:	e9 81       	ldd	r30, Y+1	; 0x01
    3c20:	fa 81       	ldd	r31, Y+2	; 0x02
    3c22:	11 86       	std	Z+9, r1	; 0x09
    3c24:	10 86       	std	Z+8, r1	; 0x08
}
    3c26:	0f 90       	pop	r0
    3c28:	0f 90       	pop	r0
    3c2a:	cf 91       	pop	r28
    3c2c:	df 91       	pop	r29
    3c2e:	08 95       	ret

00003c30 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3c30:	df 93       	push	r29
    3c32:	cf 93       	push	r28
    3c34:	00 d0       	rcall	.+0      	; 0x3c36 <vListInsertEnd+0x6>
    3c36:	00 d0       	rcall	.+0      	; 0x3c38 <vListInsertEnd+0x8>
    3c38:	00 d0       	rcall	.+0      	; 0x3c3a <vListInsertEnd+0xa>
    3c3a:	cd b7       	in	r28, 0x3d	; 61
    3c3c:	de b7       	in	r29, 0x3e	; 62
    3c3e:	9c 83       	std	Y+4, r25	; 0x04
    3c40:	8b 83       	std	Y+3, r24	; 0x03
    3c42:	7e 83       	std	Y+6, r23	; 0x06
    3c44:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    3c46:	eb 81       	ldd	r30, Y+3	; 0x03
    3c48:	fc 81       	ldd	r31, Y+4	; 0x04
    3c4a:	81 81       	ldd	r24, Z+1	; 0x01
    3c4c:	92 81       	ldd	r25, Z+2	; 0x02
    3c4e:	9a 83       	std	Y+2, r25	; 0x02
    3c50:	89 83       	std	Y+1, r24	; 0x01

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    3c52:	ed 81       	ldd	r30, Y+5	; 0x05
    3c54:	fe 81       	ldd	r31, Y+6	; 0x06
    3c56:	89 81       	ldd	r24, Y+1	; 0x01
    3c58:	9a 81       	ldd	r25, Y+2	; 0x02
    3c5a:	93 83       	std	Z+3, r25	; 0x03
    3c5c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3c5e:	e9 81       	ldd	r30, Y+1	; 0x01
    3c60:	fa 81       	ldd	r31, Y+2	; 0x02
    3c62:	84 81       	ldd	r24, Z+4	; 0x04
    3c64:	95 81       	ldd	r25, Z+5	; 0x05
    3c66:	ed 81       	ldd	r30, Y+5	; 0x05
    3c68:	fe 81       	ldd	r31, Y+6	; 0x06
    3c6a:	95 83       	std	Z+5, r25	; 0x05
    3c6c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    3c6e:	e9 81       	ldd	r30, Y+1	; 0x01
    3c70:	fa 81       	ldd	r31, Y+2	; 0x02
    3c72:	04 80       	ldd	r0, Z+4	; 0x04
    3c74:	f5 81       	ldd	r31, Z+5	; 0x05
    3c76:	e0 2d       	mov	r30, r0
    3c78:	8d 81       	ldd	r24, Y+5	; 0x05
    3c7a:	9e 81       	ldd	r25, Y+6	; 0x06
    3c7c:	93 83       	std	Z+3, r25	; 0x03
    3c7e:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    3c80:	e9 81       	ldd	r30, Y+1	; 0x01
    3c82:	fa 81       	ldd	r31, Y+2	; 0x02
    3c84:	8d 81       	ldd	r24, Y+5	; 0x05
    3c86:	9e 81       	ldd	r25, Y+6	; 0x06
    3c88:	95 83       	std	Z+5, r25	; 0x05
    3c8a:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    3c8c:	ed 81       	ldd	r30, Y+5	; 0x05
    3c8e:	fe 81       	ldd	r31, Y+6	; 0x06
    3c90:	8b 81       	ldd	r24, Y+3	; 0x03
    3c92:	9c 81       	ldd	r25, Y+4	; 0x04
    3c94:	91 87       	std	Z+9, r25	; 0x09
    3c96:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    3c98:	eb 81       	ldd	r30, Y+3	; 0x03
    3c9a:	fc 81       	ldd	r31, Y+4	; 0x04
    3c9c:	80 81       	ld	r24, Z
    3c9e:	8f 5f       	subi	r24, 0xFF	; 255
    3ca0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ca2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ca4:	80 83       	st	Z, r24
}
    3ca6:	26 96       	adiw	r28, 0x06	; 6
    3ca8:	0f b6       	in	r0, 0x3f	; 63
    3caa:	f8 94       	cli
    3cac:	de bf       	out	0x3e, r29	; 62
    3cae:	0f be       	out	0x3f, r0	; 63
    3cb0:	cd bf       	out	0x3d, r28	; 61
    3cb2:	cf 91       	pop	r28
    3cb4:	df 91       	pop	r29
    3cb6:	08 95       	ret

00003cb8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3cb8:	df 93       	push	r29
    3cba:	cf 93       	push	r28
    3cbc:	cd b7       	in	r28, 0x3d	; 61
    3cbe:	de b7       	in	r29, 0x3e	; 62
    3cc0:	28 97       	sbiw	r28, 0x08	; 8
    3cc2:	0f b6       	in	r0, 0x3f	; 63
    3cc4:	f8 94       	cli
    3cc6:	de bf       	out	0x3e, r29	; 62
    3cc8:	0f be       	out	0x3f, r0	; 63
    3cca:	cd bf       	out	0x3d, r28	; 61
    3ccc:	9e 83       	std	Y+6, r25	; 0x06
    3cce:	8d 83       	std	Y+5, r24	; 0x05
    3cd0:	78 87       	std	Y+8, r23	; 0x08
    3cd2:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    3cd4:	ef 81       	ldd	r30, Y+7	; 0x07
    3cd6:	f8 85       	ldd	r31, Y+8	; 0x08
    3cd8:	80 81       	ld	r24, Z
    3cda:	91 81       	ldd	r25, Z+1	; 0x01
    3cdc:	9a 83       	std	Y+2, r25	; 0x02
    3cde:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    3ce0:	89 81       	ldd	r24, Y+1	; 0x01
    3ce2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ce4:	2f ef       	ldi	r18, 0xFF	; 255
    3ce6:	8f 3f       	cpi	r24, 0xFF	; 255
    3ce8:	92 07       	cpc	r25, r18
    3cea:	39 f4       	brne	.+14     	; 0x3cfa <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    3cec:	ed 81       	ldd	r30, Y+5	; 0x05
    3cee:	fe 81       	ldd	r31, Y+6	; 0x06
    3cf0:	87 81       	ldd	r24, Z+7	; 0x07
    3cf2:	90 85       	ldd	r25, Z+8	; 0x08
    3cf4:	9c 83       	std	Y+4, r25	; 0x04
    3cf6:	8b 83       	std	Y+3, r24	; 0x03
    3cf8:	18 c0       	rjmp	.+48     	; 0x3d2a <vListInsert+0x72>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3cfa:	8d 81       	ldd	r24, Y+5	; 0x05
    3cfc:	9e 81       	ldd	r25, Y+6	; 0x06
    3cfe:	03 96       	adiw	r24, 0x03	; 3
    3d00:	9c 83       	std	Y+4, r25	; 0x04
    3d02:	8b 83       	std	Y+3, r24	; 0x03
    3d04:	06 c0       	rjmp	.+12     	; 0x3d12 <vListInsert+0x5a>
    3d06:	eb 81       	ldd	r30, Y+3	; 0x03
    3d08:	fc 81       	ldd	r31, Y+4	; 0x04
    3d0a:	82 81       	ldd	r24, Z+2	; 0x02
    3d0c:	93 81       	ldd	r25, Z+3	; 0x03
    3d0e:	9c 83       	std	Y+4, r25	; 0x04
    3d10:	8b 83       	std	Y+3, r24	; 0x03
    3d12:	eb 81       	ldd	r30, Y+3	; 0x03
    3d14:	fc 81       	ldd	r31, Y+4	; 0x04
    3d16:	02 80       	ldd	r0, Z+2	; 0x02
    3d18:	f3 81       	ldd	r31, Z+3	; 0x03
    3d1a:	e0 2d       	mov	r30, r0
    3d1c:	20 81       	ld	r18, Z
    3d1e:	31 81       	ldd	r19, Z+1	; 0x01
    3d20:	89 81       	ldd	r24, Y+1	; 0x01
    3d22:	9a 81       	ldd	r25, Y+2	; 0x02
    3d24:	82 17       	cp	r24, r18
    3d26:	93 07       	cpc	r25, r19
    3d28:	70 f7       	brcc	.-36     	; 0x3d06 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    3d2a:	eb 81       	ldd	r30, Y+3	; 0x03
    3d2c:	fc 81       	ldd	r31, Y+4	; 0x04
    3d2e:	82 81       	ldd	r24, Z+2	; 0x02
    3d30:	93 81       	ldd	r25, Z+3	; 0x03
    3d32:	ef 81       	ldd	r30, Y+7	; 0x07
    3d34:	f8 85       	ldd	r31, Y+8	; 0x08
    3d36:	93 83       	std	Z+3, r25	; 0x03
    3d38:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3d3a:	ef 81       	ldd	r30, Y+7	; 0x07
    3d3c:	f8 85       	ldd	r31, Y+8	; 0x08
    3d3e:	02 80       	ldd	r0, Z+2	; 0x02
    3d40:	f3 81       	ldd	r31, Z+3	; 0x03
    3d42:	e0 2d       	mov	r30, r0
    3d44:	8f 81       	ldd	r24, Y+7	; 0x07
    3d46:	98 85       	ldd	r25, Y+8	; 0x08
    3d48:	95 83       	std	Z+5, r25	; 0x05
    3d4a:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    3d4c:	ef 81       	ldd	r30, Y+7	; 0x07
    3d4e:	f8 85       	ldd	r31, Y+8	; 0x08
    3d50:	8b 81       	ldd	r24, Y+3	; 0x03
    3d52:	9c 81       	ldd	r25, Y+4	; 0x04
    3d54:	95 83       	std	Z+5, r25	; 0x05
    3d56:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    3d58:	eb 81       	ldd	r30, Y+3	; 0x03
    3d5a:	fc 81       	ldd	r31, Y+4	; 0x04
    3d5c:	8f 81       	ldd	r24, Y+7	; 0x07
    3d5e:	98 85       	ldd	r25, Y+8	; 0x08
    3d60:	93 83       	std	Z+3, r25	; 0x03
    3d62:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    3d64:	ef 81       	ldd	r30, Y+7	; 0x07
    3d66:	f8 85       	ldd	r31, Y+8	; 0x08
    3d68:	8d 81       	ldd	r24, Y+5	; 0x05
    3d6a:	9e 81       	ldd	r25, Y+6	; 0x06
    3d6c:	91 87       	std	Z+9, r25	; 0x09
    3d6e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    3d70:	ed 81       	ldd	r30, Y+5	; 0x05
    3d72:	fe 81       	ldd	r31, Y+6	; 0x06
    3d74:	80 81       	ld	r24, Z
    3d76:	8f 5f       	subi	r24, 0xFF	; 255
    3d78:	ed 81       	ldd	r30, Y+5	; 0x05
    3d7a:	fe 81       	ldd	r31, Y+6	; 0x06
    3d7c:	80 83       	st	Z, r24
}
    3d7e:	28 96       	adiw	r28, 0x08	; 8
    3d80:	0f b6       	in	r0, 0x3f	; 63
    3d82:	f8 94       	cli
    3d84:	de bf       	out	0x3e, r29	; 62
    3d86:	0f be       	out	0x3f, r0	; 63
    3d88:	cd bf       	out	0x3d, r28	; 61
    3d8a:	cf 91       	pop	r28
    3d8c:	df 91       	pop	r29
    3d8e:	08 95       	ret

00003d90 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3d90:	df 93       	push	r29
    3d92:	cf 93       	push	r28
    3d94:	00 d0       	rcall	.+0      	; 0x3d96 <uxListRemove+0x6>
    3d96:	00 d0       	rcall	.+0      	; 0x3d98 <uxListRemove+0x8>
    3d98:	cd b7       	in	r28, 0x3d	; 61
    3d9a:	de b7       	in	r29, 0x3e	; 62
    3d9c:	9c 83       	std	Y+4, r25	; 0x04
    3d9e:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    3da0:	eb 81       	ldd	r30, Y+3	; 0x03
    3da2:	fc 81       	ldd	r31, Y+4	; 0x04
    3da4:	80 85       	ldd	r24, Z+8	; 0x08
    3da6:	91 85       	ldd	r25, Z+9	; 0x09
    3da8:	9a 83       	std	Y+2, r25	; 0x02
    3daa:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3dac:	eb 81       	ldd	r30, Y+3	; 0x03
    3dae:	fc 81       	ldd	r31, Y+4	; 0x04
    3db0:	a2 81       	ldd	r26, Z+2	; 0x02
    3db2:	b3 81       	ldd	r27, Z+3	; 0x03
    3db4:	eb 81       	ldd	r30, Y+3	; 0x03
    3db6:	fc 81       	ldd	r31, Y+4	; 0x04
    3db8:	84 81       	ldd	r24, Z+4	; 0x04
    3dba:	95 81       	ldd	r25, Z+5	; 0x05
    3dbc:	15 96       	adiw	r26, 0x05	; 5
    3dbe:	9c 93       	st	X, r25
    3dc0:	8e 93       	st	-X, r24
    3dc2:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3dc4:	eb 81       	ldd	r30, Y+3	; 0x03
    3dc6:	fc 81       	ldd	r31, Y+4	; 0x04
    3dc8:	a4 81       	ldd	r26, Z+4	; 0x04
    3dca:	b5 81       	ldd	r27, Z+5	; 0x05
    3dcc:	eb 81       	ldd	r30, Y+3	; 0x03
    3dce:	fc 81       	ldd	r31, Y+4	; 0x04
    3dd0:	82 81       	ldd	r24, Z+2	; 0x02
    3dd2:	93 81       	ldd	r25, Z+3	; 0x03
    3dd4:	13 96       	adiw	r26, 0x03	; 3
    3dd6:	9c 93       	st	X, r25
    3dd8:	8e 93       	st	-X, r24
    3dda:	12 97       	sbiw	r26, 0x02	; 2

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    3ddc:	e9 81       	ldd	r30, Y+1	; 0x01
    3dde:	fa 81       	ldd	r31, Y+2	; 0x02
    3de0:	21 81       	ldd	r18, Z+1	; 0x01
    3de2:	32 81       	ldd	r19, Z+2	; 0x02
    3de4:	8b 81       	ldd	r24, Y+3	; 0x03
    3de6:	9c 81       	ldd	r25, Y+4	; 0x04
    3de8:	28 17       	cp	r18, r24
    3dea:	39 07       	cpc	r19, r25
    3dec:	41 f4       	brne	.+16     	; 0x3dfe <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    3dee:	eb 81       	ldd	r30, Y+3	; 0x03
    3df0:	fc 81       	ldd	r31, Y+4	; 0x04
    3df2:	84 81       	ldd	r24, Z+4	; 0x04
    3df4:	95 81       	ldd	r25, Z+5	; 0x05
    3df6:	e9 81       	ldd	r30, Y+1	; 0x01
    3df8:	fa 81       	ldd	r31, Y+2	; 0x02
    3dfa:	92 83       	std	Z+2, r25	; 0x02
    3dfc:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    3dfe:	eb 81       	ldd	r30, Y+3	; 0x03
    3e00:	fc 81       	ldd	r31, Y+4	; 0x04
    3e02:	11 86       	std	Z+9, r1	; 0x09
    3e04:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    3e06:	e9 81       	ldd	r30, Y+1	; 0x01
    3e08:	fa 81       	ldd	r31, Y+2	; 0x02
    3e0a:	80 81       	ld	r24, Z
    3e0c:	81 50       	subi	r24, 0x01	; 1
    3e0e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e10:	fa 81       	ldd	r31, Y+2	; 0x02
    3e12:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    3e14:	e9 81       	ldd	r30, Y+1	; 0x01
    3e16:	fa 81       	ldd	r31, Y+2	; 0x02
    3e18:	80 81       	ld	r24, Z
}
    3e1a:	0f 90       	pop	r0
    3e1c:	0f 90       	pop	r0
    3e1e:	0f 90       	pop	r0
    3e20:	0f 90       	pop	r0
    3e22:	cf 91       	pop	r28
    3e24:	df 91       	pop	r29
    3e26:	08 95       	ret

00003e28 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    3e28:	df 93       	push	r29
    3e2a:	cf 93       	push	r28
    3e2c:	cd b7       	in	r28, 0x3d	; 61
    3e2e:	de b7       	in	r29, 0x3e	; 62
    3e30:	28 97       	sbiw	r28, 0x08	; 8
    3e32:	0f b6       	in	r0, 0x3f	; 63
    3e34:	f8 94       	cli
    3e36:	de bf       	out	0x3e, r29	; 62
    3e38:	0f be       	out	0x3f, r0	; 63
    3e3a:	cd bf       	out	0x3d, r28	; 61
    3e3c:	9c 83       	std	Y+4, r25	; 0x04
    3e3e:	8b 83       	std	Y+3, r24	; 0x03
    3e40:	7e 83       	std	Y+6, r23	; 0x06
    3e42:	6d 83       	std	Y+5, r22	; 0x05
    3e44:	58 87       	std	Y+8, r21	; 0x08
    3e46:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3e48:	eb 81       	ldd	r30, Y+3	; 0x03
    3e4a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e4c:	81 e1       	ldi	r24, 0x11	; 17
    3e4e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3e50:	8b 81       	ldd	r24, Y+3	; 0x03
    3e52:	9c 81       	ldd	r25, Y+4	; 0x04
    3e54:	01 97       	sbiw	r24, 0x01	; 1
    3e56:	9c 83       	std	Y+4, r25	; 0x04
    3e58:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    3e5a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e5c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e5e:	82 e2       	ldi	r24, 0x22	; 34
    3e60:	80 83       	st	Z, r24
	pxTopOfStack--;
    3e62:	8b 81       	ldd	r24, Y+3	; 0x03
    3e64:	9c 81       	ldd	r25, Y+4	; 0x04
    3e66:	01 97       	sbiw	r24, 0x01	; 1
    3e68:	9c 83       	std	Y+4, r25	; 0x04
    3e6a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    3e6c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e6e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e70:	83 e3       	ldi	r24, 0x33	; 51
    3e72:	80 83       	st	Z, r24
	pxTopOfStack--;
    3e74:	8b 81       	ldd	r24, Y+3	; 0x03
    3e76:	9c 81       	ldd	r25, Y+4	; 0x04
    3e78:	01 97       	sbiw	r24, 0x01	; 1
    3e7a:	9c 83       	std	Y+4, r25	; 0x04
    3e7c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    3e7e:	8d 81       	ldd	r24, Y+5	; 0x05
    3e80:	9e 81       	ldd	r25, Y+6	; 0x06
    3e82:	9a 83       	std	Y+2, r25	; 0x02
    3e84:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3e86:	89 81       	ldd	r24, Y+1	; 0x01
    3e88:	eb 81       	ldd	r30, Y+3	; 0x03
    3e8a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e8c:	80 83       	st	Z, r24
	pxTopOfStack--;
    3e8e:	8b 81       	ldd	r24, Y+3	; 0x03
    3e90:	9c 81       	ldd	r25, Y+4	; 0x04
    3e92:	01 97       	sbiw	r24, 0x01	; 1
    3e94:	9c 83       	std	Y+4, r25	; 0x04
    3e96:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3e98:	89 81       	ldd	r24, Y+1	; 0x01
    3e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e9c:	89 2f       	mov	r24, r25
    3e9e:	99 27       	eor	r25, r25
    3ea0:	9a 83       	std	Y+2, r25	; 0x02
    3ea2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3ea4:	89 81       	ldd	r24, Y+1	; 0x01
    3ea6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ea8:	fc 81       	ldd	r31, Y+4	; 0x04
    3eaa:	80 83       	st	Z, r24
	pxTopOfStack--;
    3eac:	8b 81       	ldd	r24, Y+3	; 0x03
    3eae:	9c 81       	ldd	r25, Y+4	; 0x04
    3eb0:	01 97       	sbiw	r24, 0x01	; 1
    3eb2:	9c 83       	std	Y+4, r25	; 0x04
    3eb4:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    3eb6:	eb 81       	ldd	r30, Y+3	; 0x03
    3eb8:	fc 81       	ldd	r31, Y+4	; 0x04
    3eba:	10 82       	st	Z, r1
	pxTopOfStack--;
    3ebc:	8b 81       	ldd	r24, Y+3	; 0x03
    3ebe:	9c 81       	ldd	r25, Y+4	; 0x04
    3ec0:	01 97       	sbiw	r24, 0x01	; 1
    3ec2:	9c 83       	std	Y+4, r25	; 0x04
    3ec4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3ec6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ec8:	fc 81       	ldd	r31, Y+4	; 0x04
    3eca:	80 e8       	ldi	r24, 0x80	; 128
    3ecc:	80 83       	st	Z, r24
	pxTopOfStack--;
    3ece:	8b 81       	ldd	r24, Y+3	; 0x03
    3ed0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ed2:	01 97       	sbiw	r24, 0x01	; 1
    3ed4:	9c 83       	std	Y+4, r25	; 0x04
    3ed6:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    3ed8:	eb 81       	ldd	r30, Y+3	; 0x03
    3eda:	fc 81       	ldd	r31, Y+4	; 0x04
    3edc:	10 82       	st	Z, r1
	pxTopOfStack--;
    3ede:	8b 81       	ldd	r24, Y+3	; 0x03
    3ee0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ee2:	01 97       	sbiw	r24, 0x01	; 1
    3ee4:	9c 83       	std	Y+4, r25	; 0x04
    3ee6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    3ee8:	eb 81       	ldd	r30, Y+3	; 0x03
    3eea:	fc 81       	ldd	r31, Y+4	; 0x04
    3eec:	82 e0       	ldi	r24, 0x02	; 2
    3eee:	80 83       	st	Z, r24
	pxTopOfStack--;
    3ef0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ef2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ef4:	01 97       	sbiw	r24, 0x01	; 1
    3ef6:	9c 83       	std	Y+4, r25	; 0x04
    3ef8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    3efa:	eb 81       	ldd	r30, Y+3	; 0x03
    3efc:	fc 81       	ldd	r31, Y+4	; 0x04
    3efe:	83 e0       	ldi	r24, 0x03	; 3
    3f00:	80 83       	st	Z, r24
	pxTopOfStack--;
    3f02:	8b 81       	ldd	r24, Y+3	; 0x03
    3f04:	9c 81       	ldd	r25, Y+4	; 0x04
    3f06:	01 97       	sbiw	r24, 0x01	; 1
    3f08:	9c 83       	std	Y+4, r25	; 0x04
    3f0a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    3f0c:	eb 81       	ldd	r30, Y+3	; 0x03
    3f0e:	fc 81       	ldd	r31, Y+4	; 0x04
    3f10:	84 e0       	ldi	r24, 0x04	; 4
    3f12:	80 83       	st	Z, r24
	pxTopOfStack--;
    3f14:	8b 81       	ldd	r24, Y+3	; 0x03
    3f16:	9c 81       	ldd	r25, Y+4	; 0x04
    3f18:	01 97       	sbiw	r24, 0x01	; 1
    3f1a:	9c 83       	std	Y+4, r25	; 0x04
    3f1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    3f1e:	eb 81       	ldd	r30, Y+3	; 0x03
    3f20:	fc 81       	ldd	r31, Y+4	; 0x04
    3f22:	85 e0       	ldi	r24, 0x05	; 5
    3f24:	80 83       	st	Z, r24
	pxTopOfStack--;
    3f26:	8b 81       	ldd	r24, Y+3	; 0x03
    3f28:	9c 81       	ldd	r25, Y+4	; 0x04
    3f2a:	01 97       	sbiw	r24, 0x01	; 1
    3f2c:	9c 83       	std	Y+4, r25	; 0x04
    3f2e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    3f30:	eb 81       	ldd	r30, Y+3	; 0x03
    3f32:	fc 81       	ldd	r31, Y+4	; 0x04
    3f34:	86 e0       	ldi	r24, 0x06	; 6
    3f36:	80 83       	st	Z, r24
	pxTopOfStack--;
    3f38:	8b 81       	ldd	r24, Y+3	; 0x03
    3f3a:	9c 81       	ldd	r25, Y+4	; 0x04
    3f3c:	01 97       	sbiw	r24, 0x01	; 1
    3f3e:	9c 83       	std	Y+4, r25	; 0x04
    3f40:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    3f42:	eb 81       	ldd	r30, Y+3	; 0x03
    3f44:	fc 81       	ldd	r31, Y+4	; 0x04
    3f46:	87 e0       	ldi	r24, 0x07	; 7
    3f48:	80 83       	st	Z, r24
	pxTopOfStack--;
    3f4a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f4c:	9c 81       	ldd	r25, Y+4	; 0x04
    3f4e:	01 97       	sbiw	r24, 0x01	; 1
    3f50:	9c 83       	std	Y+4, r25	; 0x04
    3f52:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    3f54:	eb 81       	ldd	r30, Y+3	; 0x03
    3f56:	fc 81       	ldd	r31, Y+4	; 0x04
    3f58:	88 e0       	ldi	r24, 0x08	; 8
    3f5a:	80 83       	st	Z, r24
	pxTopOfStack--;
    3f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f5e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f60:	01 97       	sbiw	r24, 0x01	; 1
    3f62:	9c 83       	std	Y+4, r25	; 0x04
    3f64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    3f66:	eb 81       	ldd	r30, Y+3	; 0x03
    3f68:	fc 81       	ldd	r31, Y+4	; 0x04
    3f6a:	89 e0       	ldi	r24, 0x09	; 9
    3f6c:	80 83       	st	Z, r24
	pxTopOfStack--;
    3f6e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f70:	9c 81       	ldd	r25, Y+4	; 0x04
    3f72:	01 97       	sbiw	r24, 0x01	; 1
    3f74:	9c 83       	std	Y+4, r25	; 0x04
    3f76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    3f78:	eb 81       	ldd	r30, Y+3	; 0x03
    3f7a:	fc 81       	ldd	r31, Y+4	; 0x04
    3f7c:	80 e1       	ldi	r24, 0x10	; 16
    3f7e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3f80:	8b 81       	ldd	r24, Y+3	; 0x03
    3f82:	9c 81       	ldd	r25, Y+4	; 0x04
    3f84:	01 97       	sbiw	r24, 0x01	; 1
    3f86:	9c 83       	std	Y+4, r25	; 0x04
    3f88:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    3f8a:	eb 81       	ldd	r30, Y+3	; 0x03
    3f8c:	fc 81       	ldd	r31, Y+4	; 0x04
    3f8e:	81 e1       	ldi	r24, 0x11	; 17
    3f90:	80 83       	st	Z, r24
	pxTopOfStack--;
    3f92:	8b 81       	ldd	r24, Y+3	; 0x03
    3f94:	9c 81       	ldd	r25, Y+4	; 0x04
    3f96:	01 97       	sbiw	r24, 0x01	; 1
    3f98:	9c 83       	std	Y+4, r25	; 0x04
    3f9a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    3f9c:	eb 81       	ldd	r30, Y+3	; 0x03
    3f9e:	fc 81       	ldd	r31, Y+4	; 0x04
    3fa0:	82 e1       	ldi	r24, 0x12	; 18
    3fa2:	80 83       	st	Z, r24
	pxTopOfStack--;
    3fa4:	8b 81       	ldd	r24, Y+3	; 0x03
    3fa6:	9c 81       	ldd	r25, Y+4	; 0x04
    3fa8:	01 97       	sbiw	r24, 0x01	; 1
    3faa:	9c 83       	std	Y+4, r25	; 0x04
    3fac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    3fae:	eb 81       	ldd	r30, Y+3	; 0x03
    3fb0:	fc 81       	ldd	r31, Y+4	; 0x04
    3fb2:	83 e1       	ldi	r24, 0x13	; 19
    3fb4:	80 83       	st	Z, r24
	pxTopOfStack--;
    3fb6:	8b 81       	ldd	r24, Y+3	; 0x03
    3fb8:	9c 81       	ldd	r25, Y+4	; 0x04
    3fba:	01 97       	sbiw	r24, 0x01	; 1
    3fbc:	9c 83       	std	Y+4, r25	; 0x04
    3fbe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    3fc0:	eb 81       	ldd	r30, Y+3	; 0x03
    3fc2:	fc 81       	ldd	r31, Y+4	; 0x04
    3fc4:	84 e1       	ldi	r24, 0x14	; 20
    3fc6:	80 83       	st	Z, r24
	pxTopOfStack--;
    3fc8:	8b 81       	ldd	r24, Y+3	; 0x03
    3fca:	9c 81       	ldd	r25, Y+4	; 0x04
    3fcc:	01 97       	sbiw	r24, 0x01	; 1
    3fce:	9c 83       	std	Y+4, r25	; 0x04
    3fd0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    3fd2:	eb 81       	ldd	r30, Y+3	; 0x03
    3fd4:	fc 81       	ldd	r31, Y+4	; 0x04
    3fd6:	85 e1       	ldi	r24, 0x15	; 21
    3fd8:	80 83       	st	Z, r24
	pxTopOfStack--;
    3fda:	8b 81       	ldd	r24, Y+3	; 0x03
    3fdc:	9c 81       	ldd	r25, Y+4	; 0x04
    3fde:	01 97       	sbiw	r24, 0x01	; 1
    3fe0:	9c 83       	std	Y+4, r25	; 0x04
    3fe2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    3fe4:	eb 81       	ldd	r30, Y+3	; 0x03
    3fe6:	fc 81       	ldd	r31, Y+4	; 0x04
    3fe8:	86 e1       	ldi	r24, 0x16	; 22
    3fea:	80 83       	st	Z, r24
	pxTopOfStack--;
    3fec:	8b 81       	ldd	r24, Y+3	; 0x03
    3fee:	9c 81       	ldd	r25, Y+4	; 0x04
    3ff0:	01 97       	sbiw	r24, 0x01	; 1
    3ff2:	9c 83       	std	Y+4, r25	; 0x04
    3ff4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    3ff6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ff8:	fc 81       	ldd	r31, Y+4	; 0x04
    3ffa:	87 e1       	ldi	r24, 0x17	; 23
    3ffc:	80 83       	st	Z, r24
	pxTopOfStack--;
    3ffe:	8b 81       	ldd	r24, Y+3	; 0x03
    4000:	9c 81       	ldd	r25, Y+4	; 0x04
    4002:	01 97       	sbiw	r24, 0x01	; 1
    4004:	9c 83       	std	Y+4, r25	; 0x04
    4006:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    4008:	eb 81       	ldd	r30, Y+3	; 0x03
    400a:	fc 81       	ldd	r31, Y+4	; 0x04
    400c:	88 e1       	ldi	r24, 0x18	; 24
    400e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4010:	8b 81       	ldd	r24, Y+3	; 0x03
    4012:	9c 81       	ldd	r25, Y+4	; 0x04
    4014:	01 97       	sbiw	r24, 0x01	; 1
    4016:	9c 83       	std	Y+4, r25	; 0x04
    4018:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    401a:	eb 81       	ldd	r30, Y+3	; 0x03
    401c:	fc 81       	ldd	r31, Y+4	; 0x04
    401e:	89 e1       	ldi	r24, 0x19	; 25
    4020:	80 83       	st	Z, r24
	pxTopOfStack--;
    4022:	8b 81       	ldd	r24, Y+3	; 0x03
    4024:	9c 81       	ldd	r25, Y+4	; 0x04
    4026:	01 97       	sbiw	r24, 0x01	; 1
    4028:	9c 83       	std	Y+4, r25	; 0x04
    402a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    402c:	eb 81       	ldd	r30, Y+3	; 0x03
    402e:	fc 81       	ldd	r31, Y+4	; 0x04
    4030:	80 e2       	ldi	r24, 0x20	; 32
    4032:	80 83       	st	Z, r24
	pxTopOfStack--;
    4034:	8b 81       	ldd	r24, Y+3	; 0x03
    4036:	9c 81       	ldd	r25, Y+4	; 0x04
    4038:	01 97       	sbiw	r24, 0x01	; 1
    403a:	9c 83       	std	Y+4, r25	; 0x04
    403c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    403e:	eb 81       	ldd	r30, Y+3	; 0x03
    4040:	fc 81       	ldd	r31, Y+4	; 0x04
    4042:	81 e2       	ldi	r24, 0x21	; 33
    4044:	80 83       	st	Z, r24
	pxTopOfStack--;
    4046:	8b 81       	ldd	r24, Y+3	; 0x03
    4048:	9c 81       	ldd	r25, Y+4	; 0x04
    404a:	01 97       	sbiw	r24, 0x01	; 1
    404c:	9c 83       	std	Y+4, r25	; 0x04
    404e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    4050:	eb 81       	ldd	r30, Y+3	; 0x03
    4052:	fc 81       	ldd	r31, Y+4	; 0x04
    4054:	82 e2       	ldi	r24, 0x22	; 34
    4056:	80 83       	st	Z, r24
	pxTopOfStack--;
    4058:	8b 81       	ldd	r24, Y+3	; 0x03
    405a:	9c 81       	ldd	r25, Y+4	; 0x04
    405c:	01 97       	sbiw	r24, 0x01	; 1
    405e:	9c 83       	std	Y+4, r25	; 0x04
    4060:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    4062:	eb 81       	ldd	r30, Y+3	; 0x03
    4064:	fc 81       	ldd	r31, Y+4	; 0x04
    4066:	83 e2       	ldi	r24, 0x23	; 35
    4068:	80 83       	st	Z, r24
	pxTopOfStack--;
    406a:	8b 81       	ldd	r24, Y+3	; 0x03
    406c:	9c 81       	ldd	r25, Y+4	; 0x04
    406e:	01 97       	sbiw	r24, 0x01	; 1
    4070:	9c 83       	std	Y+4, r25	; 0x04
    4072:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    4074:	8f 81       	ldd	r24, Y+7	; 0x07
    4076:	98 85       	ldd	r25, Y+8	; 0x08
    4078:	9a 83       	std	Y+2, r25	; 0x02
    407a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    407c:	89 81       	ldd	r24, Y+1	; 0x01
    407e:	eb 81       	ldd	r30, Y+3	; 0x03
    4080:	fc 81       	ldd	r31, Y+4	; 0x04
    4082:	80 83       	st	Z, r24
	pxTopOfStack--;
    4084:	8b 81       	ldd	r24, Y+3	; 0x03
    4086:	9c 81       	ldd	r25, Y+4	; 0x04
    4088:	01 97       	sbiw	r24, 0x01	; 1
    408a:	9c 83       	std	Y+4, r25	; 0x04
    408c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    408e:	89 81       	ldd	r24, Y+1	; 0x01
    4090:	9a 81       	ldd	r25, Y+2	; 0x02
    4092:	89 2f       	mov	r24, r25
    4094:	99 27       	eor	r25, r25
    4096:	9a 83       	std	Y+2, r25	; 0x02
    4098:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    409a:	89 81       	ldd	r24, Y+1	; 0x01
    409c:	eb 81       	ldd	r30, Y+3	; 0x03
    409e:	fc 81       	ldd	r31, Y+4	; 0x04
    40a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    40a2:	8b 81       	ldd	r24, Y+3	; 0x03
    40a4:	9c 81       	ldd	r25, Y+4	; 0x04
    40a6:	01 97       	sbiw	r24, 0x01	; 1
    40a8:	9c 83       	std	Y+4, r25	; 0x04
    40aa:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    40ac:	eb 81       	ldd	r30, Y+3	; 0x03
    40ae:	fc 81       	ldd	r31, Y+4	; 0x04
    40b0:	86 e2       	ldi	r24, 0x26	; 38
    40b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    40b4:	8b 81       	ldd	r24, Y+3	; 0x03
    40b6:	9c 81       	ldd	r25, Y+4	; 0x04
    40b8:	01 97       	sbiw	r24, 0x01	; 1
    40ba:	9c 83       	std	Y+4, r25	; 0x04
    40bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    40be:	eb 81       	ldd	r30, Y+3	; 0x03
    40c0:	fc 81       	ldd	r31, Y+4	; 0x04
    40c2:	87 e2       	ldi	r24, 0x27	; 39
    40c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    40c6:	8b 81       	ldd	r24, Y+3	; 0x03
    40c8:	9c 81       	ldd	r25, Y+4	; 0x04
    40ca:	01 97       	sbiw	r24, 0x01	; 1
    40cc:	9c 83       	std	Y+4, r25	; 0x04
    40ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    40d0:	eb 81       	ldd	r30, Y+3	; 0x03
    40d2:	fc 81       	ldd	r31, Y+4	; 0x04
    40d4:	88 e2       	ldi	r24, 0x28	; 40
    40d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    40d8:	8b 81       	ldd	r24, Y+3	; 0x03
    40da:	9c 81       	ldd	r25, Y+4	; 0x04
    40dc:	01 97       	sbiw	r24, 0x01	; 1
    40de:	9c 83       	std	Y+4, r25	; 0x04
    40e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    40e2:	eb 81       	ldd	r30, Y+3	; 0x03
    40e4:	fc 81       	ldd	r31, Y+4	; 0x04
    40e6:	89 e2       	ldi	r24, 0x29	; 41
    40e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    40ea:	8b 81       	ldd	r24, Y+3	; 0x03
    40ec:	9c 81       	ldd	r25, Y+4	; 0x04
    40ee:	01 97       	sbiw	r24, 0x01	; 1
    40f0:	9c 83       	std	Y+4, r25	; 0x04
    40f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    40f4:	eb 81       	ldd	r30, Y+3	; 0x03
    40f6:	fc 81       	ldd	r31, Y+4	; 0x04
    40f8:	80 e3       	ldi	r24, 0x30	; 48
    40fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    40fc:	8b 81       	ldd	r24, Y+3	; 0x03
    40fe:	9c 81       	ldd	r25, Y+4	; 0x04
    4100:	01 97       	sbiw	r24, 0x01	; 1
    4102:	9c 83       	std	Y+4, r25	; 0x04
    4104:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    4106:	eb 81       	ldd	r30, Y+3	; 0x03
    4108:	fc 81       	ldd	r31, Y+4	; 0x04
    410a:	81 e3       	ldi	r24, 0x31	; 49
    410c:	80 83       	st	Z, r24
	pxTopOfStack--;
    410e:	8b 81       	ldd	r24, Y+3	; 0x03
    4110:	9c 81       	ldd	r25, Y+4	; 0x04
    4112:	01 97       	sbiw	r24, 0x01	; 1
    4114:	9c 83       	std	Y+4, r25	; 0x04
    4116:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    4118:	8b 81       	ldd	r24, Y+3	; 0x03
    411a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    411c:	28 96       	adiw	r28, 0x08	; 8
    411e:	0f b6       	in	r0, 0x3f	; 63
    4120:	f8 94       	cli
    4122:	de bf       	out	0x3e, r29	; 62
    4124:	0f be       	out	0x3f, r0	; 63
    4126:	cd bf       	out	0x3d, r28	; 61
    4128:	cf 91       	pop	r28
    412a:	df 91       	pop	r29
    412c:	08 95       	ret

0000412e <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    412e:	df 93       	push	r29
    4130:	cf 93       	push	r28
    4132:	cd b7       	in	r28, 0x3d	; 61
    4134:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    4136:	0e 94 89 21 	call	0x4312	; 0x4312 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    413a:	a0 91 97 06 	lds	r26, 0x0697
    413e:	b0 91 98 06 	lds	r27, 0x0698
    4142:	cd 91       	ld	r28, X+
    4144:	cd bf       	out	0x3d, r28	; 61
    4146:	dd 91       	ld	r29, X+
    4148:	de bf       	out	0x3e, r29	; 62
    414a:	ff 91       	pop	r31
    414c:	ef 91       	pop	r30
    414e:	df 91       	pop	r29
    4150:	cf 91       	pop	r28
    4152:	bf 91       	pop	r27
    4154:	af 91       	pop	r26
    4156:	9f 91       	pop	r25
    4158:	8f 91       	pop	r24
    415a:	7f 91       	pop	r23
    415c:	6f 91       	pop	r22
    415e:	5f 91       	pop	r21
    4160:	4f 91       	pop	r20
    4162:	3f 91       	pop	r19
    4164:	2f 91       	pop	r18
    4166:	1f 91       	pop	r17
    4168:	0f 91       	pop	r16
    416a:	ff 90       	pop	r15
    416c:	ef 90       	pop	r14
    416e:	df 90       	pop	r13
    4170:	cf 90       	pop	r12
    4172:	bf 90       	pop	r11
    4174:	af 90       	pop	r10
    4176:	9f 90       	pop	r9
    4178:	8f 90       	pop	r8
    417a:	7f 90       	pop	r7
    417c:	6f 90       	pop	r6
    417e:	5f 90       	pop	r5
    4180:	4f 90       	pop	r4
    4182:	3f 90       	pop	r3
    4184:	2f 90       	pop	r2
    4186:	1f 90       	pop	r1
    4188:	0f 90       	pop	r0
    418a:	0f be       	out	0x3f, r0	; 63
    418c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    418e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    4190:	81 e0       	ldi	r24, 0x01	; 1
}
    4192:	cf 91       	pop	r28
    4194:	df 91       	pop	r29
    4196:	08 95       	ret

00004198 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    4198:	df 93       	push	r29
    419a:	cf 93       	push	r28
    419c:	cd b7       	in	r28, 0x3d	; 61
    419e:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    41a0:	cf 91       	pop	r28
    41a2:	df 91       	pop	r29
    41a4:	08 95       	ret

000041a6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    41a6:	0f 92       	push	r0
    41a8:	0f b6       	in	r0, 0x3f	; 63
    41aa:	f8 94       	cli
    41ac:	0f 92       	push	r0
    41ae:	1f 92       	push	r1
    41b0:	11 24       	eor	r1, r1
    41b2:	2f 92       	push	r2
    41b4:	3f 92       	push	r3
    41b6:	4f 92       	push	r4
    41b8:	5f 92       	push	r5
    41ba:	6f 92       	push	r6
    41bc:	7f 92       	push	r7
    41be:	8f 92       	push	r8
    41c0:	9f 92       	push	r9
    41c2:	af 92       	push	r10
    41c4:	bf 92       	push	r11
    41c6:	cf 92       	push	r12
    41c8:	df 92       	push	r13
    41ca:	ef 92       	push	r14
    41cc:	ff 92       	push	r15
    41ce:	0f 93       	push	r16
    41d0:	1f 93       	push	r17
    41d2:	2f 93       	push	r18
    41d4:	3f 93       	push	r19
    41d6:	4f 93       	push	r20
    41d8:	5f 93       	push	r21
    41da:	6f 93       	push	r22
    41dc:	7f 93       	push	r23
    41de:	8f 93       	push	r24
    41e0:	9f 93       	push	r25
    41e2:	af 93       	push	r26
    41e4:	bf 93       	push	r27
    41e6:	cf 93       	push	r28
    41e8:	df 93       	push	r29
    41ea:	ef 93       	push	r30
    41ec:	ff 93       	push	r31
    41ee:	a0 91 97 06 	lds	r26, 0x0697
    41f2:	b0 91 98 06 	lds	r27, 0x0698
    41f6:	0d b6       	in	r0, 0x3d	; 61
    41f8:	0d 92       	st	X+, r0
    41fa:	0e b6       	in	r0, 0x3e	; 62
    41fc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    41fe:	0e 94 04 2d 	call	0x5a08	; 0x5a08 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    4202:	a0 91 97 06 	lds	r26, 0x0697
    4206:	b0 91 98 06 	lds	r27, 0x0698
    420a:	cd 91       	ld	r28, X+
    420c:	cd bf       	out	0x3d, r28	; 61
    420e:	dd 91       	ld	r29, X+
    4210:	de bf       	out	0x3e, r29	; 62
    4212:	ff 91       	pop	r31
    4214:	ef 91       	pop	r30
    4216:	df 91       	pop	r29
    4218:	cf 91       	pop	r28
    421a:	bf 91       	pop	r27
    421c:	af 91       	pop	r26
    421e:	9f 91       	pop	r25
    4220:	8f 91       	pop	r24
    4222:	7f 91       	pop	r23
    4224:	6f 91       	pop	r22
    4226:	5f 91       	pop	r21
    4228:	4f 91       	pop	r20
    422a:	3f 91       	pop	r19
    422c:	2f 91       	pop	r18
    422e:	1f 91       	pop	r17
    4230:	0f 91       	pop	r16
    4232:	ff 90       	pop	r15
    4234:	ef 90       	pop	r14
    4236:	df 90       	pop	r13
    4238:	cf 90       	pop	r12
    423a:	bf 90       	pop	r11
    423c:	af 90       	pop	r10
    423e:	9f 90       	pop	r9
    4240:	8f 90       	pop	r8
    4242:	7f 90       	pop	r7
    4244:	6f 90       	pop	r6
    4246:	5f 90       	pop	r5
    4248:	4f 90       	pop	r4
    424a:	3f 90       	pop	r3
    424c:	2f 90       	pop	r2
    424e:	1f 90       	pop	r1
    4250:	0f 90       	pop	r0
    4252:	0f be       	out	0x3f, r0	; 63
    4254:	0f 90       	pop	r0

	asm volatile ( "ret" );
    4256:	08 95       	ret

00004258 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    4258:	0f 92       	push	r0
    425a:	0f b6       	in	r0, 0x3f	; 63
    425c:	f8 94       	cli
    425e:	0f 92       	push	r0
    4260:	1f 92       	push	r1
    4262:	11 24       	eor	r1, r1
    4264:	2f 92       	push	r2
    4266:	3f 92       	push	r3
    4268:	4f 92       	push	r4
    426a:	5f 92       	push	r5
    426c:	6f 92       	push	r6
    426e:	7f 92       	push	r7
    4270:	8f 92       	push	r8
    4272:	9f 92       	push	r9
    4274:	af 92       	push	r10
    4276:	bf 92       	push	r11
    4278:	cf 92       	push	r12
    427a:	df 92       	push	r13
    427c:	ef 92       	push	r14
    427e:	ff 92       	push	r15
    4280:	0f 93       	push	r16
    4282:	1f 93       	push	r17
    4284:	2f 93       	push	r18
    4286:	3f 93       	push	r19
    4288:	4f 93       	push	r20
    428a:	5f 93       	push	r21
    428c:	6f 93       	push	r22
    428e:	7f 93       	push	r23
    4290:	8f 93       	push	r24
    4292:	9f 93       	push	r25
    4294:	af 93       	push	r26
    4296:	bf 93       	push	r27
    4298:	cf 93       	push	r28
    429a:	df 93       	push	r29
    429c:	ef 93       	push	r30
    429e:	ff 93       	push	r31
    42a0:	a0 91 97 06 	lds	r26, 0x0697
    42a4:	b0 91 98 06 	lds	r27, 0x0698
    42a8:	0d b6       	in	r0, 0x3d	; 61
    42aa:	0d 92       	st	X+, r0
    42ac:	0e b6       	in	r0, 0x3e	; 62
    42ae:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    42b0:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskIncrementTick>
    42b4:	88 23       	and	r24, r24
    42b6:	11 f0       	breq	.+4      	; 0x42bc <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    42b8:	0e 94 04 2d 	call	0x5a08	; 0x5a08 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    42bc:	a0 91 97 06 	lds	r26, 0x0697
    42c0:	b0 91 98 06 	lds	r27, 0x0698
    42c4:	cd 91       	ld	r28, X+
    42c6:	cd bf       	out	0x3d, r28	; 61
    42c8:	dd 91       	ld	r29, X+
    42ca:	de bf       	out	0x3e, r29	; 62
    42cc:	ff 91       	pop	r31
    42ce:	ef 91       	pop	r30
    42d0:	df 91       	pop	r29
    42d2:	cf 91       	pop	r28
    42d4:	bf 91       	pop	r27
    42d6:	af 91       	pop	r26
    42d8:	9f 91       	pop	r25
    42da:	8f 91       	pop	r24
    42dc:	7f 91       	pop	r23
    42de:	6f 91       	pop	r22
    42e0:	5f 91       	pop	r21
    42e2:	4f 91       	pop	r20
    42e4:	3f 91       	pop	r19
    42e6:	2f 91       	pop	r18
    42e8:	1f 91       	pop	r17
    42ea:	0f 91       	pop	r16
    42ec:	ff 90       	pop	r15
    42ee:	ef 90       	pop	r14
    42f0:	df 90       	pop	r13
    42f2:	cf 90       	pop	r12
    42f4:	bf 90       	pop	r11
    42f6:	af 90       	pop	r10
    42f8:	9f 90       	pop	r9
    42fa:	8f 90       	pop	r8
    42fc:	7f 90       	pop	r7
    42fe:	6f 90       	pop	r6
    4300:	5f 90       	pop	r5
    4302:	4f 90       	pop	r4
    4304:	3f 90       	pop	r3
    4306:	2f 90       	pop	r2
    4308:	1f 90       	pop	r1
    430a:	0f 90       	pop	r0
    430c:	0f be       	out	0x3f, r0	; 63
    430e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    4310:	08 95       	ret

00004312 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    4312:	df 93       	push	r29
    4314:	cf 93       	push	r28
    4316:	00 d0       	rcall	.+0      	; 0x4318 <prvSetupTimerInterrupt+0x6>
    4318:	00 d0       	rcall	.+0      	; 0x431a <prvSetupTimerInterrupt+0x8>
    431a:	00 d0       	rcall	.+0      	; 0x431c <prvSetupTimerInterrupt+0xa>
    431c:	cd b7       	in	r28, 0x3d	; 61
    431e:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    4320:	80 e4       	ldi	r24, 0x40	; 64
    4322:	9f e1       	ldi	r25, 0x1F	; 31
    4324:	a0 e0       	ldi	r26, 0x00	; 0
    4326:	b0 e0       	ldi	r27, 0x00	; 0
    4328:	8b 83       	std	Y+3, r24	; 0x03
    432a:	9c 83       	std	Y+4, r25	; 0x04
    432c:	ad 83       	std	Y+5, r26	; 0x05
    432e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    4330:	8b 81       	ldd	r24, Y+3	; 0x03
    4332:	9c 81       	ldd	r25, Y+4	; 0x04
    4334:	ad 81       	ldd	r26, Y+5	; 0x05
    4336:	be 81       	ldd	r27, Y+6	; 0x06
    4338:	68 94       	set
    433a:	15 f8       	bld	r1, 5
    433c:	b6 95       	lsr	r27
    433e:	a7 95       	ror	r26
    4340:	97 95       	ror	r25
    4342:	87 95       	ror	r24
    4344:	16 94       	lsr	r1
    4346:	d1 f7       	brne	.-12     	; 0x433c <prvSetupTimerInterrupt+0x2a>
    4348:	8b 83       	std	Y+3, r24	; 0x03
    434a:	9c 83       	std	Y+4, r25	; 0x04
    434c:	ad 83       	std	Y+5, r26	; 0x05
    434e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    4350:	8b 81       	ldd	r24, Y+3	; 0x03
    4352:	9c 81       	ldd	r25, Y+4	; 0x04
    4354:	ad 81       	ldd	r26, Y+5	; 0x05
    4356:	be 81       	ldd	r27, Y+6	; 0x06
    4358:	01 97       	sbiw	r24, 0x01	; 1
    435a:	a1 09       	sbc	r26, r1
    435c:	b1 09       	sbc	r27, r1
    435e:	8b 83       	std	Y+3, r24	; 0x03
    4360:	9c 83       	std	Y+4, r25	; 0x04
    4362:	ad 83       	std	Y+5, r26	; 0x05
    4364:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    4366:	8b 81       	ldd	r24, Y+3	; 0x03
    4368:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    436a:	8b 81       	ldd	r24, Y+3	; 0x03
    436c:	9c 81       	ldd	r25, Y+4	; 0x04
    436e:	ad 81       	ldd	r26, Y+5	; 0x05
    4370:	be 81       	ldd	r27, Y+6	; 0x06
    4372:	89 2f       	mov	r24, r25
    4374:	9a 2f       	mov	r25, r26
    4376:	ab 2f       	mov	r26, r27
    4378:	bb 27       	eor	r27, r27
    437a:	8b 83       	std	Y+3, r24	; 0x03
    437c:	9c 83       	std	Y+4, r25	; 0x04
    437e:	ad 83       	std	Y+5, r26	; 0x05
    4380:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    4382:	8b 81       	ldd	r24, Y+3	; 0x03
    4384:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    4386:	eb e4       	ldi	r30, 0x4B	; 75
    4388:	f0 e0       	ldi	r31, 0x00	; 0
    438a:	8a 81       	ldd	r24, Y+2	; 0x02
    438c:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    438e:	ea e4       	ldi	r30, 0x4A	; 74
    4390:	f0 e0       	ldi	r31, 0x00	; 0
    4392:	89 81       	ldd	r24, Y+1	; 0x01
    4394:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    4396:	8b e0       	ldi	r24, 0x0B	; 11
    4398:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    439a:	ee e4       	ldi	r30, 0x4E	; 78
    439c:	f0 e0       	ldi	r31, 0x00	; 0
    439e:	89 81       	ldd	r24, Y+1	; 0x01
    43a0:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    43a2:	e9 e5       	ldi	r30, 0x59	; 89
    43a4:	f0 e0       	ldi	r31, 0x00	; 0
    43a6:	80 81       	ld	r24, Z
    43a8:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    43aa:	89 81       	ldd	r24, Y+1	; 0x01
    43ac:	80 61       	ori	r24, 0x10	; 16
    43ae:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    43b0:	e9 e5       	ldi	r30, 0x59	; 89
    43b2:	f0 e0       	ldi	r31, 0x00	; 0
    43b4:	89 81       	ldd	r24, Y+1	; 0x01
    43b6:	80 83       	st	Z, r24
}
    43b8:	26 96       	adiw	r28, 0x06	; 6
    43ba:	0f b6       	in	r0, 0x3f	; 63
    43bc:	f8 94       	cli
    43be:	de bf       	out	0x3e, r29	; 62
    43c0:	0f be       	out	0x3f, r0	; 63
    43c2:	cd bf       	out	0x3d, r28	; 61
    43c4:	cf 91       	pop	r28
    43c6:	df 91       	pop	r29
    43c8:	08 95       	ret

000043ca <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    43ca:	0e 94 2c 21 	call	0x4258	; 0x4258 <vPortYieldFromTick>
		asm volatile ( "reti" );
    43ce:	18 95       	reti

000043d0 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    43d0:	df 93       	push	r29
    43d2:	cf 93       	push	r28
    43d4:	00 d0       	rcall	.+0      	; 0x43d6 <xQueueGenericReset+0x6>
    43d6:	00 d0       	rcall	.+0      	; 0x43d8 <xQueueGenericReset+0x8>
    43d8:	0f 92       	push	r0
    43da:	cd b7       	in	r28, 0x3d	; 61
    43dc:	de b7       	in	r29, 0x3e	; 62
    43de:	9c 83       	std	Y+4, r25	; 0x04
    43e0:	8b 83       	std	Y+3, r24	; 0x03
    43e2:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    43e4:	8b 81       	ldd	r24, Y+3	; 0x03
    43e6:	9c 81       	ldd	r25, Y+4	; 0x04
    43e8:	9a 83       	std	Y+2, r25	; 0x02
    43ea:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    43ec:	0f b6       	in	r0, 0x3f	; 63
    43ee:	f8 94       	cli
    43f0:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    43f2:	e9 81       	ldd	r30, Y+1	; 0x01
    43f4:	fa 81       	ldd	r31, Y+2	; 0x02
    43f6:	40 81       	ld	r20, Z
    43f8:	51 81       	ldd	r21, Z+1	; 0x01
    43fa:	e9 81       	ldd	r30, Y+1	; 0x01
    43fc:	fa 81       	ldd	r31, Y+2	; 0x02
    43fe:	83 8d       	ldd	r24, Z+27	; 0x1b
    4400:	28 2f       	mov	r18, r24
    4402:	30 e0       	ldi	r19, 0x00	; 0
    4404:	e9 81       	ldd	r30, Y+1	; 0x01
    4406:	fa 81       	ldd	r31, Y+2	; 0x02
    4408:	84 8d       	ldd	r24, Z+28	; 0x1c
    440a:	88 2f       	mov	r24, r24
    440c:	90 e0       	ldi	r25, 0x00	; 0
    440e:	bc 01       	movw	r22, r24
    4410:	26 9f       	mul	r18, r22
    4412:	c0 01       	movw	r24, r0
    4414:	27 9f       	mul	r18, r23
    4416:	90 0d       	add	r25, r0
    4418:	36 9f       	mul	r19, r22
    441a:	90 0d       	add	r25, r0
    441c:	11 24       	eor	r1, r1
    441e:	84 0f       	add	r24, r20
    4420:	95 1f       	adc	r25, r21
    4422:	e9 81       	ldd	r30, Y+1	; 0x01
    4424:	fa 81       	ldd	r31, Y+2	; 0x02
    4426:	93 83       	std	Z+3, r25	; 0x03
    4428:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    442a:	e9 81       	ldd	r30, Y+1	; 0x01
    442c:	fa 81       	ldd	r31, Y+2	; 0x02
    442e:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    4430:	e9 81       	ldd	r30, Y+1	; 0x01
    4432:	fa 81       	ldd	r31, Y+2	; 0x02
    4434:	80 81       	ld	r24, Z
    4436:	91 81       	ldd	r25, Z+1	; 0x01
    4438:	e9 81       	ldd	r30, Y+1	; 0x01
    443a:	fa 81       	ldd	r31, Y+2	; 0x02
    443c:	95 83       	std	Z+5, r25	; 0x05
    443e:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    4440:	e9 81       	ldd	r30, Y+1	; 0x01
    4442:	fa 81       	ldd	r31, Y+2	; 0x02
    4444:	40 81       	ld	r20, Z
    4446:	51 81       	ldd	r21, Z+1	; 0x01
    4448:	e9 81       	ldd	r30, Y+1	; 0x01
    444a:	fa 81       	ldd	r31, Y+2	; 0x02
    444c:	83 8d       	ldd	r24, Z+27	; 0x1b
    444e:	88 2f       	mov	r24, r24
    4450:	90 e0       	ldi	r25, 0x00	; 0
    4452:	9c 01       	movw	r18, r24
    4454:	21 50       	subi	r18, 0x01	; 1
    4456:	30 40       	sbci	r19, 0x00	; 0
    4458:	e9 81       	ldd	r30, Y+1	; 0x01
    445a:	fa 81       	ldd	r31, Y+2	; 0x02
    445c:	84 8d       	ldd	r24, Z+28	; 0x1c
    445e:	88 2f       	mov	r24, r24
    4460:	90 e0       	ldi	r25, 0x00	; 0
    4462:	bc 01       	movw	r22, r24
    4464:	26 9f       	mul	r18, r22
    4466:	c0 01       	movw	r24, r0
    4468:	27 9f       	mul	r18, r23
    446a:	90 0d       	add	r25, r0
    446c:	36 9f       	mul	r19, r22
    446e:	90 0d       	add	r25, r0
    4470:	11 24       	eor	r1, r1
    4472:	84 0f       	add	r24, r20
    4474:	95 1f       	adc	r25, r21
    4476:	e9 81       	ldd	r30, Y+1	; 0x01
    4478:	fa 81       	ldd	r31, Y+2	; 0x02
    447a:	97 83       	std	Z+7, r25	; 0x07
    447c:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    447e:	e9 81       	ldd	r30, Y+1	; 0x01
    4480:	fa 81       	ldd	r31, Y+2	; 0x02
    4482:	8f ef       	ldi	r24, 0xFF	; 255
    4484:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    4486:	e9 81       	ldd	r30, Y+1	; 0x01
    4488:	fa 81       	ldd	r31, Y+2	; 0x02
    448a:	8f ef       	ldi	r24, 0xFF	; 255
    448c:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    448e:	8d 81       	ldd	r24, Y+5	; 0x05
    4490:	88 23       	and	r24, r24
    4492:	79 f4       	brne	.+30     	; 0x44b2 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4494:	e9 81       	ldd	r30, Y+1	; 0x01
    4496:	fa 81       	ldd	r31, Y+2	; 0x02
    4498:	80 85       	ldd	r24, Z+8	; 0x08
    449a:	88 23       	and	r24, r24
    449c:	a1 f0       	breq	.+40     	; 0x44c6 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    449e:	89 81       	ldd	r24, Y+1	; 0x01
    44a0:	9a 81       	ldd	r25, Y+2	; 0x02
    44a2:	08 96       	adiw	r24, 0x08	; 8
    44a4:	0e 94 e5 2d 	call	0x5bca	; 0x5bca <xTaskRemoveFromEventList>
    44a8:	81 30       	cpi	r24, 0x01	; 1
    44aa:	69 f4       	brne	.+26     	; 0x44c6 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    44ac:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>
    44b0:	0a c0       	rjmp	.+20     	; 0x44c6 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    44b2:	89 81       	ldd	r24, Y+1	; 0x01
    44b4:	9a 81       	ldd	r25, Y+2	; 0x02
    44b6:	08 96       	adiw	r24, 0x08	; 8
    44b8:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    44bc:	89 81       	ldd	r24, Y+1	; 0x01
    44be:	9a 81       	ldd	r25, Y+2	; 0x02
    44c0:	41 96       	adiw	r24, 0x11	; 17
    44c2:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    44c6:	0f 90       	pop	r0
    44c8:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    44ca:	81 e0       	ldi	r24, 0x01	; 1
}
    44cc:	0f 90       	pop	r0
    44ce:	0f 90       	pop	r0
    44d0:	0f 90       	pop	r0
    44d2:	0f 90       	pop	r0
    44d4:	0f 90       	pop	r0
    44d6:	cf 91       	pop	r28
    44d8:	df 91       	pop	r29
    44da:	08 95       	ret

000044dc <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    44dc:	df 93       	push	r29
    44de:	cf 93       	push	r28
    44e0:	cd b7       	in	r28, 0x3d	; 61
    44e2:	de b7       	in	r29, 0x3e	; 62
    44e4:	29 97       	sbiw	r28, 0x09	; 9
    44e6:	0f b6       	in	r0, 0x3f	; 63
    44e8:	f8 94       	cli
    44ea:	de bf       	out	0x3e, r29	; 62
    44ec:	0f be       	out	0x3f, r0	; 63
    44ee:	cd bf       	out	0x3d, r28	; 61
    44f0:	8f 83       	std	Y+7, r24	; 0x07
    44f2:	68 87       	std	Y+8, r22	; 0x08
    44f4:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    44f6:	1a 82       	std	Y+2, r1	; 0x02
    44f8:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    44fa:	8f 81       	ldd	r24, Y+7	; 0x07
    44fc:	88 23       	and	r24, r24
    44fe:	09 f4       	brne	.+2      	; 0x4502 <xQueueGenericCreate+0x26>
    4500:	3f c0       	rjmp	.+126    	; 0x4580 <xQueueGenericCreate+0xa4>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    4502:	8f e1       	ldi	r24, 0x1F	; 31
    4504:	90 e0       	ldi	r25, 0x00	; 0
    4506:	0e 94 90 1c 	call	0x3920	; 0x3920 <pvPortMalloc>
    450a:	9e 83       	std	Y+6, r25	; 0x06
    450c:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    450e:	8d 81       	ldd	r24, Y+5	; 0x05
    4510:	9e 81       	ldd	r25, Y+6	; 0x06
    4512:	00 97       	sbiw	r24, 0x00	; 0
    4514:	a9 f1       	breq	.+106    	; 0x4580 <xQueueGenericCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4516:	8f 81       	ldd	r24, Y+7	; 0x07
    4518:	28 2f       	mov	r18, r24
    451a:	30 e0       	ldi	r19, 0x00	; 0
    451c:	88 85       	ldd	r24, Y+8	; 0x08
    451e:	88 2f       	mov	r24, r24
    4520:	90 e0       	ldi	r25, 0x00	; 0
    4522:	ac 01       	movw	r20, r24
    4524:	24 9f       	mul	r18, r20
    4526:	c0 01       	movw	r24, r0
    4528:	25 9f       	mul	r18, r21
    452a:	90 0d       	add	r25, r0
    452c:	34 9f       	mul	r19, r20
    452e:	90 0d       	add	r25, r0
    4530:	11 24       	eor	r1, r1
    4532:	01 96       	adiw	r24, 0x01	; 1
    4534:	9c 83       	std	Y+4, r25	; 0x04
    4536:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    4538:	8b 81       	ldd	r24, Y+3	; 0x03
    453a:	9c 81       	ldd	r25, Y+4	; 0x04
    453c:	0e 94 90 1c 	call	0x3920	; 0x3920 <pvPortMalloc>
    4540:	ed 81       	ldd	r30, Y+5	; 0x05
    4542:	fe 81       	ldd	r31, Y+6	; 0x06
    4544:	91 83       	std	Z+1, r25	; 0x01
    4546:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    4548:	ed 81       	ldd	r30, Y+5	; 0x05
    454a:	fe 81       	ldd	r31, Y+6	; 0x06
    454c:	80 81       	ld	r24, Z
    454e:	91 81       	ldd	r25, Z+1	; 0x01
    4550:	00 97       	sbiw	r24, 0x00	; 0
    4552:	91 f0       	breq	.+36     	; 0x4578 <xQueueGenericCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    4554:	ed 81       	ldd	r30, Y+5	; 0x05
    4556:	fe 81       	ldd	r31, Y+6	; 0x06
    4558:	8f 81       	ldd	r24, Y+7	; 0x07
    455a:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    455c:	ed 81       	ldd	r30, Y+5	; 0x05
    455e:	fe 81       	ldd	r31, Y+6	; 0x06
    4560:	88 85       	ldd	r24, Y+8	; 0x08
    4562:	84 8f       	std	Z+28, r24	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    4564:	8d 81       	ldd	r24, Y+5	; 0x05
    4566:	9e 81       	ldd	r25, Y+6	; 0x06
    4568:	61 e0       	ldi	r22, 0x01	; 1
    456a:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    456e:	8d 81       	ldd	r24, Y+5	; 0x05
    4570:	9e 81       	ldd	r25, Y+6	; 0x06
    4572:	9a 83       	std	Y+2, r25	; 0x02
    4574:	89 83       	std	Y+1, r24	; 0x01
    4576:	04 c0       	rjmp	.+8      	; 0x4580 <xQueueGenericCreate+0xa4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    4578:	8d 81       	ldd	r24, Y+5	; 0x05
    457a:	9e 81       	ldd	r25, Y+6	; 0x06
    457c:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    4580:	89 81       	ldd	r24, Y+1	; 0x01
    4582:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4584:	29 96       	adiw	r28, 0x09	; 9
    4586:	0f b6       	in	r0, 0x3f	; 63
    4588:	f8 94       	cli
    458a:	de bf       	out	0x3e, r29	; 62
    458c:	0f be       	out	0x3f, r0	; 63
    458e:	cd bf       	out	0x3d, r28	; 61
    4590:	cf 91       	pop	r28
    4592:	df 91       	pop	r29
    4594:	08 95       	ret

00004596 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    4596:	df 93       	push	r29
    4598:	cf 93       	push	r28
    459a:	00 d0       	rcall	.+0      	; 0x459c <xQueueCreateMutex+0x6>
    459c:	0f 92       	push	r0
    459e:	cd b7       	in	r28, 0x3d	; 61
    45a0:	de b7       	in	r29, 0x3e	; 62
    45a2:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    45a4:	8f e1       	ldi	r24, 0x1F	; 31
    45a6:	90 e0       	ldi	r25, 0x00	; 0
    45a8:	0e 94 90 1c 	call	0x3920	; 0x3920 <pvPortMalloc>
    45ac:	9a 83       	std	Y+2, r25	; 0x02
    45ae:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    45b0:	89 81       	ldd	r24, Y+1	; 0x01
    45b2:	9a 81       	ldd	r25, Y+2	; 0x02
    45b4:	00 97       	sbiw	r24, 0x00	; 0
    45b6:	a9 f1       	breq	.+106    	; 0x4622 <xQueueCreateMutex+0x8c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    45b8:	e9 81       	ldd	r30, Y+1	; 0x01
    45ba:	fa 81       	ldd	r31, Y+2	; 0x02
    45bc:	13 82       	std	Z+3, r1	; 0x03
    45be:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    45c0:	e9 81       	ldd	r30, Y+1	; 0x01
    45c2:	fa 81       	ldd	r31, Y+2	; 0x02
    45c4:	11 82       	std	Z+1, r1	; 0x01
    45c6:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    45c8:	e9 81       	ldd	r30, Y+1	; 0x01
    45ca:	fa 81       	ldd	r31, Y+2	; 0x02
    45cc:	15 82       	std	Z+5, r1	; 0x05
    45ce:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    45d0:	e9 81       	ldd	r30, Y+1	; 0x01
    45d2:	fa 81       	ldd	r31, Y+2	; 0x02
    45d4:	17 82       	std	Z+7, r1	; 0x07
    45d6:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    45d8:	e9 81       	ldd	r30, Y+1	; 0x01
    45da:	fa 81       	ldd	r31, Y+2	; 0x02
    45dc:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    45de:	e9 81       	ldd	r30, Y+1	; 0x01
    45e0:	fa 81       	ldd	r31, Y+2	; 0x02
    45e2:	81 e0       	ldi	r24, 0x01	; 1
    45e4:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    45e6:	e9 81       	ldd	r30, Y+1	; 0x01
    45e8:	fa 81       	ldd	r31, Y+2	; 0x02
    45ea:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    45ec:	e9 81       	ldd	r30, Y+1	; 0x01
    45ee:	fa 81       	ldd	r31, Y+2	; 0x02
    45f0:	8f ef       	ldi	r24, 0xFF	; 255
    45f2:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    45f4:	e9 81       	ldd	r30, Y+1	; 0x01
    45f6:	fa 81       	ldd	r31, Y+2	; 0x02
    45f8:	8f ef       	ldi	r24, 0xFF	; 255
    45fa:	86 8f       	std	Z+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    45fc:	89 81       	ldd	r24, Y+1	; 0x01
    45fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4600:	08 96       	adiw	r24, 0x08	; 8
    4602:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    4606:	89 81       	ldd	r24, Y+1	; 0x01
    4608:	9a 81       	ldd	r25, Y+2	; 0x02
    460a:	41 96       	adiw	r24, 0x11	; 17
    460c:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    4610:	89 81       	ldd	r24, Y+1	; 0x01
    4612:	9a 81       	ldd	r25, Y+2	; 0x02
    4614:	60 e0       	ldi	r22, 0x00	; 0
    4616:	70 e0       	ldi	r23, 0x00	; 0
    4618:	40 e0       	ldi	r20, 0x00	; 0
    461a:	50 e0       	ldi	r21, 0x00	; 0
    461c:	20 e0       	ldi	r18, 0x00	; 0
    461e:	0e 94 39 23 	call	0x4672	; 0x4672 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    4622:	89 81       	ldd	r24, Y+1	; 0x01
    4624:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4626:	0f 90       	pop	r0
    4628:	0f 90       	pop	r0
    462a:	0f 90       	pop	r0
    462c:	cf 91       	pop	r28
    462e:	df 91       	pop	r29
    4630:	08 95       	ret

00004632 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    4632:	df 93       	push	r29
    4634:	cf 93       	push	r28
    4636:	00 d0       	rcall	.+0      	; 0x4638 <xQueueCreateCountingSemaphore+0x6>
    4638:	00 d0       	rcall	.+0      	; 0x463a <xQueueCreateCountingSemaphore+0x8>
    463a:	cd b7       	in	r28, 0x3d	; 61
    463c:	de b7       	in	r29, 0x3e	; 62
    463e:	8b 83       	std	Y+3, r24	; 0x03
    4640:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    4642:	8b 81       	ldd	r24, Y+3	; 0x03
    4644:	60 e0       	ldi	r22, 0x00	; 0
    4646:	42 e0       	ldi	r20, 0x02	; 2
    4648:	0e 94 6e 22 	call	0x44dc	; 0x44dc <xQueueGenericCreate>
    464c:	9a 83       	std	Y+2, r25	; 0x02
    464e:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    4650:	89 81       	ldd	r24, Y+1	; 0x01
    4652:	9a 81       	ldd	r25, Y+2	; 0x02
    4654:	00 97       	sbiw	r24, 0x00	; 0
    4656:	21 f0       	breq	.+8      	; 0x4660 <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    4658:	e9 81       	ldd	r30, Y+1	; 0x01
    465a:	fa 81       	ldd	r31, Y+2	; 0x02
    465c:	8c 81       	ldd	r24, Y+4	; 0x04
    465e:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
    4660:	89 81       	ldd	r24, Y+1	; 0x01
    4662:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4664:	0f 90       	pop	r0
    4666:	0f 90       	pop	r0
    4668:	0f 90       	pop	r0
    466a:	0f 90       	pop	r0
    466c:	cf 91       	pop	r28
    466e:	df 91       	pop	r29
    4670:	08 95       	ret

00004672 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    4672:	df 93       	push	r29
    4674:	cf 93       	push	r28
    4676:	cd b7       	in	r28, 0x3d	; 61
    4678:	de b7       	in	r29, 0x3e	; 62
    467a:	2f 97       	sbiw	r28, 0x0f	; 15
    467c:	0f b6       	in	r0, 0x3f	; 63
    467e:	f8 94       	cli
    4680:	de bf       	out	0x3e, r29	; 62
    4682:	0f be       	out	0x3f, r0	; 63
    4684:	cd bf       	out	0x3d, r28	; 61
    4686:	99 87       	std	Y+9, r25	; 0x09
    4688:	88 87       	std	Y+8, r24	; 0x08
    468a:	7b 87       	std	Y+11, r23	; 0x0b
    468c:	6a 87       	std	Y+10, r22	; 0x0a
    468e:	5d 87       	std	Y+13, r21	; 0x0d
    4690:	4c 87       	std	Y+12, r20	; 0x0c
    4692:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    4694:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4696:	88 85       	ldd	r24, Y+8	; 0x08
    4698:	99 85       	ldd	r25, Y+9	; 0x09
    469a:	9a 83       	std	Y+2, r25	; 0x02
    469c:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    469e:	0f b6       	in	r0, 0x3f	; 63
    46a0:	f8 94       	cli
    46a2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    46a4:	e9 81       	ldd	r30, Y+1	; 0x01
    46a6:	fa 81       	ldd	r31, Y+2	; 0x02
    46a8:	92 8d       	ldd	r25, Z+26	; 0x1a
    46aa:	e9 81       	ldd	r30, Y+1	; 0x01
    46ac:	fa 81       	ldd	r31, Y+2	; 0x02
    46ae:	83 8d       	ldd	r24, Z+27	; 0x1b
    46b0:	98 17       	cp	r25, r24
    46b2:	18 f0       	brcs	.+6      	; 0x46ba <xQueueGenericSend+0x48>
    46b4:	8e 85       	ldd	r24, Y+14	; 0x0e
    46b6:	82 30       	cpi	r24, 0x02	; 2
    46b8:	11 f5       	brne	.+68     	; 0x46fe <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    46ba:	89 81       	ldd	r24, Y+1	; 0x01
    46bc:	9a 81       	ldd	r25, Y+2	; 0x02
    46be:	2a 85       	ldd	r18, Y+10	; 0x0a
    46c0:	3b 85       	ldd	r19, Y+11	; 0x0b
    46c2:	b9 01       	movw	r22, r18
    46c4:	4e 85       	ldd	r20, Y+14	; 0x0e
    46c6:	0e 94 2b 26 	call	0x4c56	; 0x4c56 <prvCopyDataToQueue>
    46ca:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    46cc:	e9 81       	ldd	r30, Y+1	; 0x01
    46ce:	fa 81       	ldd	r31, Y+2	; 0x02
    46d0:	81 89       	ldd	r24, Z+17	; 0x11
    46d2:	88 23       	and	r24, r24
    46d4:	51 f0       	breq	.+20     	; 0x46ea <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    46d6:	89 81       	ldd	r24, Y+1	; 0x01
    46d8:	9a 81       	ldd	r25, Y+2	; 0x02
    46da:	41 96       	adiw	r24, 0x11	; 17
    46dc:	0e 94 e5 2d 	call	0x5bca	; 0x5bca <xTaskRemoveFromEventList>
    46e0:	81 30       	cpi	r24, 0x01	; 1
    46e2:	41 f4       	brne	.+16     	; 0x46f4 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    46e4:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>
    46e8:	05 c0       	rjmp	.+10     	; 0x46f4 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    46ea:	8b 81       	ldd	r24, Y+3	; 0x03
    46ec:	88 23       	and	r24, r24
    46ee:	11 f0       	breq	.+4      	; 0x46f4 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    46f0:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    46f4:	0f 90       	pop	r0
    46f6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    46f8:	81 e0       	ldi	r24, 0x01	; 1
    46fa:	8f 87       	std	Y+15, r24	; 0x0f
    46fc:	5c c0       	rjmp	.+184    	; 0x47b6 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    46fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    4700:	9d 85       	ldd	r25, Y+13	; 0x0d
    4702:	00 97       	sbiw	r24, 0x00	; 0
    4704:	21 f4       	brne	.+8      	; 0x470e <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    4706:	0f 90       	pop	r0
    4708:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    470a:	1f 86       	std	Y+15, r1	; 0x0f
    470c:	54 c0       	rjmp	.+168    	; 0x47b6 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    470e:	8c 81       	ldd	r24, Y+4	; 0x04
    4710:	88 23       	and	r24, r24
    4712:	31 f4       	brne	.+12     	; 0x4720 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4714:	ce 01       	movw	r24, r28
    4716:	05 96       	adiw	r24, 0x05	; 5
    4718:	0e 94 b5 2e 	call	0x5d6a	; 0x5d6a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    471c:	81 e0       	ldi	r24, 0x01	; 1
    471e:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    4720:	0f 90       	pop	r0
    4722:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4724:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4728:	0f b6       	in	r0, 0x3f	; 63
    472a:	f8 94       	cli
    472c:	0f 92       	push	r0
    472e:	e9 81       	ldd	r30, Y+1	; 0x01
    4730:	fa 81       	ldd	r31, Y+2	; 0x02
    4732:	85 8d       	ldd	r24, Z+29	; 0x1d
    4734:	8f 3f       	cpi	r24, 0xFF	; 255
    4736:	19 f4       	brne	.+6      	; 0x473e <xQueueGenericSend+0xcc>
    4738:	e9 81       	ldd	r30, Y+1	; 0x01
    473a:	fa 81       	ldd	r31, Y+2	; 0x02
    473c:	15 8e       	std	Z+29, r1	; 0x1d
    473e:	e9 81       	ldd	r30, Y+1	; 0x01
    4740:	fa 81       	ldd	r31, Y+2	; 0x02
    4742:	86 8d       	ldd	r24, Z+30	; 0x1e
    4744:	8f 3f       	cpi	r24, 0xFF	; 255
    4746:	19 f4       	brne	.+6      	; 0x474e <xQueueGenericSend+0xdc>
    4748:	e9 81       	ldd	r30, Y+1	; 0x01
    474a:	fa 81       	ldd	r31, Y+2	; 0x02
    474c:	16 8e       	std	Z+30, r1	; 0x1e
    474e:	0f 90       	pop	r0
    4750:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4752:	ce 01       	movw	r24, r28
    4754:	05 96       	adiw	r24, 0x05	; 5
    4756:	9e 01       	movw	r18, r28
    4758:	24 5f       	subi	r18, 0xF4	; 244
    475a:	3f 4f       	sbci	r19, 0xFF	; 255
    475c:	b9 01       	movw	r22, r18
    475e:	0e 94 ce 2e 	call	0x5d9c	; 0x5d9c <xTaskCheckForTimeOut>
    4762:	88 23       	and	r24, r24
    4764:	09 f5       	brne	.+66     	; 0x47a8 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    4766:	89 81       	ldd	r24, Y+1	; 0x01
    4768:	9a 81       	ldd	r25, Y+2	; 0x02
    476a:	0e 94 b4 27 	call	0x4f68	; 0x4f68 <prvIsQueueFull>
    476e:	88 23       	and	r24, r24
    4770:	a1 f0       	breq	.+40     	; 0x479a <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    4772:	89 81       	ldd	r24, Y+1	; 0x01
    4774:	9a 81       	ldd	r25, Y+2	; 0x02
    4776:	08 96       	adiw	r24, 0x08	; 8
    4778:	2c 85       	ldd	r18, Y+12	; 0x0c
    477a:	3d 85       	ldd	r19, Y+13	; 0x0d
    477c:	b9 01       	movw	r22, r18
    477e:	0e 94 6d 2d 	call	0x5ada	; 0x5ada <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    4782:	89 81       	ldd	r24, Y+1	; 0x01
    4784:	9a 81       	ldd	r25, Y+2	; 0x02
    4786:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    478a:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>
    478e:	88 23       	and	r24, r24
    4790:	09 f0       	breq	.+2      	; 0x4794 <xQueueGenericSend+0x122>
    4792:	85 cf       	rjmp	.-246    	; 0x469e <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    4794:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>
    4798:	82 cf       	rjmp	.-252    	; 0x469e <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    479a:	89 81       	ldd	r24, Y+1	; 0x01
    479c:	9a 81       	ldd	r25, Y+2	; 0x02
    479e:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    47a2:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>
    47a6:	7b cf       	rjmp	.-266    	; 0x469e <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    47a8:	89 81       	ldd	r24, Y+1	; 0x01
    47aa:	9a 81       	ldd	r25, Y+2	; 0x02
    47ac:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    47b0:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    47b4:	1f 86       	std	Y+15, r1	; 0x0f
    47b6:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    47b8:	2f 96       	adiw	r28, 0x0f	; 15
    47ba:	0f b6       	in	r0, 0x3f	; 63
    47bc:	f8 94       	cli
    47be:	de bf       	out	0x3e, r29	; 62
    47c0:	0f be       	out	0x3f, r0	; 63
    47c2:	cd bf       	out	0x3d, r28	; 61
    47c4:	cf 91       	pop	r28
    47c6:	df 91       	pop	r29
    47c8:	08 95       	ret

000047ca <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    47ca:	df 93       	push	r29
    47cc:	cf 93       	push	r28
    47ce:	cd b7       	in	r28, 0x3d	; 61
    47d0:	de b7       	in	r29, 0x3e	; 62
    47d2:	2b 97       	sbiw	r28, 0x0b	; 11
    47d4:	0f b6       	in	r0, 0x3f	; 63
    47d6:	f8 94       	cli
    47d8:	de bf       	out	0x3e, r29	; 62
    47da:	0f be       	out	0x3f, r0	; 63
    47dc:	cd bf       	out	0x3d, r28	; 61
    47de:	9e 83       	std	Y+6, r25	; 0x06
    47e0:	8d 83       	std	Y+5, r24	; 0x05
    47e2:	78 87       	std	Y+8, r23	; 0x08
    47e4:	6f 83       	std	Y+7, r22	; 0x07
    47e6:	5a 87       	std	Y+10, r21	; 0x0a
    47e8:	49 87       	std	Y+9, r20	; 0x09
    47ea:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    47ec:	8d 81       	ldd	r24, Y+5	; 0x05
    47ee:	9e 81       	ldd	r25, Y+6	; 0x06
    47f0:	9a 83       	std	Y+2, r25	; 0x02
    47f2:	89 83       	std	Y+1, r24	; 0x01
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    47f4:	1b 82       	std	Y+3, r1	; 0x03
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    47f6:	e9 81       	ldd	r30, Y+1	; 0x01
    47f8:	fa 81       	ldd	r31, Y+2	; 0x02
    47fa:	92 8d       	ldd	r25, Z+26	; 0x1a
    47fc:	e9 81       	ldd	r30, Y+1	; 0x01
    47fe:	fa 81       	ldd	r31, Y+2	; 0x02
    4800:	83 8d       	ldd	r24, Z+27	; 0x1b
    4802:	98 17       	cp	r25, r24
    4804:	18 f0       	brcs	.+6      	; 0x480c <xQueueGenericSendFromISR+0x42>
    4806:	8b 85       	ldd	r24, Y+11	; 0x0b
    4808:	82 30       	cpi	r24, 0x02	; 2
    480a:	b1 f5       	brne	.+108    	; 0x4878 <xQueueGenericSendFromISR+0xae>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    480c:	89 81       	ldd	r24, Y+1	; 0x01
    480e:	9a 81       	ldd	r25, Y+2	; 0x02
    4810:	2f 81       	ldd	r18, Y+7	; 0x07
    4812:	38 85       	ldd	r19, Y+8	; 0x08
    4814:	b9 01       	movw	r22, r18
    4816:	4b 85       	ldd	r20, Y+11	; 0x0b
    4818:	0e 94 2b 26 	call	0x4c56	; 0x4c56 <prvCopyDataToQueue>
    481c:	88 23       	and	r24, r24
    481e:	41 f0       	breq	.+16     	; 0x4830 <xQueueGenericSendFromISR+0x66>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    4820:	89 85       	ldd	r24, Y+9	; 0x09
    4822:	9a 85       	ldd	r25, Y+10	; 0x0a
    4824:	00 97       	sbiw	r24, 0x00	; 0
    4826:	21 f0       	breq	.+8      	; 0x4830 <xQueueGenericSendFromISR+0x66>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    4828:	e9 85       	ldd	r30, Y+9	; 0x09
    482a:	fa 85       	ldd	r31, Y+10	; 0x0a
    482c:	81 e0       	ldi	r24, 0x01	; 1
    482e:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    4830:	e9 81       	ldd	r30, Y+1	; 0x01
    4832:	fa 81       	ldd	r31, Y+2	; 0x02
    4834:	86 8d       	ldd	r24, Z+30	; 0x1e
    4836:	8f 3f       	cpi	r24, 0xFF	; 255
    4838:	a9 f4       	brne	.+42     	; 0x4864 <xQueueGenericSendFromISR+0x9a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    483a:	e9 81       	ldd	r30, Y+1	; 0x01
    483c:	fa 81       	ldd	r31, Y+2	; 0x02
    483e:	81 89       	ldd	r24, Z+17	; 0x11
    4840:	88 23       	and	r24, r24
    4842:	b9 f0       	breq	.+46     	; 0x4872 <xQueueGenericSendFromISR+0xa8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4844:	89 81       	ldd	r24, Y+1	; 0x01
    4846:	9a 81       	ldd	r25, Y+2	; 0x02
    4848:	41 96       	adiw	r24, 0x11	; 17
    484a:	0e 94 e5 2d 	call	0x5bca	; 0x5bca <xTaskRemoveFromEventList>
    484e:	88 23       	and	r24, r24
    4850:	81 f0       	breq	.+32     	; 0x4872 <xQueueGenericSendFromISR+0xa8>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    4852:	89 85       	ldd	r24, Y+9	; 0x09
    4854:	9a 85       	ldd	r25, Y+10	; 0x0a
    4856:	00 97       	sbiw	r24, 0x00	; 0
    4858:	61 f0       	breq	.+24     	; 0x4872 <xQueueGenericSendFromISR+0xa8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    485a:	e9 85       	ldd	r30, Y+9	; 0x09
    485c:	fa 85       	ldd	r31, Y+10	; 0x0a
    485e:	81 e0       	ldi	r24, 0x01	; 1
    4860:	80 83       	st	Z, r24
    4862:	07 c0       	rjmp	.+14     	; 0x4872 <xQueueGenericSendFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    4864:	e9 81       	ldd	r30, Y+1	; 0x01
    4866:	fa 81       	ldd	r31, Y+2	; 0x02
    4868:	86 8d       	ldd	r24, Z+30	; 0x1e
    486a:	8f 5f       	subi	r24, 0xFF	; 255
    486c:	e9 81       	ldd	r30, Y+1	; 0x01
    486e:	fa 81       	ldd	r31, Y+2	; 0x02
    4870:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    4872:	81 e0       	ldi	r24, 0x01	; 1
    4874:	8c 83       	std	Y+4, r24	; 0x04
    4876:	01 c0       	rjmp	.+2      	; 0x487a <xQueueGenericSendFromISR+0xb0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    4878:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    487a:	8c 81       	ldd	r24, Y+4	; 0x04
}
    487c:	2b 96       	adiw	r28, 0x0b	; 11
    487e:	0f b6       	in	r0, 0x3f	; 63
    4880:	f8 94       	cli
    4882:	de bf       	out	0x3e, r29	; 62
    4884:	0f be       	out	0x3f, r0	; 63
    4886:	cd bf       	out	0x3d, r28	; 61
    4888:	cf 91       	pop	r28
    488a:	df 91       	pop	r29
    488c:	08 95       	ret

0000488e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    488e:	df 93       	push	r29
    4890:	cf 93       	push	r28
    4892:	cd b7       	in	r28, 0x3d	; 61
    4894:	de b7       	in	r29, 0x3e	; 62
    4896:	60 97       	sbiw	r28, 0x10	; 16
    4898:	0f b6       	in	r0, 0x3f	; 63
    489a:	f8 94       	cli
    489c:	de bf       	out	0x3e, r29	; 62
    489e:	0f be       	out	0x3f, r0	; 63
    48a0:	cd bf       	out	0x3d, r28	; 61
    48a2:	9a 87       	std	Y+10, r25	; 0x0a
    48a4:	89 87       	std	Y+9, r24	; 0x09
    48a6:	7c 87       	std	Y+12, r23	; 0x0c
    48a8:	6b 87       	std	Y+11, r22	; 0x0b
    48aa:	5e 87       	std	Y+14, r21	; 0x0e
    48ac:	4d 87       	std	Y+13, r20	; 0x0d
    48ae:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    48b0:	1d 82       	std	Y+5, r1	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    48b2:	89 85       	ldd	r24, Y+9	; 0x09
    48b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    48b6:	9a 83       	std	Y+2, r25	; 0x02
    48b8:	89 83       	std	Y+1, r24	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    48ba:	0f b6       	in	r0, 0x3f	; 63
    48bc:	f8 94       	cli
    48be:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    48c0:	e9 81       	ldd	r30, Y+1	; 0x01
    48c2:	fa 81       	ldd	r31, Y+2	; 0x02
    48c4:	82 8d       	ldd	r24, Z+26	; 0x1a
    48c6:	88 23       	and	r24, r24
    48c8:	09 f4       	brne	.+2      	; 0x48cc <xQueueGenericReceive+0x3e>
    48ca:	4b c0       	rjmp	.+150    	; 0x4962 <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    48cc:	e9 81       	ldd	r30, Y+1	; 0x01
    48ce:	fa 81       	ldd	r31, Y+2	; 0x02
    48d0:	86 81       	ldd	r24, Z+6	; 0x06
    48d2:	97 81       	ldd	r25, Z+7	; 0x07
    48d4:	9c 83       	std	Y+4, r25	; 0x04
    48d6:	8b 83       	std	Y+3, r24	; 0x03

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    48d8:	89 81       	ldd	r24, Y+1	; 0x01
    48da:	9a 81       	ldd	r25, Y+2	; 0x02
    48dc:	2b 85       	ldd	r18, Y+11	; 0x0b
    48de:	3c 85       	ldd	r19, Y+12	; 0x0c
    48e0:	b9 01       	movw	r22, r18
    48e2:	0e 94 e4 26 	call	0x4dc8	; 0x4dc8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    48e6:	8f 85       	ldd	r24, Y+15	; 0x0f
    48e8:	88 23       	and	r24, r24
    48ea:	11 f5       	brne	.+68     	; 0x4930 <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    48ec:	e9 81       	ldd	r30, Y+1	; 0x01
    48ee:	fa 81       	ldd	r31, Y+2	; 0x02
    48f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    48f2:	81 50       	subi	r24, 0x01	; 1
    48f4:	e9 81       	ldd	r30, Y+1	; 0x01
    48f6:	fa 81       	ldd	r31, Y+2	; 0x02
    48f8:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    48fa:	e9 81       	ldd	r30, Y+1	; 0x01
    48fc:	fa 81       	ldd	r31, Y+2	; 0x02
    48fe:	80 81       	ld	r24, Z
    4900:	91 81       	ldd	r25, Z+1	; 0x01
    4902:	00 97       	sbiw	r24, 0x00	; 0
    4904:	31 f4       	brne	.+12     	; 0x4912 <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    4906:	0e 94 45 32 	call	0x648a	; 0x648a <pvTaskIncrementMutexHeldCount>
    490a:	e9 81       	ldd	r30, Y+1	; 0x01
    490c:	fa 81       	ldd	r31, Y+2	; 0x02
    490e:	93 83       	std	Z+3, r25	; 0x03
    4910:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4912:	e9 81       	ldd	r30, Y+1	; 0x01
    4914:	fa 81       	ldd	r31, Y+2	; 0x02
    4916:	80 85       	ldd	r24, Z+8	; 0x08
    4918:	88 23       	and	r24, r24
    491a:	f1 f0       	breq	.+60     	; 0x4958 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    491c:	89 81       	ldd	r24, Y+1	; 0x01
    491e:	9a 81       	ldd	r25, Y+2	; 0x02
    4920:	08 96       	adiw	r24, 0x08	; 8
    4922:	0e 94 e5 2d 	call	0x5bca	; 0x5bca <xTaskRemoveFromEventList>
    4926:	81 30       	cpi	r24, 0x01	; 1
    4928:	b9 f4       	brne	.+46     	; 0x4958 <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    492a:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>
    492e:	14 c0       	rjmp	.+40     	; 0x4958 <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    4930:	e9 81       	ldd	r30, Y+1	; 0x01
    4932:	fa 81       	ldd	r31, Y+2	; 0x02
    4934:	8b 81       	ldd	r24, Y+3	; 0x03
    4936:	9c 81       	ldd	r25, Y+4	; 0x04
    4938:	97 83       	std	Z+7, r25	; 0x07
    493a:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    493c:	e9 81       	ldd	r30, Y+1	; 0x01
    493e:	fa 81       	ldd	r31, Y+2	; 0x02
    4940:	81 89       	ldd	r24, Z+17	; 0x11
    4942:	88 23       	and	r24, r24
    4944:	49 f0       	breq	.+18     	; 0x4958 <xQueueGenericReceive+0xca>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4946:	89 81       	ldd	r24, Y+1	; 0x01
    4948:	9a 81       	ldd	r25, Y+2	; 0x02
    494a:	41 96       	adiw	r24, 0x11	; 17
    494c:	0e 94 e5 2d 	call	0x5bca	; 0x5bca <xTaskRemoveFromEventList>
    4950:	88 23       	and	r24, r24
    4952:	11 f0       	breq	.+4      	; 0x4958 <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    4954:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    4958:	0f 90       	pop	r0
    495a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    495c:	81 e0       	ldi	r24, 0x01	; 1
    495e:	88 8b       	std	Y+16, r24	; 0x10
    4960:	6d c0       	rjmp	.+218    	; 0x4a3c <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    4962:	8d 85       	ldd	r24, Y+13	; 0x0d
    4964:	9e 85       	ldd	r25, Y+14	; 0x0e
    4966:	00 97       	sbiw	r24, 0x00	; 0
    4968:	21 f4       	brne	.+8      	; 0x4972 <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    496a:	0f 90       	pop	r0
    496c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    496e:	18 8a       	std	Y+16, r1	; 0x10
    4970:	65 c0       	rjmp	.+202    	; 0x4a3c <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
    4972:	8d 81       	ldd	r24, Y+5	; 0x05
    4974:	88 23       	and	r24, r24
    4976:	31 f4       	brne	.+12     	; 0x4984 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4978:	ce 01       	movw	r24, r28
    497a:	06 96       	adiw	r24, 0x06	; 6
    497c:	0e 94 b5 2e 	call	0x5d6a	; 0x5d6a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    4980:	81 e0       	ldi	r24, 0x01	; 1
    4982:	8d 83       	std	Y+5, r24	; 0x05
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    4984:	0f 90       	pop	r0
    4986:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4988:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    498c:	0f b6       	in	r0, 0x3f	; 63
    498e:	f8 94       	cli
    4990:	0f 92       	push	r0
    4992:	e9 81       	ldd	r30, Y+1	; 0x01
    4994:	fa 81       	ldd	r31, Y+2	; 0x02
    4996:	85 8d       	ldd	r24, Z+29	; 0x1d
    4998:	8f 3f       	cpi	r24, 0xFF	; 255
    499a:	19 f4       	brne	.+6      	; 0x49a2 <xQueueGenericReceive+0x114>
    499c:	e9 81       	ldd	r30, Y+1	; 0x01
    499e:	fa 81       	ldd	r31, Y+2	; 0x02
    49a0:	15 8e       	std	Z+29, r1	; 0x1d
    49a2:	e9 81       	ldd	r30, Y+1	; 0x01
    49a4:	fa 81       	ldd	r31, Y+2	; 0x02
    49a6:	86 8d       	ldd	r24, Z+30	; 0x1e
    49a8:	8f 3f       	cpi	r24, 0xFF	; 255
    49aa:	19 f4       	brne	.+6      	; 0x49b2 <xQueueGenericReceive+0x124>
    49ac:	e9 81       	ldd	r30, Y+1	; 0x01
    49ae:	fa 81       	ldd	r31, Y+2	; 0x02
    49b0:	16 8e       	std	Z+30, r1	; 0x1e
    49b2:	0f 90       	pop	r0
    49b4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    49b6:	ce 01       	movw	r24, r28
    49b8:	06 96       	adiw	r24, 0x06	; 6
    49ba:	9e 01       	movw	r18, r28
    49bc:	23 5f       	subi	r18, 0xF3	; 243
    49be:	3f 4f       	sbci	r19, 0xFF	; 255
    49c0:	b9 01       	movw	r22, r18
    49c2:	0e 94 ce 2e 	call	0x5d9c	; 0x5d9c <xTaskCheckForTimeOut>
    49c6:	88 23       	and	r24, r24
    49c8:	91 f5       	brne	.+100    	; 0x4a2e <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    49ca:	89 81       	ldd	r24, Y+1	; 0x01
    49cc:	9a 81       	ldd	r25, Y+2	; 0x02
    49ce:	0e 94 7f 27 	call	0x4efe	; 0x4efe <prvIsQueueEmpty>
    49d2:	88 23       	and	r24, r24
    49d4:	29 f1       	breq	.+74     	; 0x4a20 <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    49d6:	e9 81       	ldd	r30, Y+1	; 0x01
    49d8:	fa 81       	ldd	r31, Y+2	; 0x02
    49da:	80 81       	ld	r24, Z
    49dc:	91 81       	ldd	r25, Z+1	; 0x01
    49de:	00 97       	sbiw	r24, 0x00	; 0
    49e0:	59 f4       	brne	.+22     	; 0x49f8 <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    49e2:	0f b6       	in	r0, 0x3f	; 63
    49e4:	f8 94       	cli
    49e6:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    49e8:	e9 81       	ldd	r30, Y+1	; 0x01
    49ea:	fa 81       	ldd	r31, Y+2	; 0x02
    49ec:	82 81       	ldd	r24, Z+2	; 0x02
    49ee:	93 81       	ldd	r25, Z+3	; 0x03
    49f0:	0e 94 21 31 	call	0x6242	; 0x6242 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    49f4:	0f 90       	pop	r0
    49f6:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    49f8:	89 81       	ldd	r24, Y+1	; 0x01
    49fa:	9a 81       	ldd	r25, Y+2	; 0x02
    49fc:	41 96       	adiw	r24, 0x11	; 17
    49fe:	2d 85       	ldd	r18, Y+13	; 0x0d
    4a00:	3e 85       	ldd	r19, Y+14	; 0x0e
    4a02:	b9 01       	movw	r22, r18
    4a04:	0e 94 6d 2d 	call	0x5ada	; 0x5ada <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    4a08:	89 81       	ldd	r24, Y+1	; 0x01
    4a0a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a0c:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    4a10:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>
    4a14:	88 23       	and	r24, r24
    4a16:	09 f0       	breq	.+2      	; 0x4a1a <xQueueGenericReceive+0x18c>
    4a18:	50 cf       	rjmp	.-352    	; 0x48ba <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    4a1a:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>
    4a1e:	4d cf       	rjmp	.-358    	; 0x48ba <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    4a20:	89 81       	ldd	r24, Y+1	; 0x01
    4a22:	9a 81       	ldd	r25, Y+2	; 0x02
    4a24:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    4a28:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>
    4a2c:	46 cf       	rjmp	.-372    	; 0x48ba <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    4a2e:	89 81       	ldd	r24, Y+1	; 0x01
    4a30:	9a 81       	ldd	r25, Y+2	; 0x02
    4a32:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    4a36:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    4a3a:	18 8a       	std	Y+16, r1	; 0x10
    4a3c:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    4a3e:	60 96       	adiw	r28, 0x10	; 16
    4a40:	0f b6       	in	r0, 0x3f	; 63
    4a42:	f8 94       	cli
    4a44:	de bf       	out	0x3e, r29	; 62
    4a46:	0f be       	out	0x3f, r0	; 63
    4a48:	cd bf       	out	0x3d, r28	; 61
    4a4a:	cf 91       	pop	r28
    4a4c:	df 91       	pop	r29
    4a4e:	08 95       	ret

00004a50 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    4a50:	df 93       	push	r29
    4a52:	cf 93       	push	r28
    4a54:	cd b7       	in	r28, 0x3d	; 61
    4a56:	de b7       	in	r29, 0x3e	; 62
    4a58:	2a 97       	sbiw	r28, 0x0a	; 10
    4a5a:	0f b6       	in	r0, 0x3f	; 63
    4a5c:	f8 94       	cli
    4a5e:	de bf       	out	0x3e, r29	; 62
    4a60:	0f be       	out	0x3f, r0	; 63
    4a62:	cd bf       	out	0x3d, r28	; 61
    4a64:	9e 83       	std	Y+6, r25	; 0x06
    4a66:	8d 83       	std	Y+5, r24	; 0x05
    4a68:	78 87       	std	Y+8, r23	; 0x08
    4a6a:	6f 83       	std	Y+7, r22	; 0x07
    4a6c:	5a 87       	std	Y+10, r21	; 0x0a
    4a6e:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4a70:	8d 81       	ldd	r24, Y+5	; 0x05
    4a72:	9e 81       	ldd	r25, Y+6	; 0x06
    4a74:	9a 83       	std	Y+2, r25	; 0x02
    4a76:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4a78:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a7e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4a80:	88 23       	and	r24, r24
    4a82:	91 f1       	breq	.+100    	; 0x4ae8 <xQueueReceiveFromISR+0x98>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    4a84:	89 81       	ldd	r24, Y+1	; 0x01
    4a86:	9a 81       	ldd	r25, Y+2	; 0x02
    4a88:	2f 81       	ldd	r18, Y+7	; 0x07
    4a8a:	38 85       	ldd	r19, Y+8	; 0x08
    4a8c:	b9 01       	movw	r22, r18
    4a8e:	0e 94 e4 26 	call	0x4dc8	; 0x4dc8 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    4a92:	e9 81       	ldd	r30, Y+1	; 0x01
    4a94:	fa 81       	ldd	r31, Y+2	; 0x02
    4a96:	82 8d       	ldd	r24, Z+26	; 0x1a
    4a98:	81 50       	subi	r24, 0x01	; 1
    4a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a9e:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    4aa0:	e9 81       	ldd	r30, Y+1	; 0x01
    4aa2:	fa 81       	ldd	r31, Y+2	; 0x02
    4aa4:	85 8d       	ldd	r24, Z+29	; 0x1d
    4aa6:	8f 3f       	cpi	r24, 0xFF	; 255
    4aa8:	a9 f4       	brne	.+42     	; 0x4ad4 <xQueueReceiveFromISR+0x84>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4aaa:	e9 81       	ldd	r30, Y+1	; 0x01
    4aac:	fa 81       	ldd	r31, Y+2	; 0x02
    4aae:	80 85       	ldd	r24, Z+8	; 0x08
    4ab0:	88 23       	and	r24, r24
    4ab2:	b9 f0       	breq	.+46     	; 0x4ae2 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4ab4:	89 81       	ldd	r24, Y+1	; 0x01
    4ab6:	9a 81       	ldd	r25, Y+2	; 0x02
    4ab8:	08 96       	adiw	r24, 0x08	; 8
    4aba:	0e 94 e5 2d 	call	0x5bca	; 0x5bca <xTaskRemoveFromEventList>
    4abe:	88 23       	and	r24, r24
    4ac0:	81 f0       	breq	.+32     	; 0x4ae2 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    4ac2:	89 85       	ldd	r24, Y+9	; 0x09
    4ac4:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ac6:	00 97       	sbiw	r24, 0x00	; 0
    4ac8:	61 f0       	breq	.+24     	; 0x4ae2 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    4aca:	e9 85       	ldd	r30, Y+9	; 0x09
    4acc:	fa 85       	ldd	r31, Y+10	; 0x0a
    4ace:	81 e0       	ldi	r24, 0x01	; 1
    4ad0:	80 83       	st	Z, r24
    4ad2:	07 c0       	rjmp	.+14     	; 0x4ae2 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    4ad4:	e9 81       	ldd	r30, Y+1	; 0x01
    4ad6:	fa 81       	ldd	r31, Y+2	; 0x02
    4ad8:	85 8d       	ldd	r24, Z+29	; 0x1d
    4ada:	8f 5f       	subi	r24, 0xFF	; 255
    4adc:	e9 81       	ldd	r30, Y+1	; 0x01
    4ade:	fa 81       	ldd	r31, Y+2	; 0x02
    4ae0:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    4ae2:	81 e0       	ldi	r24, 0x01	; 1
    4ae4:	8c 83       	std	Y+4, r24	; 0x04
    4ae6:	01 c0       	rjmp	.+2      	; 0x4aea <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    4ae8:	1c 82       	std	Y+4, r1	; 0x04
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4aea:	8c 81       	ldd	r24, Y+4	; 0x04
}
    4aec:	2a 96       	adiw	r28, 0x0a	; 10
    4aee:	0f b6       	in	r0, 0x3f	; 63
    4af0:	f8 94       	cli
    4af2:	de bf       	out	0x3e, r29	; 62
    4af4:	0f be       	out	0x3f, r0	; 63
    4af6:	cd bf       	out	0x3d, r28	; 61
    4af8:	cf 91       	pop	r28
    4afa:	df 91       	pop	r29
    4afc:	08 95       	ret

00004afe <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    4afe:	df 93       	push	r29
    4b00:	cf 93       	push	r28
    4b02:	cd b7       	in	r28, 0x3d	; 61
    4b04:	de b7       	in	r29, 0x3e	; 62
    4b06:	2a 97       	sbiw	r28, 0x0a	; 10
    4b08:	0f b6       	in	r0, 0x3f	; 63
    4b0a:	f8 94       	cli
    4b0c:	de bf       	out	0x3e, r29	; 62
    4b0e:	0f be       	out	0x3f, r0	; 63
    4b10:	cd bf       	out	0x3d, r28	; 61
    4b12:	98 87       	std	Y+8, r25	; 0x08
    4b14:	8f 83       	std	Y+7, r24	; 0x07
    4b16:	7a 87       	std	Y+10, r23	; 0x0a
    4b18:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4b1a:	8f 81       	ldd	r24, Y+7	; 0x07
    4b1c:	98 85       	ldd	r25, Y+8	; 0x08
    4b1e:	9a 83       	std	Y+2, r25	; 0x02
    4b20:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4b22:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4b24:	e9 81       	ldd	r30, Y+1	; 0x01
    4b26:	fa 81       	ldd	r31, Y+2	; 0x02
    4b28:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b2a:	88 23       	and	r24, r24
    4b2c:	b1 f0       	breq	.+44     	; 0x4b5a <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    4b2e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b30:	fa 81       	ldd	r31, Y+2	; 0x02
    4b32:	86 81       	ldd	r24, Z+6	; 0x06
    4b34:	97 81       	ldd	r25, Z+7	; 0x07
    4b36:	9c 83       	std	Y+4, r25	; 0x04
    4b38:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    4b3a:	89 81       	ldd	r24, Y+1	; 0x01
    4b3c:	9a 81       	ldd	r25, Y+2	; 0x02
    4b3e:	29 85       	ldd	r18, Y+9	; 0x09
    4b40:	3a 85       	ldd	r19, Y+10	; 0x0a
    4b42:	b9 01       	movw	r22, r18
    4b44:	0e 94 e4 26 	call	0x4dc8	; 0x4dc8 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    4b48:	e9 81       	ldd	r30, Y+1	; 0x01
    4b4a:	fa 81       	ldd	r31, Y+2	; 0x02
    4b4c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b4e:	9c 81       	ldd	r25, Y+4	; 0x04
    4b50:	97 83       	std	Z+7, r25	; 0x07
    4b52:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    4b54:	81 e0       	ldi	r24, 0x01	; 1
    4b56:	8e 83       	std	Y+6, r24	; 0x06
    4b58:	01 c0       	rjmp	.+2      	; 0x4b5c <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    4b5a:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4b5c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    4b5e:	2a 96       	adiw	r28, 0x0a	; 10
    4b60:	0f b6       	in	r0, 0x3f	; 63
    4b62:	f8 94       	cli
    4b64:	de bf       	out	0x3e, r29	; 62
    4b66:	0f be       	out	0x3f, r0	; 63
    4b68:	cd bf       	out	0x3d, r28	; 61
    4b6a:	cf 91       	pop	r28
    4b6c:	df 91       	pop	r29
    4b6e:	08 95       	ret

00004b70 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    4b70:	df 93       	push	r29
    4b72:	cf 93       	push	r28
    4b74:	00 d0       	rcall	.+0      	; 0x4b76 <uxQueueMessagesWaiting+0x6>
    4b76:	0f 92       	push	r0
    4b78:	cd b7       	in	r28, 0x3d	; 61
    4b7a:	de b7       	in	r29, 0x3e	; 62
    4b7c:	9b 83       	std	Y+3, r25	; 0x03
    4b7e:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    4b80:	0f b6       	in	r0, 0x3f	; 63
    4b82:	f8 94       	cli
    4b84:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    4b86:	ea 81       	ldd	r30, Y+2	; 0x02
    4b88:	fb 81       	ldd	r31, Y+3	; 0x03
    4b8a:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b8c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4b8e:	0f 90       	pop	r0
    4b90:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    4b92:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4b94:	0f 90       	pop	r0
    4b96:	0f 90       	pop	r0
    4b98:	0f 90       	pop	r0
    4b9a:	cf 91       	pop	r28
    4b9c:	df 91       	pop	r29
    4b9e:	08 95       	ret

00004ba0 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    4ba0:	df 93       	push	r29
    4ba2:	cf 93       	push	r28
    4ba4:	00 d0       	rcall	.+0      	; 0x4ba6 <uxQueueSpacesAvailable+0x6>
    4ba6:	00 d0       	rcall	.+0      	; 0x4ba8 <uxQueueSpacesAvailable+0x8>
    4ba8:	0f 92       	push	r0
    4baa:	cd b7       	in	r28, 0x3d	; 61
    4bac:	de b7       	in	r29, 0x3e	; 62
    4bae:	9d 83       	std	Y+5, r25	; 0x05
    4bb0:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    4bb2:	8c 81       	ldd	r24, Y+4	; 0x04
    4bb4:	9d 81       	ldd	r25, Y+5	; 0x05
    4bb6:	9a 83       	std	Y+2, r25	; 0x02
    4bb8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    4bba:	0f b6       	in	r0, 0x3f	; 63
    4bbc:	f8 94       	cli
    4bbe:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    4bc0:	e9 81       	ldd	r30, Y+1	; 0x01
    4bc2:	fa 81       	ldd	r31, Y+2	; 0x02
    4bc4:	93 8d       	ldd	r25, Z+27	; 0x1b
    4bc6:	e9 81       	ldd	r30, Y+1	; 0x01
    4bc8:	fa 81       	ldd	r31, Y+2	; 0x02
    4bca:	82 8d       	ldd	r24, Z+26	; 0x1a
    4bcc:	29 2f       	mov	r18, r25
    4bce:	28 1b       	sub	r18, r24
    4bd0:	82 2f       	mov	r24, r18
    4bd2:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    4bd4:	0f 90       	pop	r0
    4bd6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    4bd8:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4bda:	0f 90       	pop	r0
    4bdc:	0f 90       	pop	r0
    4bde:	0f 90       	pop	r0
    4be0:	0f 90       	pop	r0
    4be2:	0f 90       	pop	r0
    4be4:	cf 91       	pop	r28
    4be6:	df 91       	pop	r29
    4be8:	08 95       	ret

00004bea <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    4bea:	df 93       	push	r29
    4bec:	cf 93       	push	r28
    4bee:	00 d0       	rcall	.+0      	; 0x4bf0 <uxQueueMessagesWaitingFromISR+0x6>
    4bf0:	0f 92       	push	r0
    4bf2:	cd b7       	in	r28, 0x3d	; 61
    4bf4:	de b7       	in	r29, 0x3e	; 62
    4bf6:	9b 83       	std	Y+3, r25	; 0x03
    4bf8:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    4bfa:	ea 81       	ldd	r30, Y+2	; 0x02
    4bfc:	fb 81       	ldd	r31, Y+3	; 0x03
    4bfe:	82 8d       	ldd	r24, Z+26	; 0x1a
    4c00:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    4c02:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4c04:	0f 90       	pop	r0
    4c06:	0f 90       	pop	r0
    4c08:	0f 90       	pop	r0
    4c0a:	cf 91       	pop	r28
    4c0c:	df 91       	pop	r29
    4c0e:	08 95       	ret

00004c10 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    4c10:	df 93       	push	r29
    4c12:	cf 93       	push	r28
    4c14:	00 d0       	rcall	.+0      	; 0x4c16 <vQueueDelete+0x6>
    4c16:	00 d0       	rcall	.+0      	; 0x4c18 <vQueueDelete+0x8>
    4c18:	cd b7       	in	r28, 0x3d	; 61
    4c1a:	de b7       	in	r29, 0x3e	; 62
    4c1c:	9c 83       	std	Y+4, r25	; 0x04
    4c1e:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4c20:	8b 81       	ldd	r24, Y+3	; 0x03
    4c22:	9c 81       	ldd	r25, Y+4	; 0x04
    4c24:	9a 83       	std	Y+2, r25	; 0x02
    4c26:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    4c28:	e9 81       	ldd	r30, Y+1	; 0x01
    4c2a:	fa 81       	ldd	r31, Y+2	; 0x02
    4c2c:	80 81       	ld	r24, Z
    4c2e:	91 81       	ldd	r25, Z+1	; 0x01
    4c30:	00 97       	sbiw	r24, 0x00	; 0
    4c32:	31 f0       	breq	.+12     	; 0x4c40 <vQueueDelete+0x30>
	{
		vPortFree( pxQueue->pcHead );
    4c34:	e9 81       	ldd	r30, Y+1	; 0x01
    4c36:	fa 81       	ldd	r31, Y+2	; 0x02
    4c38:	80 81       	ld	r24, Z
    4c3a:	91 81       	ldd	r25, Z+1	; 0x01
    4c3c:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <vPortFree>
	}
	vPortFree( pxQueue );
    4c40:	89 81       	ldd	r24, Y+1	; 0x01
    4c42:	9a 81       	ldd	r25, Y+2	; 0x02
    4c44:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <vPortFree>
}
    4c48:	0f 90       	pop	r0
    4c4a:	0f 90       	pop	r0
    4c4c:	0f 90       	pop	r0
    4c4e:	0f 90       	pop	r0
    4c50:	cf 91       	pop	r28
    4c52:	df 91       	pop	r29
    4c54:	08 95       	ret

00004c56 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    4c56:	df 93       	push	r29
    4c58:	cf 93       	push	r28
    4c5a:	00 d0       	rcall	.+0      	; 0x4c5c <prvCopyDataToQueue+0x6>
    4c5c:	00 d0       	rcall	.+0      	; 0x4c5e <prvCopyDataToQueue+0x8>
    4c5e:	00 d0       	rcall	.+0      	; 0x4c60 <prvCopyDataToQueue+0xa>
    4c60:	cd b7       	in	r28, 0x3d	; 61
    4c62:	de b7       	in	r29, 0x3e	; 62
    4c64:	9b 83       	std	Y+3, r25	; 0x03
    4c66:	8a 83       	std	Y+2, r24	; 0x02
    4c68:	7d 83       	std	Y+5, r23	; 0x05
    4c6a:	6c 83       	std	Y+4, r22	; 0x04
    4c6c:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    4c6e:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    4c70:	ea 81       	ldd	r30, Y+2	; 0x02
    4c72:	fb 81       	ldd	r31, Y+3	; 0x03
    4c74:	84 8d       	ldd	r24, Z+28	; 0x1c
    4c76:	88 23       	and	r24, r24
    4c78:	99 f4       	brne	.+38     	; 0x4ca0 <prvCopyDataToQueue+0x4a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4c7a:	ea 81       	ldd	r30, Y+2	; 0x02
    4c7c:	fb 81       	ldd	r31, Y+3	; 0x03
    4c7e:	80 81       	ld	r24, Z
    4c80:	91 81       	ldd	r25, Z+1	; 0x01
    4c82:	00 97       	sbiw	r24, 0x00	; 0
    4c84:	09 f0       	breq	.+2      	; 0x4c88 <prvCopyDataToQueue+0x32>
    4c86:	8f c0       	rjmp	.+286    	; 0x4da6 <prvCopyDataToQueue+0x150>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    4c88:	ea 81       	ldd	r30, Y+2	; 0x02
    4c8a:	fb 81       	ldd	r31, Y+3	; 0x03
    4c8c:	82 81       	ldd	r24, Z+2	; 0x02
    4c8e:	93 81       	ldd	r25, Z+3	; 0x03
    4c90:	0e 94 ac 31 	call	0x6358	; 0x6358 <xTaskPriorityDisinherit>
    4c94:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->pxMutexHolder = NULL;
    4c96:	ea 81       	ldd	r30, Y+2	; 0x02
    4c98:	fb 81       	ldd	r31, Y+3	; 0x03
    4c9a:	13 82       	std	Z+3, r1	; 0x03
    4c9c:	12 82       	std	Z+2, r1	; 0x02
    4c9e:	83 c0       	rjmp	.+262    	; 0x4da6 <prvCopyDataToQueue+0x150>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    4ca0:	8e 81       	ldd	r24, Y+6	; 0x06
    4ca2:	88 23       	and	r24, r24
    4ca4:	99 f5       	brne	.+102    	; 0x4d0c <prvCopyDataToQueue+0xb6>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    4ca6:	ea 81       	ldd	r30, Y+2	; 0x02
    4ca8:	fb 81       	ldd	r31, Y+3	; 0x03
    4caa:	64 81       	ldd	r22, Z+4	; 0x04
    4cac:	75 81       	ldd	r23, Z+5	; 0x05
    4cae:	ea 81       	ldd	r30, Y+2	; 0x02
    4cb0:	fb 81       	ldd	r31, Y+3	; 0x03
    4cb2:	84 8d       	ldd	r24, Z+28	; 0x1c
    4cb4:	48 2f       	mov	r20, r24
    4cb6:	50 e0       	ldi	r21, 0x00	; 0
    4cb8:	2c 81       	ldd	r18, Y+4	; 0x04
    4cba:	3d 81       	ldd	r19, Y+5	; 0x05
    4cbc:	cb 01       	movw	r24, r22
    4cbe:	b9 01       	movw	r22, r18
    4cc0:	0e 94 22 33 	call	0x6644	; 0x6644 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    4cc4:	ea 81       	ldd	r30, Y+2	; 0x02
    4cc6:	fb 81       	ldd	r31, Y+3	; 0x03
    4cc8:	24 81       	ldd	r18, Z+4	; 0x04
    4cca:	35 81       	ldd	r19, Z+5	; 0x05
    4ccc:	ea 81       	ldd	r30, Y+2	; 0x02
    4cce:	fb 81       	ldd	r31, Y+3	; 0x03
    4cd0:	84 8d       	ldd	r24, Z+28	; 0x1c
    4cd2:	88 2f       	mov	r24, r24
    4cd4:	90 e0       	ldi	r25, 0x00	; 0
    4cd6:	82 0f       	add	r24, r18
    4cd8:	93 1f       	adc	r25, r19
    4cda:	ea 81       	ldd	r30, Y+2	; 0x02
    4cdc:	fb 81       	ldd	r31, Y+3	; 0x03
    4cde:	95 83       	std	Z+5, r25	; 0x05
    4ce0:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    4ce2:	ea 81       	ldd	r30, Y+2	; 0x02
    4ce4:	fb 81       	ldd	r31, Y+3	; 0x03
    4ce6:	24 81       	ldd	r18, Z+4	; 0x04
    4ce8:	35 81       	ldd	r19, Z+5	; 0x05
    4cea:	ea 81       	ldd	r30, Y+2	; 0x02
    4cec:	fb 81       	ldd	r31, Y+3	; 0x03
    4cee:	82 81       	ldd	r24, Z+2	; 0x02
    4cf0:	93 81       	ldd	r25, Z+3	; 0x03
    4cf2:	28 17       	cp	r18, r24
    4cf4:	39 07       	cpc	r19, r25
    4cf6:	08 f4       	brcc	.+2      	; 0x4cfa <prvCopyDataToQueue+0xa4>
    4cf8:	56 c0       	rjmp	.+172    	; 0x4da6 <prvCopyDataToQueue+0x150>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    4cfa:	ea 81       	ldd	r30, Y+2	; 0x02
    4cfc:	fb 81       	ldd	r31, Y+3	; 0x03
    4cfe:	80 81       	ld	r24, Z
    4d00:	91 81       	ldd	r25, Z+1	; 0x01
    4d02:	ea 81       	ldd	r30, Y+2	; 0x02
    4d04:	fb 81       	ldd	r31, Y+3	; 0x03
    4d06:	95 83       	std	Z+5, r25	; 0x05
    4d08:	84 83       	std	Z+4, r24	; 0x04
    4d0a:	4d c0       	rjmp	.+154    	; 0x4da6 <prvCopyDataToQueue+0x150>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4d0c:	ea 81       	ldd	r30, Y+2	; 0x02
    4d0e:	fb 81       	ldd	r31, Y+3	; 0x03
    4d10:	66 81       	ldd	r22, Z+6	; 0x06
    4d12:	77 81       	ldd	r23, Z+7	; 0x07
    4d14:	ea 81       	ldd	r30, Y+2	; 0x02
    4d16:	fb 81       	ldd	r31, Y+3	; 0x03
    4d18:	84 8d       	ldd	r24, Z+28	; 0x1c
    4d1a:	48 2f       	mov	r20, r24
    4d1c:	50 e0       	ldi	r21, 0x00	; 0
    4d1e:	2c 81       	ldd	r18, Y+4	; 0x04
    4d20:	3d 81       	ldd	r19, Y+5	; 0x05
    4d22:	cb 01       	movw	r24, r22
    4d24:	b9 01       	movw	r22, r18
    4d26:	0e 94 22 33 	call	0x6644	; 0x6644 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    4d2a:	ea 81       	ldd	r30, Y+2	; 0x02
    4d2c:	fb 81       	ldd	r31, Y+3	; 0x03
    4d2e:	26 81       	ldd	r18, Z+6	; 0x06
    4d30:	37 81       	ldd	r19, Z+7	; 0x07
    4d32:	ea 81       	ldd	r30, Y+2	; 0x02
    4d34:	fb 81       	ldd	r31, Y+3	; 0x03
    4d36:	84 8d       	ldd	r24, Z+28	; 0x1c
    4d38:	88 2f       	mov	r24, r24
    4d3a:	90 e0       	ldi	r25, 0x00	; 0
    4d3c:	90 95       	com	r25
    4d3e:	81 95       	neg	r24
    4d40:	9f 4f       	sbci	r25, 0xFF	; 255
    4d42:	82 0f       	add	r24, r18
    4d44:	93 1f       	adc	r25, r19
    4d46:	ea 81       	ldd	r30, Y+2	; 0x02
    4d48:	fb 81       	ldd	r31, Y+3	; 0x03
    4d4a:	97 83       	std	Z+7, r25	; 0x07
    4d4c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    4d4e:	ea 81       	ldd	r30, Y+2	; 0x02
    4d50:	fb 81       	ldd	r31, Y+3	; 0x03
    4d52:	26 81       	ldd	r18, Z+6	; 0x06
    4d54:	37 81       	ldd	r19, Z+7	; 0x07
    4d56:	ea 81       	ldd	r30, Y+2	; 0x02
    4d58:	fb 81       	ldd	r31, Y+3	; 0x03
    4d5a:	80 81       	ld	r24, Z
    4d5c:	91 81       	ldd	r25, Z+1	; 0x01
    4d5e:	28 17       	cp	r18, r24
    4d60:	39 07       	cpc	r19, r25
    4d62:	90 f4       	brcc	.+36     	; 0x4d88 <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    4d64:	ea 81       	ldd	r30, Y+2	; 0x02
    4d66:	fb 81       	ldd	r31, Y+3	; 0x03
    4d68:	22 81       	ldd	r18, Z+2	; 0x02
    4d6a:	33 81       	ldd	r19, Z+3	; 0x03
    4d6c:	ea 81       	ldd	r30, Y+2	; 0x02
    4d6e:	fb 81       	ldd	r31, Y+3	; 0x03
    4d70:	84 8d       	ldd	r24, Z+28	; 0x1c
    4d72:	88 2f       	mov	r24, r24
    4d74:	90 e0       	ldi	r25, 0x00	; 0
    4d76:	90 95       	com	r25
    4d78:	81 95       	neg	r24
    4d7a:	9f 4f       	sbci	r25, 0xFF	; 255
    4d7c:	82 0f       	add	r24, r18
    4d7e:	93 1f       	adc	r25, r19
    4d80:	ea 81       	ldd	r30, Y+2	; 0x02
    4d82:	fb 81       	ldd	r31, Y+3	; 0x03
    4d84:	97 83       	std	Z+7, r25	; 0x07
    4d86:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    4d88:	8e 81       	ldd	r24, Y+6	; 0x06
    4d8a:	82 30       	cpi	r24, 0x02	; 2
    4d8c:	61 f4       	brne	.+24     	; 0x4da6 <prvCopyDataToQueue+0x150>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4d8e:	ea 81       	ldd	r30, Y+2	; 0x02
    4d90:	fb 81       	ldd	r31, Y+3	; 0x03
    4d92:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d94:	88 23       	and	r24, r24
    4d96:	39 f0       	breq	.+14     	; 0x4da6 <prvCopyDataToQueue+0x150>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    4d98:	ea 81       	ldd	r30, Y+2	; 0x02
    4d9a:	fb 81       	ldd	r31, Y+3	; 0x03
    4d9c:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d9e:	81 50       	subi	r24, 0x01	; 1
    4da0:	ea 81       	ldd	r30, Y+2	; 0x02
    4da2:	fb 81       	ldd	r31, Y+3	; 0x03
    4da4:	82 8f       	std	Z+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    4da6:	ea 81       	ldd	r30, Y+2	; 0x02
    4da8:	fb 81       	ldd	r31, Y+3	; 0x03
    4daa:	82 8d       	ldd	r24, Z+26	; 0x1a
    4dac:	8f 5f       	subi	r24, 0xFF	; 255
    4dae:	ea 81       	ldd	r30, Y+2	; 0x02
    4db0:	fb 81       	ldd	r31, Y+3	; 0x03
    4db2:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    4db4:	89 81       	ldd	r24, Y+1	; 0x01
}
    4db6:	26 96       	adiw	r28, 0x06	; 6
    4db8:	0f b6       	in	r0, 0x3f	; 63
    4dba:	f8 94       	cli
    4dbc:	de bf       	out	0x3e, r29	; 62
    4dbe:	0f be       	out	0x3f, r0	; 63
    4dc0:	cd bf       	out	0x3d, r28	; 61
    4dc2:	cf 91       	pop	r28
    4dc4:	df 91       	pop	r29
    4dc6:	08 95       	ret

00004dc8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    4dc8:	df 93       	push	r29
    4dca:	cf 93       	push	r28
    4dcc:	00 d0       	rcall	.+0      	; 0x4dce <prvCopyDataFromQueue+0x6>
    4dce:	00 d0       	rcall	.+0      	; 0x4dd0 <prvCopyDataFromQueue+0x8>
    4dd0:	cd b7       	in	r28, 0x3d	; 61
    4dd2:	de b7       	in	r29, 0x3e	; 62
    4dd4:	9a 83       	std	Y+2, r25	; 0x02
    4dd6:	89 83       	std	Y+1, r24	; 0x01
    4dd8:	7c 83       	std	Y+4, r23	; 0x04
    4dda:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    4ddc:	e9 81       	ldd	r30, Y+1	; 0x01
    4dde:	fa 81       	ldd	r31, Y+2	; 0x02
    4de0:	84 8d       	ldd	r24, Z+28	; 0x1c
    4de2:	88 23       	and	r24, r24
    4de4:	89 f1       	breq	.+98     	; 0x4e48 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    4de6:	e9 81       	ldd	r30, Y+1	; 0x01
    4de8:	fa 81       	ldd	r31, Y+2	; 0x02
    4dea:	26 81       	ldd	r18, Z+6	; 0x06
    4dec:	37 81       	ldd	r19, Z+7	; 0x07
    4dee:	e9 81       	ldd	r30, Y+1	; 0x01
    4df0:	fa 81       	ldd	r31, Y+2	; 0x02
    4df2:	84 8d       	ldd	r24, Z+28	; 0x1c
    4df4:	88 2f       	mov	r24, r24
    4df6:	90 e0       	ldi	r25, 0x00	; 0
    4df8:	82 0f       	add	r24, r18
    4dfa:	93 1f       	adc	r25, r19
    4dfc:	e9 81       	ldd	r30, Y+1	; 0x01
    4dfe:	fa 81       	ldd	r31, Y+2	; 0x02
    4e00:	97 83       	std	Z+7, r25	; 0x07
    4e02:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    4e04:	e9 81       	ldd	r30, Y+1	; 0x01
    4e06:	fa 81       	ldd	r31, Y+2	; 0x02
    4e08:	26 81       	ldd	r18, Z+6	; 0x06
    4e0a:	37 81       	ldd	r19, Z+7	; 0x07
    4e0c:	e9 81       	ldd	r30, Y+1	; 0x01
    4e0e:	fa 81       	ldd	r31, Y+2	; 0x02
    4e10:	82 81       	ldd	r24, Z+2	; 0x02
    4e12:	93 81       	ldd	r25, Z+3	; 0x03
    4e14:	28 17       	cp	r18, r24
    4e16:	39 07       	cpc	r19, r25
    4e18:	40 f0       	brcs	.+16     	; 0x4e2a <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    4e1a:	e9 81       	ldd	r30, Y+1	; 0x01
    4e1c:	fa 81       	ldd	r31, Y+2	; 0x02
    4e1e:	80 81       	ld	r24, Z
    4e20:	91 81       	ldd	r25, Z+1	; 0x01
    4e22:	e9 81       	ldd	r30, Y+1	; 0x01
    4e24:	fa 81       	ldd	r31, Y+2	; 0x02
    4e26:	97 83       	std	Z+7, r25	; 0x07
    4e28:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    4e2a:	e9 81       	ldd	r30, Y+1	; 0x01
    4e2c:	fa 81       	ldd	r31, Y+2	; 0x02
    4e2e:	46 81       	ldd	r20, Z+6	; 0x06
    4e30:	57 81       	ldd	r21, Z+7	; 0x07
    4e32:	e9 81       	ldd	r30, Y+1	; 0x01
    4e34:	fa 81       	ldd	r31, Y+2	; 0x02
    4e36:	84 8d       	ldd	r24, Z+28	; 0x1c
    4e38:	28 2f       	mov	r18, r24
    4e3a:	30 e0       	ldi	r19, 0x00	; 0
    4e3c:	8b 81       	ldd	r24, Y+3	; 0x03
    4e3e:	9c 81       	ldd	r25, Y+4	; 0x04
    4e40:	ba 01       	movw	r22, r20
    4e42:	a9 01       	movw	r20, r18
    4e44:	0e 94 22 33 	call	0x6644	; 0x6644 <memcpy>
	}
}
    4e48:	0f 90       	pop	r0
    4e4a:	0f 90       	pop	r0
    4e4c:	0f 90       	pop	r0
    4e4e:	0f 90       	pop	r0
    4e50:	cf 91       	pop	r28
    4e52:	df 91       	pop	r29
    4e54:	08 95       	ret

00004e56 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    4e56:	df 93       	push	r29
    4e58:	cf 93       	push	r28
    4e5a:	00 d0       	rcall	.+0      	; 0x4e5c <prvUnlockQueue+0x6>
    4e5c:	cd b7       	in	r28, 0x3d	; 61
    4e5e:	de b7       	in	r29, 0x3e	; 62
    4e60:	9a 83       	std	Y+2, r25	; 0x02
    4e62:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4e64:	0f b6       	in	r0, 0x3f	; 63
    4e66:	f8 94       	cli
    4e68:	0f 92       	push	r0
    4e6a:	15 c0       	rjmp	.+42     	; 0x4e96 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4e6c:	e9 81       	ldd	r30, Y+1	; 0x01
    4e6e:	fa 81       	ldd	r31, Y+2	; 0x02
    4e70:	81 89       	ldd	r24, Z+17	; 0x11
    4e72:	88 23       	and	r24, r24
    4e74:	a9 f0       	breq	.+42     	; 0x4ea0 <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4e76:	89 81       	ldd	r24, Y+1	; 0x01
    4e78:	9a 81       	ldd	r25, Y+2	; 0x02
    4e7a:	41 96       	adiw	r24, 0x11	; 17
    4e7c:	0e 94 e5 2d 	call	0x5bca	; 0x5bca <xTaskRemoveFromEventList>
    4e80:	88 23       	and	r24, r24
    4e82:	11 f0       	breq	.+4      	; 0x4e88 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    4e84:	0e 94 31 2f 	call	0x5e62	; 0x5e62 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    4e88:	e9 81       	ldd	r30, Y+1	; 0x01
    4e8a:	fa 81       	ldd	r31, Y+2	; 0x02
    4e8c:	86 8d       	ldd	r24, Z+30	; 0x1e
    4e8e:	81 50       	subi	r24, 0x01	; 1
    4e90:	e9 81       	ldd	r30, Y+1	; 0x01
    4e92:	fa 81       	ldd	r31, Y+2	; 0x02
    4e94:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4e96:	e9 81       	ldd	r30, Y+1	; 0x01
    4e98:	fa 81       	ldd	r31, Y+2	; 0x02
    4e9a:	86 8d       	ldd	r24, Z+30	; 0x1e
    4e9c:	18 16       	cp	r1, r24
    4e9e:	34 f3       	brlt	.-52     	; 0x4e6c <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ea4:	8f ef       	ldi	r24, 0xFF	; 255
    4ea6:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    4ea8:	0f 90       	pop	r0
    4eaa:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4eac:	0f b6       	in	r0, 0x3f	; 63
    4eae:	f8 94       	cli
    4eb0:	0f 92       	push	r0
    4eb2:	15 c0       	rjmp	.+42     	; 0x4ede <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4eb4:	e9 81       	ldd	r30, Y+1	; 0x01
    4eb6:	fa 81       	ldd	r31, Y+2	; 0x02
    4eb8:	80 85       	ldd	r24, Z+8	; 0x08
    4eba:	88 23       	and	r24, r24
    4ebc:	a9 f0       	breq	.+42     	; 0x4ee8 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4ebe:	89 81       	ldd	r24, Y+1	; 0x01
    4ec0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ec2:	08 96       	adiw	r24, 0x08	; 8
    4ec4:	0e 94 e5 2d 	call	0x5bca	; 0x5bca <xTaskRemoveFromEventList>
    4ec8:	88 23       	and	r24, r24
    4eca:	11 f0       	breq	.+4      	; 0x4ed0 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    4ecc:	0e 94 31 2f 	call	0x5e62	; 0x5e62 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    4ed0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ed2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ed4:	85 8d       	ldd	r24, Z+29	; 0x1d
    4ed6:	81 50       	subi	r24, 0x01	; 1
    4ed8:	e9 81       	ldd	r30, Y+1	; 0x01
    4eda:	fa 81       	ldd	r31, Y+2	; 0x02
    4edc:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4ede:	e9 81       	ldd	r30, Y+1	; 0x01
    4ee0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ee2:	85 8d       	ldd	r24, Z+29	; 0x1d
    4ee4:	18 16       	cp	r1, r24
    4ee6:	34 f3       	brlt	.-52     	; 0x4eb4 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4ee8:	e9 81       	ldd	r30, Y+1	; 0x01
    4eea:	fa 81       	ldd	r31, Y+2	; 0x02
    4eec:	8f ef       	ldi	r24, 0xFF	; 255
    4eee:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4ef0:	0f 90       	pop	r0
    4ef2:	0f be       	out	0x3f, r0	; 63
}
    4ef4:	0f 90       	pop	r0
    4ef6:	0f 90       	pop	r0
    4ef8:	cf 91       	pop	r28
    4efa:	df 91       	pop	r29
    4efc:	08 95       	ret

00004efe <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    4efe:	df 93       	push	r29
    4f00:	cf 93       	push	r28
    4f02:	00 d0       	rcall	.+0      	; 0x4f04 <prvIsQueueEmpty+0x6>
    4f04:	0f 92       	push	r0
    4f06:	cd b7       	in	r28, 0x3d	; 61
    4f08:	de b7       	in	r29, 0x3e	; 62
    4f0a:	9b 83       	std	Y+3, r25	; 0x03
    4f0c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    4f0e:	0f b6       	in	r0, 0x3f	; 63
    4f10:	f8 94       	cli
    4f12:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    4f14:	ea 81       	ldd	r30, Y+2	; 0x02
    4f16:	fb 81       	ldd	r31, Y+3	; 0x03
    4f18:	82 8d       	ldd	r24, Z+26	; 0x1a
    4f1a:	88 23       	and	r24, r24
    4f1c:	19 f4       	brne	.+6      	; 0x4f24 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    4f1e:	81 e0       	ldi	r24, 0x01	; 1
    4f20:	89 83       	std	Y+1, r24	; 0x01
    4f22:	01 c0       	rjmp	.+2      	; 0x4f26 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    4f24:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4f26:	0f 90       	pop	r0
    4f28:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4f2a:	89 81       	ldd	r24, Y+1	; 0x01
}
    4f2c:	0f 90       	pop	r0
    4f2e:	0f 90       	pop	r0
    4f30:	0f 90       	pop	r0
    4f32:	cf 91       	pop	r28
    4f34:	df 91       	pop	r29
    4f36:	08 95       	ret

00004f38 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    4f38:	df 93       	push	r29
    4f3a:	cf 93       	push	r28
    4f3c:	00 d0       	rcall	.+0      	; 0x4f3e <xQueueIsQueueEmptyFromISR+0x6>
    4f3e:	0f 92       	push	r0
    4f40:	cd b7       	in	r28, 0x3d	; 61
    4f42:	de b7       	in	r29, 0x3e	; 62
    4f44:	9b 83       	std	Y+3, r25	; 0x03
    4f46:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    4f48:	ea 81       	ldd	r30, Y+2	; 0x02
    4f4a:	fb 81       	ldd	r31, Y+3	; 0x03
    4f4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    4f4e:	88 23       	and	r24, r24
    4f50:	19 f4       	brne	.+6      	; 0x4f58 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    4f52:	81 e0       	ldi	r24, 0x01	; 1
    4f54:	89 83       	std	Y+1, r24	; 0x01
    4f56:	01 c0       	rjmp	.+2      	; 0x4f5a <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    4f58:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4f5a:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4f5c:	0f 90       	pop	r0
    4f5e:	0f 90       	pop	r0
    4f60:	0f 90       	pop	r0
    4f62:	cf 91       	pop	r28
    4f64:	df 91       	pop	r29
    4f66:	08 95       	ret

00004f68 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    4f68:	df 93       	push	r29
    4f6a:	cf 93       	push	r28
    4f6c:	00 d0       	rcall	.+0      	; 0x4f6e <prvIsQueueFull+0x6>
    4f6e:	0f 92       	push	r0
    4f70:	cd b7       	in	r28, 0x3d	; 61
    4f72:	de b7       	in	r29, 0x3e	; 62
    4f74:	9b 83       	std	Y+3, r25	; 0x03
    4f76:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    4f78:	0f b6       	in	r0, 0x3f	; 63
    4f7a:	f8 94       	cli
    4f7c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4f7e:	ea 81       	ldd	r30, Y+2	; 0x02
    4f80:	fb 81       	ldd	r31, Y+3	; 0x03
    4f82:	92 8d       	ldd	r25, Z+26	; 0x1a
    4f84:	ea 81       	ldd	r30, Y+2	; 0x02
    4f86:	fb 81       	ldd	r31, Y+3	; 0x03
    4f88:	83 8d       	ldd	r24, Z+27	; 0x1b
    4f8a:	98 17       	cp	r25, r24
    4f8c:	19 f4       	brne	.+6      	; 0x4f94 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    4f8e:	81 e0       	ldi	r24, 0x01	; 1
    4f90:	89 83       	std	Y+1, r24	; 0x01
    4f92:	01 c0       	rjmp	.+2      	; 0x4f96 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    4f94:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4f96:	0f 90       	pop	r0
    4f98:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4f9a:	89 81       	ldd	r24, Y+1	; 0x01
}
    4f9c:	0f 90       	pop	r0
    4f9e:	0f 90       	pop	r0
    4fa0:	0f 90       	pop	r0
    4fa2:	cf 91       	pop	r28
    4fa4:	df 91       	pop	r29
    4fa6:	08 95       	ret

00004fa8 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    4fa8:	df 93       	push	r29
    4faa:	cf 93       	push	r28
    4fac:	00 d0       	rcall	.+0      	; 0x4fae <xQueueIsQueueFullFromISR+0x6>
    4fae:	0f 92       	push	r0
    4fb0:	cd b7       	in	r28, 0x3d	; 61
    4fb2:	de b7       	in	r29, 0x3e	; 62
    4fb4:	9b 83       	std	Y+3, r25	; 0x03
    4fb6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    4fb8:	ea 81       	ldd	r30, Y+2	; 0x02
    4fba:	fb 81       	ldd	r31, Y+3	; 0x03
    4fbc:	92 8d       	ldd	r25, Z+26	; 0x1a
    4fbe:	ea 81       	ldd	r30, Y+2	; 0x02
    4fc0:	fb 81       	ldd	r31, Y+3	; 0x03
    4fc2:	83 8d       	ldd	r24, Z+27	; 0x1b
    4fc4:	98 17       	cp	r25, r24
    4fc6:	19 f4       	brne	.+6      	; 0x4fce <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    4fc8:	81 e0       	ldi	r24, 0x01	; 1
    4fca:	89 83       	std	Y+1, r24	; 0x01
    4fcc:	01 c0       	rjmp	.+2      	; 0x4fd0 <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    4fce:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4fd0:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4fd2:	0f 90       	pop	r0
    4fd4:	0f 90       	pop	r0
    4fd6:	0f 90       	pop	r0
    4fd8:	cf 91       	pop	r28
    4fda:	df 91       	pop	r29
    4fdc:	08 95       	ret

00004fde <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    4fde:	df 93       	push	r29
    4fe0:	cf 93       	push	r28
    4fe2:	cd b7       	in	r28, 0x3d	; 61
    4fe4:	de b7       	in	r29, 0x3e	; 62
    4fe6:	2a 97       	sbiw	r28, 0x0a	; 10
    4fe8:	0f b6       	in	r0, 0x3f	; 63
    4fea:	f8 94       	cli
    4fec:	de bf       	out	0x3e, r29	; 62
    4fee:	0f be       	out	0x3f, r0	; 63
    4ff0:	cd bf       	out	0x3d, r28	; 61
    4ff2:	9d 83       	std	Y+5, r25	; 0x05
    4ff4:	8c 83       	std	Y+4, r24	; 0x04
    4ff6:	7f 83       	std	Y+7, r23	; 0x07
    4ff8:	6e 83       	std	Y+6, r22	; 0x06
    4ffa:	59 87       	std	Y+9, r21	; 0x09
    4ffc:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4ffe:	8c 81       	ldd	r24, Y+4	; 0x04
    5000:	9d 81       	ldd	r25, Y+5	; 0x05
    5002:	9a 83       	std	Y+2, r25	; 0x02
    5004:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    5006:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    5008:	89 81       	ldd	r24, Y+1	; 0x01
    500a:	9a 81       	ldd	r25, Y+2	; 0x02
    500c:	0e 94 b4 27 	call	0x4f68	; 0x4f68 <prvIsQueueFull>
    5010:	88 23       	and	r24, r24
    5012:	a9 f0       	breq	.+42     	; 0x503e <xQueueCRSend+0x60>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    5014:	88 85       	ldd	r24, Y+8	; 0x08
    5016:	99 85       	ldd	r25, Y+9	; 0x09
    5018:	00 97       	sbiw	r24, 0x00	; 0
    501a:	71 f0       	breq	.+28     	; 0x5038 <xQueueCRSend+0x5a>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    501c:	89 81       	ldd	r24, Y+1	; 0x01
    501e:	9a 81       	ldd	r25, Y+2	; 0x02
    5020:	9c 01       	movw	r18, r24
    5022:	28 5f       	subi	r18, 0xF8	; 248
    5024:	3f 4f       	sbci	r19, 0xFF	; 255
    5026:	88 85       	ldd	r24, Y+8	; 0x08
    5028:	99 85       	ldd	r25, Y+9	; 0x09
    502a:	b9 01       	movw	r22, r18
    502c:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    5030:	78 94       	sei
					return errQUEUE_BLOCKED;
    5032:	8c ef       	ldi	r24, 0xFC	; 252
    5034:	8a 87       	std	Y+10, r24	; 0x0a
    5036:	2a c0       	rjmp	.+84     	; 0x508c <xQueueCRSend+0xae>
				}
				else
				{
					portENABLE_INTERRUPTS();
    5038:	78 94       	sei
					return errQUEUE_FULL;
    503a:	1a 86       	std	Y+10, r1	; 0x0a
    503c:	27 c0       	rjmp	.+78     	; 0x508c <xQueueCRSend+0xae>
				}
			}
		}
		portENABLE_INTERRUPTS();
    503e:	78 94       	sei

		portDISABLE_INTERRUPTS();
    5040:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    5042:	e9 81       	ldd	r30, Y+1	; 0x01
    5044:	fa 81       	ldd	r31, Y+2	; 0x02
    5046:	92 8d       	ldd	r25, Z+26	; 0x1a
    5048:	e9 81       	ldd	r30, Y+1	; 0x01
    504a:	fa 81       	ldd	r31, Y+2	; 0x02
    504c:	83 8d       	ldd	r24, Z+27	; 0x1b
    504e:	98 17       	cp	r25, r24
    5050:	c8 f4       	brcc	.+50     	; 0x5084 <xQueueCRSend+0xa6>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    5052:	89 81       	ldd	r24, Y+1	; 0x01
    5054:	9a 81       	ldd	r25, Y+2	; 0x02
    5056:	2e 81       	ldd	r18, Y+6	; 0x06
    5058:	3f 81       	ldd	r19, Y+7	; 0x07
    505a:	b9 01       	movw	r22, r18
    505c:	40 e0       	ldi	r20, 0x00	; 0
    505e:	0e 94 2b 26 	call	0x4c56	; 0x4c56 <prvCopyDataToQueue>
				xReturn = pdPASS;
    5062:	81 e0       	ldi	r24, 0x01	; 1
    5064:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5066:	e9 81       	ldd	r30, Y+1	; 0x01
    5068:	fa 81       	ldd	r31, Y+2	; 0x02
    506a:	81 89       	ldd	r24, Z+17	; 0x11
    506c:	88 23       	and	r24, r24
    506e:	59 f0       	breq	.+22     	; 0x5086 <xQueueCRSend+0xa8>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5070:	89 81       	ldd	r24, Y+1	; 0x01
    5072:	9a 81       	ldd	r25, Y+2	; 0x02
    5074:	41 96       	adiw	r24, 0x11	; 17
    5076:	0e 94 18 19 	call	0x3230	; 0x3230 <xCoRoutineRemoveFromEventList>
    507a:	88 23       	and	r24, r24
    507c:	21 f0       	breq	.+8      	; 0x5086 <xQueueCRSend+0xa8>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    507e:	8b ef       	ldi	r24, 0xFB	; 251
    5080:	8b 83       	std	Y+3, r24	; 0x03
    5082:	01 c0       	rjmp	.+2      	; 0x5086 <xQueueCRSend+0xa8>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    5084:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    5086:	78 94       	sei

		return xReturn;
    5088:	8b 81       	ldd	r24, Y+3	; 0x03
    508a:	8a 87       	std	Y+10, r24	; 0x0a
    508c:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    508e:	2a 96       	adiw	r28, 0x0a	; 10
    5090:	0f b6       	in	r0, 0x3f	; 63
    5092:	f8 94       	cli
    5094:	de bf       	out	0x3e, r29	; 62
    5096:	0f be       	out	0x3f, r0	; 63
    5098:	cd bf       	out	0x3d, r28	; 61
    509a:	cf 91       	pop	r28
    509c:	df 91       	pop	r29
    509e:	08 95       	ret

000050a0 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    50a0:	df 93       	push	r29
    50a2:	cf 93       	push	r28
    50a4:	cd b7       	in	r28, 0x3d	; 61
    50a6:	de b7       	in	r29, 0x3e	; 62
    50a8:	2a 97       	sbiw	r28, 0x0a	; 10
    50aa:	0f b6       	in	r0, 0x3f	; 63
    50ac:	f8 94       	cli
    50ae:	de bf       	out	0x3e, r29	; 62
    50b0:	0f be       	out	0x3f, r0	; 63
    50b2:	cd bf       	out	0x3d, r28	; 61
    50b4:	9d 83       	std	Y+5, r25	; 0x05
    50b6:	8c 83       	std	Y+4, r24	; 0x04
    50b8:	7f 83       	std	Y+7, r23	; 0x07
    50ba:	6e 83       	std	Y+6, r22	; 0x06
    50bc:	59 87       	std	Y+9, r21	; 0x09
    50be:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    50c0:	8c 81       	ldd	r24, Y+4	; 0x04
    50c2:	9d 81       	ldd	r25, Y+5	; 0x05
    50c4:	9a 83       	std	Y+2, r25	; 0x02
    50c6:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    50c8:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    50ca:	e9 81       	ldd	r30, Y+1	; 0x01
    50cc:	fa 81       	ldd	r31, Y+2	; 0x02
    50ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    50d0:	88 23       	and	r24, r24
    50d2:	a9 f4       	brne	.+42     	; 0x50fe <xQueueCRReceive+0x5e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    50d4:	88 85       	ldd	r24, Y+8	; 0x08
    50d6:	99 85       	ldd	r25, Y+9	; 0x09
    50d8:	00 97       	sbiw	r24, 0x00	; 0
    50da:	71 f0       	breq	.+28     	; 0x50f8 <xQueueCRReceive+0x58>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    50dc:	89 81       	ldd	r24, Y+1	; 0x01
    50de:	9a 81       	ldd	r25, Y+2	; 0x02
    50e0:	9c 01       	movw	r18, r24
    50e2:	2f 5e       	subi	r18, 0xEF	; 239
    50e4:	3f 4f       	sbci	r19, 0xFF	; 255
    50e6:	88 85       	ldd	r24, Y+8	; 0x08
    50e8:	99 85       	ldd	r25, Y+9	; 0x09
    50ea:	b9 01       	movw	r22, r18
    50ec:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    50f0:	78 94       	sei
					return errQUEUE_BLOCKED;
    50f2:	8c ef       	ldi	r24, 0xFC	; 252
    50f4:	8a 87       	std	Y+10, r24	; 0x0a
    50f6:	58 c0       	rjmp	.+176    	; 0x51a8 <xQueueCRReceive+0x108>
				}
				else
				{
					portENABLE_INTERRUPTS();
    50f8:	78 94       	sei
					return errQUEUE_FULL;
    50fa:	1a 86       	std	Y+10, r1	; 0x0a
    50fc:	55 c0       	rjmp	.+170    	; 0x51a8 <xQueueCRReceive+0x108>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    50fe:	78 94       	sei

		portDISABLE_INTERRUPTS();
    5100:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    5102:	e9 81       	ldd	r30, Y+1	; 0x01
    5104:	fa 81       	ldd	r31, Y+2	; 0x02
    5106:	82 8d       	ldd	r24, Z+26	; 0x1a
    5108:	88 23       	and	r24, r24
    510a:	09 f4       	brne	.+2      	; 0x510e <xQueueCRReceive+0x6e>
    510c:	49 c0       	rjmp	.+146    	; 0x51a0 <xQueueCRReceive+0x100>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    510e:	e9 81       	ldd	r30, Y+1	; 0x01
    5110:	fa 81       	ldd	r31, Y+2	; 0x02
    5112:	26 81       	ldd	r18, Z+6	; 0x06
    5114:	37 81       	ldd	r19, Z+7	; 0x07
    5116:	e9 81       	ldd	r30, Y+1	; 0x01
    5118:	fa 81       	ldd	r31, Y+2	; 0x02
    511a:	84 8d       	ldd	r24, Z+28	; 0x1c
    511c:	88 2f       	mov	r24, r24
    511e:	90 e0       	ldi	r25, 0x00	; 0
    5120:	82 0f       	add	r24, r18
    5122:	93 1f       	adc	r25, r19
    5124:	e9 81       	ldd	r30, Y+1	; 0x01
    5126:	fa 81       	ldd	r31, Y+2	; 0x02
    5128:	97 83       	std	Z+7, r25	; 0x07
    512a:	86 83       	std	Z+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    512c:	e9 81       	ldd	r30, Y+1	; 0x01
    512e:	fa 81       	ldd	r31, Y+2	; 0x02
    5130:	26 81       	ldd	r18, Z+6	; 0x06
    5132:	37 81       	ldd	r19, Z+7	; 0x07
    5134:	e9 81       	ldd	r30, Y+1	; 0x01
    5136:	fa 81       	ldd	r31, Y+2	; 0x02
    5138:	82 81       	ldd	r24, Z+2	; 0x02
    513a:	93 81       	ldd	r25, Z+3	; 0x03
    513c:	28 17       	cp	r18, r24
    513e:	39 07       	cpc	r19, r25
    5140:	40 f0       	brcs	.+16     	; 0x5152 <xQueueCRReceive+0xb2>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    5142:	e9 81       	ldd	r30, Y+1	; 0x01
    5144:	fa 81       	ldd	r31, Y+2	; 0x02
    5146:	80 81       	ld	r24, Z
    5148:	91 81       	ldd	r25, Z+1	; 0x01
    514a:	e9 81       	ldd	r30, Y+1	; 0x01
    514c:	fa 81       	ldd	r31, Y+2	; 0x02
    514e:	97 83       	std	Z+7, r25	; 0x07
    5150:	86 83       	std	Z+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    5152:	e9 81       	ldd	r30, Y+1	; 0x01
    5154:	fa 81       	ldd	r31, Y+2	; 0x02
    5156:	82 8d       	ldd	r24, Z+26	; 0x1a
    5158:	81 50       	subi	r24, 0x01	; 1
    515a:	e9 81       	ldd	r30, Y+1	; 0x01
    515c:	fa 81       	ldd	r31, Y+2	; 0x02
    515e:	82 8f       	std	Z+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    5160:	e9 81       	ldd	r30, Y+1	; 0x01
    5162:	fa 81       	ldd	r31, Y+2	; 0x02
    5164:	46 81       	ldd	r20, Z+6	; 0x06
    5166:	57 81       	ldd	r21, Z+7	; 0x07
    5168:	e9 81       	ldd	r30, Y+1	; 0x01
    516a:	fa 81       	ldd	r31, Y+2	; 0x02
    516c:	84 8d       	ldd	r24, Z+28	; 0x1c
    516e:	28 2f       	mov	r18, r24
    5170:	30 e0       	ldi	r19, 0x00	; 0
    5172:	8e 81       	ldd	r24, Y+6	; 0x06
    5174:	9f 81       	ldd	r25, Y+7	; 0x07
    5176:	ba 01       	movw	r22, r20
    5178:	a9 01       	movw	r20, r18
    517a:	0e 94 22 33 	call	0x6644	; 0x6644 <memcpy>

				xReturn = pdPASS;
    517e:	81 e0       	ldi	r24, 0x01	; 1
    5180:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5182:	e9 81       	ldd	r30, Y+1	; 0x01
    5184:	fa 81       	ldd	r31, Y+2	; 0x02
    5186:	80 85       	ldd	r24, Z+8	; 0x08
    5188:	88 23       	and	r24, r24
    518a:	59 f0       	breq	.+22     	; 0x51a2 <xQueueCRReceive+0x102>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    518c:	89 81       	ldd	r24, Y+1	; 0x01
    518e:	9a 81       	ldd	r25, Y+2	; 0x02
    5190:	08 96       	adiw	r24, 0x08	; 8
    5192:	0e 94 18 19 	call	0x3230	; 0x3230 <xCoRoutineRemoveFromEventList>
    5196:	88 23       	and	r24, r24
    5198:	21 f0       	breq	.+8      	; 0x51a2 <xQueueCRReceive+0x102>
					{
						xReturn = errQUEUE_YIELD;
    519a:	8b ef       	ldi	r24, 0xFB	; 251
    519c:	8b 83       	std	Y+3, r24	; 0x03
    519e:	01 c0       	rjmp	.+2      	; 0x51a2 <xQueueCRReceive+0x102>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    51a0:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    51a2:	78 94       	sei

		return xReturn;
    51a4:	8b 81       	ldd	r24, Y+3	; 0x03
    51a6:	8a 87       	std	Y+10, r24	; 0x0a
    51a8:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    51aa:	2a 96       	adiw	r28, 0x0a	; 10
    51ac:	0f b6       	in	r0, 0x3f	; 63
    51ae:	f8 94       	cli
    51b0:	de bf       	out	0x3e, r29	; 62
    51b2:	0f be       	out	0x3f, r0	; 63
    51b4:	cd bf       	out	0x3d, r28	; 61
    51b6:	cf 91       	pop	r28
    51b8:	df 91       	pop	r29
    51ba:	08 95       	ret

000051bc <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    51bc:	df 93       	push	r29
    51be:	cf 93       	push	r28
    51c0:	cd b7       	in	r28, 0x3d	; 61
    51c2:	de b7       	in	r29, 0x3e	; 62
    51c4:	28 97       	sbiw	r28, 0x08	; 8
    51c6:	0f b6       	in	r0, 0x3f	; 63
    51c8:	f8 94       	cli
    51ca:	de bf       	out	0x3e, r29	; 62
    51cc:	0f be       	out	0x3f, r0	; 63
    51ce:	cd bf       	out	0x3d, r28	; 61
    51d0:	9c 83       	std	Y+4, r25	; 0x04
    51d2:	8b 83       	std	Y+3, r24	; 0x03
    51d4:	7e 83       	std	Y+6, r23	; 0x06
    51d6:	6d 83       	std	Y+5, r22	; 0x05
    51d8:	4f 83       	std	Y+7, r20	; 0x07
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    51da:	8b 81       	ldd	r24, Y+3	; 0x03
    51dc:	9c 81       	ldd	r25, Y+4	; 0x04
    51de:	9a 83       	std	Y+2, r25	; 0x02
    51e0:	89 83       	std	Y+1, r24	; 0x01

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    51e2:	e9 81       	ldd	r30, Y+1	; 0x01
    51e4:	fa 81       	ldd	r31, Y+2	; 0x02
    51e6:	92 8d       	ldd	r25, Z+26	; 0x1a
    51e8:	e9 81       	ldd	r30, Y+1	; 0x01
    51ea:	fa 81       	ldd	r31, Y+2	; 0x02
    51ec:	83 8d       	ldd	r24, Z+27	; 0x1b
    51ee:	98 17       	cp	r25, r24
    51f0:	d0 f4       	brcc	.+52     	; 0x5226 <xQueueCRSendFromISR+0x6a>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    51f2:	89 81       	ldd	r24, Y+1	; 0x01
    51f4:	9a 81       	ldd	r25, Y+2	; 0x02
    51f6:	2d 81       	ldd	r18, Y+5	; 0x05
    51f8:	3e 81       	ldd	r19, Y+6	; 0x06
    51fa:	b9 01       	movw	r22, r18
    51fc:	40 e0       	ldi	r20, 0x00	; 0
    51fe:	0e 94 2b 26 	call	0x4c56	; 0x4c56 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    5202:	8f 81       	ldd	r24, Y+7	; 0x07
    5204:	88 23       	and	r24, r24
    5206:	79 f4       	brne	.+30     	; 0x5226 <xQueueCRSendFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5208:	e9 81       	ldd	r30, Y+1	; 0x01
    520a:	fa 81       	ldd	r31, Y+2	; 0x02
    520c:	81 89       	ldd	r24, Z+17	; 0x11
    520e:	88 23       	and	r24, r24
    5210:	51 f0       	breq	.+20     	; 0x5226 <xQueueCRSendFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5212:	89 81       	ldd	r24, Y+1	; 0x01
    5214:	9a 81       	ldd	r25, Y+2	; 0x02
    5216:	41 96       	adiw	r24, 0x11	; 17
    5218:	0e 94 18 19 	call	0x3230	; 0x3230 <xCoRoutineRemoveFromEventList>
    521c:	88 23       	and	r24, r24
    521e:	19 f0       	breq	.+6      	; 0x5226 <xQueueCRSendFromISR+0x6a>
					{
						return pdTRUE;
    5220:	81 e0       	ldi	r24, 0x01	; 1
    5222:	88 87       	std	Y+8, r24	; 0x08
    5224:	02 c0       	rjmp	.+4      	; 0x522a <xQueueCRSendFromISR+0x6e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    5226:	8f 81       	ldd	r24, Y+7	; 0x07
    5228:	88 87       	std	Y+8, r24	; 0x08
    522a:	88 85       	ldd	r24, Y+8	; 0x08
	}
    522c:	28 96       	adiw	r28, 0x08	; 8
    522e:	0f b6       	in	r0, 0x3f	; 63
    5230:	f8 94       	cli
    5232:	de bf       	out	0x3e, r29	; 62
    5234:	0f be       	out	0x3f, r0	; 63
    5236:	cd bf       	out	0x3d, r28	; 61
    5238:	cf 91       	pop	r28
    523a:	df 91       	pop	r29
    523c:	08 95       	ret

0000523e <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    523e:	df 93       	push	r29
    5240:	cf 93       	push	r28
    5242:	cd b7       	in	r28, 0x3d	; 61
    5244:	de b7       	in	r29, 0x3e	; 62
    5246:	29 97       	sbiw	r28, 0x09	; 9
    5248:	0f b6       	in	r0, 0x3f	; 63
    524a:	f8 94       	cli
    524c:	de bf       	out	0x3e, r29	; 62
    524e:	0f be       	out	0x3f, r0	; 63
    5250:	cd bf       	out	0x3d, r28	; 61
    5252:	9d 83       	std	Y+5, r25	; 0x05
    5254:	8c 83       	std	Y+4, r24	; 0x04
    5256:	7f 83       	std	Y+7, r23	; 0x07
    5258:	6e 83       	std	Y+6, r22	; 0x06
    525a:	59 87       	std	Y+9, r21	; 0x09
    525c:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    525e:	8c 81       	ldd	r24, Y+4	; 0x04
    5260:	9d 81       	ldd	r25, Y+5	; 0x05
    5262:	9a 83       	std	Y+2, r25	; 0x02
    5264:	89 83       	std	Y+1, r24	; 0x01

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    5266:	e9 81       	ldd	r30, Y+1	; 0x01
    5268:	fa 81       	ldd	r31, Y+2	; 0x02
    526a:	82 8d       	ldd	r24, Z+26	; 0x1a
    526c:	88 23       	and	r24, r24
    526e:	09 f4       	brne	.+2      	; 0x5272 <xQueueCRReceiveFromISR+0x34>
    5270:	50 c0       	rjmp	.+160    	; 0x5312 <xQueueCRReceiveFromISR+0xd4>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    5272:	e9 81       	ldd	r30, Y+1	; 0x01
    5274:	fa 81       	ldd	r31, Y+2	; 0x02
    5276:	26 81       	ldd	r18, Z+6	; 0x06
    5278:	37 81       	ldd	r19, Z+7	; 0x07
    527a:	e9 81       	ldd	r30, Y+1	; 0x01
    527c:	fa 81       	ldd	r31, Y+2	; 0x02
    527e:	84 8d       	ldd	r24, Z+28	; 0x1c
    5280:	88 2f       	mov	r24, r24
    5282:	90 e0       	ldi	r25, 0x00	; 0
    5284:	82 0f       	add	r24, r18
    5286:	93 1f       	adc	r25, r19
    5288:	e9 81       	ldd	r30, Y+1	; 0x01
    528a:	fa 81       	ldd	r31, Y+2	; 0x02
    528c:	97 83       	std	Z+7, r25	; 0x07
    528e:	86 83       	std	Z+6, r24	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    5290:	e9 81       	ldd	r30, Y+1	; 0x01
    5292:	fa 81       	ldd	r31, Y+2	; 0x02
    5294:	26 81       	ldd	r18, Z+6	; 0x06
    5296:	37 81       	ldd	r19, Z+7	; 0x07
    5298:	e9 81       	ldd	r30, Y+1	; 0x01
    529a:	fa 81       	ldd	r31, Y+2	; 0x02
    529c:	82 81       	ldd	r24, Z+2	; 0x02
    529e:	93 81       	ldd	r25, Z+3	; 0x03
    52a0:	28 17       	cp	r18, r24
    52a2:	39 07       	cpc	r19, r25
    52a4:	40 f0       	brcs	.+16     	; 0x52b6 <xQueueCRReceiveFromISR+0x78>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    52a6:	e9 81       	ldd	r30, Y+1	; 0x01
    52a8:	fa 81       	ldd	r31, Y+2	; 0x02
    52aa:	80 81       	ld	r24, Z
    52ac:	91 81       	ldd	r25, Z+1	; 0x01
    52ae:	e9 81       	ldd	r30, Y+1	; 0x01
    52b0:	fa 81       	ldd	r31, Y+2	; 0x02
    52b2:	97 83       	std	Z+7, r25	; 0x07
    52b4:	86 83       	std	Z+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    52b6:	e9 81       	ldd	r30, Y+1	; 0x01
    52b8:	fa 81       	ldd	r31, Y+2	; 0x02
    52ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    52bc:	81 50       	subi	r24, 0x01	; 1
    52be:	e9 81       	ldd	r30, Y+1	; 0x01
    52c0:	fa 81       	ldd	r31, Y+2	; 0x02
    52c2:	82 8f       	std	Z+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    52c4:	e9 81       	ldd	r30, Y+1	; 0x01
    52c6:	fa 81       	ldd	r31, Y+2	; 0x02
    52c8:	46 81       	ldd	r20, Z+6	; 0x06
    52ca:	57 81       	ldd	r21, Z+7	; 0x07
    52cc:	e9 81       	ldd	r30, Y+1	; 0x01
    52ce:	fa 81       	ldd	r31, Y+2	; 0x02
    52d0:	84 8d       	ldd	r24, Z+28	; 0x1c
    52d2:	28 2f       	mov	r18, r24
    52d4:	30 e0       	ldi	r19, 0x00	; 0
    52d6:	8e 81       	ldd	r24, Y+6	; 0x06
    52d8:	9f 81       	ldd	r25, Y+7	; 0x07
    52da:	ba 01       	movw	r22, r20
    52dc:	a9 01       	movw	r20, r18
    52de:	0e 94 22 33 	call	0x6644	; 0x6644 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    52e2:	e8 85       	ldd	r30, Y+8	; 0x08
    52e4:	f9 85       	ldd	r31, Y+9	; 0x09
    52e6:	80 81       	ld	r24, Z
    52e8:	88 23       	and	r24, r24
    52ea:	81 f4       	brne	.+32     	; 0x530c <xQueueCRReceiveFromISR+0xce>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    52ec:	e9 81       	ldd	r30, Y+1	; 0x01
    52ee:	fa 81       	ldd	r31, Y+2	; 0x02
    52f0:	80 85       	ldd	r24, Z+8	; 0x08
    52f2:	88 23       	and	r24, r24
    52f4:	59 f0       	breq	.+22     	; 0x530c <xQueueCRReceiveFromISR+0xce>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    52f6:	89 81       	ldd	r24, Y+1	; 0x01
    52f8:	9a 81       	ldd	r25, Y+2	; 0x02
    52fa:	08 96       	adiw	r24, 0x08	; 8
    52fc:	0e 94 18 19 	call	0x3230	; 0x3230 <xCoRoutineRemoveFromEventList>
    5300:	88 23       	and	r24, r24
    5302:	21 f0       	breq	.+8      	; 0x530c <xQueueCRReceiveFromISR+0xce>
					{
						*pxCoRoutineWoken = pdTRUE;
    5304:	e8 85       	ldd	r30, Y+8	; 0x08
    5306:	f9 85       	ldd	r31, Y+9	; 0x09
    5308:	81 e0       	ldi	r24, 0x01	; 1
    530a:	80 83       	st	Z, r24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    530c:	81 e0       	ldi	r24, 0x01	; 1
    530e:	8b 83       	std	Y+3, r24	; 0x03
    5310:	01 c0       	rjmp	.+2      	; 0x5314 <xQueueCRReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
    5312:	1b 82       	std	Y+3, r1	; 0x03
		}

		return xReturn;
    5314:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    5316:	29 96       	adiw	r28, 0x09	; 9
    5318:	0f b6       	in	r0, 0x3f	; 63
    531a:	f8 94       	cli
    531c:	de bf       	out	0x3e, r29	; 62
    531e:	0f be       	out	0x3f, r0	; 63
    5320:	cd bf       	out	0x3d, r28	; 61
    5322:	cf 91       	pop	r28
    5324:	df 91       	pop	r29
    5326:	08 95       	ret

00005328 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    5328:	af 92       	push	r10
    532a:	bf 92       	push	r11
    532c:	cf 92       	push	r12
    532e:	df 92       	push	r13
    5330:	ef 92       	push	r14
    5332:	ff 92       	push	r15
    5334:	0f 93       	push	r16
    5336:	1f 93       	push	r17
    5338:	df 93       	push	r29
    533a:	cf 93       	push	r28
    533c:	cd b7       	in	r28, 0x3d	; 61
    533e:	de b7       	in	r29, 0x3e	; 62
    5340:	64 97       	sbiw	r28, 0x14	; 20
    5342:	0f b6       	in	r0, 0x3f	; 63
    5344:	f8 94       	cli
    5346:	de bf       	out	0x3e, r29	; 62
    5348:	0f be       	out	0x3f, r0	; 63
    534a:	cd bf       	out	0x3d, r28	; 61
    534c:	9f 83       	std	Y+7, r25	; 0x07
    534e:	8e 83       	std	Y+6, r24	; 0x06
    5350:	79 87       	std	Y+9, r23	; 0x09
    5352:	68 87       	std	Y+8, r22	; 0x08
    5354:	5b 87       	std	Y+11, r21	; 0x0b
    5356:	4a 87       	std	Y+10, r20	; 0x0a
    5358:	3d 87       	std	Y+13, r19	; 0x0d
    535a:	2c 87       	std	Y+12, r18	; 0x0c
    535c:	0e 87       	std	Y+14, r16	; 0x0e
    535e:	f8 8a       	std	Y+16, r15	; 0x10
    5360:	ef 86       	std	Y+15, r14	; 0x0f
    5362:	da 8a       	std	Y+18, r13	; 0x12
    5364:	c9 8a       	std	Y+17, r12	; 0x11
    5366:	bc 8a       	std	Y+20, r11	; 0x14
    5368:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    536a:	8a 85       	ldd	r24, Y+10	; 0x0a
    536c:	9b 85       	ldd	r25, Y+11	; 0x0b
    536e:	29 89       	ldd	r18, Y+17	; 0x11
    5370:	3a 89       	ldd	r19, Y+18	; 0x12
    5372:	b9 01       	movw	r22, r18
    5374:	0e 94 8a 30 	call	0x6114	; 0x6114 <prvAllocateTCBAndStack>
    5378:	9c 83       	std	Y+4, r25	; 0x04
    537a:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    537c:	8b 81       	ldd	r24, Y+3	; 0x03
    537e:	9c 81       	ldd	r25, Y+4	; 0x04
    5380:	00 97       	sbiw	r24, 0x00	; 0
    5382:	09 f4       	brne	.+2      	; 0x5386 <xTaskGenericCreate+0x5e>
    5384:	8d c0       	rjmp	.+282    	; 0x54a0 <xTaskGenericCreate+0x178>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    5386:	eb 81       	ldd	r30, Y+3	; 0x03
    5388:	fc 81       	ldd	r31, Y+4	; 0x04
    538a:	27 89       	ldd	r18, Z+23	; 0x17
    538c:	30 8d       	ldd	r19, Z+24	; 0x18
    538e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5390:	9b 85       	ldd	r25, Y+11	; 0x0b
    5392:	01 97       	sbiw	r24, 0x01	; 1
    5394:	82 0f       	add	r24, r18
    5396:	93 1f       	adc	r25, r19
    5398:	9a 83       	std	Y+2, r25	; 0x02
    539a:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    539c:	8b 81       	ldd	r24, Y+3	; 0x03
    539e:	9c 81       	ldd	r25, Y+4	; 0x04
    53a0:	28 85       	ldd	r18, Y+8	; 0x08
    53a2:	39 85       	ldd	r19, Y+9	; 0x09
    53a4:	eb 89       	ldd	r30, Y+19	; 0x13
    53a6:	fc 89       	ldd	r31, Y+20	; 0x14
    53a8:	aa 85       	ldd	r26, Y+10	; 0x0a
    53aa:	bb 85       	ldd	r27, Y+11	; 0x0b
    53ac:	b9 01       	movw	r22, r18
    53ae:	4e 85       	ldd	r20, Y+14	; 0x0e
    53b0:	9f 01       	movw	r18, r30
    53b2:	8d 01       	movw	r16, r26
    53b4:	0e 94 4b 2f 	call	0x5e96	; 0x5e96 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    53b8:	89 81       	ldd	r24, Y+1	; 0x01
    53ba:	9a 81       	ldd	r25, Y+2	; 0x02
    53bc:	2e 81       	ldd	r18, Y+6	; 0x06
    53be:	3f 81       	ldd	r19, Y+7	; 0x07
    53c0:	4c 85       	ldd	r20, Y+12	; 0x0c
    53c2:	5d 85       	ldd	r21, Y+13	; 0x0d
    53c4:	b9 01       	movw	r22, r18
    53c6:	0e 94 14 1f 	call	0x3e28	; 0x3e28 <pxPortInitialiseStack>
    53ca:	eb 81       	ldd	r30, Y+3	; 0x03
    53cc:	fc 81       	ldd	r31, Y+4	; 0x04
    53ce:	91 83       	std	Z+1, r25	; 0x01
    53d0:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    53d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    53d4:	98 89       	ldd	r25, Y+16	; 0x10
    53d6:	00 97       	sbiw	r24, 0x00	; 0
    53d8:	31 f0       	breq	.+12     	; 0x53e6 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    53da:	ef 85       	ldd	r30, Y+15	; 0x0f
    53dc:	f8 89       	ldd	r31, Y+16	; 0x10
    53de:	8b 81       	ldd	r24, Y+3	; 0x03
    53e0:	9c 81       	ldd	r25, Y+4	; 0x04
    53e2:	91 83       	std	Z+1, r25	; 0x01
    53e4:	80 83       	st	Z, r24
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    53e6:	0f b6       	in	r0, 0x3f	; 63
    53e8:	f8 94       	cli
    53ea:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    53ec:	80 91 9a 06 	lds	r24, 0x069A
    53f0:	8f 5f       	subi	r24, 0xFF	; 255
    53f2:	80 93 9a 06 	sts	0x069A, r24
			if( pxCurrentTCB == NULL )
    53f6:	80 91 97 06 	lds	r24, 0x0697
    53fa:	90 91 98 06 	lds	r25, 0x0698
    53fe:	00 97       	sbiw	r24, 0x00	; 0
    5400:	69 f4       	brne	.+26     	; 0x541c <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    5402:	8b 81       	ldd	r24, Y+3	; 0x03
    5404:	9c 81       	ldd	r25, Y+4	; 0x04
    5406:	90 93 98 06 	sts	0x0698, r25
    540a:	80 93 97 06 	sts	0x0697, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    540e:	80 91 9a 06 	lds	r24, 0x069A
    5412:	81 30       	cpi	r24, 0x01	; 1
    5414:	a9 f4       	brne	.+42     	; 0x5440 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    5416:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <prvInitialiseTaskLists>
    541a:	12 c0       	rjmp	.+36     	; 0x5440 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    541c:	80 91 9e 06 	lds	r24, 0x069E
    5420:	88 23       	and	r24, r24
    5422:	71 f4       	brne	.+28     	; 0x5440 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    5424:	e0 91 97 06 	lds	r30, 0x0697
    5428:	f0 91 98 06 	lds	r31, 0x0698
    542c:	96 89       	ldd	r25, Z+22	; 0x16
    542e:	8e 85       	ldd	r24, Y+14	; 0x0e
    5430:	89 17       	cp	r24, r25
    5432:	30 f0       	brcs	.+12     	; 0x5440 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    5434:	8b 81       	ldd	r24, Y+3	; 0x03
    5436:	9c 81       	ldd	r25, Y+4	; 0x04
    5438:	90 93 98 06 	sts	0x0698, r25
    543c:	80 93 97 06 	sts	0x0697, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    5440:	80 91 a2 06 	lds	r24, 0x06A2
    5444:	8f 5f       	subi	r24, 0xFF	; 255
    5446:	80 93 a2 06 	sts	0x06A2, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    544a:	eb 81       	ldd	r30, Y+3	; 0x03
    544c:	fc 81       	ldd	r31, Y+4	; 0x04
    544e:	96 89       	ldd	r25, Z+22	; 0x16
    5450:	80 91 9d 06 	lds	r24, 0x069D
    5454:	89 17       	cp	r24, r25
    5456:	28 f4       	brcc	.+10     	; 0x5462 <xTaskGenericCreate+0x13a>
    5458:	eb 81       	ldd	r30, Y+3	; 0x03
    545a:	fc 81       	ldd	r31, Y+4	; 0x04
    545c:	86 89       	ldd	r24, Z+22	; 0x16
    545e:	80 93 9d 06 	sts	0x069D, r24
    5462:	eb 81       	ldd	r30, Y+3	; 0x03
    5464:	fc 81       	ldd	r31, Y+4	; 0x04
    5466:	86 89       	ldd	r24, Z+22	; 0x16
    5468:	28 2f       	mov	r18, r24
    546a:	30 e0       	ldi	r19, 0x00	; 0
    546c:	c9 01       	movw	r24, r18
    546e:	88 0f       	add	r24, r24
    5470:	99 1f       	adc	r25, r25
    5472:	88 0f       	add	r24, r24
    5474:	99 1f       	adc	r25, r25
    5476:	88 0f       	add	r24, r24
    5478:	99 1f       	adc	r25, r25
    547a:	82 0f       	add	r24, r18
    547c:	93 1f       	adc	r25, r19
    547e:	ac 01       	movw	r20, r24
    5480:	4c 55       	subi	r20, 0x5C	; 92
    5482:	59 4f       	sbci	r21, 0xF9	; 249
    5484:	8b 81       	ldd	r24, Y+3	; 0x03
    5486:	9c 81       	ldd	r25, Y+4	; 0x04
    5488:	9c 01       	movw	r18, r24
    548a:	2e 5f       	subi	r18, 0xFE	; 254
    548c:	3f 4f       	sbci	r19, 0xFF	; 255
    548e:	ca 01       	movw	r24, r20
    5490:	b9 01       	movw	r22, r18
    5492:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>

			xReturn = pdPASS;
    5496:	81 e0       	ldi	r24, 0x01	; 1
    5498:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    549a:	0f 90       	pop	r0
    549c:	0f be       	out	0x3f, r0	; 63
    549e:	02 c0       	rjmp	.+4      	; 0x54a4 <xTaskGenericCreate+0x17c>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    54a0:	8f ef       	ldi	r24, 0xFF	; 255
    54a2:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    54a4:	8d 81       	ldd	r24, Y+5	; 0x05
    54a6:	81 30       	cpi	r24, 0x01	; 1
    54a8:	71 f4       	brne	.+28     	; 0x54c6 <xTaskGenericCreate+0x19e>
	{
		if( xSchedulerRunning != pdFALSE )
    54aa:	80 91 9e 06 	lds	r24, 0x069E
    54ae:	88 23       	and	r24, r24
    54b0:	51 f0       	breq	.+20     	; 0x54c6 <xTaskGenericCreate+0x19e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    54b2:	e0 91 97 06 	lds	r30, 0x0697
    54b6:	f0 91 98 06 	lds	r31, 0x0698
    54ba:	96 89       	ldd	r25, Z+22	; 0x16
    54bc:	8e 85       	ldd	r24, Y+14	; 0x0e
    54be:	98 17       	cp	r25, r24
    54c0:	10 f4       	brcc	.+4      	; 0x54c6 <xTaskGenericCreate+0x19e>
			{
				taskYIELD_IF_USING_PREEMPTION();
    54c2:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    54c6:	8d 81       	ldd	r24, Y+5	; 0x05
}
    54c8:	64 96       	adiw	r28, 0x14	; 20
    54ca:	0f b6       	in	r0, 0x3f	; 63
    54cc:	f8 94       	cli
    54ce:	de bf       	out	0x3e, r29	; 62
    54d0:	0f be       	out	0x3f, r0	; 63
    54d2:	cd bf       	out	0x3d, r28	; 61
    54d4:	cf 91       	pop	r28
    54d6:	df 91       	pop	r29
    54d8:	1f 91       	pop	r17
    54da:	0f 91       	pop	r16
    54dc:	ff 90       	pop	r15
    54de:	ef 90       	pop	r14
    54e0:	df 90       	pop	r13
    54e2:	cf 90       	pop	r12
    54e4:	bf 90       	pop	r11
    54e6:	af 90       	pop	r10
    54e8:	08 95       	ret

000054ea <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    54ea:	df 93       	push	r29
    54ec:	cf 93       	push	r28
    54ee:	00 d0       	rcall	.+0      	; 0x54f0 <vTaskDelete+0x6>
    54f0:	00 d0       	rcall	.+0      	; 0x54f2 <vTaskDelete+0x8>
    54f2:	00 d0       	rcall	.+0      	; 0x54f4 <vTaskDelete+0xa>
    54f4:	cd b7       	in	r28, 0x3d	; 61
    54f6:	de b7       	in	r29, 0x3e	; 62
    54f8:	9c 83       	std	Y+4, r25	; 0x04
    54fa:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    54fc:	0f b6       	in	r0, 0x3f	; 63
    54fe:	f8 94       	cli
    5500:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    5502:	8b 81       	ldd	r24, Y+3	; 0x03
    5504:	9c 81       	ldd	r25, Y+4	; 0x04
    5506:	00 97       	sbiw	r24, 0x00	; 0
    5508:	39 f4       	brne	.+14     	; 0x5518 <vTaskDelete+0x2e>
    550a:	80 91 97 06 	lds	r24, 0x0697
    550e:	90 91 98 06 	lds	r25, 0x0698
    5512:	9e 83       	std	Y+6, r25	; 0x06
    5514:	8d 83       	std	Y+5, r24	; 0x05
    5516:	04 c0       	rjmp	.+8      	; 0x5520 <vTaskDelete+0x36>
    5518:	8b 81       	ldd	r24, Y+3	; 0x03
    551a:	9c 81       	ldd	r25, Y+4	; 0x04
    551c:	9e 83       	std	Y+6, r25	; 0x06
    551e:	8d 83       	std	Y+5, r24	; 0x05
    5520:	8d 81       	ldd	r24, Y+5	; 0x05
    5522:	9e 81       	ldd	r25, Y+6	; 0x06
    5524:	9a 83       	std	Y+2, r25	; 0x02
    5526:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5528:	89 81       	ldd	r24, Y+1	; 0x01
    552a:	9a 81       	ldd	r25, Y+2	; 0x02
    552c:	02 96       	adiw	r24, 0x02	; 2
    552e:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5532:	e9 81       	ldd	r30, Y+1	; 0x01
    5534:	fa 81       	ldd	r31, Y+2	; 0x02
    5536:	84 89       	ldd	r24, Z+20	; 0x14
    5538:	95 89       	ldd	r25, Z+21	; 0x15
    553a:	00 97       	sbiw	r24, 0x00	; 0
    553c:	29 f0       	breq	.+10     	; 0x5548 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    553e:	89 81       	ldd	r24, Y+1	; 0x01
    5540:	9a 81       	ldd	r25, Y+2	; 0x02
    5542:	0c 96       	adiw	r24, 0x0c	; 12
    5544:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    5548:	89 81       	ldd	r24, Y+1	; 0x01
    554a:	9a 81       	ldd	r25, Y+2	; 0x02
    554c:	9c 01       	movw	r18, r24
    554e:	2e 5f       	subi	r18, 0xFE	; 254
    5550:	3f 4f       	sbci	r19, 0xFF	; 255
    5552:	89 ef       	ldi	r24, 0xF9	; 249
    5554:	96 e0       	ldi	r25, 0x06	; 6
    5556:	b9 01       	movw	r22, r18
    5558:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    555c:	80 91 99 06 	lds	r24, 0x0699
    5560:	8f 5f       	subi	r24, 0xFF	; 255
    5562:	80 93 99 06 	sts	0x0699, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    5566:	80 91 a2 06 	lds	r24, 0x06A2
    556a:	8f 5f       	subi	r24, 0xFF	; 255
    556c:	80 93 a2 06 	sts	0x06A2, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    5570:	0f 90       	pop	r0
    5572:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    5574:	80 91 9e 06 	lds	r24, 0x069E
    5578:	88 23       	and	r24, r24
    557a:	99 f0       	breq	.+38     	; 0x55a2 <vTaskDelete+0xb8>
		{
			if( pxTCB == pxCurrentTCB )
    557c:	20 91 97 06 	lds	r18, 0x0697
    5580:	30 91 98 06 	lds	r19, 0x0698
    5584:	89 81       	ldd	r24, Y+1	; 0x01
    5586:	9a 81       	ldd	r25, Y+2	; 0x02
    5588:	82 17       	cp	r24, r18
    558a:	93 07       	cpc	r25, r19
    558c:	19 f4       	brne	.+6      	; 0x5594 <vTaskDelete+0xaa>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    558e:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>
    5592:	07 c0       	rjmp	.+14     	; 0x55a2 <vTaskDelete+0xb8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    5594:	0f b6       	in	r0, 0x3f	; 63
    5596:	f8 94       	cli
    5598:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    559a:	0e 94 e4 30 	call	0x61c8	; 0x61c8 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    559e:	0f 90       	pop	r0
    55a0:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    55a2:	26 96       	adiw	r28, 0x06	; 6
    55a4:	0f b6       	in	r0, 0x3f	; 63
    55a6:	f8 94       	cli
    55a8:	de bf       	out	0x3e, r29	; 62
    55aa:	0f be       	out	0x3f, r0	; 63
    55ac:	cd bf       	out	0x3d, r28	; 61
    55ae:	cf 91       	pop	r28
    55b0:	df 91       	pop	r29
    55b2:	08 95       	ret

000055b4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    55b4:	df 93       	push	r29
    55b6:	cf 93       	push	r28
    55b8:	00 d0       	rcall	.+0      	; 0x55ba <vTaskDelay+0x6>
    55ba:	00 d0       	rcall	.+0      	; 0x55bc <vTaskDelay+0x8>
    55bc:	0f 92       	push	r0
    55be:	cd b7       	in	r28, 0x3d	; 61
    55c0:	de b7       	in	r29, 0x3e	; 62
    55c2:	9d 83       	std	Y+5, r25	; 0x05
    55c4:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    55c6:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    55c8:	8c 81       	ldd	r24, Y+4	; 0x04
    55ca:	9d 81       	ldd	r25, Y+5	; 0x05
    55cc:	00 97       	sbiw	r24, 0x00	; 0
    55ce:	d1 f0       	breq	.+52     	; 0x5604 <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    55d0:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    55d4:	20 91 9b 06 	lds	r18, 0x069B
    55d8:	30 91 9c 06 	lds	r19, 0x069C
    55dc:	8c 81       	ldd	r24, Y+4	; 0x04
    55de:	9d 81       	ldd	r25, Y+5	; 0x05
    55e0:	82 0f       	add	r24, r18
    55e2:	93 1f       	adc	r25, r19
    55e4:	9b 83       	std	Y+3, r25	; 0x03
    55e6:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    55e8:	80 91 97 06 	lds	r24, 0x0697
    55ec:	90 91 98 06 	lds	r25, 0x0698
    55f0:	02 96       	adiw	r24, 0x02	; 2
    55f2:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    55f6:	8a 81       	ldd	r24, Y+2	; 0x02
    55f8:	9b 81       	ldd	r25, Y+3	; 0x03
    55fa:	0e 94 41 30 	call	0x6082	; 0x6082 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    55fe:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>
    5602:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5604:	89 81       	ldd	r24, Y+1	; 0x01
    5606:	88 23       	and	r24, r24
    5608:	11 f4       	brne	.+4      	; 0x560e <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    560a:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    560e:	0f 90       	pop	r0
    5610:	0f 90       	pop	r0
    5612:	0f 90       	pop	r0
    5614:	0f 90       	pop	r0
    5616:	0f 90       	pop	r0
    5618:	cf 91       	pop	r28
    561a:	df 91       	pop	r29
    561c:	08 95       	ret

0000561e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    561e:	af 92       	push	r10
    5620:	bf 92       	push	r11
    5622:	cf 92       	push	r12
    5624:	df 92       	push	r13
    5626:	ef 92       	push	r14
    5628:	ff 92       	push	r15
    562a:	0f 93       	push	r16
    562c:	df 93       	push	r29
    562e:	cf 93       	push	r28
    5630:	0f 92       	push	r0
    5632:	cd b7       	in	r28, 0x3d	; 61
    5634:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    5636:	8b e3       	ldi	r24, 0x3B	; 59
    5638:	9f e2       	ldi	r25, 0x2F	; 47
    563a:	22 e5       	ldi	r18, 0x52	; 82
    563c:	31 e0       	ldi	r19, 0x01	; 1
    563e:	b9 01       	movw	r22, r18
    5640:	45 e5       	ldi	r20, 0x55	; 85
    5642:	50 e0       	ldi	r21, 0x00	; 0
    5644:	20 e0       	ldi	r18, 0x00	; 0
    5646:	30 e0       	ldi	r19, 0x00	; 0
    5648:	00 e0       	ldi	r16, 0x00	; 0
    564a:	ee 24       	eor	r14, r14
    564c:	ff 24       	eor	r15, r15
    564e:	cc 24       	eor	r12, r12
    5650:	dd 24       	eor	r13, r13
    5652:	aa 24       	eor	r10, r10
    5654:	bb 24       	eor	r11, r11
    5656:	0e 94 94 29 	call	0x5328	; 0x5328 <xTaskGenericCreate>
    565a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    565c:	89 81       	ldd	r24, Y+1	; 0x01
    565e:	81 30       	cpi	r24, 0x01	; 1
    5660:	51 f4       	brne	.+20     	; 0x5676 <vTaskStartScheduler+0x58>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    5662:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    5664:	81 e0       	ldi	r24, 0x01	; 1
    5666:	80 93 9e 06 	sts	0x069E, r24
		xTickCount = ( TickType_t ) 0U;
    566a:	10 92 9c 06 	sts	0x069C, r1
    566e:	10 92 9b 06 	sts	0x069B, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    5672:	0e 94 97 20 	call	0x412e	; 0x412e <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    5676:	0f 90       	pop	r0
    5678:	cf 91       	pop	r28
    567a:	df 91       	pop	r29
    567c:	0f 91       	pop	r16
    567e:	ff 90       	pop	r15
    5680:	ef 90       	pop	r14
    5682:	df 90       	pop	r13
    5684:	cf 90       	pop	r12
    5686:	bf 90       	pop	r11
    5688:	af 90       	pop	r10
    568a:	08 95       	ret

0000568c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    568c:	df 93       	push	r29
    568e:	cf 93       	push	r28
    5690:	cd b7       	in	r28, 0x3d	; 61
    5692:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    5694:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    5696:	10 92 9e 06 	sts	0x069E, r1
	vPortEndScheduler();
    569a:	0e 94 cc 20 	call	0x4198	; 0x4198 <vPortEndScheduler>
}
    569e:	cf 91       	pop	r28
    56a0:	df 91       	pop	r29
    56a2:	08 95       	ret

000056a4 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    56a4:	df 93       	push	r29
    56a6:	cf 93       	push	r28
    56a8:	cd b7       	in	r28, 0x3d	; 61
    56aa:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    56ac:	80 91 a3 06 	lds	r24, 0x06A3
    56b0:	8f 5f       	subi	r24, 0xFF	; 255
    56b2:	80 93 a3 06 	sts	0x06A3, r24
}
    56b6:	cf 91       	pop	r28
    56b8:	df 91       	pop	r29
    56ba:	08 95       	ret

000056bc <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    56bc:	df 93       	push	r29
    56be:	cf 93       	push	r28
    56c0:	00 d0       	rcall	.+0      	; 0x56c2 <xTaskResumeAll+0x6>
    56c2:	0f 92       	push	r0
    56c4:	cd b7       	in	r28, 0x3d	; 61
    56c6:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    56c8:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    56ca:	0f b6       	in	r0, 0x3f	; 63
    56cc:	f8 94       	cli
    56ce:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    56d0:	80 91 a3 06 	lds	r24, 0x06A3
    56d4:	81 50       	subi	r24, 0x01	; 1
    56d6:	80 93 a3 06 	sts	0x06A3, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    56da:	80 91 a3 06 	lds	r24, 0x06A3
    56de:	88 23       	and	r24, r24
    56e0:	09 f0       	breq	.+2      	; 0x56e4 <xTaskResumeAll+0x28>
    56e2:	6d c0       	rjmp	.+218    	; 0x57be <xTaskResumeAll+0x102>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    56e4:	80 91 9a 06 	lds	r24, 0x069A
    56e8:	88 23       	and	r24, r24
    56ea:	09 f4       	brne	.+2      	; 0x56ee <xTaskResumeAll+0x32>
    56ec:	68 c0       	rjmp	.+208    	; 0x57be <xTaskResumeAll+0x102>
    56ee:	45 c0       	rjmp	.+138    	; 0x577a <xTaskResumeAll+0xbe>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    56f0:	e0 91 f5 06 	lds	r30, 0x06F5
    56f4:	f0 91 f6 06 	lds	r31, 0x06F6
    56f8:	86 81       	ldd	r24, Z+6	; 0x06
    56fa:	97 81       	ldd	r25, Z+7	; 0x07
    56fc:	9b 83       	std	Y+3, r25	; 0x03
    56fe:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5700:	8a 81       	ldd	r24, Y+2	; 0x02
    5702:	9b 81       	ldd	r25, Y+3	; 0x03
    5704:	0c 96       	adiw	r24, 0x0c	; 12
    5706:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    570a:	8a 81       	ldd	r24, Y+2	; 0x02
    570c:	9b 81       	ldd	r25, Y+3	; 0x03
    570e:	02 96       	adiw	r24, 0x02	; 2
    5710:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5714:	ea 81       	ldd	r30, Y+2	; 0x02
    5716:	fb 81       	ldd	r31, Y+3	; 0x03
    5718:	96 89       	ldd	r25, Z+22	; 0x16
    571a:	80 91 9d 06 	lds	r24, 0x069D
    571e:	89 17       	cp	r24, r25
    5720:	28 f4       	brcc	.+10     	; 0x572c <xTaskResumeAll+0x70>
    5722:	ea 81       	ldd	r30, Y+2	; 0x02
    5724:	fb 81       	ldd	r31, Y+3	; 0x03
    5726:	86 89       	ldd	r24, Z+22	; 0x16
    5728:	80 93 9d 06 	sts	0x069D, r24
    572c:	ea 81       	ldd	r30, Y+2	; 0x02
    572e:	fb 81       	ldd	r31, Y+3	; 0x03
    5730:	86 89       	ldd	r24, Z+22	; 0x16
    5732:	28 2f       	mov	r18, r24
    5734:	30 e0       	ldi	r19, 0x00	; 0
    5736:	c9 01       	movw	r24, r18
    5738:	88 0f       	add	r24, r24
    573a:	99 1f       	adc	r25, r25
    573c:	88 0f       	add	r24, r24
    573e:	99 1f       	adc	r25, r25
    5740:	88 0f       	add	r24, r24
    5742:	99 1f       	adc	r25, r25
    5744:	82 0f       	add	r24, r18
    5746:	93 1f       	adc	r25, r19
    5748:	ac 01       	movw	r20, r24
    574a:	4c 55       	subi	r20, 0x5C	; 92
    574c:	59 4f       	sbci	r21, 0xF9	; 249
    574e:	8a 81       	ldd	r24, Y+2	; 0x02
    5750:	9b 81       	ldd	r25, Y+3	; 0x03
    5752:	9c 01       	movw	r18, r24
    5754:	2e 5f       	subi	r18, 0xFE	; 254
    5756:	3f 4f       	sbci	r19, 0xFF	; 255
    5758:	ca 01       	movw	r24, r20
    575a:	b9 01       	movw	r22, r18
    575c:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5760:	ea 81       	ldd	r30, Y+2	; 0x02
    5762:	fb 81       	ldd	r31, Y+3	; 0x03
    5764:	96 89       	ldd	r25, Z+22	; 0x16
    5766:	e0 91 97 06 	lds	r30, 0x0697
    576a:	f0 91 98 06 	lds	r31, 0x0698
    576e:	86 89       	ldd	r24, Z+22	; 0x16
    5770:	98 17       	cp	r25, r24
    5772:	18 f0       	brcs	.+6      	; 0x577a <xTaskResumeAll+0xbe>
					{
						xYieldPending = pdTRUE;
    5774:	81 e0       	ldi	r24, 0x01	; 1
    5776:	80 93 a0 06 	sts	0x06A0, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    577a:	80 91 f0 06 	lds	r24, 0x06F0
    577e:	88 23       	and	r24, r24
    5780:	09 f0       	breq	.+2      	; 0x5784 <xTaskResumeAll+0xc8>
    5782:	b6 cf       	rjmp	.-148    	; 0x56f0 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    5784:	80 91 9f 06 	lds	r24, 0x069F
    5788:	88 23       	and	r24, r24
    578a:	89 f0       	breq	.+34     	; 0x57ae <xTaskResumeAll+0xf2>
    578c:	0c c0       	rjmp	.+24     	; 0x57a6 <xTaskResumeAll+0xea>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    578e:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskIncrementTick>
    5792:	88 23       	and	r24, r24
    5794:	19 f0       	breq	.+6      	; 0x579c <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
    5796:	81 e0       	ldi	r24, 0x01	; 1
    5798:	80 93 a0 06 	sts	0x06A0, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    579c:	80 91 9f 06 	lds	r24, 0x069F
    57a0:	81 50       	subi	r24, 0x01	; 1
    57a2:	80 93 9f 06 	sts	0x069F, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    57a6:	80 91 9f 06 	lds	r24, 0x069F
    57aa:	88 23       	and	r24, r24
    57ac:	81 f7       	brne	.-32     	; 0x578e <xTaskResumeAll+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    57ae:	80 91 a0 06 	lds	r24, 0x06A0
    57b2:	81 30       	cpi	r24, 0x01	; 1
    57b4:	21 f4       	brne	.+8      	; 0x57be <xTaskResumeAll+0x102>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    57b6:	81 e0       	ldi	r24, 0x01	; 1
    57b8:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    57ba:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    57be:	0f 90       	pop	r0
    57c0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    57c2:	89 81       	ldd	r24, Y+1	; 0x01
}
    57c4:	0f 90       	pop	r0
    57c6:	0f 90       	pop	r0
    57c8:	0f 90       	pop	r0
    57ca:	cf 91       	pop	r28
    57cc:	df 91       	pop	r29
    57ce:	08 95       	ret

000057d0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    57d0:	df 93       	push	r29
    57d2:	cf 93       	push	r28
    57d4:	00 d0       	rcall	.+0      	; 0x57d6 <xTaskGetTickCount+0x6>
    57d6:	cd b7       	in	r28, 0x3d	; 61
    57d8:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    57da:	0f b6       	in	r0, 0x3f	; 63
    57dc:	f8 94       	cli
    57de:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    57e0:	80 91 9b 06 	lds	r24, 0x069B
    57e4:	90 91 9c 06 	lds	r25, 0x069C
    57e8:	9a 83       	std	Y+2, r25	; 0x02
    57ea:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    57ec:	0f 90       	pop	r0
    57ee:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    57f0:	89 81       	ldd	r24, Y+1	; 0x01
    57f2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    57f4:	0f 90       	pop	r0
    57f6:	0f 90       	pop	r0
    57f8:	cf 91       	pop	r28
    57fa:	df 91       	pop	r29
    57fc:	08 95       	ret

000057fe <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    57fe:	df 93       	push	r29
    5800:	cf 93       	push	r28
    5802:	00 d0       	rcall	.+0      	; 0x5804 <xTaskGetTickCountFromISR+0x6>
    5804:	0f 92       	push	r0
    5806:	cd b7       	in	r28, 0x3d	; 61
    5808:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    580a:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    580c:	80 91 9b 06 	lds	r24, 0x069B
    5810:	90 91 9c 06 	lds	r25, 0x069C
    5814:	9b 83       	std	Y+3, r25	; 0x03
    5816:	8a 83       	std	Y+2, r24	; 0x02
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5818:	8a 81       	ldd	r24, Y+2	; 0x02
    581a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    581c:	0f 90       	pop	r0
    581e:	0f 90       	pop	r0
    5820:	0f 90       	pop	r0
    5822:	cf 91       	pop	r28
    5824:	df 91       	pop	r29
    5826:	08 95       	ret

00005828 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    5828:	df 93       	push	r29
    582a:	cf 93       	push	r28
    582c:	cd b7       	in	r28, 0x3d	; 61
    582e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    5830:	80 91 9a 06 	lds	r24, 0x069A
}
    5834:	cf 91       	pop	r28
    5836:	df 91       	pop	r29
    5838:	08 95       	ret

0000583a <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    583a:	df 93       	push	r29
    583c:	cf 93       	push	r28
    583e:	cd b7       	in	r28, 0x3d	; 61
    5840:	de b7       	in	r29, 0x3e	; 62
    5842:	29 97       	sbiw	r28, 0x09	; 9
    5844:	0f b6       	in	r0, 0x3f	; 63
    5846:	f8 94       	cli
    5848:	de bf       	out	0x3e, r29	; 62
    584a:	0f be       	out	0x3f, r0	; 63
    584c:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    584e:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5850:	80 91 a3 06 	lds	r24, 0x06A3
    5854:	88 23       	and	r24, r24
    5856:	09 f0       	breq	.+2      	; 0x585a <xTaskIncrementTick+0x20>
    5858:	c2 c0       	rjmp	.+388    	; 0x59de <xTaskIncrementTick+0x1a4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    585a:	80 91 9b 06 	lds	r24, 0x069B
    585e:	90 91 9c 06 	lds	r25, 0x069C
    5862:	01 96       	adiw	r24, 0x01	; 1
    5864:	90 93 9c 06 	sts	0x069C, r25
    5868:	80 93 9b 06 	sts	0x069B, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    586c:	80 91 9b 06 	lds	r24, 0x069B
    5870:	90 91 9c 06 	lds	r25, 0x069C
    5874:	9c 83       	std	Y+4, r25	; 0x04
    5876:	8b 83       	std	Y+3, r24	; 0x03

			if( xConstTickCount == ( TickType_t ) 0U )
    5878:	8b 81       	ldd	r24, Y+3	; 0x03
    587a:	9c 81       	ldd	r25, Y+4	; 0x04
    587c:	00 97       	sbiw	r24, 0x00	; 0
    587e:	d9 f4       	brne	.+54     	; 0x58b6 <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    5880:	80 91 ec 06 	lds	r24, 0x06EC
    5884:	90 91 ed 06 	lds	r25, 0x06ED
    5888:	9a 83       	std	Y+2, r25	; 0x02
    588a:	89 83       	std	Y+1, r24	; 0x01
    588c:	80 91 ee 06 	lds	r24, 0x06EE
    5890:	90 91 ef 06 	lds	r25, 0x06EF
    5894:	90 93 ed 06 	sts	0x06ED, r25
    5898:	80 93 ec 06 	sts	0x06EC, r24
    589c:	89 81       	ldd	r24, Y+1	; 0x01
    589e:	9a 81       	ldd	r25, Y+2	; 0x02
    58a0:	90 93 ef 06 	sts	0x06EF, r25
    58a4:	80 93 ee 06 	sts	0x06EE, r24
    58a8:	80 91 a1 06 	lds	r24, 0x06A1
    58ac:	8f 5f       	subi	r24, 0xFF	; 255
    58ae:	80 93 a1 06 	sts	0x06A1, r24
    58b2:	0e 94 e4 30 	call	0x61c8	; 0x61c8 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    58b6:	20 91 5f 01 	lds	r18, 0x015F
    58ba:	30 91 60 01 	lds	r19, 0x0160
    58be:	8b 81       	ldd	r24, Y+3	; 0x03
    58c0:	9c 81       	ldd	r25, Y+4	; 0x04
    58c2:	82 17       	cp	r24, r18
    58c4:	93 07       	cpc	r25, r19
    58c6:	08 f4       	brcc	.+2      	; 0x58ca <xTaskIncrementTick+0x90>
    58c8:	71 c0       	rjmp	.+226    	; 0x59ac <xTaskIncrementTick+0x172>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    58ca:	e0 91 ec 06 	lds	r30, 0x06EC
    58ce:	f0 91 ed 06 	lds	r31, 0x06ED
    58d2:	80 81       	ld	r24, Z
    58d4:	88 23       	and	r24, r24
    58d6:	39 f4       	brne	.+14     	; 0x58e6 <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    58d8:	8f ef       	ldi	r24, 0xFF	; 255
    58da:	9f ef       	ldi	r25, 0xFF	; 255
    58dc:	90 93 60 01 	sts	0x0160, r25
    58e0:	80 93 5f 01 	sts	0x015F, r24
    58e4:	63 c0       	rjmp	.+198    	; 0x59ac <xTaskIncrementTick+0x172>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    58e6:	e0 91 ec 06 	lds	r30, 0x06EC
    58ea:	f0 91 ed 06 	lds	r31, 0x06ED
    58ee:	05 80       	ldd	r0, Z+5	; 0x05
    58f0:	f6 81       	ldd	r31, Z+6	; 0x06
    58f2:	e0 2d       	mov	r30, r0
    58f4:	86 81       	ldd	r24, Z+6	; 0x06
    58f6:	97 81       	ldd	r25, Z+7	; 0x07
    58f8:	99 87       	std	Y+9, r25	; 0x09
    58fa:	88 87       	std	Y+8, r24	; 0x08
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    58fc:	e8 85       	ldd	r30, Y+8	; 0x08
    58fe:	f9 85       	ldd	r31, Y+9	; 0x09
    5900:	82 81       	ldd	r24, Z+2	; 0x02
    5902:	93 81       	ldd	r25, Z+3	; 0x03
    5904:	9f 83       	std	Y+7, r25	; 0x07
    5906:	8e 83       	std	Y+6, r24	; 0x06

						if( xConstTickCount < xItemValue )
    5908:	2b 81       	ldd	r18, Y+3	; 0x03
    590a:	3c 81       	ldd	r19, Y+4	; 0x04
    590c:	8e 81       	ldd	r24, Y+6	; 0x06
    590e:	9f 81       	ldd	r25, Y+7	; 0x07
    5910:	28 17       	cp	r18, r24
    5912:	39 07       	cpc	r19, r25
    5914:	38 f4       	brcc	.+14     	; 0x5924 <xTaskIncrementTick+0xea>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    5916:	8e 81       	ldd	r24, Y+6	; 0x06
    5918:	9f 81       	ldd	r25, Y+7	; 0x07
    591a:	90 93 60 01 	sts	0x0160, r25
    591e:	80 93 5f 01 	sts	0x015F, r24
    5922:	44 c0       	rjmp	.+136    	; 0x59ac <xTaskIncrementTick+0x172>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    5924:	88 85       	ldd	r24, Y+8	; 0x08
    5926:	99 85       	ldd	r25, Y+9	; 0x09
    5928:	02 96       	adiw	r24, 0x02	; 2
    592a:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    592e:	e8 85       	ldd	r30, Y+8	; 0x08
    5930:	f9 85       	ldd	r31, Y+9	; 0x09
    5932:	84 89       	ldd	r24, Z+20	; 0x14
    5934:	95 89       	ldd	r25, Z+21	; 0x15
    5936:	00 97       	sbiw	r24, 0x00	; 0
    5938:	29 f0       	breq	.+10     	; 0x5944 <xTaskIncrementTick+0x10a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    593a:	88 85       	ldd	r24, Y+8	; 0x08
    593c:	99 85       	ldd	r25, Y+9	; 0x09
    593e:	0c 96       	adiw	r24, 0x0c	; 12
    5940:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    5944:	e8 85       	ldd	r30, Y+8	; 0x08
    5946:	f9 85       	ldd	r31, Y+9	; 0x09
    5948:	96 89       	ldd	r25, Z+22	; 0x16
    594a:	80 91 9d 06 	lds	r24, 0x069D
    594e:	89 17       	cp	r24, r25
    5950:	28 f4       	brcc	.+10     	; 0x595c <xTaskIncrementTick+0x122>
    5952:	e8 85       	ldd	r30, Y+8	; 0x08
    5954:	f9 85       	ldd	r31, Y+9	; 0x09
    5956:	86 89       	ldd	r24, Z+22	; 0x16
    5958:	80 93 9d 06 	sts	0x069D, r24
    595c:	e8 85       	ldd	r30, Y+8	; 0x08
    595e:	f9 85       	ldd	r31, Y+9	; 0x09
    5960:	86 89       	ldd	r24, Z+22	; 0x16
    5962:	28 2f       	mov	r18, r24
    5964:	30 e0       	ldi	r19, 0x00	; 0
    5966:	c9 01       	movw	r24, r18
    5968:	88 0f       	add	r24, r24
    596a:	99 1f       	adc	r25, r25
    596c:	88 0f       	add	r24, r24
    596e:	99 1f       	adc	r25, r25
    5970:	88 0f       	add	r24, r24
    5972:	99 1f       	adc	r25, r25
    5974:	82 0f       	add	r24, r18
    5976:	93 1f       	adc	r25, r19
    5978:	ac 01       	movw	r20, r24
    597a:	4c 55       	subi	r20, 0x5C	; 92
    597c:	59 4f       	sbci	r21, 0xF9	; 249
    597e:	88 85       	ldd	r24, Y+8	; 0x08
    5980:	99 85       	ldd	r25, Y+9	; 0x09
    5982:	9c 01       	movw	r18, r24
    5984:	2e 5f       	subi	r18, 0xFE	; 254
    5986:	3f 4f       	sbci	r19, 0xFF	; 255
    5988:	ca 01       	movw	r24, r20
    598a:	b9 01       	movw	r22, r18
    598c:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5990:	e8 85       	ldd	r30, Y+8	; 0x08
    5992:	f9 85       	ldd	r31, Y+9	; 0x09
    5994:	96 89       	ldd	r25, Z+22	; 0x16
    5996:	e0 91 97 06 	lds	r30, 0x0697
    599a:	f0 91 98 06 	lds	r31, 0x0698
    599e:	86 89       	ldd	r24, Z+22	; 0x16
    59a0:	98 17       	cp	r25, r24
    59a2:	08 f4       	brcc	.+2      	; 0x59a6 <xTaskIncrementTick+0x16c>
    59a4:	92 cf       	rjmp	.-220    	; 0x58ca <xTaskIncrementTick+0x90>
							{
								xSwitchRequired = pdTRUE;
    59a6:	81 e0       	ldi	r24, 0x01	; 1
    59a8:	8d 83       	std	Y+5, r24	; 0x05
    59aa:	8f cf       	rjmp	.-226    	; 0x58ca <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    59ac:	e0 91 97 06 	lds	r30, 0x0697
    59b0:	f0 91 98 06 	lds	r31, 0x0698
    59b4:	86 89       	ldd	r24, Z+22	; 0x16
    59b6:	28 2f       	mov	r18, r24
    59b8:	30 e0       	ldi	r19, 0x00	; 0
    59ba:	c9 01       	movw	r24, r18
    59bc:	88 0f       	add	r24, r24
    59be:	99 1f       	adc	r25, r25
    59c0:	88 0f       	add	r24, r24
    59c2:	99 1f       	adc	r25, r25
    59c4:	88 0f       	add	r24, r24
    59c6:	99 1f       	adc	r25, r25
    59c8:	82 0f       	add	r24, r18
    59ca:	93 1f       	adc	r25, r19
    59cc:	fc 01       	movw	r30, r24
    59ce:	ec 55       	subi	r30, 0x5C	; 92
    59d0:	f9 4f       	sbci	r31, 0xF9	; 249
    59d2:	80 81       	ld	r24, Z
    59d4:	82 30       	cpi	r24, 0x02	; 2
    59d6:	40 f0       	brcs	.+16     	; 0x59e8 <xTaskIncrementTick+0x1ae>
			{
				xSwitchRequired = pdTRUE;
    59d8:	81 e0       	ldi	r24, 0x01	; 1
    59da:	8d 83       	std	Y+5, r24	; 0x05
    59dc:	05 c0       	rjmp	.+10     	; 0x59e8 <xTaskIncrementTick+0x1ae>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    59de:	80 91 9f 06 	lds	r24, 0x069F
    59e2:	8f 5f       	subi	r24, 0xFF	; 255
    59e4:	80 93 9f 06 	sts	0x069F, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    59e8:	80 91 a0 06 	lds	r24, 0x06A0
    59ec:	88 23       	and	r24, r24
    59ee:	11 f0       	breq	.+4      	; 0x59f4 <xTaskIncrementTick+0x1ba>
		{
			xSwitchRequired = pdTRUE;
    59f0:	81 e0       	ldi	r24, 0x01	; 1
    59f2:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    59f4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    59f6:	29 96       	adiw	r28, 0x09	; 9
    59f8:	0f b6       	in	r0, 0x3f	; 63
    59fa:	f8 94       	cli
    59fc:	de bf       	out	0x3e, r29	; 62
    59fe:	0f be       	out	0x3f, r0	; 63
    5a00:	cd bf       	out	0x3d, r28	; 61
    5a02:	cf 91       	pop	r28
    5a04:	df 91       	pop	r29
    5a06:	08 95       	ret

00005a08 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5a08:	df 93       	push	r29
    5a0a:	cf 93       	push	r28
    5a0c:	00 d0       	rcall	.+0      	; 0x5a0e <vTaskSwitchContext+0x6>
    5a0e:	cd b7       	in	r28, 0x3d	; 61
    5a10:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    5a12:	80 91 a3 06 	lds	r24, 0x06A3
    5a16:	88 23       	and	r24, r24
    5a18:	21 f0       	breq	.+8      	; 0x5a22 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    5a1a:	81 e0       	ldi	r24, 0x01	; 1
    5a1c:	80 93 a0 06 	sts	0x06A0, r24
    5a20:	57 c0       	rjmp	.+174    	; 0x5ad0 <vTaskSwitchContext+0xc8>
	}
	else
	{
		xYieldPending = pdFALSE;
    5a22:	10 92 a0 06 	sts	0x06A0, r1
    5a26:	05 c0       	rjmp	.+10     	; 0x5a32 <vTaskSwitchContext+0x2a>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    5a28:	80 91 9d 06 	lds	r24, 0x069D
    5a2c:	81 50       	subi	r24, 0x01	; 1
    5a2e:	80 93 9d 06 	sts	0x069D, r24
    5a32:	80 91 9d 06 	lds	r24, 0x069D
    5a36:	28 2f       	mov	r18, r24
    5a38:	30 e0       	ldi	r19, 0x00	; 0
    5a3a:	c9 01       	movw	r24, r18
    5a3c:	88 0f       	add	r24, r24
    5a3e:	99 1f       	adc	r25, r25
    5a40:	88 0f       	add	r24, r24
    5a42:	99 1f       	adc	r25, r25
    5a44:	88 0f       	add	r24, r24
    5a46:	99 1f       	adc	r25, r25
    5a48:	82 0f       	add	r24, r18
    5a4a:	93 1f       	adc	r25, r19
    5a4c:	fc 01       	movw	r30, r24
    5a4e:	ec 55       	subi	r30, 0x5C	; 92
    5a50:	f9 4f       	sbci	r31, 0xF9	; 249
    5a52:	80 81       	ld	r24, Z
    5a54:	88 23       	and	r24, r24
    5a56:	41 f3       	breq	.-48     	; 0x5a28 <vTaskSwitchContext+0x20>
    5a58:	80 91 9d 06 	lds	r24, 0x069D
    5a5c:	28 2f       	mov	r18, r24
    5a5e:	30 e0       	ldi	r19, 0x00	; 0
    5a60:	c9 01       	movw	r24, r18
    5a62:	88 0f       	add	r24, r24
    5a64:	99 1f       	adc	r25, r25
    5a66:	88 0f       	add	r24, r24
    5a68:	99 1f       	adc	r25, r25
    5a6a:	88 0f       	add	r24, r24
    5a6c:	99 1f       	adc	r25, r25
    5a6e:	82 0f       	add	r24, r18
    5a70:	93 1f       	adc	r25, r19
    5a72:	8c 55       	subi	r24, 0x5C	; 92
    5a74:	99 4f       	sbci	r25, 0xF9	; 249
    5a76:	9a 83       	std	Y+2, r25	; 0x02
    5a78:	89 83       	std	Y+1, r24	; 0x01
    5a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a7e:	01 80       	ldd	r0, Z+1	; 0x01
    5a80:	f2 81       	ldd	r31, Z+2	; 0x02
    5a82:	e0 2d       	mov	r30, r0
    5a84:	82 81       	ldd	r24, Z+2	; 0x02
    5a86:	93 81       	ldd	r25, Z+3	; 0x03
    5a88:	e9 81       	ldd	r30, Y+1	; 0x01
    5a8a:	fa 81       	ldd	r31, Y+2	; 0x02
    5a8c:	92 83       	std	Z+2, r25	; 0x02
    5a8e:	81 83       	std	Z+1, r24	; 0x01
    5a90:	e9 81       	ldd	r30, Y+1	; 0x01
    5a92:	fa 81       	ldd	r31, Y+2	; 0x02
    5a94:	21 81       	ldd	r18, Z+1	; 0x01
    5a96:	32 81       	ldd	r19, Z+2	; 0x02
    5a98:	89 81       	ldd	r24, Y+1	; 0x01
    5a9a:	9a 81       	ldd	r25, Y+2	; 0x02
    5a9c:	03 96       	adiw	r24, 0x03	; 3
    5a9e:	28 17       	cp	r18, r24
    5aa0:	39 07       	cpc	r19, r25
    5aa2:	59 f4       	brne	.+22     	; 0x5aba <vTaskSwitchContext+0xb2>
    5aa4:	e9 81       	ldd	r30, Y+1	; 0x01
    5aa6:	fa 81       	ldd	r31, Y+2	; 0x02
    5aa8:	01 80       	ldd	r0, Z+1	; 0x01
    5aaa:	f2 81       	ldd	r31, Z+2	; 0x02
    5aac:	e0 2d       	mov	r30, r0
    5aae:	82 81       	ldd	r24, Z+2	; 0x02
    5ab0:	93 81       	ldd	r25, Z+3	; 0x03
    5ab2:	e9 81       	ldd	r30, Y+1	; 0x01
    5ab4:	fa 81       	ldd	r31, Y+2	; 0x02
    5ab6:	92 83       	std	Z+2, r25	; 0x02
    5ab8:	81 83       	std	Z+1, r24	; 0x01
    5aba:	e9 81       	ldd	r30, Y+1	; 0x01
    5abc:	fa 81       	ldd	r31, Y+2	; 0x02
    5abe:	01 80       	ldd	r0, Z+1	; 0x01
    5ac0:	f2 81       	ldd	r31, Z+2	; 0x02
    5ac2:	e0 2d       	mov	r30, r0
    5ac4:	86 81       	ldd	r24, Z+6	; 0x06
    5ac6:	97 81       	ldd	r25, Z+7	; 0x07
    5ac8:	90 93 98 06 	sts	0x0698, r25
    5acc:	80 93 97 06 	sts	0x0697, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    5ad0:	0f 90       	pop	r0
    5ad2:	0f 90       	pop	r0
    5ad4:	cf 91       	pop	r28
    5ad6:	df 91       	pop	r29
    5ad8:	08 95       	ret

00005ada <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    5ada:	df 93       	push	r29
    5adc:	cf 93       	push	r28
    5ade:	00 d0       	rcall	.+0      	; 0x5ae0 <vTaskPlaceOnEventList+0x6>
    5ae0:	00 d0       	rcall	.+0      	; 0x5ae2 <vTaskPlaceOnEventList+0x8>
    5ae2:	00 d0       	rcall	.+0      	; 0x5ae4 <vTaskPlaceOnEventList+0xa>
    5ae4:	cd b7       	in	r28, 0x3d	; 61
    5ae6:	de b7       	in	r29, 0x3e	; 62
    5ae8:	9c 83       	std	Y+4, r25	; 0x04
    5aea:	8b 83       	std	Y+3, r24	; 0x03
    5aec:	7e 83       	std	Y+6, r23	; 0x06
    5aee:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5af0:	80 91 97 06 	lds	r24, 0x0697
    5af4:	90 91 98 06 	lds	r25, 0x0698
    5af8:	9c 01       	movw	r18, r24
    5afa:	24 5f       	subi	r18, 0xF4	; 244
    5afc:	3f 4f       	sbci	r19, 0xFF	; 255
    5afe:	8b 81       	ldd	r24, Y+3	; 0x03
    5b00:	9c 81       	ldd	r25, Y+4	; 0x04
    5b02:	b9 01       	movw	r22, r18
    5b04:	0e 94 5c 1e 	call	0x3cb8	; 0x3cb8 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5b08:	80 91 97 06 	lds	r24, 0x0697
    5b0c:	90 91 98 06 	lds	r25, 0x0698
    5b10:	02 96       	adiw	r24, 0x02	; 2
    5b12:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    5b16:	20 91 9b 06 	lds	r18, 0x069B
    5b1a:	30 91 9c 06 	lds	r19, 0x069C
    5b1e:	8d 81       	ldd	r24, Y+5	; 0x05
    5b20:	9e 81       	ldd	r25, Y+6	; 0x06
    5b22:	82 0f       	add	r24, r18
    5b24:	93 1f       	adc	r25, r19
    5b26:	9a 83       	std	Y+2, r25	; 0x02
    5b28:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5b2a:	89 81       	ldd	r24, Y+1	; 0x01
    5b2c:	9a 81       	ldd	r25, Y+2	; 0x02
    5b2e:	0e 94 41 30 	call	0x6082	; 0x6082 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5b32:	26 96       	adiw	r28, 0x06	; 6
    5b34:	0f b6       	in	r0, 0x3f	; 63
    5b36:	f8 94       	cli
    5b38:	de bf       	out	0x3e, r29	; 62
    5b3a:	0f be       	out	0x3f, r0	; 63
    5b3c:	cd bf       	out	0x3d, r28	; 61
    5b3e:	cf 91       	pop	r28
    5b40:	df 91       	pop	r29
    5b42:	08 95       	ret

00005b44 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    5b44:	df 93       	push	r29
    5b46:	cf 93       	push	r28
    5b48:	cd b7       	in	r28, 0x3d	; 61
    5b4a:	de b7       	in	r29, 0x3e	; 62
    5b4c:	28 97       	sbiw	r28, 0x08	; 8
    5b4e:	0f b6       	in	r0, 0x3f	; 63
    5b50:	f8 94       	cli
    5b52:	de bf       	out	0x3e, r29	; 62
    5b54:	0f be       	out	0x3f, r0	; 63
    5b56:	cd bf       	out	0x3d, r28	; 61
    5b58:	9c 83       	std	Y+4, r25	; 0x04
    5b5a:	8b 83       	std	Y+3, r24	; 0x03
    5b5c:	7e 83       	std	Y+6, r23	; 0x06
    5b5e:	6d 83       	std	Y+5, r22	; 0x05
    5b60:	58 87       	std	Y+8, r21	; 0x08
    5b62:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5b64:	e0 91 97 06 	lds	r30, 0x0697
    5b68:	f0 91 98 06 	lds	r31, 0x0698
    5b6c:	8d 81       	ldd	r24, Y+5	; 0x05
    5b6e:	9e 81       	ldd	r25, Y+6	; 0x06
    5b70:	90 68       	ori	r25, 0x80	; 128
    5b72:	95 87       	std	Z+13, r25	; 0x0d
    5b74:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5b76:	80 91 97 06 	lds	r24, 0x0697
    5b7a:	90 91 98 06 	lds	r25, 0x0698
    5b7e:	9c 01       	movw	r18, r24
    5b80:	24 5f       	subi	r18, 0xF4	; 244
    5b82:	3f 4f       	sbci	r19, 0xFF	; 255
    5b84:	8b 81       	ldd	r24, Y+3	; 0x03
    5b86:	9c 81       	ldd	r25, Y+4	; 0x04
    5b88:	b9 01       	movw	r22, r18
    5b8a:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5b8e:	80 91 97 06 	lds	r24, 0x0697
    5b92:	90 91 98 06 	lds	r25, 0x0698
    5b96:	02 96       	adiw	r24, 0x02	; 2
    5b98:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    5b9c:	20 91 9b 06 	lds	r18, 0x069B
    5ba0:	30 91 9c 06 	lds	r19, 0x069C
    5ba4:	8f 81       	ldd	r24, Y+7	; 0x07
    5ba6:	98 85       	ldd	r25, Y+8	; 0x08
    5ba8:	82 0f       	add	r24, r18
    5baa:	93 1f       	adc	r25, r19
    5bac:	9a 83       	std	Y+2, r25	; 0x02
    5bae:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5bb0:	89 81       	ldd	r24, Y+1	; 0x01
    5bb2:	9a 81       	ldd	r25, Y+2	; 0x02
    5bb4:	0e 94 41 30 	call	0x6082	; 0x6082 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5bb8:	28 96       	adiw	r28, 0x08	; 8
    5bba:	0f b6       	in	r0, 0x3f	; 63
    5bbc:	f8 94       	cli
    5bbe:	de bf       	out	0x3e, r29	; 62
    5bc0:	0f be       	out	0x3f, r0	; 63
    5bc2:	cd bf       	out	0x3d, r28	; 61
    5bc4:	cf 91       	pop	r28
    5bc6:	df 91       	pop	r29
    5bc8:	08 95       	ret

00005bca <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    5bca:	df 93       	push	r29
    5bcc:	cf 93       	push	r28
    5bce:	00 d0       	rcall	.+0      	; 0x5bd0 <xTaskRemoveFromEventList+0x6>
    5bd0:	00 d0       	rcall	.+0      	; 0x5bd2 <xTaskRemoveFromEventList+0x8>
    5bd2:	0f 92       	push	r0
    5bd4:	cd b7       	in	r28, 0x3d	; 61
    5bd6:	de b7       	in	r29, 0x3e	; 62
    5bd8:	9d 83       	std	Y+5, r25	; 0x05
    5bda:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    5bdc:	ec 81       	ldd	r30, Y+4	; 0x04
    5bde:	fd 81       	ldd	r31, Y+5	; 0x05
    5be0:	05 80       	ldd	r0, Z+5	; 0x05
    5be2:	f6 81       	ldd	r31, Z+6	; 0x06
    5be4:	e0 2d       	mov	r30, r0
    5be6:	86 81       	ldd	r24, Z+6	; 0x06
    5be8:	97 81       	ldd	r25, Z+7	; 0x07
    5bea:	9b 83       	std	Y+3, r25	; 0x03
    5bec:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5bee:	8a 81       	ldd	r24, Y+2	; 0x02
    5bf0:	9b 81       	ldd	r25, Y+3	; 0x03
    5bf2:	0c 96       	adiw	r24, 0x0c	; 12
    5bf4:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5bf8:	80 91 a3 06 	lds	r24, 0x06A3
    5bfc:	88 23       	and	r24, r24
    5bfe:	61 f5       	brne	.+88     	; 0x5c58 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5c00:	8a 81       	ldd	r24, Y+2	; 0x02
    5c02:	9b 81       	ldd	r25, Y+3	; 0x03
    5c04:	02 96       	adiw	r24, 0x02	; 2
    5c06:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    5c0a:	ea 81       	ldd	r30, Y+2	; 0x02
    5c0c:	fb 81       	ldd	r31, Y+3	; 0x03
    5c0e:	96 89       	ldd	r25, Z+22	; 0x16
    5c10:	80 91 9d 06 	lds	r24, 0x069D
    5c14:	89 17       	cp	r24, r25
    5c16:	28 f4       	brcc	.+10     	; 0x5c22 <xTaskRemoveFromEventList+0x58>
    5c18:	ea 81       	ldd	r30, Y+2	; 0x02
    5c1a:	fb 81       	ldd	r31, Y+3	; 0x03
    5c1c:	86 89       	ldd	r24, Z+22	; 0x16
    5c1e:	80 93 9d 06 	sts	0x069D, r24
    5c22:	ea 81       	ldd	r30, Y+2	; 0x02
    5c24:	fb 81       	ldd	r31, Y+3	; 0x03
    5c26:	86 89       	ldd	r24, Z+22	; 0x16
    5c28:	28 2f       	mov	r18, r24
    5c2a:	30 e0       	ldi	r19, 0x00	; 0
    5c2c:	c9 01       	movw	r24, r18
    5c2e:	88 0f       	add	r24, r24
    5c30:	99 1f       	adc	r25, r25
    5c32:	88 0f       	add	r24, r24
    5c34:	99 1f       	adc	r25, r25
    5c36:	88 0f       	add	r24, r24
    5c38:	99 1f       	adc	r25, r25
    5c3a:	82 0f       	add	r24, r18
    5c3c:	93 1f       	adc	r25, r19
    5c3e:	ac 01       	movw	r20, r24
    5c40:	4c 55       	subi	r20, 0x5C	; 92
    5c42:	59 4f       	sbci	r21, 0xF9	; 249
    5c44:	8a 81       	ldd	r24, Y+2	; 0x02
    5c46:	9b 81       	ldd	r25, Y+3	; 0x03
    5c48:	9c 01       	movw	r18, r24
    5c4a:	2e 5f       	subi	r18, 0xFE	; 254
    5c4c:	3f 4f       	sbci	r19, 0xFF	; 255
    5c4e:	ca 01       	movw	r24, r20
    5c50:	b9 01       	movw	r22, r18
    5c52:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>
    5c56:	0a c0       	rjmp	.+20     	; 0x5c6c <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5c58:	8a 81       	ldd	r24, Y+2	; 0x02
    5c5a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c5c:	9c 01       	movw	r18, r24
    5c5e:	24 5f       	subi	r18, 0xF4	; 244
    5c60:	3f 4f       	sbci	r19, 0xFF	; 255
    5c62:	80 ef       	ldi	r24, 0xF0	; 240
    5c64:	96 e0       	ldi	r25, 0x06	; 6
    5c66:	b9 01       	movw	r22, r18
    5c68:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5c6c:	ea 81       	ldd	r30, Y+2	; 0x02
    5c6e:	fb 81       	ldd	r31, Y+3	; 0x03
    5c70:	96 89       	ldd	r25, Z+22	; 0x16
    5c72:	e0 91 97 06 	lds	r30, 0x0697
    5c76:	f0 91 98 06 	lds	r31, 0x0698
    5c7a:	86 89       	ldd	r24, Z+22	; 0x16
    5c7c:	89 17       	cp	r24, r25
    5c7e:	30 f4       	brcc	.+12     	; 0x5c8c <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    5c80:	81 e0       	ldi	r24, 0x01	; 1
    5c82:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5c84:	81 e0       	ldi	r24, 0x01	; 1
    5c86:	80 93 a0 06 	sts	0x06A0, r24
    5c8a:	01 c0       	rjmp	.+2      	; 0x5c8e <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    5c8c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5c8e:	89 81       	ldd	r24, Y+1	; 0x01
}
    5c90:	0f 90       	pop	r0
    5c92:	0f 90       	pop	r0
    5c94:	0f 90       	pop	r0
    5c96:	0f 90       	pop	r0
    5c98:	0f 90       	pop	r0
    5c9a:	cf 91       	pop	r28
    5c9c:	df 91       	pop	r29
    5c9e:	08 95       	ret

00005ca0 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    5ca0:	df 93       	push	r29
    5ca2:	cf 93       	push	r28
    5ca4:	cd b7       	in	r28, 0x3d	; 61
    5ca6:	de b7       	in	r29, 0x3e	; 62
    5ca8:	27 97       	sbiw	r28, 0x07	; 7
    5caa:	0f b6       	in	r0, 0x3f	; 63
    5cac:	f8 94       	cli
    5cae:	de bf       	out	0x3e, r29	; 62
    5cb0:	0f be       	out	0x3f, r0	; 63
    5cb2:	cd bf       	out	0x3d, r28	; 61
    5cb4:	9d 83       	std	Y+5, r25	; 0x05
    5cb6:	8c 83       	std	Y+4, r24	; 0x04
    5cb8:	7f 83       	std	Y+7, r23	; 0x07
    5cba:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5cbc:	8e 81       	ldd	r24, Y+6	; 0x06
    5cbe:	9f 81       	ldd	r25, Y+7	; 0x07
    5cc0:	90 68       	ori	r25, 0x80	; 128
    5cc2:	ec 81       	ldd	r30, Y+4	; 0x04
    5cc4:	fd 81       	ldd	r31, Y+5	; 0x05
    5cc6:	91 83       	std	Z+1, r25	; 0x01
    5cc8:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    5cca:	ec 81       	ldd	r30, Y+4	; 0x04
    5ccc:	fd 81       	ldd	r31, Y+5	; 0x05
    5cce:	86 81       	ldd	r24, Z+6	; 0x06
    5cd0:	97 81       	ldd	r25, Z+7	; 0x07
    5cd2:	9b 83       	std	Y+3, r25	; 0x03
    5cd4:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    5cd6:	8c 81       	ldd	r24, Y+4	; 0x04
    5cd8:	9d 81       	ldd	r25, Y+5	; 0x05
    5cda:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5cde:	8a 81       	ldd	r24, Y+2	; 0x02
    5ce0:	9b 81       	ldd	r25, Y+3	; 0x03
    5ce2:	02 96       	adiw	r24, 0x02	; 2
    5ce4:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    5ce8:	ea 81       	ldd	r30, Y+2	; 0x02
    5cea:	fb 81       	ldd	r31, Y+3	; 0x03
    5cec:	96 89       	ldd	r25, Z+22	; 0x16
    5cee:	80 91 9d 06 	lds	r24, 0x069D
    5cf2:	89 17       	cp	r24, r25
    5cf4:	28 f4       	brcc	.+10     	; 0x5d00 <xTaskRemoveFromUnorderedEventList+0x60>
    5cf6:	ea 81       	ldd	r30, Y+2	; 0x02
    5cf8:	fb 81       	ldd	r31, Y+3	; 0x03
    5cfa:	86 89       	ldd	r24, Z+22	; 0x16
    5cfc:	80 93 9d 06 	sts	0x069D, r24
    5d00:	ea 81       	ldd	r30, Y+2	; 0x02
    5d02:	fb 81       	ldd	r31, Y+3	; 0x03
    5d04:	86 89       	ldd	r24, Z+22	; 0x16
    5d06:	28 2f       	mov	r18, r24
    5d08:	30 e0       	ldi	r19, 0x00	; 0
    5d0a:	c9 01       	movw	r24, r18
    5d0c:	88 0f       	add	r24, r24
    5d0e:	99 1f       	adc	r25, r25
    5d10:	88 0f       	add	r24, r24
    5d12:	99 1f       	adc	r25, r25
    5d14:	88 0f       	add	r24, r24
    5d16:	99 1f       	adc	r25, r25
    5d18:	82 0f       	add	r24, r18
    5d1a:	93 1f       	adc	r25, r19
    5d1c:	ac 01       	movw	r20, r24
    5d1e:	4c 55       	subi	r20, 0x5C	; 92
    5d20:	59 4f       	sbci	r21, 0xF9	; 249
    5d22:	8a 81       	ldd	r24, Y+2	; 0x02
    5d24:	9b 81       	ldd	r25, Y+3	; 0x03
    5d26:	9c 01       	movw	r18, r24
    5d28:	2e 5f       	subi	r18, 0xFE	; 254
    5d2a:	3f 4f       	sbci	r19, 0xFF	; 255
    5d2c:	ca 01       	movw	r24, r20
    5d2e:	b9 01       	movw	r22, r18
    5d30:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5d34:	ea 81       	ldd	r30, Y+2	; 0x02
    5d36:	fb 81       	ldd	r31, Y+3	; 0x03
    5d38:	96 89       	ldd	r25, Z+22	; 0x16
    5d3a:	e0 91 97 06 	lds	r30, 0x0697
    5d3e:	f0 91 98 06 	lds	r31, 0x0698
    5d42:	86 89       	ldd	r24, Z+22	; 0x16
    5d44:	89 17       	cp	r24, r25
    5d46:	30 f4       	brcc	.+12     	; 0x5d54 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    5d48:	81 e0       	ldi	r24, 0x01	; 1
    5d4a:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5d4c:	81 e0       	ldi	r24, 0x01	; 1
    5d4e:	80 93 a0 06 	sts	0x06A0, r24
    5d52:	01 c0       	rjmp	.+2      	; 0x5d56 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    5d54:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5d56:	89 81       	ldd	r24, Y+1	; 0x01
}
    5d58:	27 96       	adiw	r28, 0x07	; 7
    5d5a:	0f b6       	in	r0, 0x3f	; 63
    5d5c:	f8 94       	cli
    5d5e:	de bf       	out	0x3e, r29	; 62
    5d60:	0f be       	out	0x3f, r0	; 63
    5d62:	cd bf       	out	0x3d, r28	; 61
    5d64:	cf 91       	pop	r28
    5d66:	df 91       	pop	r29
    5d68:	08 95       	ret

00005d6a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5d6a:	df 93       	push	r29
    5d6c:	cf 93       	push	r28
    5d6e:	00 d0       	rcall	.+0      	; 0x5d70 <vTaskSetTimeOutState+0x6>
    5d70:	cd b7       	in	r28, 0x3d	; 61
    5d72:	de b7       	in	r29, 0x3e	; 62
    5d74:	9a 83       	std	Y+2, r25	; 0x02
    5d76:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5d78:	80 91 a1 06 	lds	r24, 0x06A1
    5d7c:	e9 81       	ldd	r30, Y+1	; 0x01
    5d7e:	fa 81       	ldd	r31, Y+2	; 0x02
    5d80:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5d82:	80 91 9b 06 	lds	r24, 0x069B
    5d86:	90 91 9c 06 	lds	r25, 0x069C
    5d8a:	e9 81       	ldd	r30, Y+1	; 0x01
    5d8c:	fa 81       	ldd	r31, Y+2	; 0x02
    5d8e:	92 83       	std	Z+2, r25	; 0x02
    5d90:	81 83       	std	Z+1, r24	; 0x01
}
    5d92:	0f 90       	pop	r0
    5d94:	0f 90       	pop	r0
    5d96:	cf 91       	pop	r28
    5d98:	df 91       	pop	r29
    5d9a:	08 95       	ret

00005d9c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5d9c:	df 93       	push	r29
    5d9e:	cf 93       	push	r28
    5da0:	cd b7       	in	r28, 0x3d	; 61
    5da2:	de b7       	in	r29, 0x3e	; 62
    5da4:	27 97       	sbiw	r28, 0x07	; 7
    5da6:	0f b6       	in	r0, 0x3f	; 63
    5da8:	f8 94       	cli
    5daa:	de bf       	out	0x3e, r29	; 62
    5dac:	0f be       	out	0x3f, r0	; 63
    5dae:	cd bf       	out	0x3d, r28	; 61
    5db0:	9d 83       	std	Y+5, r25	; 0x05
    5db2:	8c 83       	std	Y+4, r24	; 0x04
    5db4:	7f 83       	std	Y+7, r23	; 0x07
    5db6:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5db8:	0f b6       	in	r0, 0x3f	; 63
    5dba:	f8 94       	cli
    5dbc:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5dbe:	80 91 9b 06 	lds	r24, 0x069B
    5dc2:	90 91 9c 06 	lds	r25, 0x069C
    5dc6:	9a 83       	std	Y+2, r25	; 0x02
    5dc8:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5dca:	ec 81       	ldd	r30, Y+4	; 0x04
    5dcc:	fd 81       	ldd	r31, Y+5	; 0x05
    5dce:	90 81       	ld	r25, Z
    5dd0:	80 91 a1 06 	lds	r24, 0x06A1
    5dd4:	98 17       	cp	r25, r24
    5dd6:	61 f0       	breq	.+24     	; 0x5df0 <xTaskCheckForTimeOut+0x54>
    5dd8:	ec 81       	ldd	r30, Y+4	; 0x04
    5dda:	fd 81       	ldd	r31, Y+5	; 0x05
    5ddc:	21 81       	ldd	r18, Z+1	; 0x01
    5dde:	32 81       	ldd	r19, Z+2	; 0x02
    5de0:	89 81       	ldd	r24, Y+1	; 0x01
    5de2:	9a 81       	ldd	r25, Y+2	; 0x02
    5de4:	82 17       	cp	r24, r18
    5de6:	93 07       	cpc	r25, r19
    5de8:	18 f0       	brcs	.+6      	; 0x5df0 <xTaskCheckForTimeOut+0x54>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    5dea:	81 e0       	ldi	r24, 0x01	; 1
    5dec:	8b 83       	std	Y+3, r24	; 0x03
    5dee:	2d c0       	rjmp	.+90     	; 0x5e4a <xTaskCheckForTimeOut+0xae>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    5df0:	ec 81       	ldd	r30, Y+4	; 0x04
    5df2:	fd 81       	ldd	r31, Y+5	; 0x05
    5df4:	21 81       	ldd	r18, Z+1	; 0x01
    5df6:	32 81       	ldd	r19, Z+2	; 0x02
    5df8:	89 81       	ldd	r24, Y+1	; 0x01
    5dfa:	9a 81       	ldd	r25, Y+2	; 0x02
    5dfc:	ac 01       	movw	r20, r24
    5dfe:	42 1b       	sub	r20, r18
    5e00:	53 0b       	sbc	r21, r19
    5e02:	9a 01       	movw	r18, r20
    5e04:	ee 81       	ldd	r30, Y+6	; 0x06
    5e06:	ff 81       	ldd	r31, Y+7	; 0x07
    5e08:	80 81       	ld	r24, Z
    5e0a:	91 81       	ldd	r25, Z+1	; 0x01
    5e0c:	28 17       	cp	r18, r24
    5e0e:	39 07       	cpc	r19, r25
    5e10:	d0 f4       	brcc	.+52     	; 0x5e46 <xTaskCheckForTimeOut+0xaa>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    5e12:	ee 81       	ldd	r30, Y+6	; 0x06
    5e14:	ff 81       	ldd	r31, Y+7	; 0x07
    5e16:	40 81       	ld	r20, Z
    5e18:	51 81       	ldd	r21, Z+1	; 0x01
    5e1a:	ec 81       	ldd	r30, Y+4	; 0x04
    5e1c:	fd 81       	ldd	r31, Y+5	; 0x05
    5e1e:	21 81       	ldd	r18, Z+1	; 0x01
    5e20:	32 81       	ldd	r19, Z+2	; 0x02
    5e22:	89 81       	ldd	r24, Y+1	; 0x01
    5e24:	9a 81       	ldd	r25, Y+2	; 0x02
    5e26:	b9 01       	movw	r22, r18
    5e28:	68 1b       	sub	r22, r24
    5e2a:	79 0b       	sbc	r23, r25
    5e2c:	cb 01       	movw	r24, r22
    5e2e:	84 0f       	add	r24, r20
    5e30:	95 1f       	adc	r25, r21
    5e32:	ee 81       	ldd	r30, Y+6	; 0x06
    5e34:	ff 81       	ldd	r31, Y+7	; 0x07
    5e36:	91 83       	std	Z+1, r25	; 0x01
    5e38:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    5e3a:	8c 81       	ldd	r24, Y+4	; 0x04
    5e3c:	9d 81       	ldd	r25, Y+5	; 0x05
    5e3e:	0e 94 b5 2e 	call	0x5d6a	; 0x5d6a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    5e42:	1b 82       	std	Y+3, r1	; 0x03
    5e44:	02 c0       	rjmp	.+4      	; 0x5e4a <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			xReturn = pdTRUE;
    5e46:	81 e0       	ldi	r24, 0x01	; 1
    5e48:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    5e4a:	0f 90       	pop	r0
    5e4c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5e4e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    5e50:	27 96       	adiw	r28, 0x07	; 7
    5e52:	0f b6       	in	r0, 0x3f	; 63
    5e54:	f8 94       	cli
    5e56:	de bf       	out	0x3e, r29	; 62
    5e58:	0f be       	out	0x3f, r0	; 63
    5e5a:	cd bf       	out	0x3d, r28	; 61
    5e5c:	cf 91       	pop	r28
    5e5e:	df 91       	pop	r29
    5e60:	08 95       	ret

00005e62 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5e62:	df 93       	push	r29
    5e64:	cf 93       	push	r28
    5e66:	cd b7       	in	r28, 0x3d	; 61
    5e68:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    5e6a:	81 e0       	ldi	r24, 0x01	; 1
    5e6c:	80 93 a0 06 	sts	0x06A0, r24
}
    5e70:	cf 91       	pop	r28
    5e72:	df 91       	pop	r29
    5e74:	08 95       	ret

00005e76 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5e76:	df 93       	push	r29
    5e78:	cf 93       	push	r28
    5e7a:	00 d0       	rcall	.+0      	; 0x5e7c <prvIdleTask+0x6>
    5e7c:	cd b7       	in	r28, 0x3d	; 61
    5e7e:	de b7       	in	r29, 0x3e	; 62
    5e80:	9a 83       	std	Y+2, r25	; 0x02
    5e82:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    5e84:	0e 94 02 30 	call	0x6004	; 0x6004 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5e88:	80 91 a4 06 	lds	r24, 0x06A4
    5e8c:	82 30       	cpi	r24, 0x02	; 2
    5e8e:	d0 f3       	brcs	.-12     	; 0x5e84 <prvIdleTask+0xe>
			{
				taskYIELD();
    5e90:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <vPortYield>
    5e94:	f7 cf       	rjmp	.-18     	; 0x5e84 <prvIdleTask+0xe>

00005e96 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    5e96:	0f 93       	push	r16
    5e98:	1f 93       	push	r17
    5e9a:	df 93       	push	r29
    5e9c:	cf 93       	push	r28
    5e9e:	cd b7       	in	r28, 0x3d	; 61
    5ea0:	de b7       	in	r29, 0x3e	; 62
    5ea2:	2a 97       	sbiw	r28, 0x0a	; 10
    5ea4:	0f b6       	in	r0, 0x3f	; 63
    5ea6:	f8 94       	cli
    5ea8:	de bf       	out	0x3e, r29	; 62
    5eaa:	0f be       	out	0x3f, r0	; 63
    5eac:	cd bf       	out	0x3d, r28	; 61
    5eae:	9b 83       	std	Y+3, r25	; 0x03
    5eb0:	8a 83       	std	Y+2, r24	; 0x02
    5eb2:	7d 83       	std	Y+5, r23	; 0x05
    5eb4:	6c 83       	std	Y+4, r22	; 0x04
    5eb6:	4e 83       	std	Y+6, r20	; 0x06
    5eb8:	38 87       	std	Y+8, r19	; 0x08
    5eba:	2f 83       	std	Y+7, r18	; 0x07
    5ebc:	1a 87       	std	Y+10, r17	; 0x0a
    5ebe:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5ec0:	19 82       	std	Y+1, r1	; 0x01
    5ec2:	21 c0       	rjmp	.+66     	; 0x5f06 <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    5ec4:	89 81       	ldd	r24, Y+1	; 0x01
    5ec6:	48 2f       	mov	r20, r24
    5ec8:	50 e0       	ldi	r21, 0x00	; 0
    5eca:	89 81       	ldd	r24, Y+1	; 0x01
    5ecc:	28 2f       	mov	r18, r24
    5ece:	30 e0       	ldi	r19, 0x00	; 0
    5ed0:	8c 81       	ldd	r24, Y+4	; 0x04
    5ed2:	9d 81       	ldd	r25, Y+5	; 0x05
    5ed4:	fc 01       	movw	r30, r24
    5ed6:	e2 0f       	add	r30, r18
    5ed8:	f3 1f       	adc	r31, r19
    5eda:	20 81       	ld	r18, Z
    5edc:	8a 81       	ldd	r24, Y+2	; 0x02
    5ede:	9b 81       	ldd	r25, Y+3	; 0x03
    5ee0:	84 0f       	add	r24, r20
    5ee2:	95 1f       	adc	r25, r21
    5ee4:	fc 01       	movw	r30, r24
    5ee6:	79 96       	adiw	r30, 0x19	; 25
    5ee8:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    5eea:	89 81       	ldd	r24, Y+1	; 0x01
    5eec:	28 2f       	mov	r18, r24
    5eee:	30 e0       	ldi	r19, 0x00	; 0
    5ef0:	8c 81       	ldd	r24, Y+4	; 0x04
    5ef2:	9d 81       	ldd	r25, Y+5	; 0x05
    5ef4:	fc 01       	movw	r30, r24
    5ef6:	e2 0f       	add	r30, r18
    5ef8:	f3 1f       	adc	r31, r19
    5efa:	80 81       	ld	r24, Z
    5efc:	88 23       	and	r24, r24
    5efe:	31 f0       	breq	.+12     	; 0x5f0c <prvInitialiseTCBVariables+0x76>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5f00:	89 81       	ldd	r24, Y+1	; 0x01
    5f02:	8f 5f       	subi	r24, 0xFF	; 255
    5f04:	89 83       	std	Y+1, r24	; 0x01
    5f06:	89 81       	ldd	r24, Y+1	; 0x01
    5f08:	84 31       	cpi	r24, 0x14	; 20
    5f0a:	e0 f2       	brcs	.-72     	; 0x5ec4 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    5f0c:	ea 81       	ldd	r30, Y+2	; 0x02
    5f0e:	fb 81       	ldd	r31, Y+3	; 0x03
    5f10:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    5f12:	8e 81       	ldd	r24, Y+6	; 0x06
    5f14:	86 30       	cpi	r24, 0x06	; 6
    5f16:	10 f0       	brcs	.+4      	; 0x5f1c <prvInitialiseTCBVariables+0x86>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    5f18:	85 e0       	ldi	r24, 0x05	; 5
    5f1a:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    5f1c:	ea 81       	ldd	r30, Y+2	; 0x02
    5f1e:	fb 81       	ldd	r31, Y+3	; 0x03
    5f20:	8e 81       	ldd	r24, Y+6	; 0x06
    5f22:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    5f24:	ea 81       	ldd	r30, Y+2	; 0x02
    5f26:	fb 81       	ldd	r31, Y+3	; 0x03
    5f28:	8e 81       	ldd	r24, Y+6	; 0x06
    5f2a:	85 a7       	std	Z+45, r24	; 0x2d
		pxTCB->uxMutexesHeld = 0;
    5f2c:	ea 81       	ldd	r30, Y+2	; 0x02
    5f2e:	fb 81       	ldd	r31, Y+3	; 0x03
    5f30:	16 a6       	std	Z+46, r1	; 0x2e
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    5f32:	8a 81       	ldd	r24, Y+2	; 0x02
    5f34:	9b 81       	ldd	r25, Y+3	; 0x03
    5f36:	02 96       	adiw	r24, 0x02	; 2
    5f38:	0e 94 08 1e 	call	0x3c10	; 0x3c10 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    5f3c:	8a 81       	ldd	r24, Y+2	; 0x02
    5f3e:	9b 81       	ldd	r25, Y+3	; 0x03
    5f40:	0c 96       	adiw	r24, 0x0c	; 12
    5f42:	0e 94 08 1e 	call	0x3c10	; 0x3c10 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    5f46:	ea 81       	ldd	r30, Y+2	; 0x02
    5f48:	fb 81       	ldd	r31, Y+3	; 0x03
    5f4a:	8a 81       	ldd	r24, Y+2	; 0x02
    5f4c:	9b 81       	ldd	r25, Y+3	; 0x03
    5f4e:	91 87       	std	Z+9, r25	; 0x09
    5f50:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5f52:	8e 81       	ldd	r24, Y+6	; 0x06
    5f54:	28 2f       	mov	r18, r24
    5f56:	30 e0       	ldi	r19, 0x00	; 0
    5f58:	86 e0       	ldi	r24, 0x06	; 6
    5f5a:	90 e0       	ldi	r25, 0x00	; 0
    5f5c:	82 1b       	sub	r24, r18
    5f5e:	93 0b       	sbc	r25, r19
    5f60:	ea 81       	ldd	r30, Y+2	; 0x02
    5f62:	fb 81       	ldd	r31, Y+3	; 0x03
    5f64:	95 87       	std	Z+13, r25	; 0x0d
    5f66:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    5f68:	ea 81       	ldd	r30, Y+2	; 0x02
    5f6a:	fb 81       	ldd	r31, Y+3	; 0x03
    5f6c:	8a 81       	ldd	r24, Y+2	; 0x02
    5f6e:	9b 81       	ldd	r25, Y+3	; 0x03
    5f70:	93 8b       	std	Z+19, r25	; 0x13
    5f72:	82 8b       	std	Z+18, r24	; 0x12
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    5f74:	2a 96       	adiw	r28, 0x0a	; 10
    5f76:	0f b6       	in	r0, 0x3f	; 63
    5f78:	f8 94       	cli
    5f7a:	de bf       	out	0x3e, r29	; 62
    5f7c:	0f be       	out	0x3f, r0	; 63
    5f7e:	cd bf       	out	0x3d, r28	; 61
    5f80:	cf 91       	pop	r28
    5f82:	df 91       	pop	r29
    5f84:	1f 91       	pop	r17
    5f86:	0f 91       	pop	r16
    5f88:	08 95       	ret

00005f8a <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5f8a:	df 93       	push	r29
    5f8c:	cf 93       	push	r28
    5f8e:	0f 92       	push	r0
    5f90:	cd b7       	in	r28, 0x3d	; 61
    5f92:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5f94:	19 82       	std	Y+1, r1	; 0x01
    5f96:	13 c0       	rjmp	.+38     	; 0x5fbe <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5f98:	89 81       	ldd	r24, Y+1	; 0x01
    5f9a:	28 2f       	mov	r18, r24
    5f9c:	30 e0       	ldi	r19, 0x00	; 0
    5f9e:	c9 01       	movw	r24, r18
    5fa0:	88 0f       	add	r24, r24
    5fa2:	99 1f       	adc	r25, r25
    5fa4:	88 0f       	add	r24, r24
    5fa6:	99 1f       	adc	r25, r25
    5fa8:	88 0f       	add	r24, r24
    5faa:	99 1f       	adc	r25, r25
    5fac:	82 0f       	add	r24, r18
    5fae:	93 1f       	adc	r25, r19
    5fb0:	8c 55       	subi	r24, 0x5C	; 92
    5fb2:	99 4f       	sbci	r25, 0xF9	; 249
    5fb4:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5fb8:	89 81       	ldd	r24, Y+1	; 0x01
    5fba:	8f 5f       	subi	r24, 0xFF	; 255
    5fbc:	89 83       	std	Y+1, r24	; 0x01
    5fbe:	89 81       	ldd	r24, Y+1	; 0x01
    5fc0:	86 30       	cpi	r24, 0x06	; 6
    5fc2:	50 f3       	brcs	.-44     	; 0x5f98 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5fc4:	8a ed       	ldi	r24, 0xDA	; 218
    5fc6:	96 e0       	ldi	r25, 0x06	; 6
    5fc8:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    5fcc:	83 ee       	ldi	r24, 0xE3	; 227
    5fce:	96 e0       	ldi	r25, 0x06	; 6
    5fd0:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>
	vListInitialise( &xPendingReadyList );
    5fd4:	80 ef       	ldi	r24, 0xF0	; 240
    5fd6:	96 e0       	ldi	r25, 0x06	; 6
    5fd8:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    5fdc:	89 ef       	ldi	r24, 0xF9	; 249
    5fde:	96 e0       	ldi	r25, 0x06	; 6
    5fe0:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5fe4:	8a ed       	ldi	r24, 0xDA	; 218
    5fe6:	96 e0       	ldi	r25, 0x06	; 6
    5fe8:	90 93 ed 06 	sts	0x06ED, r25
    5fec:	80 93 ec 06 	sts	0x06EC, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5ff0:	83 ee       	ldi	r24, 0xE3	; 227
    5ff2:	96 e0       	ldi	r25, 0x06	; 6
    5ff4:	90 93 ef 06 	sts	0x06EF, r25
    5ff8:	80 93 ee 06 	sts	0x06EE, r24
}
    5ffc:	0f 90       	pop	r0
    5ffe:	cf 91       	pop	r28
    6000:	df 91       	pop	r29
    6002:	08 95       	ret

00006004 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    6004:	df 93       	push	r29
    6006:	cf 93       	push	r28
    6008:	00 d0       	rcall	.+0      	; 0x600a <prvCheckTasksWaitingTermination+0x6>
    600a:	0f 92       	push	r0
    600c:	cd b7       	in	r28, 0x3d	; 61
    600e:	de b7       	in	r29, 0x3e	; 62
    6010:	2e c0       	rjmp	.+92     	; 0x606e <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    6012:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    6016:	80 91 f9 06 	lds	r24, 0x06F9
    601a:	1b 82       	std	Y+3, r1	; 0x03
    601c:	88 23       	and	r24, r24
    601e:	11 f4       	brne	.+4      	; 0x6024 <prvCheckTasksWaitingTermination+0x20>
    6020:	81 e0       	ldi	r24, 0x01	; 1
    6022:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    6024:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    6028:	8b 81       	ldd	r24, Y+3	; 0x03
    602a:	88 23       	and	r24, r24
    602c:	01 f5       	brne	.+64     	; 0x606e <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    602e:	0f b6       	in	r0, 0x3f	; 63
    6030:	f8 94       	cli
    6032:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    6034:	e0 91 fe 06 	lds	r30, 0x06FE
    6038:	f0 91 ff 06 	lds	r31, 0x06FF
    603c:	86 81       	ldd	r24, Z+6	; 0x06
    603e:	97 81       	ldd	r25, Z+7	; 0x07
    6040:	9a 83       	std	Y+2, r25	; 0x02
    6042:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    6044:	89 81       	ldd	r24, Y+1	; 0x01
    6046:	9a 81       	ldd	r25, Y+2	; 0x02
    6048:	02 96       	adiw	r24, 0x02	; 2
    604a:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
					--uxCurrentNumberOfTasks;
    604e:	80 91 9a 06 	lds	r24, 0x069A
    6052:	81 50       	subi	r24, 0x01	; 1
    6054:	80 93 9a 06 	sts	0x069A, r24
					--uxTasksDeleted;
    6058:	80 91 99 06 	lds	r24, 0x0699
    605c:	81 50       	subi	r24, 0x01	; 1
    605e:	80 93 99 06 	sts	0x0699, r24
				}
				taskEXIT_CRITICAL();
    6062:	0f 90       	pop	r0
    6064:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    6066:	89 81       	ldd	r24, Y+1	; 0x01
    6068:	9a 81       	ldd	r25, Y+2	; 0x02
    606a:	0e 94 ce 30 	call	0x619c	; 0x619c <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    606e:	80 91 99 06 	lds	r24, 0x0699
    6072:	88 23       	and	r24, r24
    6074:	71 f6       	brne	.-100    	; 0x6012 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    6076:	0f 90       	pop	r0
    6078:	0f 90       	pop	r0
    607a:	0f 90       	pop	r0
    607c:	cf 91       	pop	r28
    607e:	df 91       	pop	r29
    6080:	08 95       	ret

00006082 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    6082:	df 93       	push	r29
    6084:	cf 93       	push	r28
    6086:	00 d0       	rcall	.+0      	; 0x6088 <prvAddCurrentTaskToDelayedList+0x6>
    6088:	cd b7       	in	r28, 0x3d	; 61
    608a:	de b7       	in	r29, 0x3e	; 62
    608c:	9a 83       	std	Y+2, r25	; 0x02
    608e:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    6090:	e0 91 97 06 	lds	r30, 0x0697
    6094:	f0 91 98 06 	lds	r31, 0x0698
    6098:	89 81       	ldd	r24, Y+1	; 0x01
    609a:	9a 81       	ldd	r25, Y+2	; 0x02
    609c:	93 83       	std	Z+3, r25	; 0x03
    609e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    60a0:	20 91 9b 06 	lds	r18, 0x069B
    60a4:	30 91 9c 06 	lds	r19, 0x069C
    60a8:	89 81       	ldd	r24, Y+1	; 0x01
    60aa:	9a 81       	ldd	r25, Y+2	; 0x02
    60ac:	82 17       	cp	r24, r18
    60ae:	93 07       	cpc	r25, r19
    60b0:	70 f4       	brcc	.+28     	; 0x60ce <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    60b2:	80 91 ee 06 	lds	r24, 0x06EE
    60b6:	90 91 ef 06 	lds	r25, 0x06EF
    60ba:	20 91 97 06 	lds	r18, 0x0697
    60be:	30 91 98 06 	lds	r19, 0x0698
    60c2:	2e 5f       	subi	r18, 0xFE	; 254
    60c4:	3f 4f       	sbci	r19, 0xFF	; 255
    60c6:	b9 01       	movw	r22, r18
    60c8:	0e 94 5c 1e 	call	0x3cb8	; 0x3cb8 <vListInsert>
    60cc:	1e c0       	rjmp	.+60     	; 0x610a <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    60ce:	40 91 ec 06 	lds	r20, 0x06EC
    60d2:	50 91 ed 06 	lds	r21, 0x06ED
    60d6:	80 91 97 06 	lds	r24, 0x0697
    60da:	90 91 98 06 	lds	r25, 0x0698
    60de:	9c 01       	movw	r18, r24
    60e0:	2e 5f       	subi	r18, 0xFE	; 254
    60e2:	3f 4f       	sbci	r19, 0xFF	; 255
    60e4:	ca 01       	movw	r24, r20
    60e6:	b9 01       	movw	r22, r18
    60e8:	0e 94 5c 1e 	call	0x3cb8	; 0x3cb8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    60ec:	20 91 5f 01 	lds	r18, 0x015F
    60f0:	30 91 60 01 	lds	r19, 0x0160
    60f4:	89 81       	ldd	r24, Y+1	; 0x01
    60f6:	9a 81       	ldd	r25, Y+2	; 0x02
    60f8:	82 17       	cp	r24, r18
    60fa:	93 07       	cpc	r25, r19
    60fc:	30 f4       	brcc	.+12     	; 0x610a <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    60fe:	89 81       	ldd	r24, Y+1	; 0x01
    6100:	9a 81       	ldd	r25, Y+2	; 0x02
    6102:	90 93 60 01 	sts	0x0160, r25
    6106:	80 93 5f 01 	sts	0x015F, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    610a:	0f 90       	pop	r0
    610c:	0f 90       	pop	r0
    610e:	cf 91       	pop	r28
    6110:	df 91       	pop	r29
    6112:	08 95       	ret

00006114 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    6114:	df 93       	push	r29
    6116:	cf 93       	push	r28
    6118:	cd b7       	in	r28, 0x3d	; 61
    611a:	de b7       	in	r29, 0x3e	; 62
    611c:	28 97       	sbiw	r28, 0x08	; 8
    611e:	0f b6       	in	r0, 0x3f	; 63
    6120:	f8 94       	cli
    6122:	de bf       	out	0x3e, r29	; 62
    6124:	0f be       	out	0x3f, r0	; 63
    6126:	cd bf       	out	0x3d, r28	; 61
    6128:	9c 83       	std	Y+4, r25	; 0x04
    612a:	8b 83       	std	Y+3, r24	; 0x03
    612c:	7e 83       	std	Y+6, r23	; 0x06
    612e:	6d 83       	std	Y+5, r22	; 0x05
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    6130:	8f e2       	ldi	r24, 0x2F	; 47
    6132:	90 e0       	ldi	r25, 0x00	; 0
    6134:	0e 94 90 1c 	call	0x3920	; 0x3920 <pvPortMalloc>
    6138:	9a 83       	std	Y+2, r25	; 0x02
    613a:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    613c:	89 81       	ldd	r24, Y+1	; 0x01
    613e:	9a 81       	ldd	r25, Y+2	; 0x02
    6140:	00 97       	sbiw	r24, 0x00	; 0
    6142:	09 f1       	breq	.+66     	; 0x6186 <prvAllocateTCBAndStack+0x72>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6144:	8d 81       	ldd	r24, Y+5	; 0x05
    6146:	9e 81       	ldd	r25, Y+6	; 0x06
    6148:	00 97       	sbiw	r24, 0x00	; 0
    614a:	39 f4       	brne	.+14     	; 0x615a <prvAllocateTCBAndStack+0x46>
    614c:	8b 81       	ldd	r24, Y+3	; 0x03
    614e:	9c 81       	ldd	r25, Y+4	; 0x04
    6150:	0e 94 90 1c 	call	0x3920	; 0x3920 <pvPortMalloc>
    6154:	98 87       	std	Y+8, r25	; 0x08
    6156:	8f 83       	std	Y+7, r24	; 0x07
    6158:	04 c0       	rjmp	.+8      	; 0x6162 <prvAllocateTCBAndStack+0x4e>
    615a:	8d 81       	ldd	r24, Y+5	; 0x05
    615c:	9e 81       	ldd	r25, Y+6	; 0x06
    615e:	98 87       	std	Y+8, r25	; 0x08
    6160:	8f 83       	std	Y+7, r24	; 0x07
    6162:	e9 81       	ldd	r30, Y+1	; 0x01
    6164:	fa 81       	ldd	r31, Y+2	; 0x02
    6166:	8f 81       	ldd	r24, Y+7	; 0x07
    6168:	98 85       	ldd	r25, Y+8	; 0x08
    616a:	90 8f       	std	Z+24, r25	; 0x18
    616c:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    616e:	e9 81       	ldd	r30, Y+1	; 0x01
    6170:	fa 81       	ldd	r31, Y+2	; 0x02
    6172:	87 89       	ldd	r24, Z+23	; 0x17
    6174:	90 8d       	ldd	r25, Z+24	; 0x18
    6176:	00 97       	sbiw	r24, 0x00	; 0
    6178:	31 f4       	brne	.+12     	; 0x6186 <prvAllocateTCBAndStack+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    617a:	89 81       	ldd	r24, Y+1	; 0x01
    617c:	9a 81       	ldd	r25, Y+2	; 0x02
    617e:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <vPortFree>
			pxNewTCB = NULL;
    6182:	1a 82       	std	Y+2, r1	; 0x02
    6184:	19 82       	std	Y+1, r1	; 0x01
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
    6186:	89 81       	ldd	r24, Y+1	; 0x01
    6188:	9a 81       	ldd	r25, Y+2	; 0x02
}
    618a:	28 96       	adiw	r28, 0x08	; 8
    618c:	0f b6       	in	r0, 0x3f	; 63
    618e:	f8 94       	cli
    6190:	de bf       	out	0x3e, r29	; 62
    6192:	0f be       	out	0x3f, r0	; 63
    6194:	cd bf       	out	0x3d, r28	; 61
    6196:	cf 91       	pop	r28
    6198:	df 91       	pop	r29
    619a:	08 95       	ret

0000619c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    619c:	df 93       	push	r29
    619e:	cf 93       	push	r28
    61a0:	00 d0       	rcall	.+0      	; 0x61a2 <prvDeleteTCB+0x6>
    61a2:	cd b7       	in	r28, 0x3d	; 61
    61a4:	de b7       	in	r29, 0x3e	; 62
    61a6:	9a 83       	std	Y+2, r25	; 0x02
    61a8:	89 83       	std	Y+1, r24	; 0x01
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    61aa:	e9 81       	ldd	r30, Y+1	; 0x01
    61ac:	fa 81       	ldd	r31, Y+2	; 0x02
    61ae:	87 89       	ldd	r24, Z+23	; 0x17
    61b0:	90 8d       	ldd	r25, Z+24	; 0x18
    61b2:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <vPortFree>
		vPortFree( pxTCB );
    61b6:	89 81       	ldd	r24, Y+1	; 0x01
    61b8:	9a 81       	ldd	r25, Y+2	; 0x02
    61ba:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <vPortFree>
	}
    61be:	0f 90       	pop	r0
    61c0:	0f 90       	pop	r0
    61c2:	cf 91       	pop	r28
    61c4:	df 91       	pop	r29
    61c6:	08 95       	ret

000061c8 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    61c8:	df 93       	push	r29
    61ca:	cf 93       	push	r28
    61cc:	00 d0       	rcall	.+0      	; 0x61ce <prvResetNextTaskUnblockTime+0x6>
    61ce:	cd b7       	in	r28, 0x3d	; 61
    61d0:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    61d2:	e0 91 ec 06 	lds	r30, 0x06EC
    61d6:	f0 91 ed 06 	lds	r31, 0x06ED
    61da:	80 81       	ld	r24, Z
    61dc:	88 23       	and	r24, r24
    61de:	39 f4       	brne	.+14     	; 0x61ee <prvResetNextTaskUnblockTime+0x26>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    61e0:	8f ef       	ldi	r24, 0xFF	; 255
    61e2:	9f ef       	ldi	r25, 0xFF	; 255
    61e4:	90 93 60 01 	sts	0x0160, r25
    61e8:	80 93 5f 01 	sts	0x015F, r24
    61ec:	13 c0       	rjmp	.+38     	; 0x6214 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    61ee:	e0 91 ec 06 	lds	r30, 0x06EC
    61f2:	f0 91 ed 06 	lds	r31, 0x06ED
    61f6:	05 80       	ldd	r0, Z+5	; 0x05
    61f8:	f6 81       	ldd	r31, Z+6	; 0x06
    61fa:	e0 2d       	mov	r30, r0
    61fc:	86 81       	ldd	r24, Z+6	; 0x06
    61fe:	97 81       	ldd	r25, Z+7	; 0x07
    6200:	9a 83       	std	Y+2, r25	; 0x02
    6202:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    6204:	e9 81       	ldd	r30, Y+1	; 0x01
    6206:	fa 81       	ldd	r31, Y+2	; 0x02
    6208:	82 81       	ldd	r24, Z+2	; 0x02
    620a:	93 81       	ldd	r25, Z+3	; 0x03
    620c:	90 93 60 01 	sts	0x0160, r25
    6210:	80 93 5f 01 	sts	0x015F, r24
	}
}
    6214:	0f 90       	pop	r0
    6216:	0f 90       	pop	r0
    6218:	cf 91       	pop	r28
    621a:	df 91       	pop	r29
    621c:	08 95       	ret

0000621e <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    621e:	df 93       	push	r29
    6220:	cf 93       	push	r28
    6222:	00 d0       	rcall	.+0      	; 0x6224 <xTaskGetCurrentTaskHandle+0x6>
    6224:	cd b7       	in	r28, 0x3d	; 61
    6226:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    6228:	80 91 97 06 	lds	r24, 0x0697
    622c:	90 91 98 06 	lds	r25, 0x0698
    6230:	9a 83       	std	Y+2, r25	; 0x02
    6232:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    6234:	89 81       	ldd	r24, Y+1	; 0x01
    6236:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    6238:	0f 90       	pop	r0
    623a:	0f 90       	pop	r0
    623c:	cf 91       	pop	r28
    623e:	df 91       	pop	r29
    6240:	08 95       	ret

00006242 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    6242:	df 93       	push	r29
    6244:	cf 93       	push	r28
    6246:	00 d0       	rcall	.+0      	; 0x6248 <vTaskPriorityInherit+0x6>
    6248:	00 d0       	rcall	.+0      	; 0x624a <vTaskPriorityInherit+0x8>
    624a:	cd b7       	in	r28, 0x3d	; 61
    624c:	de b7       	in	r29, 0x3e	; 62
    624e:	9c 83       	std	Y+4, r25	; 0x04
    6250:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    6252:	8b 81       	ldd	r24, Y+3	; 0x03
    6254:	9c 81       	ldd	r25, Y+4	; 0x04
    6256:	9a 83       	std	Y+2, r25	; 0x02
    6258:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    625a:	8b 81       	ldd	r24, Y+3	; 0x03
    625c:	9c 81       	ldd	r25, Y+4	; 0x04
    625e:	00 97       	sbiw	r24, 0x00	; 0
    6260:	09 f4       	brne	.+2      	; 0x6264 <vTaskPriorityInherit+0x22>
    6262:	73 c0       	rjmp	.+230    	; 0x634a <vTaskPriorityInherit+0x108>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    6264:	e9 81       	ldd	r30, Y+1	; 0x01
    6266:	fa 81       	ldd	r31, Y+2	; 0x02
    6268:	96 89       	ldd	r25, Z+22	; 0x16
    626a:	e0 91 97 06 	lds	r30, 0x0697
    626e:	f0 91 98 06 	lds	r31, 0x0698
    6272:	86 89       	ldd	r24, Z+22	; 0x16
    6274:	98 17       	cp	r25, r24
    6276:	08 f0       	brcs	.+2      	; 0x627a <vTaskPriorityInherit+0x38>
    6278:	68 c0       	rjmp	.+208    	; 0x634a <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    627a:	e9 81       	ldd	r30, Y+1	; 0x01
    627c:	fa 81       	ldd	r31, Y+2	; 0x02
    627e:	84 85       	ldd	r24, Z+12	; 0x0c
    6280:	95 85       	ldd	r25, Z+13	; 0x0d
    6282:	99 23       	and	r25, r25
    6284:	7c f0       	brlt	.+30     	; 0x62a4 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6286:	e0 91 97 06 	lds	r30, 0x0697
    628a:	f0 91 98 06 	lds	r31, 0x0698
    628e:	86 89       	ldd	r24, Z+22	; 0x16
    6290:	28 2f       	mov	r18, r24
    6292:	30 e0       	ldi	r19, 0x00	; 0
    6294:	86 e0       	ldi	r24, 0x06	; 6
    6296:	90 e0       	ldi	r25, 0x00	; 0
    6298:	82 1b       	sub	r24, r18
    629a:	93 0b       	sbc	r25, r19
    629c:	e9 81       	ldd	r30, Y+1	; 0x01
    629e:	fa 81       	ldd	r31, Y+2	; 0x02
    62a0:	95 87       	std	Z+13, r25	; 0x0d
    62a2:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    62a4:	e9 81       	ldd	r30, Y+1	; 0x01
    62a6:	fa 81       	ldd	r31, Y+2	; 0x02
    62a8:	42 85       	ldd	r20, Z+10	; 0x0a
    62aa:	53 85       	ldd	r21, Z+11	; 0x0b
    62ac:	e9 81       	ldd	r30, Y+1	; 0x01
    62ae:	fa 81       	ldd	r31, Y+2	; 0x02
    62b0:	86 89       	ldd	r24, Z+22	; 0x16
    62b2:	28 2f       	mov	r18, r24
    62b4:	30 e0       	ldi	r19, 0x00	; 0
    62b6:	c9 01       	movw	r24, r18
    62b8:	88 0f       	add	r24, r24
    62ba:	99 1f       	adc	r25, r25
    62bc:	88 0f       	add	r24, r24
    62be:	99 1f       	adc	r25, r25
    62c0:	88 0f       	add	r24, r24
    62c2:	99 1f       	adc	r25, r25
    62c4:	82 0f       	add	r24, r18
    62c6:	93 1f       	adc	r25, r19
    62c8:	8c 55       	subi	r24, 0x5C	; 92
    62ca:	99 4f       	sbci	r25, 0xF9	; 249
    62cc:	48 17       	cp	r20, r24
    62ce:	59 07       	cpc	r21, r25
    62d0:	a1 f5       	brne	.+104    	; 0x633a <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    62d2:	89 81       	ldd	r24, Y+1	; 0x01
    62d4:	9a 81       	ldd	r25, Y+2	; 0x02
    62d6:	02 96       	adiw	r24, 0x02	; 2
    62d8:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    62dc:	e0 91 97 06 	lds	r30, 0x0697
    62e0:	f0 91 98 06 	lds	r31, 0x0698
    62e4:	86 89       	ldd	r24, Z+22	; 0x16
    62e6:	e9 81       	ldd	r30, Y+1	; 0x01
    62e8:	fa 81       	ldd	r31, Y+2	; 0x02
    62ea:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    62ec:	e9 81       	ldd	r30, Y+1	; 0x01
    62ee:	fa 81       	ldd	r31, Y+2	; 0x02
    62f0:	96 89       	ldd	r25, Z+22	; 0x16
    62f2:	80 91 9d 06 	lds	r24, 0x069D
    62f6:	89 17       	cp	r24, r25
    62f8:	28 f4       	brcc	.+10     	; 0x6304 <vTaskPriorityInherit+0xc2>
    62fa:	e9 81       	ldd	r30, Y+1	; 0x01
    62fc:	fa 81       	ldd	r31, Y+2	; 0x02
    62fe:	86 89       	ldd	r24, Z+22	; 0x16
    6300:	80 93 9d 06 	sts	0x069D, r24
    6304:	e9 81       	ldd	r30, Y+1	; 0x01
    6306:	fa 81       	ldd	r31, Y+2	; 0x02
    6308:	86 89       	ldd	r24, Z+22	; 0x16
    630a:	28 2f       	mov	r18, r24
    630c:	30 e0       	ldi	r19, 0x00	; 0
    630e:	c9 01       	movw	r24, r18
    6310:	88 0f       	add	r24, r24
    6312:	99 1f       	adc	r25, r25
    6314:	88 0f       	add	r24, r24
    6316:	99 1f       	adc	r25, r25
    6318:	88 0f       	add	r24, r24
    631a:	99 1f       	adc	r25, r25
    631c:	82 0f       	add	r24, r18
    631e:	93 1f       	adc	r25, r19
    6320:	ac 01       	movw	r20, r24
    6322:	4c 55       	subi	r20, 0x5C	; 92
    6324:	59 4f       	sbci	r21, 0xF9	; 249
    6326:	89 81       	ldd	r24, Y+1	; 0x01
    6328:	9a 81       	ldd	r25, Y+2	; 0x02
    632a:	9c 01       	movw	r18, r24
    632c:	2e 5f       	subi	r18, 0xFE	; 254
    632e:	3f 4f       	sbci	r19, 0xFF	; 255
    6330:	ca 01       	movw	r24, r20
    6332:	b9 01       	movw	r22, r18
    6334:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>
    6338:	08 c0       	rjmp	.+16     	; 0x634a <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    633a:	e0 91 97 06 	lds	r30, 0x0697
    633e:	f0 91 98 06 	lds	r31, 0x0698
    6342:	86 89       	ldd	r24, Z+22	; 0x16
    6344:	e9 81       	ldd	r30, Y+1	; 0x01
    6346:	fa 81       	ldd	r31, Y+2	; 0x02
    6348:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    634a:	0f 90       	pop	r0
    634c:	0f 90       	pop	r0
    634e:	0f 90       	pop	r0
    6350:	0f 90       	pop	r0
    6352:	cf 91       	pop	r28
    6354:	df 91       	pop	r29
    6356:	08 95       	ret

00006358 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    6358:	df 93       	push	r29
    635a:	cf 93       	push	r28
    635c:	00 d0       	rcall	.+0      	; 0x635e <xTaskPriorityDisinherit+0x6>
    635e:	00 d0       	rcall	.+0      	; 0x6360 <xTaskPriorityDisinherit+0x8>
    6360:	0f 92       	push	r0
    6362:	cd b7       	in	r28, 0x3d	; 61
    6364:	de b7       	in	r29, 0x3e	; 62
    6366:	9d 83       	std	Y+5, r25	; 0x05
    6368:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    636a:	8c 81       	ldd	r24, Y+4	; 0x04
    636c:	9d 81       	ldd	r25, Y+5	; 0x05
    636e:	9b 83       	std	Y+3, r25	; 0x03
    6370:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    6372:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    6374:	8c 81       	ldd	r24, Y+4	; 0x04
    6376:	9d 81       	ldd	r25, Y+5	; 0x05
    6378:	00 97       	sbiw	r24, 0x00	; 0
    637a:	09 f4       	brne	.+2      	; 0x637e <xTaskPriorityDisinherit+0x26>
    637c:	56 c0       	rjmp	.+172    	; 0x642a <xTaskPriorityDisinherit+0xd2>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    637e:	ea 81       	ldd	r30, Y+2	; 0x02
    6380:	fb 81       	ldd	r31, Y+3	; 0x03
    6382:	86 a5       	ldd	r24, Z+46	; 0x2e
    6384:	81 50       	subi	r24, 0x01	; 1
    6386:	ea 81       	ldd	r30, Y+2	; 0x02
    6388:	fb 81       	ldd	r31, Y+3	; 0x03
    638a:	86 a7       	std	Z+46, r24	; 0x2e

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    638c:	ea 81       	ldd	r30, Y+2	; 0x02
    638e:	fb 81       	ldd	r31, Y+3	; 0x03
    6390:	96 89       	ldd	r25, Z+22	; 0x16
    6392:	ea 81       	ldd	r30, Y+2	; 0x02
    6394:	fb 81       	ldd	r31, Y+3	; 0x03
    6396:	85 a5       	ldd	r24, Z+45	; 0x2d
    6398:	98 17       	cp	r25, r24
    639a:	09 f4       	brne	.+2      	; 0x639e <xTaskPriorityDisinherit+0x46>
    639c:	46 c0       	rjmp	.+140    	; 0x642a <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    639e:	ea 81       	ldd	r30, Y+2	; 0x02
    63a0:	fb 81       	ldd	r31, Y+3	; 0x03
    63a2:	86 a5       	ldd	r24, Z+46	; 0x2e
    63a4:	88 23       	and	r24, r24
    63a6:	09 f0       	breq	.+2      	; 0x63aa <xTaskPriorityDisinherit+0x52>
    63a8:	40 c0       	rjmp	.+128    	; 0x642a <xTaskPriorityDisinherit+0xd2>
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    63aa:	8a 81       	ldd	r24, Y+2	; 0x02
    63ac:	9b 81       	ldd	r25, Y+3	; 0x03
    63ae:	02 96       	adiw	r24, 0x02	; 2
    63b0:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    63b4:	ea 81       	ldd	r30, Y+2	; 0x02
    63b6:	fb 81       	ldd	r31, Y+3	; 0x03
    63b8:	85 a5       	ldd	r24, Z+45	; 0x2d
    63ba:	ea 81       	ldd	r30, Y+2	; 0x02
    63bc:	fb 81       	ldd	r31, Y+3	; 0x03
    63be:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    63c0:	ea 81       	ldd	r30, Y+2	; 0x02
    63c2:	fb 81       	ldd	r31, Y+3	; 0x03
    63c4:	86 89       	ldd	r24, Z+22	; 0x16
    63c6:	28 2f       	mov	r18, r24
    63c8:	30 e0       	ldi	r19, 0x00	; 0
    63ca:	86 e0       	ldi	r24, 0x06	; 6
    63cc:	90 e0       	ldi	r25, 0x00	; 0
    63ce:	82 1b       	sub	r24, r18
    63d0:	93 0b       	sbc	r25, r19
    63d2:	ea 81       	ldd	r30, Y+2	; 0x02
    63d4:	fb 81       	ldd	r31, Y+3	; 0x03
    63d6:	95 87       	std	Z+13, r25	; 0x0d
    63d8:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    63da:	ea 81       	ldd	r30, Y+2	; 0x02
    63dc:	fb 81       	ldd	r31, Y+3	; 0x03
    63de:	96 89       	ldd	r25, Z+22	; 0x16
    63e0:	80 91 9d 06 	lds	r24, 0x069D
    63e4:	89 17       	cp	r24, r25
    63e6:	28 f4       	brcc	.+10     	; 0x63f2 <xTaskPriorityDisinherit+0x9a>
    63e8:	ea 81       	ldd	r30, Y+2	; 0x02
    63ea:	fb 81       	ldd	r31, Y+3	; 0x03
    63ec:	86 89       	ldd	r24, Z+22	; 0x16
    63ee:	80 93 9d 06 	sts	0x069D, r24
    63f2:	ea 81       	ldd	r30, Y+2	; 0x02
    63f4:	fb 81       	ldd	r31, Y+3	; 0x03
    63f6:	86 89       	ldd	r24, Z+22	; 0x16
    63f8:	28 2f       	mov	r18, r24
    63fa:	30 e0       	ldi	r19, 0x00	; 0
    63fc:	c9 01       	movw	r24, r18
    63fe:	88 0f       	add	r24, r24
    6400:	99 1f       	adc	r25, r25
    6402:	88 0f       	add	r24, r24
    6404:	99 1f       	adc	r25, r25
    6406:	88 0f       	add	r24, r24
    6408:	99 1f       	adc	r25, r25
    640a:	82 0f       	add	r24, r18
    640c:	93 1f       	adc	r25, r19
    640e:	ac 01       	movw	r20, r24
    6410:	4c 55       	subi	r20, 0x5C	; 92
    6412:	59 4f       	sbci	r21, 0xF9	; 249
    6414:	8a 81       	ldd	r24, Y+2	; 0x02
    6416:	9b 81       	ldd	r25, Y+3	; 0x03
    6418:	9c 01       	movw	r18, r24
    641a:	2e 5f       	subi	r18, 0xFE	; 254
    641c:	3f 4f       	sbci	r19, 0xFF	; 255
    641e:	ca 01       	movw	r24, r20
    6420:	b9 01       	movw	r22, r18
    6422:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    6426:	81 e0       	ldi	r24, 0x01	; 1
    6428:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    642a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    642c:	0f 90       	pop	r0
    642e:	0f 90       	pop	r0
    6430:	0f 90       	pop	r0
    6432:	0f 90       	pop	r0
    6434:	0f 90       	pop	r0
    6436:	cf 91       	pop	r28
    6438:	df 91       	pop	r29
    643a:	08 95       	ret

0000643c <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    643c:	df 93       	push	r29
    643e:	cf 93       	push	r28
    6440:	00 d0       	rcall	.+0      	; 0x6442 <uxTaskResetEventItemValue+0x6>
    6442:	cd b7       	in	r28, 0x3d	; 61
    6444:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    6446:	e0 91 97 06 	lds	r30, 0x0697
    644a:	f0 91 98 06 	lds	r31, 0x0698
    644e:	84 85       	ldd	r24, Z+12	; 0x0c
    6450:	95 85       	ldd	r25, Z+13	; 0x0d
    6452:	9a 83       	std	Y+2, r25	; 0x02
    6454:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6456:	a0 91 97 06 	lds	r26, 0x0697
    645a:	b0 91 98 06 	lds	r27, 0x0698
    645e:	e0 91 97 06 	lds	r30, 0x0697
    6462:	f0 91 98 06 	lds	r31, 0x0698
    6466:	86 89       	ldd	r24, Z+22	; 0x16
    6468:	28 2f       	mov	r18, r24
    646a:	30 e0       	ldi	r19, 0x00	; 0
    646c:	86 e0       	ldi	r24, 0x06	; 6
    646e:	90 e0       	ldi	r25, 0x00	; 0
    6470:	82 1b       	sub	r24, r18
    6472:	93 0b       	sbc	r25, r19
    6474:	1d 96       	adiw	r26, 0x0d	; 13
    6476:	9c 93       	st	X, r25
    6478:	8e 93       	st	-X, r24
    647a:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    647c:	89 81       	ldd	r24, Y+1	; 0x01
    647e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6480:	0f 90       	pop	r0
    6482:	0f 90       	pop	r0
    6484:	cf 91       	pop	r28
    6486:	df 91       	pop	r29
    6488:	08 95       	ret

0000648a <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    648a:	df 93       	push	r29
    648c:	cf 93       	push	r28
    648e:	cd b7       	in	r28, 0x3d	; 61
    6490:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    6492:	80 91 97 06 	lds	r24, 0x0697
    6496:	90 91 98 06 	lds	r25, 0x0698
    649a:	00 97       	sbiw	r24, 0x00	; 0
    649c:	39 f0       	breq	.+14     	; 0x64ac <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    649e:	e0 91 97 06 	lds	r30, 0x0697
    64a2:	f0 91 98 06 	lds	r31, 0x0698
    64a6:	86 a5       	ldd	r24, Z+46	; 0x2e
    64a8:	8f 5f       	subi	r24, 0xFF	; 255
    64aa:	86 a7       	std	Z+46, r24	; 0x2e
		}

		return pxCurrentTCB;
    64ac:	80 91 97 06 	lds	r24, 0x0697
    64b0:	90 91 98 06 	lds	r25, 0x0698
	}
    64b4:	cf 91       	pop	r28
    64b6:	df 91       	pop	r29
    64b8:	08 95       	ret

000064ba <__mulsi3>:
    64ba:	62 9f       	mul	r22, r18
    64bc:	d0 01       	movw	r26, r0
    64be:	73 9f       	mul	r23, r19
    64c0:	f0 01       	movw	r30, r0
    64c2:	82 9f       	mul	r24, r18
    64c4:	e0 0d       	add	r30, r0
    64c6:	f1 1d       	adc	r31, r1
    64c8:	64 9f       	mul	r22, r20
    64ca:	e0 0d       	add	r30, r0
    64cc:	f1 1d       	adc	r31, r1
    64ce:	92 9f       	mul	r25, r18
    64d0:	f0 0d       	add	r31, r0
    64d2:	83 9f       	mul	r24, r19
    64d4:	f0 0d       	add	r31, r0
    64d6:	74 9f       	mul	r23, r20
    64d8:	f0 0d       	add	r31, r0
    64da:	65 9f       	mul	r22, r21
    64dc:	f0 0d       	add	r31, r0
    64de:	99 27       	eor	r25, r25
    64e0:	72 9f       	mul	r23, r18
    64e2:	b0 0d       	add	r27, r0
    64e4:	e1 1d       	adc	r30, r1
    64e6:	f9 1f       	adc	r31, r25
    64e8:	63 9f       	mul	r22, r19
    64ea:	b0 0d       	add	r27, r0
    64ec:	e1 1d       	adc	r30, r1
    64ee:	f9 1f       	adc	r31, r25
    64f0:	bd 01       	movw	r22, r26
    64f2:	cf 01       	movw	r24, r30
    64f4:	11 24       	eor	r1, r1
    64f6:	08 95       	ret

000064f8 <__udivmodhi4>:
    64f8:	aa 1b       	sub	r26, r26
    64fa:	bb 1b       	sub	r27, r27
    64fc:	51 e1       	ldi	r21, 0x11	; 17
    64fe:	07 c0       	rjmp	.+14     	; 0x650e <__udivmodhi4_ep>

00006500 <__udivmodhi4_loop>:
    6500:	aa 1f       	adc	r26, r26
    6502:	bb 1f       	adc	r27, r27
    6504:	a6 17       	cp	r26, r22
    6506:	b7 07       	cpc	r27, r23
    6508:	10 f0       	brcs	.+4      	; 0x650e <__udivmodhi4_ep>
    650a:	a6 1b       	sub	r26, r22
    650c:	b7 0b       	sbc	r27, r23

0000650e <__udivmodhi4_ep>:
    650e:	88 1f       	adc	r24, r24
    6510:	99 1f       	adc	r25, r25
    6512:	5a 95       	dec	r21
    6514:	a9 f7       	brne	.-22     	; 0x6500 <__udivmodhi4_loop>
    6516:	80 95       	com	r24
    6518:	90 95       	com	r25
    651a:	bc 01       	movw	r22, r24
    651c:	cd 01       	movw	r24, r26
    651e:	08 95       	ret

00006520 <__udivmodsi4>:
    6520:	a1 e2       	ldi	r26, 0x21	; 33
    6522:	1a 2e       	mov	r1, r26
    6524:	aa 1b       	sub	r26, r26
    6526:	bb 1b       	sub	r27, r27
    6528:	fd 01       	movw	r30, r26
    652a:	0d c0       	rjmp	.+26     	; 0x6546 <__udivmodsi4_ep>

0000652c <__udivmodsi4_loop>:
    652c:	aa 1f       	adc	r26, r26
    652e:	bb 1f       	adc	r27, r27
    6530:	ee 1f       	adc	r30, r30
    6532:	ff 1f       	adc	r31, r31
    6534:	a2 17       	cp	r26, r18
    6536:	b3 07       	cpc	r27, r19
    6538:	e4 07       	cpc	r30, r20
    653a:	f5 07       	cpc	r31, r21
    653c:	20 f0       	brcs	.+8      	; 0x6546 <__udivmodsi4_ep>
    653e:	a2 1b       	sub	r26, r18
    6540:	b3 0b       	sbc	r27, r19
    6542:	e4 0b       	sbc	r30, r20
    6544:	f5 0b       	sbc	r31, r21

00006546 <__udivmodsi4_ep>:
    6546:	66 1f       	adc	r22, r22
    6548:	77 1f       	adc	r23, r23
    654a:	88 1f       	adc	r24, r24
    654c:	99 1f       	adc	r25, r25
    654e:	1a 94       	dec	r1
    6550:	69 f7       	brne	.-38     	; 0x652c <__udivmodsi4_loop>
    6552:	60 95       	com	r22
    6554:	70 95       	com	r23
    6556:	80 95       	com	r24
    6558:	90 95       	com	r25
    655a:	9b 01       	movw	r18, r22
    655c:	ac 01       	movw	r20, r24
    655e:	bd 01       	movw	r22, r26
    6560:	cf 01       	movw	r24, r30
    6562:	08 95       	ret

00006564 <__divmodsi4>:
    6564:	97 fb       	bst	r25, 7
    6566:	09 2e       	mov	r0, r25
    6568:	05 26       	eor	r0, r21
    656a:	0e d0       	rcall	.+28     	; 0x6588 <__divmodsi4_neg1>
    656c:	57 fd       	sbrc	r21, 7
    656e:	04 d0       	rcall	.+8      	; 0x6578 <__divmodsi4_neg2>
    6570:	d7 df       	rcall	.-82     	; 0x6520 <__udivmodsi4>
    6572:	0a d0       	rcall	.+20     	; 0x6588 <__divmodsi4_neg1>
    6574:	00 1c       	adc	r0, r0
    6576:	38 f4       	brcc	.+14     	; 0x6586 <__divmodsi4_exit>

00006578 <__divmodsi4_neg2>:
    6578:	50 95       	com	r21
    657a:	40 95       	com	r20
    657c:	30 95       	com	r19
    657e:	21 95       	neg	r18
    6580:	3f 4f       	sbci	r19, 0xFF	; 255
    6582:	4f 4f       	sbci	r20, 0xFF	; 255
    6584:	5f 4f       	sbci	r21, 0xFF	; 255

00006586 <__divmodsi4_exit>:
    6586:	08 95       	ret

00006588 <__divmodsi4_neg1>:
    6588:	f6 f7       	brtc	.-4      	; 0x6586 <__divmodsi4_exit>
    658a:	90 95       	com	r25
    658c:	80 95       	com	r24
    658e:	70 95       	com	r23
    6590:	61 95       	neg	r22
    6592:	7f 4f       	sbci	r23, 0xFF	; 255
    6594:	8f 4f       	sbci	r24, 0xFF	; 255
    6596:	9f 4f       	sbci	r25, 0xFF	; 255
    6598:	08 95       	ret

0000659a <__prologue_saves__>:
    659a:	2f 92       	push	r2
    659c:	3f 92       	push	r3
    659e:	4f 92       	push	r4
    65a0:	5f 92       	push	r5
    65a2:	6f 92       	push	r6
    65a4:	7f 92       	push	r7
    65a6:	8f 92       	push	r8
    65a8:	9f 92       	push	r9
    65aa:	af 92       	push	r10
    65ac:	bf 92       	push	r11
    65ae:	cf 92       	push	r12
    65b0:	df 92       	push	r13
    65b2:	ef 92       	push	r14
    65b4:	ff 92       	push	r15
    65b6:	0f 93       	push	r16
    65b8:	1f 93       	push	r17
    65ba:	cf 93       	push	r28
    65bc:	df 93       	push	r29
    65be:	cd b7       	in	r28, 0x3d	; 61
    65c0:	de b7       	in	r29, 0x3e	; 62
    65c2:	ca 1b       	sub	r28, r26
    65c4:	db 0b       	sbc	r29, r27
    65c6:	0f b6       	in	r0, 0x3f	; 63
    65c8:	f8 94       	cli
    65ca:	de bf       	out	0x3e, r29	; 62
    65cc:	0f be       	out	0x3f, r0	; 63
    65ce:	cd bf       	out	0x3d, r28	; 61
    65d0:	09 94       	ijmp

000065d2 <__epilogue_restores__>:
    65d2:	2a 88       	ldd	r2, Y+18	; 0x12
    65d4:	39 88       	ldd	r3, Y+17	; 0x11
    65d6:	48 88       	ldd	r4, Y+16	; 0x10
    65d8:	5f 84       	ldd	r5, Y+15	; 0x0f
    65da:	6e 84       	ldd	r6, Y+14	; 0x0e
    65dc:	7d 84       	ldd	r7, Y+13	; 0x0d
    65de:	8c 84       	ldd	r8, Y+12	; 0x0c
    65e0:	9b 84       	ldd	r9, Y+11	; 0x0b
    65e2:	aa 84       	ldd	r10, Y+10	; 0x0a
    65e4:	b9 84       	ldd	r11, Y+9	; 0x09
    65e6:	c8 84       	ldd	r12, Y+8	; 0x08
    65e8:	df 80       	ldd	r13, Y+7	; 0x07
    65ea:	ee 80       	ldd	r14, Y+6	; 0x06
    65ec:	fd 80       	ldd	r15, Y+5	; 0x05
    65ee:	0c 81       	ldd	r16, Y+4	; 0x04
    65f0:	1b 81       	ldd	r17, Y+3	; 0x03
    65f2:	aa 81       	ldd	r26, Y+2	; 0x02
    65f4:	b9 81       	ldd	r27, Y+1	; 0x01
    65f6:	ce 0f       	add	r28, r30
    65f8:	d1 1d       	adc	r29, r1
    65fa:	0f b6       	in	r0, 0x3f	; 63
    65fc:	f8 94       	cli
    65fe:	de bf       	out	0x3e, r29	; 62
    6600:	0f be       	out	0x3f, r0	; 63
    6602:	cd bf       	out	0x3d, r28	; 61
    6604:	ed 01       	movw	r28, r26
    6606:	08 95       	ret

00006608 <atoi>:
    6608:	fc 01       	movw	r30, r24
    660a:	88 27       	eor	r24, r24
    660c:	99 27       	eor	r25, r25
    660e:	e8 94       	clt
    6610:	21 91       	ld	r18, Z+
    6612:	20 32       	cpi	r18, 0x20	; 32
    6614:	e9 f3       	breq	.-6      	; 0x6610 <atoi+0x8>
    6616:	29 30       	cpi	r18, 0x09	; 9
    6618:	10 f0       	brcs	.+4      	; 0x661e <atoi+0x16>
    661a:	2e 30       	cpi	r18, 0x0E	; 14
    661c:	c8 f3       	brcs	.-14     	; 0x6610 <atoi+0x8>
    661e:	2b 32       	cpi	r18, 0x2B	; 43
    6620:	41 f0       	breq	.+16     	; 0x6632 <atoi+0x2a>
    6622:	2d 32       	cpi	r18, 0x2D	; 45
    6624:	39 f4       	brne	.+14     	; 0x6634 <atoi+0x2c>
    6626:	68 94       	set
    6628:	04 c0       	rjmp	.+8      	; 0x6632 <atoi+0x2a>
    662a:	0e 94 32 33 	call	0x6664	; 0x6664 <__mulhi_const_10>
    662e:	82 0f       	add	r24, r18
    6630:	91 1d       	adc	r25, r1
    6632:	21 91       	ld	r18, Z+
    6634:	20 53       	subi	r18, 0x30	; 48
    6636:	2a 30       	cpi	r18, 0x0A	; 10
    6638:	c0 f3       	brcs	.-16     	; 0x662a <atoi+0x22>
    663a:	1e f4       	brtc	.+6      	; 0x6642 <atoi+0x3a>
    663c:	90 95       	com	r25
    663e:	81 95       	neg	r24
    6640:	9f 4f       	sbci	r25, 0xFF	; 255
    6642:	08 95       	ret

00006644 <memcpy>:
    6644:	fb 01       	movw	r30, r22
    6646:	dc 01       	movw	r26, r24
    6648:	02 c0       	rjmp	.+4      	; 0x664e <memcpy+0xa>
    664a:	01 90       	ld	r0, Z+
    664c:	0d 92       	st	X+, r0
    664e:	41 50       	subi	r20, 0x01	; 1
    6650:	50 40       	sbci	r21, 0x00	; 0
    6652:	d8 f7       	brcc	.-10     	; 0x664a <memcpy+0x6>
    6654:	08 95       	ret

00006656 <memset>:
    6656:	dc 01       	movw	r26, r24
    6658:	01 c0       	rjmp	.+2      	; 0x665c <memset+0x6>
    665a:	6d 93       	st	X+, r22
    665c:	41 50       	subi	r20, 0x01	; 1
    665e:	50 40       	sbci	r21, 0x00	; 0
    6660:	e0 f7       	brcc	.-8      	; 0x665a <memset+0x4>
    6662:	08 95       	ret

00006664 <__mulhi_const_10>:
    6664:	7a e0       	ldi	r23, 0x0A	; 10
    6666:	97 9f       	mul	r25, r23
    6668:	90 2d       	mov	r25, r0
    666a:	87 9f       	mul	r24, r23
    666c:	80 2d       	mov	r24, r0
    666e:	91 0d       	add	r25, r1
    6670:	11 24       	eor	r1, r1
    6672:	08 95       	ret

00006674 <_exit>:
    6674:	f8 94       	cli

00006676 <__stop_program>:
    6676:	ff cf       	rjmp	.-2      	; 0x6676 <__stop_program>
